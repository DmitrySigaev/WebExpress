/****************************************************************************
 * Copyright (C) 2009-2015. EPAM Systems.
 *
 * This file may be distributed and/or modified under the terms of the
 * GNU Affero General Public License version 3 as published by the Free
 * Software Foundation and appearing in the file LICENSE included in
 * the packaging of this file.
 *
 * This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
 * WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ***************************************************************************/

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.ketcher = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 1.1.20150716
 *
 * By Eli Grey, http://eligrey.com
 * License: X11/MIT
 *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
 */

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs || (function(view) {
	"use strict";
	// IE <10 is explicitly unsupported
	if (typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
		return;
	}
	var
		  doc = view.document
		  // only get URL when necessary in case Blob.js hasn't overridden it yet
		, get_URL = function() {
			return view.URL || view.webkitURL || view;
		}
		, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
		, can_use_save_link = "download" in save_link
		, click = function(node) {
			var event = new MouseEvent("click");
			node.dispatchEvent(event);
		}
		, webkit_req_fs = view.webkitRequestFileSystem
		, req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem
		, throw_outside = function(ex) {
			(view.setImmediate || view.setTimeout)(function() {
				throw ex;
			}, 0);
		}
		, force_saveable_type = "application/octet-stream"
		, fs_min_size = 0
		// See https://code.google.com/p/chromium/issues/detail?id=375297#c7 and
		// https://github.com/eligrey/FileSaver.js/commit/485930a#commitcomment-8768047
		// for the reasoning behind the timeout and revocation flow
		, arbitrary_revoke_timeout = 500 // in ms
		, revoke = function(file) {
			var revoker = function() {
				if (typeof file === "string") { // file is an object URL
					get_URL().revokeObjectURL(file);
				} else { // file is a File
					file.remove();
				}
			};
			if (view.chrome) {
				revoker();
			} else {
				setTimeout(revoker, arbitrary_revoke_timeout);
			}
		}
		, dispatch = function(filesaver, event_types, event) {
			event_types = [].concat(event_types);
			var i = event_types.length;
			while (i--) {
				var listener = filesaver["on" + event_types[i]];
				if (typeof listener === "function") {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		}
		, auto_bom = function(blob) {
			// prepend BOM for UTF-8 XML and text/* types (including HTML)
			if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
				return new Blob(["\ufeff", blob], {type: blob.type});
			}
			return blob;
		}
		, FileSaver = function(blob, name, no_auto_bom) {
			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			// First try a.download, then web filesystem, then object URLs
			var
				  filesaver = this
				, type = blob.type
				, blob_changed = false
				, object_url
				, target_view
				, dispatch_all = function() {
					dispatch(filesaver, "writestart progress write writeend".split(" "));
				}
				// on any filesys errors revert to saving with object URLs
				, fs_error = function() {
					// don't create more object URLs than needed
					if (blob_changed || !object_url) {
						object_url = get_URL().createObjectURL(blob);
					}
					if (target_view) {
						target_view.location.href = object_url;
					} else {
						var new_tab = view.open(object_url, "_blank");
						if (new_tab == undefined && typeof safari !== "undefined") {
							//Apple do not allow window.open, see http://bit.ly/1kZffRI
							view.location.href = object_url
						}
					}
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
					revoke(object_url);
				}
				, abortable = function(func) {
					return function() {
						if (filesaver.readyState !== filesaver.DONE) {
							return func.apply(this, arguments);
						}
					};
				}
				, create_if_not_found = {create: true, exclusive: false}
				, slice
			;
			filesaver.readyState = filesaver.INIT;
			if (!name) {
				name = "download";
			}
			if (can_use_save_link) {
				object_url = get_URL().createObjectURL(blob);
				save_link.href = object_url;
				save_link.download = name;
				setTimeout(function() {
					click(save_link);
					dispatch_all();
					revoke(object_url);
					filesaver.readyState = filesaver.DONE;
				});
				return;
			}
			// Object and web filesystem URLs have a problem saving in Google Chrome when
			// viewed in a tab, so I force save with application/octet-stream
			// http://code.google.com/p/chromium/issues/detail?id=91158
			// Update: Google errantly closed 91158, I submitted it again:
			// https://code.google.com/p/chromium/issues/detail?id=389642
			if (view.chrome && type && type !== force_saveable_type) {
				slice = blob.slice || blob.webkitSlice;
				blob = slice.call(blob, 0, blob.size, force_saveable_type);
				blob_changed = true;
			}
			// Since I can't be sure that the guessed media type will trigger a download
			// in WebKit, I append .download to the filename.
			// https://bugs.webkit.org/show_bug.cgi?id=65440
			if (webkit_req_fs && name !== "download") {
				name += ".download";
			}
			if (type === force_saveable_type || webkit_req_fs) {
				target_view = view;
			}
			if (!req_fs) {
				fs_error();
				return;
			}
			fs_min_size += blob.size;
			req_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {
				fs.root.getDirectory("saved", create_if_not_found, abortable(function(dir) {
					var save = function() {
						dir.getFile(name, create_if_not_found, abortable(function(file) {
							file.createWriter(abortable(function(writer) {
								writer.onwriteend = function(event) {
									target_view.location.href = file.toURL();
									filesaver.readyState = filesaver.DONE;
									dispatch(filesaver, "writeend", event);
									revoke(file);
								};
								writer.onerror = function() {
									var error = writer.error;
									if (error.code !== error.ABORT_ERR) {
										fs_error();
									}
								};
								"writestart progress write abort".split(" ").forEach(function(event) {
									writer["on" + event] = filesaver["on" + event];
								});
								writer.write(blob);
								filesaver.abort = function() {
									writer.abort();
									filesaver.readyState = filesaver.DONE;
								};
								filesaver.readyState = filesaver.WRITING;
							}), fs_error);
						}), fs_error);
					};
					dir.getFile(name, {create: false}, abortable(function(file) {
						// delete file if it already exists
						file.remove();
						save();
					}), abortable(function(ex) {
						if (ex.code === ex.NOT_FOUND_ERR) {
							save();
						} else {
							fs_error();
						}
					}));
				}), fs_error);
			}), fs_error);
		}
		, FS_proto = FileSaver.prototype
		, saveAs = function(blob, name, no_auto_bom) {
			return new FileSaver(blob, name, no_auto_bom);
		}
	;
	// IE 10+ (native saveAs)
	if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
		return function(blob, name, no_auto_bom) {
			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			return navigator.msSaveOrOpenBlob(blob, name || "download");
		};
	}

	FS_proto.abort = function() {
		var filesaver = this;
		filesaver.readyState = filesaver.DONE;
		dispatch(filesaver, "abort");
	};
	FS_proto.readyState = FS_proto.INIT = 0;
	FS_proto.WRITING = 1;
	FS_proto.DONE = 2;

	FS_proto.error =
	FS_proto.onwritestart =
	FS_proto.onprogress =
	FS_proto.onwrite =
	FS_proto.onabort =
	FS_proto.onerror =
	FS_proto.onwriteend =
		null;

	return saveAs;
}(
	   typeof self !== "undefined" && self
	|| typeof window !== "undefined" && window
	|| this.content
));
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window

if (typeof module !== "undefined" && module.exports) {
  module.exports.saveAs = saveAs;
} else if ((typeof define !== "undefined" && define !== null) && (define.amd != null)) {
  define([], function() {
    return saveAs;
  });
}

},{}],2:[function(require,module,exports){
// keymage.js - Javascript keyboard event handling
// http://github.com/piranha/keymage
//
// (c) 2012 Alexander Solovyov
// under terms of ISC License

(function(define, undefined) {
define(function() {
    var VERSION = '1.1.2';
    var isOsx = typeof navigator !== 'undefined' &&
        ~navigator.userAgent.indexOf('Mac OS X');

    // Defining all keys
    var MODPROPS = ['shiftKey', 'ctrlKey', 'altKey', 'metaKey'];
    var MODS = {
        'shift': 'shift',
        'ctrl': 'ctrl', 'control': 'ctrl',
        'alt': 'alt', 'option': 'alt',
        'win': 'meta', 'cmd': 'meta', 'super': 'meta',
                          'meta': 'meta',
        // default modifier for os x is cmd and for others is ctrl
        'defmod':  isOsx ? 'meta' : 'ctrl'
        };
    var MODORDER = ['shift', 'ctrl', 'alt', 'meta'];
    var MODNUMS = [16, 17, 18, 91];

    var KEYS = {
        'backspace': 8,
        'tab': 9,
        'enter': 13, 'return': 13,
        'pause': 19,
        'caps': 20, 'capslock': 20,
        'escape': 27, 'esc': 27,
        'space': 32,
        'pgup': 33, 'pageup': 33,
        'pgdown': 34, 'pagedown': 34,
        'end': 35,
        'home': 36,
        'ins': 45, 'insert': 45,
        'del': 46, 'delete': 46,

        'left': 37,
        'up': 38,
        'right': 39,
        'down': 40,

        '*': 106,
        '+': 107, 'plus': 107,
        'minus': 109,
        ';': 186,
        '=': 187,
        ',': 188,
        '-': 189,
        '.': 190,
        '/': 191,
        '`': 192,
        '[': 219,
        '\\': 220,
        ']': 221,
        "'": 222
    };

    var i;
    // numpad
    for (i = 0; i < 10; i++) {
        KEYS['num-' + i] = i + 95;
    }
    // top row 0-9
    for (i = 0; i < 10; i++) {
        KEYS[i.toString()] = i + 48;
    }
    // f1-f24
    for (i = 1; i < 25; i++) {
        KEYS['f' + i] = i + 111;
    }
    // alphabet
    for (i = 65; i < 91; i++) {
        KEYS[String.fromCharCode(i).toLowerCase()] = i;
    }

    // Reverse key codes
    var KEYREV = {};
    for (var k in KEYS) {
        var val = KEYS[k];
        if (!KEYREV[val] || KEYREV[val].length < k.length) {
            KEYREV[val] = k;
        }
    }

    // -----------------------
    // Actual work is done here

    var currentScope = '';
    var allChains = {};

    function parseKeyString(keystring) {
        var bits = keystring.split(/-(?!$)/);
        var button = bits[bits.length - 1];
        var key = {code: KEYS[button]};

        if (!key.code) {
            throw 'Unknown key "' + button + '" in keystring "' +
                keystring + '"';
        }

        var mod;
        for (var i = 0; i < bits.length - 1; i++) {
            button = bits[i];
            mod = MODS[button];
            if (!mod) {
                    throw 'Unknown modifier "' + button + '" in keystring "' +
                        keystring + '"';
            }
            key[mod] = true;
        }

        return key;
    }

    function stringifyKey(key) {
        var s = '';
        for (var i = 0; i < MODORDER.length; i++) {
            if (key[MODORDER[i]]) {
                s += MODORDER[i] + '-';
            }
        }
        s += KEYREV[key.code];
        return s;
    }

    function normalizeKeyChain(keychainString) {
        var keychain = [];
        var keys = keychainString.split(' ');

        for (var i = 0; i < keys.length; i++) {
            var key = parseKeyString(keys[i]);
            key = stringifyKey(key);
            keychain.push(key);
        }

        keychain.original = keychainString;
        return keychain;
    }

    function eventKeyString(e) {
        var key = {code: e.keyCode};
        for (var i = 0; i < MODPROPS.length; i++) {
            var mod = MODPROPS[i];
            if (e[mod]) {
                key[mod.slice(0, mod.length - 3)] = true;
            }
        }
        return stringifyKey(key);
    }

    function getNestedChains(chains, scope) {
        for (var i = 0; i < scope.length; i++) {
            var bit = scope[i];

            if (bit) {
                chains = chains[bit];
            }

            if (!chains) {
                break;
            }
        }
        return chains;
    }

    var sequence = [];
    function dispatch(e) {
        // Skip all modifiers
        if (~MODNUMS.indexOf(e.keyCode)) {
            return;
        }

        var seq = sequence.slice();
        seq.push(eventKeyString(e));
        var scope = currentScope.split('.');
        var matched, chains, key;

        for (var i = scope.length; i >= 0; i--) {
            chains = getNestedChains(allChains, scope.slice(0, i));
            if (!chains) {
                continue;
            }
            matched = true;
            for (var j = 0; j < seq.length; j++) {
                key = seq[j];
                if (!chains[key]) {
                    matched = false;
                    break;
                }
                chains = chains[key];
            }

            if (matched) {
                break;
            }
        }

        var definitionScope = scope.slice(0, i).join('.');
        var preventDefault = chains.preventDefault;

        // partial match, save the sequence
        if (matched && !chains.handlers) {
            sequence = seq;
            if (preventDefault) {
                e.preventDefault();
            }
            return;
        }

        if (matched) {
            for (i = 0; i < chains.handlers.length; i++) {
                var handler = chains.handlers[i];
                var options = handler._keymage;

                var res = handler.call(options.context, e, {
                    shortcut: options.original,
                    scope: currentScope,
                    definitionScope: definitionScope
                });

                if (res === false || preventDefault) {
                    e.preventDefault();
                }
            }
        }

        // either matched or not, drop the sequence
        sequence = [];
    }

    function getHandlers(scope, keychain, fn) {
        var bits = scope.split('.');
        var chains = allChains;
        bits = bits.concat(keychain);

        for (var i = 0, l = bits.length; i < l; i++) {
            var bit = bits[i];
            if (!bit) continue;

            chains = chains[bit] || (chains[bit] = {});
            if (fn && fn._keymage.preventDefault) {
                chains.preventDefault = true;
            }

            if (i === l - 1) {
                var handlers = chains.handlers || (chains.handlers = []);
                return handlers;
            }
        }
    }

    function assignKey(scope, keychain, fn) {
        var handlers = getHandlers(scope, keychain, fn);
        handlers.push(fn);
    }

    function unassignKey(scope, keychain, fn) {
        var handlers = getHandlers(scope, keychain);
        var idx = handlers.indexOf(fn);
        if (~idx) {
            handlers.splice(idx, 1);
        }
    }

    function parsed(scope, keychain, fn, options) {
        if (keychain === undefined && fn === undefined) {
            return function(keychain, fn) {
                return keymage(scope, keychain, fn);
            };
        }

        if (typeof keychain === 'function') {
            options = fn;
            fn = keychain;
            keychain = scope;
            scope = '';
        }

        var normalized = normalizeKeyChain(keychain);

        return [scope, normalized, fn, options];
    }

    // optional arguments: scope, options.
    function keymage(scope, keychain, fn, options) {
        var args = parsed(scope, keychain, fn, options);
        fn = args[2];
        options = args[3];
        fn._keymage = options || {};
        fn._keymage.original = keychain;
        assignKey.apply(null, args);
    }

    keymage.unbind = function(scope, keychain, fn) {
        var args = parsed(scope, keychain, fn);
        unassignKey.apply(null, args);
    };

    keymage.parse = parseKeyString;
    keymage.stringify = stringifyKey;

    keymage.bindings = allChains;

    keymage.setScope = function(scope) {
        currentScope = scope ? scope : '';
    };

    keymage.getScope = function() { return currentScope; };

    keymage.pushScope = function(scope) {
        currentScope = (currentScope ? currentScope + '.' : '') + scope;
        return currentScope;
    };

    keymage.popScope = function(scope) {
        var i;

        if (!scope) {
            i = currentScope.lastIndexOf('.');
            scope = currentScope.slice(i + 1);
            currentScope = i == -1 ? '' : currentScope.slice(0, i);
            return scope;
        }

        currentScope = currentScope.replace(
            new RegExp('(^|\\.)' + scope + '(\\.|$).*'), '');
        return scope;
    };

    keymage.version = VERSION;

    window.addEventListener('keydown', dispatch, false);

    return keymage;
});
})(typeof define !== 'undefined' ? define : function(factory) {
    if (typeof module !== 'undefined') {
        module.exports = factory();
    } else {
        window.keymage = factory();
    }
});

},{}],3:[function(require,module,exports){
(function(root) {

	// Use polyfill for setImmediate for performance gains
	var asap = (typeof setImmediate === 'function' && setImmediate) ||
		function(fn) { setTimeout(fn, 1); };

	// Polyfill for Function.prototype.bind
	function bind(fn, thisArg) {
		return function() {
			fn.apply(thisArg, arguments);
		}
	}

	var isArray = Array.isArray || function(value) { return Object.prototype.toString.call(value) === "[object Array]" };

	function Promise(fn) {
		if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');
		if (typeof fn !== 'function') throw new TypeError('not a function');
		this._state = null;
		this._value = null;
		this._deferreds = []

		doResolve(fn, bind(resolve, this), bind(reject, this))
	}

	function handle(deferred) {
		var me = this;
		if (this._state === null) {
			this._deferreds.push(deferred);
			return
		}
		asap(function() {
			var cb = me._state ? deferred.onFulfilled : deferred.onRejected
			if (cb === null) {
				(me._state ? deferred.resolve : deferred.reject)(me._value);
				return;
			}
			var ret;
			try {
				ret = cb(me._value);
			}
			catch (e) {
				deferred.reject(e);
				return;
			}
			deferred.resolve(ret);
		})
	}

	function resolve(newValue) {
		try { //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
			if (newValue === this) throw new TypeError('A promise cannot be resolved with itself.');
			if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
				var then = newValue.then;
				if (typeof then === 'function') {
					doResolve(bind(then, newValue), bind(resolve, this), bind(reject, this));
					return;
				}
			}
			this._state = true;
			this._value = newValue;
			finale.call(this);
		} catch (e) { reject.call(this, e); }
	}

	function reject(newValue) {
		this._state = false;
		this._value = newValue;
		finale.call(this);
	}

	function finale() {
		for (var i = 0, len = this._deferreds.length; i < len; i++) {
			handle.call(this, this._deferreds[i]);
		}
		this._deferreds = null;
	}

	function Handler(onFulfilled, onRejected, resolve, reject){
		this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
		this.onRejected = typeof onRejected === 'function' ? onRejected : null;
		this.resolve = resolve;
		this.reject = reject;
	}

	/**
	 * Take a potentially misbehaving resolver function and make sure
	 * onFulfilled and onRejected are only called once.
	 *
	 * Makes no guarantees about asynchrony.
	 */
	function doResolve(fn, onFulfilled, onRejected) {
		var done = false;
		try {
			fn(function (value) {
				if (done) return;
				done = true;
				onFulfilled(value);
			}, function (reason) {
				if (done) return;
				done = true;
				onRejected(reason);
			})
		} catch (ex) {
			if (done) return;
			done = true;
			onRejected(ex);
		}
	}

	Promise.prototype['catch'] = function (onRejected) {
		return this.then(null, onRejected);
	};

	Promise.prototype.then = function(onFulfilled, onRejected) {
		var me = this;
		return new Promise(function(resolve, reject) {
			handle.call(me, new Handler(onFulfilled, onRejected, resolve, reject));
		})
	};

	Promise.all = function () {
		var args = Array.prototype.slice.call(arguments.length === 1 && isArray(arguments[0]) ? arguments[0] : arguments);

		return new Promise(function (resolve, reject) {
			if (args.length === 0) return resolve([]);
			var remaining = args.length;
			function res(i, val) {
				try {
					if (val && (typeof val === 'object' || typeof val === 'function')) {
						var then = val.then;
						if (typeof then === 'function') {
							then.call(val, function (val) { res(i, val) }, reject);
							return;
						}
					}
					args[i] = val;
					if (--remaining === 0) {
						resolve(args);
					}
				} catch (ex) {
					reject(ex);
				}
			}
			for (var i = 0; i < args.length; i++) {
				res(i, args[i]);
			}
		});
	};

	Promise.resolve = function (value) {
		if (value && typeof value === 'object' && value.constructor === Promise) {
			return value;
		}

		return new Promise(function (resolve) {
			resolve(value);
		});
	};

	Promise.reject = function (value) {
		return new Promise(function (resolve, reject) {
			reject(value);
		});
	};

	Promise.race = function (values) {
		return new Promise(function (resolve, reject) {
			for(var i = 0, len = values.length; i < len; i++) {
				values[i].then(resolve, reject);
			}
		});
	};

	/**
	 * Set the immediate function to execute callbacks
	 * @param fn {function} Function to execute
	 * @private
	 */
	Promise._setImmediateFn = function _setImmediateFn(fn) {
		asap = fn;
	};

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = Promise;
	} else if (!root.Promise) {
		root.Promise = Promise;
	}

})(this);
},{}],4:[function(require,module,exports){
'use strict';
var strictUriEncode = require('strict-uri-encode');

exports.extract = function (str) {
	return str.split('?')[1] || '';
};

exports.parse = function (str) {
	if (typeof str !== 'string') {
		return {};
	}

	str = str.trim().replace(/^(\?|#|&)/, '');

	if (!str) {
		return {};
	}

	return str.split('&').reduce(function (ret, param) {
		var parts = param.replace(/\+/g, ' ').split('=');
		// Firefox (pre 40) decodes `%3D` to `=`
		// https://github.com/sindresorhus/query-string/pull/37
		var key = parts.shift();
		var val = parts.length > 0 ? parts.join('=') : undefined;

		key = decodeURIComponent(key);

		// missing `=` should be `null`:
		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
		val = val === undefined ? null : decodeURIComponent(val);

		if (!ret.hasOwnProperty(key)) {
			ret[key] = val;
		} else if (Array.isArray(ret[key])) {
			ret[key].push(val);
		} else {
			ret[key] = [ret[key], val];
		}

		return ret;
	}, {});
};

exports.stringify = function (obj) {
	return obj ? Object.keys(obj).sort().map(function (key) {
		var val = obj[key];

		if (Array.isArray(val)) {
			return val.sort().map(function (val2) {
				return strictUriEncode(key) + '=' + strictUriEncode(val2);
			}).join('&');
		}

		return strictUriEncode(key) + '=' + strictUriEncode(val);
	}).filter(function (x) {
		return x.length > 0;
	}).join('&') : '';
};

},{"strict-uri-encode":5}],5:[function(require,module,exports){
'use strict';
module.exports = function (str) {
	return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
		return '%' + c.charCodeAt(0).toString(16);
	});
};

},{}],6:[function(require,module,exports){
var xhrFactory = (function getXHRfactory (factories) {
  for (var i=0, xhr, X, len=factories.length; i<len; i++) {
    try { X = factories[i]; xhr = X();
      return window.XMLHttpRequest ? X : window.XMLHttpRequest = X;
    } catch (e) { continue; }
  }
})([
  function () {return new XMLHttpRequest();},// IE10+,FF,Chrome,Opera,Safari
  function () {return new ActiveXObject("Msxml3.");},            // IE9
  function () {return new ActiveXObject("Msxml2.XMLHTTP.6.0");}, // IE8
  function () {return new ActiveXObject("Msxml2.XMLHTTP.3.0");}, // IE7
  function () {return new ActiveXObject("Msxml2.XMLHTTP");},     // IE6
  function () {return new ActiveXObject("Microsoft.XMLHTTP");},  // IE5
  function () {return null;}
]);
module.exports = function getXHR() { return xhrFactory(); }

},{}],7:[function(require,module,exports){
var ajax = require('./util/ajax.js');

// stealed from https://github.com/iambumblehead/form-urlencoded/
function formEncodeString(str) {
	return str.replace(/[^ !'()~\*]*/g, encodeURIComponent)
	.replace(/ /g, '+')
	.replace(/[!'()~\*]/g, function (ch) {
		return '%' + ('0' + ch.charCodeAt(0).toString(16))
		.slice(-2).toUpperCase();
	});
}

function formEncode(obj) {
	var str = [];
	for (var prop in obj) {
		if (obj.hasOwnProperty(prop)) {// don't handle nested objects
			str.push(encodeURIComponent(prop) + '=' +
			formEncodeString(obj[prop]));
		}
	}
	return str.join('&');
}

function unwrap(xhr) {
	var data = xhr.responseText;
	var value = data.substring(data.indexOf('\n') + 1);

	if (data.startsWith('Ok.')) {
		return value;
	}
	throw Error('Unknown server error: ' + data);
}

function api (base_url) {
	function request (method, url) {
		function options(data, params, sync) {
			return {
				method: method,
				url: res.url,
				sync: sync,
				params: params,
				data: data && formEncode(data),
				headers: data && {
					'Content-Type': 'application/x-www-form-urlencoded'
				}
			};
		}
		var res = function (data, params) {
			return ajax(options(data, params)).then(unwrap);
		};
		res.sync = function (data, params) {
			// TODO: handle errors
			return unwrap(ajax(options(data, params, true)));
		};
		res.url = base_url + url;
		return res;
	}

	return {
		inchi: request('POST', 'getinchi'),
		molfile: request('POST', 'getmolfile'),
		aromatize: request('POST', 'aromatize'),
		dearomatize: request('POST', 'dearomatize'),
		calculateCip: request('POST', 'calculate_cip'),
		automap: request('POST', 'automap'),
		layout_smiles: request('GET', 'layout'),
		layout: request('POST', 'layout'),
		smiles: request('POST', 'smiles'),
		save: request('POST', 'save'),
		knocknock: function () {
			return ajax(base_url + 'knocknock').then(function (xhr) {
				if (xhr.responseText !== 'You are welcome!') {
					throw Error('Server is not compatible');
				}
			});
		}
	};
}

module.exports = api;

},{"./util/ajax.js":38}],8:[function(require,module,exports){
var Vec2 = require('../util/vec2');
var util = require('../util');
var element = require('./element');

var Atom = function (params) {
	var def = Atom.attrGetDefault;
	if (!params || !('label' in params))
		throw new Error('label must be specified!');

	this.label = params.label;
	this.fragment = !Object.isUndefined(params.fragment) ? params.fragment : -1;

	util.ifDef(this, params, 'isotope', def('isotope'));
	util.ifDef(this, params, 'radical', def('radical'));
	util.ifDef(this, params, 'charge', def('charge'));
	util.ifDef(this, params, 'rglabel', def('rglabel')); // r-group index mask, i-th bit stands for i-th r-site
	util.ifDef(this, params, 'attpnt', def('attpnt')); // attachment point
	util.ifDef(this, params, 'explicitValence', def('explicitValence'));

	this.valence = 0;
	this.implicitH = 0; // implicitH is not an attribute
	if (!Object.isUndefined(params.pp))
		this.pp = new Vec2(params.pp);
	else
		this.pp = new Vec2();

	// sgs should only be set when an atom is added to an s-group by an appropriate method,
	//   or else a copied atom might think it belongs to a group, but the group be unaware of the atom
	// TODO: make a consistency check on atom/s-group assignments
	this.sgs = {};

	// query
	util.ifDef(this, params, 'ringBondCount', def('ringBondCount'));
	util.ifDef(this, params, 'substitutionCount', def('substitutionCount'));
	util.ifDef(this, params, 'unsaturatedAtom', def('unsaturatedAtom'));
	util.ifDef(this, params, 'hCount', def('hCount'));

	// reaction
	util.ifDef(this, params, 'aam', def('aam'));
	util.ifDef(this, params, 'invRet', def('invRet'));
	util.ifDef(this, params, 'exactChangeFlag', def('exactChangeFlag'));
	util.ifDef(this, params, 'rxnFragmentType', -1); // this isn't really an attribute

	this.atomList = !Object.isUndefined(params.atomList) && params.atomList != null ? AtomList(params.atomList) : null;
	this.neighbors = []; // set of half-bonds having this atom as their origin
	this.badConn = false;
};

Atom.PATTERN =
 {
    RADICAL:
 {
        NONE: 0,
        SINGLET: 1,
        DOUPLET: 2,
        TRIPLET: 3
    }
};

Atom.attrlist = {
    'label': 'C',
    'isotope': 0,
    'radical': 0,
    'charge': 0,
    'explicitValence': -1,
    'ringBondCount': 0,
    'substitutionCount': 0,
    'unsaturatedAtom': 0,
    'hCount': 0,
    'atomList': null,
    'invRet': 0,
    'exactChangeFlag': 0,
    'rglabel': null,
    'attpnt': null,
    'aam': 0
};

Atom.getAttrHash = function (atom) {
	var attrs = new Hash();
	for (var attr in Atom.attrlist) {
		if (typeof(atom[attr]) != 'undefined') {
			attrs.set(attr, atom[attr]);
		}
	}
	return attrs;
};

Atom.attrGetDefault = function (attr) {
	if (attr in Atom.attrlist)
		return Atom.attrlist[attr];
	throw new Error('Attribute unknown');
};


Atom.prototype.clone = function (fidMap)
{
	var ret = new Atom(this);
	if (fidMap && this.fragment in fidMap) {
		ret.fragment = fidMap[this.fragment];
	}
	return ret;
};

Atom.prototype.isQuery =  function ()
{
	return this.atomList != null || this.label == 'A' || this.attpnt || this.hCount;
};

Atom.prototype.pureHydrogen =  function ()
{
	return this.label == 'H' && this.isotope == 0;
};

Atom.prototype.isPlainCarbon =  function ()
{
	return this.label == 'C' && this.isotope == 0 && this.radical == 0 && this.charge == 0
		 && this.explicitValence < 0 && this.ringBondCount == 0 && this.substitutionCount == 0
		 && this.unsaturatedAtom == 0 && this.hCount == 0 && !this.atomList;
};

Atom.prototype.isPseudo =  function ()
{
	// TODO: handle reaxys generics separately
	return !this.atomList && !this.rglabel && !element.getElementByLabel(this.label);
};

Atom.prototype.hasRxnProps =  function ()
{
	return !!(this.invRet || this.exactChangeFlag || !util.isNull(this.attpnt) || this.aam);
};


var radicalElectrons = function (radical) {
    radical = radical - 0;
    if (radical == Atom.PATTERN.RADICAL.NONE)
        return 0;
    else if (radical == Atom.PATTERN.RADICAL.DOUPLET)
        return 1;
    else if (radical == Atom.PATTERN.RADICAL.SINGLET ||
        radical == Atom.PATTERN.RADICAL.TRIPLET)
        return 2;
    throw new Error('Unknown radical value');
};

Atom.prototype.calcValence = function (conn) {
    var atom = this;
    var charge = atom.charge;
    var label = atom.label;
    if (atom.isQuery()) {
        this.implicitH = 0;
        return true;
    }
    var elem = element.getElementByLabel(label);
    if (elem == null) {
        this.implicitH = 0;
        return true;
    }

    var groupno = element.get(elem).group;
    var rad = radicalElectrons(atom.radical);

    var valence = conn;
    var hyd = 0;
    var absCharge = Math.abs(charge);

    switch (groupno) {
        case 1:
            if (label == 'H' ||
			label == 'Li' || label == 'Na' || label == 'K' ||
			label == 'Rb' || label == 'Cs' || label == 'Fr') {
                valence = 1;
                hyd = 1 - rad - conn - absCharge;
            }
            break;
        case 3:
            if (label == 'B' || label == 'Al' || label == 'Ga' || label == 'In') {
                if (charge == -1) {
                    valence = 4;
                    hyd = 4 - rad - conn;
                }
                else {
                    valence = 3;
                    hyd = 3 - rad - conn - absCharge;
                }
            }
            else {
                if (label == 'Tl') {
                    if (charge == -1) {
                        if (rad + conn <= 2) {
                            valence = 2;
                            hyd = 2 - rad - conn;
                        }
                        else {
                            valence = 4;
                            hyd = 4 - rad - conn;
                        }
                    }
                    else {
                        if (charge == -2) {
                            if (rad + conn <= 3) {
                                valence = 3;
                                hyd = 3 - rad - conn;
                            }
                            else {
                                valence = 5;
                                hyd = 5 - rad - conn;
                            }
                        }
                        else {
                            if (rad + conn + absCharge <= 1) {
                                valence = 1;
                                hyd = 1 - rad - conn - absCharge;
                            }
                            else {
                                valence = 3;
                                hyd = 3 - rad - conn - absCharge;
                            }
                        }
                    }
                }
            }
            break;
        case 4:
            if (label == 'C' || label == 'Si' || label == 'Ge') {
                valence = 4;
                hyd = 4 - rad - conn - absCharge;
            }
            else {
                if (label == 'Sn' || label == 'Pb') {
                    if (conn + rad + absCharge <= 2) {
                        valence = 2;
                        hyd = 2 - rad - conn - absCharge;
                    }
                    else {
                        valence = 4;
                        hyd = 4 - rad - conn - absCharge;
                    }
                }
            }
            break;
        case 5:
            if (label == 'N' || label == 'P') {
                if (charge == 1) {
                    valence = 4;
                    hyd = 4 - rad - conn;
                }
                else {
                    if (charge == 2) {
                        valence = 3;
                        hyd = 3 - rad - conn;
                    }
                    else {
                        if (label == 'N' || rad + conn + absCharge <= 3) {
                            valence = 3;
                            hyd = 3 - rad - conn - absCharge;
                        }
                        else // ELEM_P && rad + conn + absCharge > 3
                        {
                            valence = 5;
                            hyd = 5 - rad - conn - absCharge;
                        }
                    }
                }
            }
            else {
                if (label == 'Bi' || label == 'Sb' || label == 'As') {
                    if (charge == 1) {
                        if (rad + conn <= 2 && label != 'As') {
                            valence = 2;
                            hyd = 2 - rad - conn;
                        }
                        else {
                            valence = 4;
                            hyd = 4 - rad - conn;
                        }
                    }
                    else {
                        if (charge == 2) {
                            valence = 3;
                            hyd = 3 - rad - conn;
                        }
                        else {
                            if (rad + conn <= 3) {
                                valence = 3;
                                hyd = 3 - rad - conn - absCharge;
                            }
                            else {
                                valence = 5;
                                hyd = 5 - rad - conn - absCharge;
                            }
                        }
                    }
                }
            }
            break;
        case 6:
            if (label == 'O') {
                if (charge >= 1) {
                    valence = 3;
                    hyd = 3 - rad - conn;
                }
                else {
                    valence = 2;
                    hyd = 2 - rad - conn - absCharge;
                }
            }
            else {
                if (label == 'S' || label == 'Se' || label == 'Po') {
                    if (charge == 1) {
                        if (conn <= 3) {
                            valence = 3;
                            hyd = 3 - rad - conn;
                        }
                        else {
                            valence = 5;
                            hyd = 5 - rad - conn;
                        }
                    }
                    else {
                        if (conn + rad + absCharge <= 2) {
                            valence = 2;
                            hyd = 2 - rad - conn - absCharge;
                        }
                        else {
                            if (conn + rad + absCharge <= 4) {
                                // See examples in PubChem
                                // [S] : CID 16684216
                                // [Se]: CID 5242252
                                // [Po]: no example, just following ISIS/Draw logic here {
                                valence = 4;
                                hyd = 4 - rad - conn - absCharge;
                            }
                            else {
                                // See examples in PubChem
                                // [S] : CID 46937044
                                // [Se]: CID 59786
                                // [Po]: no example, just following ISIS/Draw logic here {
                                valence = 6;
                                hyd = 6 - rad - conn - absCharge;
                            }
                        }
                    }
                }
                else {
                    if (label == 'Te') {
                        if (charge == -1) {
                            if (conn <= 2) {
                                valence = 2;
                                hyd = 2 - rad - conn - absCharge;
                            }
                        }
                        else {
                            if (charge == 0 || charge == 2) {
                                if (conn <= 2) {
                                    valence = 2;
                                    hyd = 2 - rad - conn - absCharge;
                                }
                                else {
                                    if (conn <= 4) {
                                        valence = 4;
                                        hyd = 4 - rad - conn - absCharge;
                                    }
                                    else {
                                        if (charge == 0 && conn <= 6) {
                                            valence = 6;
                                            hyd = 6 - rad - conn - absCharge;
                                        }
                                        else {
                                            hyd = -1;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            break;
        case 7:
            if (label == 'F') {
                valence = 1;
                hyd = 1 - rad - conn - absCharge;
            }
            else {
                if (label == 'Cl' || label == 'Br' || label == 'I' || label == 'At') {
                    if (charge == 1) {
                        if (conn <= 2) {
                            valence = 2;
                            hyd = 2 - rad - conn;
                        }
                        else {
                            if (conn == 3 || conn == 5 || conn >= 7)
                                hyd = -1;
                        }
                    }
                    else {
                        if (charge == 0) {
                            if (conn <= 1) {
                                valence = 1;
                                hyd = 1 - rad - conn;
                            }
                             // While the halogens can have valence 3, they can not have
                             // hydrogens in that case.
                            else {
                                if (conn == 2 || conn == 4 || conn == 6) {
                                    if (rad == 1) {
                                        valence = conn;
                                        hyd = 0;
                                    }
                                    else
                                        hyd = -1; // will throw an error in the end
                                }
                                else {
                                    if (conn > 7)
                                        hyd = -1; // will throw an error in the end
                                }
                            }
                        }
                    }
                }
            }
    }

    this.valence = valence;
    this.implicitH = hyd;
    if (this.implicitH < 0) {
        this.valence = conn;
        this.implicitH = 0;
        this.badConn = true;
        return false;
    }
    return true;
};

Atom.prototype.calcValenceMinusHyd = function (conn) {
    var atom = this;
    var charge = atom.charge;
    var label = atom.label;
    var elem = element.getElementByLabel(label);
    if (elem == null)
        throw new Error('Element ' + label + ' unknown');
    if (elem < 0) { // query atom, skip
        this.implicitH = 0;
        return null;
    }

    var groupno = element.get(elem).group;
    var rad = radicalElectrons(atom.radical);

    if (groupno == 3) {
        if (label == 'B' || label == 'Al' || label == 'Ga' || label == 'In') {
            if (charge == -1)
                if (rad + conn <= 4)
                    return rad + conn;
        }
    }
    else if (groupno == 5) {
        if (label == 'N' || label == 'P') {
            if (charge == 1)
                return rad + conn;
            if (charge == 2)
                return rad + conn;
        }
        else if (label == 'Sb' || label == 'Bi' || label == 'As') {
            if (charge == 1)
                return rad + conn;
            else if (charge == 2)
                return rad + conn;
        }
    }
    else if (groupno == 6) {
        if (label == 'O') {
            if (charge >= 1)
                return rad + conn;
        }
        else if (label == 'S' || label == 'Se' || label == 'Po') {
            if (charge == 1)
                return rad + conn;
        }
    }
    else if (groupno == 7) {
        if (label == 'Cl' || label == 'Br' ||
			label == 'I' || label == 'At') {
            if (charge == 1)
                return rad + conn;
        }
    }

    return rad + conn + Math.abs(charge);
};

var AtomList = function (params)
{
	if (!params || !('notList' in params) || !('ids' in params))
		throw new Error('\'notList\' and \'ids\' must be specified!');

	this.notList = params.notList; /*boolean*/
	this.ids = params.ids; /*Array of integers*/
};

AtomList.prototype.labelList = function ()
{
	var labels = [];
	for (var i = 0; i < this.ids.length; ++i)
		labels.push(element.get(this.ids[i]).label);
	return labels;
};

AtomList.prototype.label = function ()
{
	var label = '[' + this.labelList().join(',') + ']';
	if (this.notList)
		label = '!' + label;
	return label;
};

AtomList.prototype.equals = function (x)
{
	return this.notList == x.notList && (this.ids || []).sort().toString() == (x.ids || []).sort().toString();
};

Atom.List = AtomList;
module.exports = Atom;

},{"../util":40,"../util/vec2":44,"./element":12}],9:[function(require,module,exports){
var Vec2 = require('../util/vec2');

var Bond = function (params)
{
	if (!params || !('begin' in params) || !('end' in params) || !('type' in params))
		throw new Error('\'begin\', \'end\' and \'type\' properties must be specified!');

	this.begin = params.begin;
	this.end = params.end;
    this.type = params.type;
    this.stereo = Bond.PATTERN.STEREO.NONE;
    this.topology = Bond.PATTERN.TOPOLOGY.EITHER;
    this.reactingCenterStatus = 0;
	this.hb1 = null; // half-bonds
	this.hb2 = null;
	this.len = 0;
	this.sb = 0;
	this.sa = 0;
    this.angle = 0;

    if (params.stereo)
        this.stereo = params.stereo;
    if (params.topology)
        this.topology = params.topology;
    if (params.reactingCenterStatus)
        this.reactingCenterStatus = params.reactingCenterStatus;

    this.center = new Vec2();

};

Bond.PATTERN =
{
    TYPE:
 {
        SINGLE: 1,
        DOUBLE: 2,
        TRIPLE: 3,
        AROMATIC: 4,
        SINGLE_OR_DOUBLE: 5,
        SINGLE_OR_AROMATIC: 6,
        DOUBLE_OR_AROMATIC: 7,
        ANY: 8
    },

    STEREO:
 {
        NONE: 0,
        UP: 1,
        EITHER: 4,
        DOWN: 6,
        CIS_TRANS: 3
    },

    TOPOLOGY:
 {
        EITHER: 0,
        RING: 1,
        CHAIN: 2
    },

    REACTING_CENTER:
 {
        NOT_CENTER: -1,
        UNMARKED: 0,
        CENTER: 1,
        UNCHANGED: 2,
        MADE_OR_BROKEN: 4,
        ORDER_CHANGED: 8,
        MADE_OR_BROKEN_AND_CHANGED: 12
    }
};

Bond.attrlist = {
	'type': Bond.PATTERN.TYPE.SINGLE,
	'stereo': Bond.PATTERN.STEREO.NONE,
	'topology': Bond.PATTERN.TOPOLOGY.EITHER,
	'reactingCenterStatus': 0
};

Bond.getAttrHash = function (bond) {
	var attrs = new Hash();
	for (var attr in Bond.attrlist) {
		if (typeof(bond[attr]) !== 'undefined') {
			attrs.set(attr, bond[attr]);
		}
	}
	return attrs;
};

Bond.attrGetDefault = function (attr) {
	if (attr in Bond.attrlist)
		return Bond.attrlist[attr];
	throw new Error('Attribute unknown');
}

Bond.prototype.hasRxnProps =  function ()
{
	return !!this.reactingCenterStatus;
};

Bond.prototype.getCenter = function (struct) {
	var p1 = struct.atoms.get(this.begin).pp;
	var p2 = struct.atoms.get(this.end).pp;
	return Vec2.lc2(p1, 0.5, p2, 0.5);
}

Bond.prototype.getDir = function (struct) {
	var p1 = struct.atoms.get(this.begin).pp;
	var p2 = struct.atoms.get(this.end).pp;
	return p2.sub(p1).normalized();
}

Bond.prototype.clone = function (aidMap)
{
	var cp = new Bond(this);
	if (aidMap) {
		cp.begin = aidMap[cp.begin];
		cp.end = aidMap[cp.end];
	}
	return cp;
};

Bond.prototype.findOtherEnd = function (i)
{
	if (i == this.begin)
		return this.end;
	if (i == this.end)
		return this.begin;
	throw new Error('bond end not found');
};

module.exports = Bond;

},{"../util/vec2":44}],10:[function(require,module,exports){
var Map = require('../util/map');
var Vec2 = require('../util/vec2');
var Bond = require('./bond');

var CisTrans = function (mol, neighborsFunc, context) {
	this.molecule = mol;
	this.bonds = new Map();
	this.getNeighbors = neighborsFunc;
	this.context = context;
};

CisTrans.PARITY = {
	NONE: 0,
	CIS: 1,
	TRANS: 2
};

CisTrans.prototype.each = function (func, context) {
	this.bonds.each(func, context);
};

CisTrans.prototype.getParity = function (idx) {
	return this.bonds.get(idx).parity;
};

CisTrans.prototype.getSubstituents = function (idx) {
	return this.bonds.get(idx).substituents;
};

CisTrans.prototype.sameside = function (beg, end, neiBeg, neiEnd) {
	var diff = Vec2.diff(beg, end);
	var norm = new Vec2(-diff.y, diff.x);

	if (!norm.normalize()) {
		return 0;
	}

	var normBeg = Vec2.diff(neiBeg, beg);
	var normEnd = Vec2.diff(neiEnd, end);

	if (!normBeg.normalize()) {
		return 0;
	}
	if (!normEnd.normalize()) {
		return 0;
	}

	var prodBeg = Vec2.dot(normBeg, norm);
	var prodEnd = Vec2.dot(normEnd, norm);

	if (Math.abs(prodBeg) < 0.001 || Math.abs(prodEnd) < 0.001) {
		return 0;
	}

	return (prodBeg * prodEnd > 0) ? 1 : -1;
};

CisTrans.prototype._sameside = function (iBeg, iEnd, iNeiBeg, iNeiEnd) {
	return this.sameside(this.molecule.atoms.get(iBeg).pp, this.molecule.atoms.get(iEnd).pp,
		this.molecule.atoms.get(iNeiBeg).pp, this.molecule.atoms.get(iNeiEnd).pp);
};

CisTrans.prototype._sortSubstituents = function (substituents) {
	var h0 = this.molecule.atoms.get(substituents[0]).pureHydrogen();
	var h1 = substituents[1] < 0 || this.molecule.atoms.get(substituents[1]).pureHydrogen();
	var h2 = this.molecule.atoms.get(substituents[2]).pureHydrogen();
	var h3 = substituents[3] < 0 || this.molecule.atoms.get(substituents[3]).pureHydrogen();

	if (h0 && h1) {
		return false;
	}
	if (h2 && h3) {
		return false;
	}

	if (h1) {
		substituents[1] = -1;
	} else if (h0) {
		substituents[0] = substituents[1];
		substituents[1] = -1;
	} else if (substituents[0] > substituents[1]) {
		substituents.swap(0, 1);
	}

	if (h3) {
		substituents[3] = -1;
	} else if (h2) {
		substituents[2] = substituents[3];
		substituents[3] = -1;
	} else if (substituents[2] > substituents[3]) {
		substituents.swap(2, 3);
	}

	return true;
};

CisTrans.prototype.isGeomStereoBond = function (bondIdx, substituents) {
	// it must be [C,N,Si]=[C,N,Si] bond
	var bond = this.molecule.bonds.get(bondIdx);

	if (bond.type != Bond.PATTERN.TYPE.DOUBLE) {
		return false;
	}

	var label1 = this.molecule.atoms.get(bond.begin).label;
	var label2 = this.molecule.atoms.get(bond.end).label;

	if (label1 != 'C' && label1 != 'N' && label1 != 'Si' && label1 != 'Ge') {
		return false;
	}
	if (label2 != 'C' && label2 != 'N' && label2 != 'Si' && label2 != 'Ge') {
		return false;
	}

	// the atoms should have 1 or 2 single bonds
	// (apart from the double bond under consideration)
	var neiBegin = this.getNeighbors.call(this.context, bond.begin);
	var neiЕnd = this.getNeighbors.call(this.context, bond.end);

	if (
	neiBegin.length < 2 || neiBegin.length > 3 ||
	neiЕnd.length < 2 || neiЕnd.length > 3
	) {
		return false;
	}

	substituents[0] = -1;
	substituents[1] = -1;
	substituents[2] = -1;
	substituents[3] = -1;

	var i;
	var nei;

	for (i = 0; i < neiBegin.length; i++) {
		nei = neiBegin[i];

		if (nei.bid == bondIdx) {
			continue;
		}

		if (this.molecule.bonds.get(nei.bid).type != Bond.PATTERN.TYPE.SINGLE) {
			return false;
		}

		if (substituents[0] == -1) {
			substituents[0] = nei.aid;
		}else { // (substituents[1] == -1)
			substituents[1] = nei.aid;
		}
	}

	for (i = 0; i < neiЕnd.length; i++) {
		nei = neiЕnd[i];

		if (nei.bid == bondIdx) {
			continue;
		}

		if (this.molecule.bonds.get(nei.bid).type != Bond.PATTERN.TYPE.SINGLE) {
			return false;
		}

		if (substituents[2] == -1) {
			substituents[2] = nei.aid;
		}
		else { // (substituents[3] == -1)
			substituents[3] = nei.aid;
		}
	}

	if (substituents[1] != -1 && this._sameside(bond.begin, bond.end, substituents[0], substituents[1]) != -1) {
		return false;
	}
	if (substituents[3] != -1 && this._sameside(bond.begin, bond.end, substituents[2], substituents[3]) != -1) {
		return false;
	}

	return true;
};

CisTrans.prototype.build = function (exclude_bonds) {
	this.molecule.bonds.each(function (bid, bond) {
		var ct = this.bonds.set(bid,
		{
			parity: 0,
			substituents: new Array(4)
		});

		if (Object.isArray(exclude_bonds) && exclude_bonds[bid])
			return;

		if (!this.isGeomStereoBond(bid, ct.substituents))
			return;

		if (!this._sortSubstituents(ct.substituents))
			return;

		var sign = this._sameside(bond.begin, bond.end, ct.substituents[0], ct.substituents[2]);

		if (sign == 1)
			ct.parity = CisTrans.PARITY.CIS;
		else if (sign == -1)
			ct.parity = CisTrans.PARITY.TRANS;
	}, this);
};

module.exports = CisTrans;

},{"../util/map":41,"../util/vec2":44,"./bond":9}],11:[function(require,module,exports){
var Set = require('../util/set');

var Dfs = function (mol, atom_data, components, nReactants) {
	this.molecule = mol;
	this.atom_data = atom_data;
	this.components = components;
	this.nComponentsInReactants = -1;
	this.nReactants = nReactants;

	this.vertices = new Array(this.molecule.atoms.count()); // Minimum size
	this.molecule.atoms.each(function (aid)
	{
		this.vertices[aid] = new Dfs.VertexDesc();
	}, this);

	this.edges = new Array(this.molecule.bonds.count()); // Minimum size
	this.molecule.bonds.each(function (bid)
	{
		this.edges[bid] = new Dfs.EdgeDesc();
	}, this);

	this.v_seq = [];
};

Dfs.VertexDesc = function ()
{
	this.dfs_state = 0;       // 0 -- not on stack
	// 1 -- on stack
	// 2 -- removed from stack
	this.parent_vertex = 0;   // parent vertex in DFS tree
	this.parent_edge = 0;     // edge to parent vertex
	this.branches = 0;    // how many DFS branches go out from this vertex}
};

Dfs.EdgeDesc = function ()
{
	this.opening_cycles = 0; // how many cycles are
	// (i) starting with this edge
	// and (ii) ending in this edge's first vertex
	this.closing_cycle = 0;  // 1 if this edge closes a cycle
};

Dfs.SeqElem = function (v_idx, par_vertex, par_edge)
{
	this.idx = v_idx;                // index of vertex in _graph
	this.parent_vertex = par_vertex; // parent vertex in DFS tree
	this.parent_edge = par_edge;     // edge to parent vertex
};

Dfs.prototype.walk = function ()
{
	var v_stack = [];
	var i, j;
	var cid = 0;
	var component = 0;

	while (true)
	{
		if (v_stack.length < 1)
		{
			var selected = -1;

			var findFunc = function (aid)
			{
				if (this.vertices[aid].dfs_state == 0)
				{
					selected = aid;
					return true;
				}
				return false;
			};

			while (cid < this.components.length && selected == -1) {
				selected = Set.find(this.components[cid], findFunc, this);
				if (selected === null) {
					selected = -1;
					cid++;
					if (cid == this.nReactants) {
						this.nComponentsInReactants = component;
					}
				}
			}
			if (selected < -1) {
				this.molecule.atoms.find(findFunc, this);
			}
			if (selected == -1)
				break;
			this.vertices[selected].parent_vertex = -1;
			this.vertices[selected].parent_edge = -1;
			v_stack.push(selected);
			component++;
		}

		var v_idx = v_stack.pop();
		var parent_vertex = this.vertices[v_idx].parent_vertex;

		var seq_elem = new Dfs.SeqElem(v_idx, parent_vertex, this.vertices[v_idx].parent_edge);
		this.v_seq.push(seq_elem);

		this.vertices[v_idx].dfs_state = 2;

		var atom_d = this.atom_data[v_idx];

		for (i = 0; i < atom_d.neighbours.length; i++)
		{
			var nei_idx = atom_d.neighbours[i].aid;
			var edge_idx = atom_d.neighbours[i].bid;

			if (nei_idx == parent_vertex)
				continue;

			if (this.vertices[nei_idx].dfs_state == 2)
			{
				this.edges[edge_idx].closing_cycle = 1;

				j = v_idx;

				while (j != -1)
				{
					if (this.vertices[j].parent_vertex == nei_idx)
						break;
					j = this.vertices[j].parent_vertex;
				}

				if (j == -1)
					throw new Error('cycle unwind error');

				this.edges[this.vertices[j].parent_edge].opening_cycles++;
				this.vertices[v_idx].branches++;

				seq_elem = new Dfs.SeqElem(nei_idx, v_idx, edge_idx);
				this.v_seq.push(seq_elem);
			}
			else
			{
				if (this.vertices[nei_idx].dfs_state == 1)
				{
					j = v_stack.indexOf(nei_idx);

					if (j == -1)
						throw new Error('internal: removing vertex from stack');

					v_stack.splice(j, 1);

					var parent = this.vertices[nei_idx].parent_vertex;

					if (parent >= 0)
						this.vertices[parent].branches--;
				}

				this.vertices[v_idx].branches++;
				this.vertices[nei_idx].parent_vertex = v_idx;
				this.vertices[nei_idx].parent_edge = edge_idx;
				this.vertices[nei_idx].dfs_state = 1;
				v_stack.push(nei_idx);
			}
		}
	}
};

Dfs.prototype.edgeClosingCycle = function (e_idx)
{
	return this.edges[e_idx].closing_cycle != 0;
};

Dfs.prototype.numBranches = function (v_idx)
{
	return this.vertices[v_idx].branches;
};

Dfs.prototype.numOpeningCycles = function (e_idx)
{
	return this.edges[e_idx].opening_cycles;
};

Dfs.prototype.toString = function ()
{
	var str = '';
	this.v_seq.each(function (seq_elem) {str += seq_elem.idx + ' -> ';});
	str += '*';
	return str;
};

module.exports = Dfs;

},{"../util/set":43}],12:[function(require,module,exports){
var Map = require('../util/map');

function el(label, period, group, putHydrogenOnTheLeft, color) {
	return {
		label: label,
		period: period,
		group: group,
		putHydrogenOnTheLeft: putHydrogenOnTheLeft,
		color: color || '#000000'
	};
};

var element = new Map({
	1: el( 'H', 1, 1, false, '#000000'),
	2: el('He', 1, 8, false, '#d9ffff'),
	3: el('Li', 2, 1, false, '#cc80ff'),
	4: el('Be', 2, 2, false, '#c2ff00'),
	5: el( 'B', 2, 3, false, '#ffb5b5'),
	6: el( 'C', 2, 4, false, '#000000'),
	7: el( 'N', 2, 5, false, '#304ff7'),
	8: el( 'O', 2, 6, true, '#ff0d0d'),
	9: el( 'F', 2, 7, true, '#8fe04f'),
	10: el('Ne', 2, 8, false, '#b3e3f5'),
	11: el('Na', 3, 1, false, '#ab5cf2'),
	12: el('Mg', 3, 2, false, '#8aff00'),
	13: el('Al', 3, 3, false, '#bfa6a6'),
	14: el('Si', 3, 4, false, '#f0c7a1'),
	15: el( 'P', 3, 5, false, '#ff8000'),
	16: el( 'S', 3, 6, true, '#d9a61a'),
	17: el('Cl', 3, 7, true, '#1fd01f'),
	18: el('Ar', 3, 8, false, '#80d1e3'),
	19: el( 'K', 4, 1, false, '#8f40d4'),
	20: el('Ca', 4, 2, false, '#3dff00'),
	21: el('Sc', 4, 3, false, '#e6e6e6'),
	22: el('Ti', 4, 4, false, '#bfc2c7'),
	23: el( 'V', 4, 5, false, '#a6a6ab'),
	24: el('Cr', 4, 6, false, '#8a99c7'),
	25: el('Mn', 4, 7, false, '#9c7ac7'),
	26: el('Fe', 4, 8, false, '#e06633'),
	27: el('Co', 4, 8, false, '#f08fa1'),
	28: el('Ni', 4, 8, false, '#4fd14f'),
	29: el('Cu', 4, 1, false, '#c78033'),
	30: el('Zn', 4, 2, false, '#7d80b0'),
	31: el('Ga', 4, 3, false, '#c28f8f'),
	32: el('Ge', 4, 4, false, '#668f8f'),
	33: el('As', 4, 5, false, '#bd80e3'),
	34: el('Se', 4, 6, true, '#ffa100'),
	35: el('Br', 4, 7, true, '#a62929'),
	36: el('Kr', 4, 8, false, '#5cb8d1'),
	37: el('Rb', 5, 1, false, '#702eb0'),
	38: el('Sr', 5, 2, false, '#00ff00'),
	39: el( 'Y', 5, 3, false, '#94ffff'),
	40: el('Zr', 5, 4, false, '#94e0e0'),
	41: el('Nb', 5, 5, false, '#73c2c9'),
	42: el('Mo', 5, 6, false, '#54b5b5'),
	43: el('Tc', 5, 7, false, '#3b9e9e'),
	44: el('Ru', 5, 8, false, '#248f8f'),
	45: el('Rh', 5, 8, false, '#0a7d8c'),
	46: el('Pd', 5, 8, false, '#006985'),
	47: el('Ag', 5, 1, false, '#bfbfbf'),
	48: el('Cd', 5, 2, false, '#ffd98f'),
	49: el('In', 5, 3, false, '#a67573'),
	50: el('Sn', 5, 4, false, '#668080'),
	51: el('Sb', 5, 5, false, '#9e63b5'),
	52: el('Te', 5, 6, false, '#d47a00'),
	53: el( 'I', 5, 7, true, '#940094'),
	54: el('Xe', 5, 8, false, '#429eb0'),
	55: el('Cs', 6, 1, false, '#57178f'),
	56: el('Ba', 6, 2, false, '#00c900'),
	57: el('La', 6, 3, false, '#70d4ff'),
	58: el('Ce', 6, 3, false, '#ffffc7'),
	59: el('Pr', 6, 3, false, '#d9ffc7'),
	60: el('Nd', 6, 3, false, '#c7ffc7'),
	61: el('Pm', 6, 3, false, '#a3ffc7'),
	62: el('Sm', 6, 3, false, '#8fffc7'),
	63: el('Eu', 6, 3, false, '#61ffc7'),
	64: el('Gd', 6, 3, false, '#45ffc7'),
	65: el('Tb', 6, 3, false, '#30ffc7'),
	66: el('Dy', 6, 3, false, '#1fffc7'),
	67: el('Ho', 6, 3, false, '#00ff9c'),
	68: el('Er', 6, 3, false, '#00e675'),
	69: el('Tm', 6, 3, false, '#00d452'),
	70: el('Yb', 6, 3, false, '#00bf38'),
	71: el('Lu', 6, 3, false, '#00ab24'),
	72: el('Hf', 6, 4, false, '#4dc2ff'),
	73: el('Ta', 6, 5, false, '#4da6ff'),
	74: el( 'W', 6, 6, false, '#2194d6'),
	75: el('Re', 6, 7, false, '#267dab'),
	76: el('Os', 6, 8, false, '#266696'),
	77: el('Ir', 6, 8, false, '#175487'),
	78: el('Pt', 6, 8, false, '#d1d1e0'),
	79: el('Au', 6, 1, false, '#ffd124'),
	80: el('Hg', 6, 2, false, '#b8b8d1'),
	81: el('Tl', 6, 3, false, '#a6544d'),
	82: el('Pb', 6, 4, false, '#575961'),
	83: el('Bi', 6, 5, false, '#9e4fb5'),
	84: el('Po', 6, 6, false, '#ab5c00'),
	85: el('At', 6, 7, false, '#754f45'),
	86: el('Rn', 6, 8, false, '#428296'),
	87: el('Fr', 7, 1, false, '#420066'),
	88: el('Ra', 7, 2, false, '#007d00'),
	89: el('Ac', 7, 3, false, '#70abfa'),
	90: el('Th', 7, 3, false, '#00baff'),
	91: el('Pa', 7, 3, false, '#00a1ff'),
	92: el( 'U', 7, 3, false, '#008fff'),
	93: el('Np', 7, 3, false, '#0080ff'),
	94: el('Pu', 7, 3, false, '#006bff'),
	95: el('Am', 7, 3, false, '#545cf2'),
	96: el('Cm', 7, 3, false, '#785ce3'),
	97: el('Bk', 7, 3, false, '#8a4fe3'),
	98: el('Cf', 7, 3, false, '#a136d4'),
	99: el('Es', 7, 3, false, '#b31fd4'),
	// TODO need to fix colors for the elements below
	100: el('Fm', 7, 3, false, '#000000'),
	101: el('Md', 7, 3, false, '#000000'),
	102: el('No', 7, 3, false, '#000000'),
	103: el('Lr', 7, 3, false, '#000000'),
	104: el('Rf', 7, 4, false, '#4dc2ff'),
	105: el('Db', 7, 5, false, '#4da6ff'),
	106: el('Sg', 7, 6, false, '#2194d6'),
	107: el('Bh', 7, 7, false, '#267dab'),
	108: el('Hs', 7, 8, false, '#266696'),
	109: el('Mt', 7, 8, false, '#175487'),
	110: el('Ds', 7, 8, false, '#d1d1e0'),
	111: el('Rg', 7, 1, false, '#ffd124'),
	112: el('Cn', 7, 2, false, '#b8b8d1'),
	113: el('Uut', 7, 3, false),
	114: el('Fl', 7, 4, false),
	115: el('Uup', 7, 5, false),
	116: el('Lv', 7, 6, false),
	117: el('Uus', 7, 7, false),
	118: el('Uuo', 7, 8, false)
});

var labelMap = null;
element.getElementByLabel = function (label) {
	if (!labelMap) {
		labelMap = {};
		element.each(function (key, value) {
			labelMap[value.label] = key - 0;
		});
	}
	return labelMap[label] || null;
};

module.exports = element;

},{"../util/map":41}],13:[function(require,module,exports){
var Map = require('../util/map');
var Set = require('../util/set');
var Vec2 = require('../util/vec2');
var element = require('./element');
var Struct = require('./struct');
var SGroup = require('./sgroup');
var Atom = require('./atom');
var Bond = require('./bond');

var util = require('../util');

var FRAGMENT = {
    NONE: 0,
    REACTANT: 1,
    PRODUCT: 2,
    AGENT: 3
};

var Molfile = function (v3000) {
    /* reader */
    /* saver */
    this.molecule = null;
    this.molfile = null;
    this.v3000 = v3000 || false;
};

Molfile.loadRGroupFragments = true; // TODO: set to load the fragments

var parseDecimalInt = function (str)
{
    /* reader */
	var val = parseInt(str, 10);

	return isNaN(val) ? 0 : val;
};

var partitionLine = function (/*string*/ str, /*array of int*/ parts, /*bool*/ withspace)
{
    /* reader */
	var res = [];
	for (var i = 0, shift = 0; i < parts.length; ++i)
	{
		res.push(str.slice(shift, shift + parts[i]));
		if (withspace)
			shift++;
		shift += parts[i];
	}
	return res;
};

var partitionLineFixed = function (/*string*/ str, /*int*/ itemLength, /*bool*/ withspace)
{
    /* reader */
	var res = [];
	for (var shift = 0; shift < str.length; shift += itemLength)
	{
		res.push(str.slice(shift, shift + itemLength));
		if (withspace)
			shift++;
	}
	return res;
};

Molfile.prototype.parseCTFile = function (molfile) {
	var molfileLines = Array.isArray(molfile) ? molfile : util.splitNewlines(molfile);
	var ret = null;
	if (molfileLines[0].search('\\$RXN') == 0)
		ret = parseRxn(molfileLines);
	else
		ret = parseMol(molfileLines);
	ret.initHalfBonds();
	ret.initNeighbors();
	ret.markFragments();
	return ret;
};

var fmtInfo = {
	bondTypeMap: {
		1: Bond.PATTERN.TYPE.SINGLE,
		2: Bond.PATTERN.TYPE.DOUBLE,
		3: Bond.PATTERN.TYPE.TRIPLE,
		4: Bond.PATTERN.TYPE.AROMATIC,
		5: Bond.PATTERN.TYPE.SINGLE_OR_DOUBLE,
		6: Bond.PATTERN.TYPE.SINGLE_OR_AROMATIC,
		7: Bond.PATTERN.TYPE.DOUBLE_OR_AROMATIC,
		8: Bond.PATTERN.TYPE.ANY
	},
	bondStereoMap: {
		0: Bond.PATTERN.STEREO.NONE,
		1: Bond.PATTERN.STEREO.UP,
		4: Bond.PATTERN.STEREO.EITHER,
		6: Bond.PATTERN.STEREO.DOWN,
		3: Bond.PATTERN.STEREO.CIS_TRANS
	},
	v30bondStereoMap: {
		0: Bond.PATTERN.STEREO.NONE,
		1: Bond.PATTERN.STEREO.UP,
		2: Bond.PATTERN.STEREO.EITHER,
		3: Bond.PATTERN.STEREO.DOWN
	},
	bondTopologyMap: {
		0: Bond.PATTERN.TOPOLOGY.EITHER,
		1: Bond.PATTERN.TOPOLOGY.RING,
		2: Bond.PATTERN.TOPOLOGY.CHAIN
	},
	countsLinePartition: [3,3,3,3,3,3,3,3,3,3,3,6],
	atomLinePartition: [10,10,10,1,3,2,3,3,3,3,3,3,3,3,3,3,3],
	bondLinePartition: [3,3,3,3,3,3,3],
	atomListHeaderPartition: [3,1,1,4,1,1],
	atomListHeaderLength: 11, // = atomListHeaderPartition.reduce(function(a,b) { return a + b; }, 0)
	atomListHeaderItemLength: 4,
	chargeMap: [0, +3, +2, +1, 0, -1, -2, -3],
	valenceMap: [undefined, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 0],
	implicitHydrogenMap: [undefined, 0, 1, 2, 3, 4],
	v30atomPropMap: {
		'CHG':'charge',
		'RAD':'radical',
		'MASS':'isotope',
		'VAL':'explicitValence',
		'HCOUNT':'hCount',
		'INVRET':'invRet',
		'SUBST':'substitutionCount',
		'UNSAT':'unsaturatedAtom',
		'RBCNT':'ringBondCount'
	},
	rxnItemsPartition: [3,3,3]
};

var parseAtomLine = function (atomLine)
{
    /* reader */
	var atomSplit = partitionLine(atomLine, fmtInfo.atomLinePartition);
	var params =
	{
		// generic
		pp: new Vec2(parseFloat(atomSplit[0]), -parseFloat(atomSplit[1])),
		label: atomSplit[4].strip(),
		explicitValence: fmtInfo.valenceMap[parseDecimalInt(atomSplit[10])],

		// obsolete
		massDifference: parseDecimalInt(atomSplit[5]),
		charge: fmtInfo.chargeMap[parseDecimalInt(atomSplit[6])],

		// query
		hCount: parseDecimalInt(parseDecimalInt(atomSplit[8])),
		stereoCare: parseDecimalInt(atomSplit[9]) != 0,

		// reaction
		aam: parseDecimalInt(atomSplit[14]),
		invRet: parseDecimalInt(atomSplit[15]),

		// reaction query
		exactChangeFlag: parseDecimalInt(atomSplit[16]) != 0
	};
	return new Atom(params);
};

var stripV30 = function (line)
{
    /* reader */
	if (line.slice(0, 7) != 'M  V30 ')
		throw Error('Prefix invalid');
	return line.slice(7);
};

var parseAtomLineV3000 = function (line)
{
    /* reader */
	var split, subsplit, key, value, i;
	split = spaceparsplit(line);
	var params = {
		pp: new Vec2(parseFloat(split[2]), -parseFloat(split[3])),
		aam: split[5].strip()
	};
	var label = split[1].strip();
	if (label.charAt(0) == '"' && label.charAt(label.length - 1) == '"') {
		label = label.substr(1, label.length - 2); // strip qutation marks
	}
	if (label.charAt(label.length - 1) == ']') { // assume atom list
		label = label.substr(0, label.length - 1); // remove ']'
		var atomListParams = {};
		atomListParams.notList = false;
		if (label.substr(0, 5) == 'NOT [') {
			atomListParams.notList = true;
			label = label.substr(5); // remove 'NOT ['
		} else if (label.charAt(0) != '[') {
			throw 'Error: atom list expected, found \'' + label + '\'';
		} else {
			label = label.substr(1); // remove '['
		}
		atomListParams.ids = labelsListToIds(label.split(','));
		params['atomList'] = new Atom.List(atomListParams);
		params['label'] = 'L#';
	} else {
		params['label'] = label;
	}
	split.splice(0, 6);
	for (i = 0; i < split.length; ++i) {
		subsplit = splitonce(split[i], '=');
		key = subsplit[0];
		value = subsplit[1];
		if (key in fmtInfo.v30atomPropMap) {
			var ival = parseDecimalInt(value);
			if (key == 'VAL') {
				if (ival == 0)
					continue;
				if (ival == -1)
					ival = 0;
			}
			params[fmtInfo.v30atomPropMap[key]] = ival;
		} else if (key == 'RGROUPS') {
			value = value.strip().substr(1, value.length - 2);
			var rgrsplit = value.split(' ').slice(1);
			params.rglabel = 0;
			for (var j = 0; j < rgrsplit.length; ++j) {
				params.rglabel |= 1 << (rgrsplit[j] - 1);
			}
		} else if (key == 'ATTCHPT') {
			params.attpnt = value.strip() - 0;
		}
	}
	return new Atom(params);
};

var parseBondLineV3000 = function (line)
{
    /* reader */
	var split, subsplit, key, value, i;
	split = spaceparsplit(line);
	var params = {
		begin: parseDecimalInt(split[2]) - 1,
		end: parseDecimalInt(split[3]) - 1,
		type: fmtInfo.bondTypeMap[parseDecimalInt(split[1])]
	};
	split.splice(0, 4);
	for (i = 0; i < split.length; ++i) {
		subsplit = splitonce(split[i], '=');
		key = subsplit[0];
		value = subsplit[1];
		if (key == 'CFG') {
			params.stereo = fmtInfo.v30bondStereoMap[parseDecimalInt(value)];
			if (params.type == Bond.PATTERN.TYPE.DOUBLE && params.stereo == Bond.PATTERN.STEREO.EITHER)
				params.stereo = Bond.PATTERN.STEREO.CIS_TRANS;
		} else if (key == 'TOPO') {
			params.topology = fmtInfo.bondTopologyMap[parseDecimalInt(value)];
		} else if (key == 'RXCTR') {
			params.reactingCenterStatus = parseDecimalInt(value);
		} else if (key == 'STBOX') {
			params.stereoCare = parseDecimalInt(value);
		}
	}
	return new Bond(params);
};

var parseBondLine = function (bondLine)
{
    /* reader */
	var bondSplit = partitionLine(bondLine, fmtInfo.bondLinePartition);
	var params =
	{
		begin: parseDecimalInt(bondSplit[0]) - 1,
		end: parseDecimalInt(bondSplit[1]) - 1,
		type: fmtInfo.bondTypeMap[parseDecimalInt(bondSplit[2])],
		stereo: fmtInfo.bondStereoMap[parseDecimalInt(bondSplit[3])],
		topology: fmtInfo.bondTopologyMap[parseDecimalInt(bondSplit[5])],
		reactingCenterStatus: parseDecimalInt(bondSplit[6])
	};

	return new Bond(params);
};

var parseAtomListLine = function (/* string */atomListLine)
{
    /* reader */
	var split = partitionLine(atomListLine, fmtInfo.atomListHeaderPartition);

	var number = parseDecimalInt(split[0]) - 1;
	var notList = (split[2].strip() == 'T');
	var count = parseDecimalInt(split[4].strip());

	var ids = atomListLine.slice(fmtInfo.atomListHeaderLength);
	var list = [];
	var itemLength = fmtInfo.atomListHeaderItemLength;
	for (var i = 0; i < count; ++i)
		list[i] = parseDecimalInt(ids.slice(i * itemLength, (i + 1) * itemLength - 1));

	return {
		'aid': number,
		'atomList': new Atom.List({
			'notList': notList,
			'ids': list
		})
	};
};

var readKeyValuePairs = function (str, /* bool */ valueString)
{
    /* reader */
	var ret = {};
	var partition = partitionLineFixed(str, 3, true);
	var count = parseDecimalInt(partition[0]);
	for (var i = 0; i < count; ++i)
		ret[parseDecimalInt(partition[2 * i + 1]) - 1] =
			valueString ? partition[2 * i + 2].strip() :
			parseDecimalInt(partition[2 * i + 2]);
	return ret;
};

var readKeyMultiValuePairs = function (str, /* bool */ valueString)
{
    /* reader */
	var ret = [];
	var partition = partitionLineFixed(str, 3, true);
	var count = parseDecimalInt(partition[0]);
	for (var i = 0; i < count; ++i)
		ret.push([
			parseDecimalInt(partition[2 * i + 1]) - 1,
				valueString ? partition[2 * i + 2].strip() : parseDecimalInt(partition[2 * i + 2])
			]);
	return ret;
};

var labelsListToIds = function (labels)
{
    /* reader */
	var ids = [];
	for (var i = 0; i < labels.length; ++i) {
		ids.push(element.getElementByLabel(labels[i].strip()));
	}
	return ids;
};

var parsePropertyLineAtomList = function (hdr, lst)
{
    /* reader */
	var aid = parseDecimalInt(hdr[1]) - 1;
	var count = parseDecimalInt(hdr[2]);
	var notList = hdr[4].strip() == 'T';
	var ids = labelsListToIds(lst.slice(0, count));
	var ret = {};
	ret[aid] = new Atom.List({
		'notList': notList,
		'ids': ids
	});
	return ret;
};

var initSGroup = function (sGroups, propData)
{
    /* reader */
	var kv = readKeyValuePairs(propData, true);
	for (var key in kv) {
		var type = kv[key];
		if (!(type in SGroup.TYPES))
			throw new Error('Unsupported S-group type');
		var sg = new SGroup(type);
		sg.number = key;
		sGroups[key] = sg;
	}
};

var applySGroupProp = function (sGroups, propName, propData, numeric, core)
{
	var kv = readKeyValuePairs(propData, !(numeric));
	for (var key in kv) {
		// "core" properties are stored directly in an sgroup, not in sgroup.data
		(core ? sGroups[key] : sGroups[key].data) [propName] = kv[key];
	}
};

var toIntArray = function (strArray)
{
    /* reader */
	var ret = [];
	for (var j = 0; j < strArray.length; ++j)
		ret[j] = parseDecimalInt(strArray[j]);
	return ret;
};

var applySGroupArrayProp = function (sGroups, propName, propData, shift)
{
    /* reader */
	var sid = parseDecimalInt(propData.slice(1, 4)) - 1;
	var num = parseDecimalInt(propData.slice(4, 8));
	var part = toIntArray(partitionLineFixed(propData.slice(8), 3, true));

	if (part.length != num)
		throw new Error('File format invalid');
	if (shift) {
		util.apply(part, function (v) {
			return v + shift;
		});
	}
	sGroups[sid][propName] = sGroups[sid][propName].concat(part);
};

var applyDataSGroupName = function (sg, name) {
    /* reader */
	sg.data.fieldName = name;
};

var applyDataSGroupQuery = function (sg, query) {
    /* reader */
	sg.data.query = query;
};

var applyDataSGroupQueryOp = function (sg, queryOp) {
    /* reader */
	sg.data.queryOp = queryOp;
};

var applyDataSGroupDesc = function (sGroups, propData) {
    /* reader */
	var split = partitionLine(propData, [4,31,2,20,2,3], false);
	var id = parseDecimalInt(split[0]) - 1;
	var fieldName = split[1].strip();
	var fieldType = split[2].strip();
	var units = split[3].strip();
	var query = split[4].strip();
	var queryOp = split[5].strip();
	var sGroup = sGroups[id];
	sGroup.data.fieldType = fieldType;
	sGroup.data.fieldName = fieldName;
	sGroup.data.units = units;
	sGroup.data.query = query;
	sGroup.data.queryOp = queryOp;
};

var applyDataSGroupInfo = function (sg, propData) {
    /* reader */
	var split = partitionLine(propData, [10/*x.x*/,10/*y.y*/,4/* eee*/,1/*f*/,1/*g*/,1/*h*/,3/* i */,3/*jjj*/,3/*kkk*/,3/*ll*/,2/*m*/,3/*n*/,2/*oo*/], false);

	var x = parseFloat(split[0]);
	var y = parseFloat(split[1]);
	var attached = split[3].strip() == 'A';
	var absolute = split[4].strip() == 'A';
	var showUnits = split[5].strip() == 'U';
	var nCharsToDisplay = split[7].strip();
	nCharsToDisplay = nCharsToDisplay == 'ALL' ? -1 : parseDecimalInt(nCharsToDisplay);
	var tagChar = split[10].strip();
	var daspPos = parseDecimalInt(split[11].strip());

	sg.pp = new Vec2(x, -y);
	sg.data.attached = attached;
	sg.data.absolute = absolute;
	sg.data.showUnits = showUnits;
	sg.data.nCharsToDisplay = nCharsToDisplay;
	sg.data.tagChar = tagChar;
	sg.data.daspPos = daspPos;
};

var applyDataSGroupInfoLine = function (sGroups, propData) {
    /* reader */
	var id = parseDecimalInt(propData.substr(0,4)) - 1;
	var sg = sGroups[id];
	applyDataSGroupInfo(sg, propData.substr(5));
};

var applyDataSGroupData = function (sg, data, finalize) {
    /* reader */
	sg.data.fieldValue = (sg.data.fieldValue || '') + data;
	if (finalize) {
		sg.data.fieldValue = util.stripRight(sg.data.fieldValue);
		if (sg.data.fieldValue.startsWith('"') && sg.data.fieldValue.endsWith('"'))
			sg.data.fieldValue = sg.data.fieldValue.substr(1, sg.data.fieldValue.length - 2);
		// Partially revert f556e8, from KETCHER-457 and RB with love
		// sg.data.fieldValue += '\n';
	}
};

var applyDataSGroupDataLine = function (sGroups, propData, finalize) {
    /* reader */
	var id = parseDecimalInt(propData.substr(0,5)) - 1;
	var data = propData.substr(5);
	var sg = sGroups[id];
	applyDataSGroupData(sg, data, finalize);
};

var parsePropertyLines = function (ctab, ctabLines, shift, end, sGroups, rLogic)
{
    /* reader */
	var props = new Map();
	while (shift < end)
	{
		var line = ctabLines[shift];
		if (line.charAt(0) == 'A') {
			if (!props.get('label'))
				props.set('label', new Map());
			props.get('label').set(parseDecimalInt(line.slice(3, 6)) - 1, ctabLines[++shift]);
		} else if (line.charAt(0) == 'M') {
			var type = line.slice(3, 6);
			var propertyData = line.slice(6);
			if (type == 'END') {
				break;
			} else if (type == 'CHG') {
				if (!props.get('charge'))
					props.set('charge', new Map());
				props.get('charge').update(readKeyValuePairs(propertyData));
			} else if (type == 'RAD') {
				if (!props.get('radical'))
					props.set('radical', new Map());
				props.get('radical').update(readKeyValuePairs(propertyData));
			} else if (type == 'ISO') {
				if (!props.get('isotope'))
					props.set('isotope', new Map());
				props.get('isotope').update(readKeyValuePairs(propertyData));
			} else if (type == 'RBC') {
				if (!props.get('ringBondCount'))
					props.set('ringBondCount', new Map());
				props.get('ringBondCount').update(readKeyValuePairs(propertyData));
			} else if (type == 'SUB') {
				if (!props.get('substitutionCount'))
					props.set('substitutionCount', new Map());
				props.get('substitutionCount').update(readKeyValuePairs(propertyData));
			} else if (type == 'UNS') {
				if (!props.get('unsaturatedAtom'))
					props.set('unsaturatedAtom', new Map());
				props.get('unsaturatedAtom').update(readKeyValuePairs(propertyData));
				// else if (type == "LIN") // link atom
			} else if (type == 'RGP') { // rgroup atom
				if (!props.get('rglabel'))
					props.set('rglabel', new Map());
				var rglabels = props.get('rglabel');
				var a2rs = readKeyMultiValuePairs(propertyData);
				for (var a2ri = 0; a2ri < a2rs.length; a2ri++) {
					var a2r = a2rs[a2ri];
					rglabels.set(a2r[0], (rglabels.get(a2r[0]) || 0) | (1 << (a2r[1] - 1)));
				}
			} else if (type == 'LOG') { // rgroup atom
				propertyData = propertyData.slice(4);
				var rgid = parseDecimalInt(propertyData.slice(0,3).strip());
				var iii = parseDecimalInt(propertyData.slice(4,7).strip());
				var hhh = parseDecimalInt(propertyData.slice(8,11).strip());
				var ooo = propertyData.slice(12).strip();
				var logic = {};
				if (iii > 0)
					logic.ifthen = iii;
				logic.resth = hhh == 1;
				logic.range = ooo;
				rLogic[rgid] = logic;
			} else if (type == 'APO') {
				if (!props.get('attpnt'))
					props.set('attpnt', new Map());
				props.get('attpnt').update(readKeyValuePairs(propertyData));
			} else if (type == 'ALS') { // atom list
				if (!props.get('atomList'))
					props.set('atomList', new Map());
				var list = parsePropertyLineAtomList(
				partitionLine(propertyData, [1,3,3,1,1,1]),
				partitionLineFixed(propertyData.slice(10), 4, false));
				props.get('atomList').update(
					list);
				if (!props.get('label'))
					props.set('label', new Map());
				for (var aid in list) props.get('label').set(aid, 'L#');
			} else if (type == 'STY') { // introduce s-group
				initSGroup(sGroups, propertyData);
			} else if (type == 'SST') {
				applySGroupProp(sGroups, 'subtype', propertyData);
			} else if (type == 'SLB') {
				applySGroupProp(sGroups, 'label', propertyData, true);
			} else if (type == 'SPL') {
				applySGroupProp(sGroups, 'parent', propertyData, true, true);
			} else if (type == 'SCN') {
				applySGroupProp(sGroups, 'connectivity', propertyData);
			} else if (type == 'SAL') {
				applySGroupArrayProp(sGroups, 'atoms', propertyData, -1);
			} else if (type == 'SBL') {
				applySGroupArrayProp(sGroups, 'bonds', propertyData, -1);
			} else if (type == 'SPA') {
				applySGroupArrayProp(sGroups, 'patoms', propertyData, -1);
			} else if (type == 'SMT') {
				var sid = parseDecimalInt(propertyData.slice(0, 4)) - 1;
				sGroups[sid].data.subscript = propertyData.slice(4).strip();
			} else if (type == 'SDT') {
				applyDataSGroupDesc(sGroups, propertyData);
			} else if (type == 'SDD') {
				applyDataSGroupInfoLine(sGroups, propertyData);
			} else if (type == 'SCD') {
				applyDataSGroupDataLine(sGroups, propertyData, false);
			} else if (type == 'SED') {
				applyDataSGroupDataLine(sGroups, propertyData, true);
			}
		}
		++shift;
	}
	return props;
};

var applyAtomProp = function (atoms /* Pool */, values /* Map */, propId /* string */, clean /* boolean */)
{
    /* reader */
	values.each(function (aid, propVal){
		atoms.get(aid)[propId] = propVal;
	});
};

var addGroup = function (mol, sg, atomMap) {
    // add the group to the molecule
    sg.id = mol.sgroups.add(sg);

    // apply type-specific post-processing
    sg.postLoad(mol, atomMap);

    // mark atoms in the group as belonging to it
    for (var s = 0; s < sg.atoms.length; ++s)
        if (mol.atoms.has(sg.atoms[s]))
            Set.add(mol.atoms.get(sg.atoms[s]).sgs, sg.id);

    mol.sGroupForest.insert(sg.id);
    return sg.id;
};

var filterAtoms = function (atoms, map) {
    var newAtoms = [];
    for (var i = 0; i < atoms.length; ++i) {
        var aid = atoms[i];
        if (typeof (map[aid]) != 'number') {
            newAtoms.push(aid);
        } else if (map[aid] >= 0) {
            newAtoms.push(map[aid]);
        } else {
            newAtoms.push(-1);
        }
    }
    return newAtoms;
};

var removeNegative = function (atoms) {
    var newAtoms = [];
    for (var j = 0; j < atoms.length; ++j)
        if (atoms[j] >= 0)
            newAtoms.push(atoms[j]);
    return newAtoms;
};

var SGroup_filter = function (mol, sg, atomMap) {
    sg.atoms = removeNegative(filterAtoms(sg.atoms, atomMap));
};

var parseCTabV2000 = function (ctabLines, countsSplit)
{
    /* reader */
	var ctab = new Struct();
	var i;
	var atomCount = parseDecimalInt(countsSplit[0]);
	var bondCount = parseDecimalInt(countsSplit[1]);
	var atomListCount = parseDecimalInt(countsSplit[2]);
	ctab.isChiral = parseDecimalInt(countsSplit[4]) != 0;
	var stextLinesCount = parseDecimalInt(countsSplit[5]);
	var propertyLinesCount = parseDecimalInt(countsSplit[10]);

	var shift = 0;
	var atomLines = ctabLines.slice(shift, shift + atomCount);
	shift += atomCount;
	var bondLines = ctabLines.slice(shift, shift + bondCount);
	shift += bondCount;
	var atomListLines = ctabLines.slice(shift, shift + atomListCount);
	shift += atomListCount + stextLinesCount;

	var atoms = atomLines.map(parseAtomLine);
	for (i = 0; i < atoms.length; ++i)
		ctab.atoms.add(atoms[i]);
	var bonds = bondLines.map(parseBondLine);
	for (i = 0; i < bonds.length; ++i)
		ctab.bonds.add(bonds[i]);

	var atomLists = atomListLines.map(parseAtomListLine);
	atomLists.each(function (pair){
		ctab.atoms.get(pair.aid).atomList = pair.atomList;
		ctab.atoms.get(pair.aid).label = 'L#';
	});

	var sGroups = {}, rLogic = {};
	var props = parsePropertyLines(ctab, ctabLines, shift,
	Math.min(ctabLines.length, shift + propertyLinesCount), sGroups, rLogic);
	props.each(function (propId, values) {
		applyAtomProp(ctab.atoms, values, propId);
	});

	var atomMap = {};
	var sid;
	for (sid in sGroups) {
		var sg = sGroups[sid];
		if (sg.type === 'DAT' && sg.atoms.length === 0) {
			var parent = sGroups[sid].parent;
			if (parent >= 0) {
				var psg = sGroups[parent - 1];
				if (psg.type === 'GEN') {
					sg.atoms = util.array(psg.atoms);
				}
			}
		}
	}
	for (sid in sGroups) {
		addGroup(ctab, sGroups[sid], atomMap);
	}
	var emptyGroups = [];
	for (sid in sGroups) { // TODO: why do we need that?
        sGroups[sid].atoms = SGroup_filter(sGroups[sid].atoms, atomMap);
		if (sGroups[sid].atoms.length == 0 && !sGroups[sid].allAtoms)
			emptyGroups.push(sid);
	}
	for (i = 0; i < emptyGroups.length; ++i) {
		ctab.sGroupForest.remove(emptyGroups[i]);
		ctab.sgroups.remove(emptyGroups[i]);
	}
	for (var rgid in rLogic) {
		ctab.rgroups.set(rgid, new Struct.RGroup(rLogic[rgid]));
	}
	return ctab;
};

// split a line by spaces outside parentheses
var spaceparsplit = function (line)
{
    /* reader */
	var split = [], pc = 0, c, i, i0 = -1;
	var line_array = line.toArray(); // IE7 doesn't support line[i]
	var quoted = false;

	for (i = 0; i < line.length; ++i)
	{
		c = line_array[i];
		if (c == '(')
			pc++;
		else if (c == ')')
			pc--;
		if (c == '"')
			quoted = !quoted;
		if (!quoted && line_array[i] == ' ' && pc == 0) {
			if (i > i0 + 1)
				split.push(line.slice(i0 + 1, i));
			i0 = i;
		}
	}
	if (i > i0 + 1)
		split.push(line.slice(i0 + 1, i));
	i0 = i;
	return split;
};

var splitonce = function (line, delim)
{
    /* reader */
	var p = line.indexOf(delim);
	return [line.slice(0,p),line.slice(p + 1)];
};

var splitSGroupDef = function (line)
{
    /* reader */
	var split = [];
	var braceBalance = 0;
	var quoted = false;
	for (var i = 0; i < line.length; ++i) {
		var c = line.charAt(i);
		if (c == '"') {
			quoted = !quoted;
		} else if (!quoted) {
			if (c == '(') {
				braceBalance++;
			} else if (c == ')') {
				braceBalance--;
			} else if (c == ' ' && braceBalance == 0) {
				split.push(line.slice(0, i));
				line = line.slice(i + 1).strip();
				i = 0;
			}
		}
	}
	if (braceBalance != 0)
		throw 'Brace balance broken. S-group properies invalid!';
	if (line.length > 0)
		split.push(line.strip());
	return split;
};

var parseBracedNumberList = function (line, shift)
{
    /* reader */
	if (!line)
		return null;
	var list = [];
	line = line.strip();
	line = line.substr(1, line.length - 2);
	var split = line.split(' ');
	shift = shift || 0;
	for (var i = 1; i < split.length; ++i) { // skip the first element
		list.push(split[i] - 0 + shift);
	}
	return list;
};

var v3000parseCollection = function (ctab, ctabLines, shift)
{
    /* reader */
	shift++;
	while (ctabLines[shift].strip() != 'M  V30 END COLLECTION')
		shift++;
	shift++;
	return shift;
};

var v3000parseSGroup = function (ctab, ctabLines, sgroups, atomMap, shift)
{
    /* reader */
	var line = '';
	shift++;
	while (shift < ctabLines.length) {
		line =stripV30(ctabLines[shift++]).strip();
		if (line.strip() == 'END SGROUP')
			return shift;
		while (line.charAt(line.length - 1) == '-')
			line = (line.substr(0, line.length - 1) +
			stripV30(ctabLines[shift++])).strip();
		var split = splitSGroupDef(line);
		var type = split[1];
		var sg = new SGroup(type);
		sg.number = split[0] - 0;
		sg.type = type;
		sg.label = split[2] - 0;
		sgroups[sg.number] = sg;
		var props = {};
		for (var i = 3; i < split.length; ++i) {
			var subsplit = splitonce(split[i],'=');
			if (subsplit.length != 2) {
				throw 'A record of form AAA=BBB or AAA=(...) expected, got \'' + split[i] + '\'';
			}
			var name = subsplit[0];
			if (!(name in props))
				props[name] = [];
			props[name].push(subsplit[1]);
		}
		sg.atoms = parseBracedNumberList(props['ATOMS'][0], -1);
		if (props['PATOMS'])
			sg.patoms = parseBracedNumberList(props['PATOMS'][0], -1);
		sg.bonds = props['BONDS'] ? parseBracedNumberList(props['BONDS'][0], -1) : [];
		var brkxyzStrs = props['BRKXYZ'];
		sg.brkxyz = [];
		if (brkxyzStrs) {
			for (var j = 0; j < brkxyzStrs.length; ++j)
				sg.brkxyz.push(parseBracedNumberList(brkxyzStrs[j]));
		}
		if (props['MULT']) {
			sg.data.subscript = props['MULT'][0] - 0;
		}
		if (props['LABEL']) {
			sg.data.subscript = props['LABEL'][0].strip();
		}
		if (props['CONNECT']) {
			sg.data.connectivity = props['CONNECT'][0].toLowerCase();
		}
		if (props['FIELDDISP']) {
			applyDataSGroupInfo(sg, util.stripQuotes(props['FIELDDISP'][0]));
		}
		if (props['FIELDDATA']) {
			applyDataSGroupData(sg, props['FIELDDATA'][0], true);
		}
		if (props['FIELDNAME']) {
			applyDataSGroupName(sg, props['FIELDNAME'][0]);
		}
		if (props['QUERYTYPE']) {
			applyDataSGroupQuery(sg, props['QUERYTYPE'][0]);
		}
		if (props['QUERYOP']) {
			applyDataSGroupQueryOp(sg, props['QUERYOP'][0]);
		}
		addGroup(ctab, sg, atomMap);
	}
	throw new Error('S-group declaration incomplete.');
};

var parseCTabV3000 = function (ctabLines, norgroups)
{
    /* reader */
	var ctab = new Struct();

	var shift = 0;
	if (ctabLines[shift++].strip() != 'M  V30 BEGIN CTAB')
		throw Error('CTAB V3000 invalid');
	if (ctabLines[shift].slice(0, 13) != 'M  V30 COUNTS')
		throw Error('CTAB V3000 invalid');
	var vals = ctabLines[shift].slice(14).split(' ');
	ctab.isChiral = (parseDecimalInt(vals[4]) == 1);
	shift++;

	if (ctabLines[shift].strip() == 'M  V30 BEGIN ATOM') {
		shift++;
		var line;
		while (shift < ctabLines.length) {
			line =stripV30(ctabLines[shift++]).strip();
			if (line == 'END ATOM')
				break;
			while (line.charAt(line.length - 1) == '-')
				line = (line.substring(0, line.length - 1) +stripV30(ctabLines[shift++])).strip();
			ctab.atoms.add(parseAtomLineV3000(line));
		}

		if (ctabLines[shift].strip() == 'M  V30 BEGIN BOND')
		{
			shift++;
			while (shift < ctabLines.length) {
				line =stripV30(ctabLines[shift++]).strip();
				if (line == 'END BOND')
					break;
				while (line.charAt(line.length - 1) == '-')
					line = (line.substring(0, line.length - 1) +stripV30(ctabLines[shift++])).strip();
				ctab.bonds.add(parseBondLineV3000(line));
			}
		}

		// TODO: let sections follow in arbitrary order
		var sgroups = {};
		var atomMap = {};

		while (ctabLines[shift].strip() != 'M  V30 END CTAB') {
			if (ctabLines[shift].strip() == 'M  V30 BEGIN COLLECTION') {
				// TODO: read collection information
				shift = v3000parseCollection(ctab, ctabLines, shift);
			} else if (ctabLines[shift].strip() == 'M  V30 BEGIN SGROUP') {
				shift = v3000parseSGroup(ctab, ctabLines, sgroups, atomMap, shift);
			} else {
				throw Error('CTAB V3000 invalid');
			}
		}
	}
	if (ctabLines[shift++].strip() != 'M  V30 END CTAB')
		throw Error('CTAB V3000 invalid');

	if (!norgroups) {
		readRGroups3000(ctab, ctabLines.slice(shift));
	}

	return ctab;
};

var readRGroups3000 = function (ctab, /* string */ ctabLines) /* Struct */
{
    /* reader */
	var rfrags = {};
	var rLogic = {};
	var shift = 0;
	while (shift < ctabLines.length && ctabLines[shift].search('M  V30 BEGIN RGROUP') == 0)
	{
		var id = ctabLines[shift++].split(' ').pop();
		rfrags[id] = [];
		rLogic[id] = {};
		while (true) {
			var line = ctabLines[shift].strip();
			if (line.search('M  V30 RLOGIC') == 0) {
				line = line.slice(13);
				var rlsplit = line.strip().split(/\s+/g);
				var iii = parseDecimalInt(rlsplit[0]);
				var hhh = parseDecimalInt(rlsplit[1]);
				var ooo = rlsplit.slice(2).join(' ');
				var logic = {};
				if (iii > 0)
					logic.ifthen = iii;
				logic.resth = hhh == 1;
				logic.range = ooo;
				rLogic[id] = logic;
				shift++;
				continue;
			}
			if (line != 'M  V30 BEGIN CTAB')
				throw Error('CTAB V3000 invalid');
			for (var i = 0; i < ctabLines.length; ++i)
				if (ctabLines[shift + i].strip() == 'M  V30 END CTAB')
					break;
			var lines = ctabLines.slice(shift, shift + i + 1);
			var rfrag = parseCTabV3000(lines, true);
			rfrags[id].push(rfrag);
			shift = shift + i + 1;
			if (ctabLines[shift].strip() == 'M  V30 END RGROUP') {
				shift++;
				break;
			}
		}
	}

	for (var rgid in rfrags) {
		for (var j = 0; j < rfrags[rgid].length; ++j) {
			var rg = rfrags[rgid][j];
			rg.rgroups.set(rgid, new Struct.RGroup(rLogic[rgid]));
			var frid = rg.frags.add(new Struct.Fragment());
			rg.rgroups.get(rgid).frags.add(frid);
			rg.atoms.each(function (aid, atom) {atom.fragment = frid;});
			rg.mergeInto(ctab);
		}
	}
};

var parseMol = function (/* string */ ctabLines) /* Struct */
{
    /* reader */
	if (ctabLines[0].search('\\$MDL') == 0) {
		return parseRg2000(ctabLines);
	}
	var struct = parseCTab(ctabLines.slice(3));
	struct.name = ctabLines[0].strip();
	return struct;
};

var parseCTab = function (/* string */ ctabLines) /* Struct */
{
    /* reader */
	var countsSplit = partitionLine(ctabLines[0], fmtInfo.countsLinePartition);
	var version = countsSplit[11].strip();
	ctabLines = ctabLines.slice(1);
	if (version == 'V2000')
		return parseCTabV2000(ctabLines, countsSplit);
	else if (version == 'V3000')
		return parseCTabV3000(ctabLines, !Molfile.loadRGroupFragments);
	else
		throw Error('Molfile version unknown: ' + version);
};

Molfile.prototype.prepareSGroups = function (skipErrors, preserveIndigoDesc) {
    var mol = this.molecule;
    var sgroups = mol.sgroups;
    var toRemove = [];
    var errors = 0;

    util.each(this.molecule.sGroupForest.getSGroupsBFS().reverse(), function (id) {
        var sg = mol.sgroups.get(id);
        var errorIgnore = false;

        try {
            sg.prepareForSaving(mol);
        } catch (ex) {
            if (!skipErrors || typeof (ex.id) != 'number')
                throw ex;
            errorIgnore = true;
        }
        if (errorIgnore ||
		    !preserveIndigoDesc && /^INDIGO_.+_DESC$/i.test(sg.data.fieldName)) {
            errors += errorIgnore;
            toRemove.push(sg.id);
        }
    }, this);
    if (errors) {
        alert('WARNING: ' + errors + ' invalid S-groups were detected. They will be omitted.');
    }

    for (var i = 0; i < toRemove.length; ++i) {
        mol.sGroupDelete(toRemove[i]);
    }
    return mol;
};

Molfile.prototype.getCTab = function (molecule, rgroups)
{
    /* saver */
	this.molecule = molecule.clone();
	this.molfile = '';
	this.writeCTab2000(rgroups);
	return this.molfile;
};

Molfile.prototype.saveMolecule = function (molecule, skipSGroupErrors, norgroups, preserveIndigoDesc)
{
    /* saver */
	this.reaction = molecule.rxnArrows.count() > 0;
	if (molecule.rxnArrows.count() > 1)
		throw new Error('Reaction may not contain more than one arrow');
	this.molfile = '';
	if (this.reaction) {
		if (molecule.rgroups.count() > 0)
			throw new Error('Unable to save the structure - reactions with r-groups are not supported at the moment');
		var components = molecule.getComponents();

		var reactants = components.reactants, products = components.products, all = reactants.concat(products);
		this.molfile = '$RXN\n\n\n\n' + util.paddedInt(reactants.length, 3) + util.paddedInt(products.length, 3) + util.paddedInt(0, 3) + '\n';
		for (var i = 0; i < all.length; ++i) {
			var saver = new Molfile(false);
			var submol = molecule.clone(all[i], null, true);
			var molfile = saver.saveMolecule(submol, false, true);
			this.molfile += '$MOL\n' + molfile;
		}
		return this.molfile;
	}

	if (molecule.rgroups.count() > 0) {
		if (norgroups) {
			molecule = molecule.getScaffold();
		} else {
			var scaffold = new Molfile(false).getCTab(molecule.getScaffold(), molecule.rgroups);
			this.molfile = '$MDL  REV  1\n$MOL\n$HDR\n\n\n\n$END HDR\n';
			this.molfile += '$CTAB\n' + scaffold + '$END CTAB\n';

			molecule.rgroups.each(function (rgid, rg){
				this.molfile += '$RGP\n';
				this.writePaddedNumber(rgid, 3);
				this.molfile += '\n';
				rg.frags.each(function (fnum, fid) {
					var group = new Molfile(false).getCTab(molecule.getFragment(fid));
					this.molfile += '$CTAB\n' + group + '$END CTAB\n';
				}, this);
				this.molfile += '$END RGP\n';
			}, this);
			this.molfile += '$END MOL\n';

			return this.molfile;
		}
	}

	this.molecule = molecule.clone();

	this.prepareSGroups(skipSGroupErrors, preserveIndigoDesc);

	this.writeHeader();

	// TODO: saving to V3000
	this.writeCTab2000();

	return this.molfile;
};

Molfile.prototype.writeHeader = function ()
{
    /* saver */

	var date = new Date();

	this.writeCR(); // TODO: write structure name
	this.writeWhiteSpace(2);
	this.write('Ketcher');
	this.writeWhiteSpace();
	this.writeCR((date.getMonth() + 1).toPaddedString(2) + date.getDate().toPaddedString(2) + (date.getFullYear() % 100).toPaddedString(2) +
	date.getHours().toPaddedString(2) + date.getMinutes().toPaddedString(2) + '2D 1   1.00000     0.00000     0');
	this.writeCR();
};

Molfile.prototype.write = function (str)
{
    /* saver */
	this.molfile += str;
};

Molfile.prototype.writeCR = function (str)
{
    /* saver */
	if (arguments.length == 0)
		str = '';

	this.molfile += str + '\n';
};

Molfile.prototype.writeWhiteSpace = function (length)
{
    /* saver */

	if (arguments.length == 0)
		length = 1;

	length.times(function ()
	{
		this.write(' ');
	}, this);
};

Molfile.prototype.writePadded = function (str, width)
{
    /* saver */
	this.write(str);
	this.writeWhiteSpace(width - str.length);
};

Molfile.prototype.writePaddedNumber = function (number, width)
{
    /* saver */

	var str = (number - 0).toString();

	this.writeWhiteSpace(width - str.length);
	this.write(str);
};

Molfile.prototype.writePaddedFloat = function (number, width, precision)
{
    /* saver */

	this.write(util.paddedFloat(number, width, precision));
};

Molfile.prototype.writeCTab2000Header = function ()
{
    /* saver */

	this.writePaddedNumber(this.molecule.atoms.count(), 3);
	this.writePaddedNumber(this.molecule.bonds.count(), 3);

	this.writePaddedNumber(0, 3);
	this.writeWhiteSpace(3);
	this.writePaddedNumber(this.molecule.isChiral ? 1 : 0, 3);
	this.writePaddedNumber(0, 3);
	this.writeWhiteSpace(12);
	this.writePaddedNumber(999, 3);
	this.writeCR(' V2000');
};

Molfile.prototype.writeCTab2000 = function (rgroups)
{
    /* saver */
	this.writeCTab2000Header();

	this.mapping = {};
	var i = 1;

	var atomList_list = [];
	var atomLabel_list = [];
	this.molecule.atoms.each(function (id, atom)
	{
		this.writePaddedFloat(atom.pp.x, 10, 4);
		this.writePaddedFloat(-atom.pp.y, 10, 4);
		this.writePaddedFloat(0, 10, 4);
		this.writeWhiteSpace();

		var label = atom.label;
		if (atom.atomList != null) {
			label = 'L';
			atomList_list.push(id);
		} else if (element.getElementByLabel(label) == null && ['A', 'Q', 'X', '*', 'R#'].indexOf(label) == -1) {
			label = 'C';
			atomLabel_list.push(id);
		}
		this.writePadded(label, 3);
		this.writePaddedNumber(0, 2);
		this.writePaddedNumber(0, 3);
		this.writePaddedNumber(0, 3);

		if (Object.isUndefined(atom.hCount))
			atom.hCount = 0;
		this.writePaddedNumber(atom.hCount, 3);

		if (Object.isUndefined(atom.stereoCare))
			atom.stereoCare = 0;
		this.writePaddedNumber(atom.stereoCare, 3);

		this.writePaddedNumber(atom.explicitValence < 0 ? 0 : (atom.explicitValence == 0 ? 15 : atom.explicitValence), 3);

		this.writePaddedNumber(0, 3);
		this.writePaddedNumber(0, 3);
		this.writePaddedNumber(0, 3);

		if (Object.isUndefined(atom.aam))
			atom.aam = 0;
		this.writePaddedNumber(atom.aam, 3);

		if (Object.isUndefined(atom.invRet))
			atom.invRet = 0;
		this.writePaddedNumber(atom.invRet, 3);

		if (Object.isUndefined(atom.exactChangeFlag))
			atom.exactChangeFlag = 0;
		this.writePaddedNumber(atom.exactChangeFlag, 3);

		this.writeCR();

		this.mapping[id] = i;
		i++;
	}, this);

	this.bondMapping = {};
	i = 1;
	this.molecule.bonds.each(function (id, bond)
	{
		this.bondMapping[id] = i++;
		this.writePaddedNumber(this.mapping[bond.begin], 3);
		this.writePaddedNumber(this.mapping[bond.end], 3);
		this.writePaddedNumber(bond.type, 3);

		if (Object.isUndefined(bond.stereo))
			bond.stereo = 0;
		this.writePaddedNumber(bond.stereo, 3);

		this.writeWhiteSpace(3);

		if (Object.isUndefined(bond.topology))
			bond.topology = 0;
		this.writePaddedNumber(bond.topology, 3);

		if (Object.isUndefined(bond.reactingCenterStatus))
			bond.reactingCenterStatus = 0;
		this.writePaddedNumber(bond.reactingCenterStatus, 3);

		this.writeCR();
	}, this);

	while (atomLabel_list.length > 0) {
		this.write('A  ');this.writePaddedNumber(atomLabel_list[0] + 1, 3);this.writeCR();
		this.writeCR(this.molecule.atoms.get(atomLabel_list[0]).label);
		atomLabel_list.splice(0, 1);
	}

	var charge_list = new Array();
	var isotope_list = new Array();
	var radical_list = new Array();
	var rglabel_list = new Array();
	var rglogic_list = new Array();
	var aplabel_list = new Array();
	var rbcount_list = new Array();
	var unsaturated_list = new Array();
	var substcount_list = new Array();

	this.molecule.atoms.each(function (id, atom)
	{
		if (atom.charge != 0)
			charge_list.push([id, atom.charge]);
		if (atom.isotope != 0)
			isotope_list.push([id, atom.isotope]);
		if (atom.radical != 0)
			radical_list.push([id, atom.radical]);
		if (atom.rglabel != null && atom.label == 'R#') { // TODO need to force rglabel=null when label is not 'R#'
			for (var rgi = 0; rgi < 32; rgi++) {
				if (atom.rglabel & (1 << rgi)) rglabel_list.push([id, rgi + 1]);
			}
		}
		if (atom.attpnt != null)
			aplabel_list.push([id, atom.attpnt]);
		if (atom.ringBondCount != 0)
			rbcount_list.push([id, atom.ringBondCount]);
		if (atom.substitutionCount != 0)
			substcount_list.push([id, atom.substitutionCount]);
		if (atom.unsaturatedAtom != 0)
			unsaturated_list.push([id, atom.unsaturatedAtom]);
	});

	if (rgroups)
		rgroups.each(function (rgid, rg) {
			if (rg.resth || rg.ifthen > 0 || rg.range.length > 0) {
				var line = '  1 ' + util.paddedInt(rgid, 3) + ' ' + util.paddedInt(rg.ifthen, 3) + ' ' + util.paddedInt(rg.resth ? 1 : 0, 3) + '   ' + rg.range;
				rglogic_list.push(line);
			}
		});

	var writeAtomPropList = function (prop_id, values)
	{
		while (values.length > 0)
		{
			var part = new Array();

			while (values.length > 0 && part.length < 8)
			{
				part.push(values[0]);
				values.splice(0, 1);
			}

			this.write(prop_id);
			this.writePaddedNumber(part.length, 3);

			part.each(function (value)
			{
				this.writeWhiteSpace();
				this.writePaddedNumber(this.mapping[value[0]], 3);
				this.writeWhiteSpace();
				this.writePaddedNumber(value[1], 3);
			}, this);

			this.writeCR();
		}
	};

	writeAtomPropList.call(this, 'M  CHG', charge_list);
	writeAtomPropList.call(this, 'M  ISO', isotope_list);
	writeAtomPropList.call(this, 'M  RAD', radical_list);
	writeAtomPropList.call(this, 'M  RGP', rglabel_list);
	for (var j = 0; j < rglogic_list.length; ++j) {
		this.write('M  LOG' + rglogic_list[j] + '\n');
	}
	writeAtomPropList.call(this, 'M  APO', aplabel_list);
	writeAtomPropList.call(this, 'M  RBC', rbcount_list);
	writeAtomPropList.call(this, 'M  SUB', substcount_list);
	writeAtomPropList.call(this, 'M  UNS', unsaturated_list);

	if (atomList_list.length > 0)
	{
		for (j = 0; j < atomList_list.length; ++j) {
			var aid = atomList_list[j];
			var atomList = this.molecule.atoms.get(aid).atomList;
			this.write('M  ALS');
			this.writePaddedNumber(aid + 1, 4);
			this.writePaddedNumber(atomList.ids.length, 3);
			this.writeWhiteSpace();
			this.write(atomList.notList ? 'T' : 'F');

			var labelList = atomList.labelList();
			for (var k = 0; k < labelList.length; ++k) {
				this.writeWhiteSpace();
				this.writePadded(labelList[k], 3);
			}
			this.writeCR();
		}
	}

	var sgmap = {}, cnt = 1, sgmapback = {};
	var sgorder = this.molecule.sGroupForest.getSGroupsBFS();
	util.each(sgorder, function (id) {
		sgmapback[cnt] = id;
		sgmap[id] = cnt++;
	}, this);
	for (var q = 1; q < cnt; ++q) { // each group on its own
		var id = sgmapback[q];
		var sgroup = this.molecule.sgroups.get(id);
		this.write('M  STY');
		this.writePaddedNumber(1, 3);
		this.writeWhiteSpace(1);
		this.writePaddedNumber(q, 3);
		this.writeWhiteSpace(1);
		this.writePadded(sgroup.type, 3);
		this.writeCR();

		// TODO: write subtype, M SST

		this.write('M  SLB');
		this.writePaddedNumber(1, 3);
		this.writeWhiteSpace(1);
		this.writePaddedNumber(q, 3);
		this.writeWhiteSpace(1);
		this.writePaddedNumber(q, 3);
		this.writeCR();

		var parentid = this.molecule.sGroupForest.parent.get(id);
		if (parentid >= 0) {
			this.write('M  SPL');
			this.writePaddedNumber(1, 3);
			this.writeWhiteSpace(1);
			this.writePaddedNumber(q, 3);
			this.writeWhiteSpace(1);
			this.writePaddedNumber(sgmap[parentid], 3);
			this.writeCR();
		}

		// connectivity
		if (sgroup.type == 'SRU' && sgroup.data.connectivity) {
			var connectivity = '';
			connectivity += ' ';
			connectivity += util.stringPadded(q.toString(), 3);
			connectivity += ' ';
			connectivity += util.stringPadded(sgroup.data.connectivity, 3, true);
			this.write('M  SCN');
			this.writePaddedNumber(1, 3);
			this.write(connectivity.toUpperCase());
			this.writeCR();
		}

		if (sgroup.type == 'SRU') {
			this.write('M  SMT ');
			this.writePaddedNumber(q, 3);
			this.writeWhiteSpace();
			this.write(sgroup.data.subscript || 'n');
			this.writeCR();
		}

		this.writeCR(sgroup.saveToMolfile(this.molecule, sgmap, this.mapping, this.bondMapping));
	}

	// TODO: write M  APO
	// TODO: write M  AAL
	// TODO: write M  RGP
	// TODO: write M  LOG

	this.writeCR('M  END');
};

var parseRxn = function (/* string[] */ ctabLines) /* Struct */
{
    /* reader */
	var split = ctabLines[0].strip().split(' ');
	if (split.length > 1 && split[1] == 'V3000')
		return parseRxn3000(ctabLines);
	else
		return parseRxn2000(ctabLines);
};

var parseRxn2000 = function (/* string[] */ ctabLines) /* Struct */
{
    /* reader */
	ctabLines = ctabLines.slice(4);
	var countsSplit = partitionLine(ctabLines[0], fmtInfo.rxnItemsPartition);
	var nReactants = countsSplit[0] - 0,
	nProducts = countsSplit[1] - 0,
	nAgents = countsSplit[2] - 0;
	ctabLines = ctabLines.slice(1); // consume counts line

	var mols = [];
	while (ctabLines.length > 0 && ctabLines[0].substr(0, 4) == '$MOL') {
		ctabLines = ctabLines.slice(1);
		var n = 0; while (n < ctabLines.length && ctabLines[n].substr(0, 4) != '$MOL') n++;
		mols.push(parseMol(ctabLines.slice(0, n)));
		ctabLines = ctabLines.slice(n);
	}
	return rxnMerge(mols, nReactants, nProducts, nAgents);
};

var parseRxn3000 = function (/* string[] */ ctabLines) /* Struct */
{
    /* reader */
	ctabLines = ctabLines.slice(4);
	var countsSplit = ctabLines[0].split(/\s+/g).slice(3);
	var nReactants = countsSplit[0] - 0,
	nProducts = countsSplit[1] - 0,
	nAgents = countsSplit.length > 2 ? countsSplit[2] - 0 : 0;

	var assert = function (condition) {
		util.assert(condition, 'CTab format invalid');
	};

	var findCtabEnd = function (i) {
		for (var j = i; j < ctabLines.length; ++j) {
			if (ctabLines[j].strip() == 'M  V30 END CTAB')
				return j;
		}
		assert(false);
	};

	var findRGroupEnd = function (i) {
		for (var j = i; j < ctabLines.length; ++j)
			if (ctabLines[j].strip() == 'M  V30 END RGROUP')
				return j;
		assert(false);
	};

	var molLinesReactants = [], molLinesProducts = [], current = null, rGroups = [];
	for (var i = 0; i < ctabLines.length; ++i) {
		var line = ctabLines[i].strip();

		if (line.startsWith('M  V30 COUNTS')) {
			// do nothing
		} else if (line == 'M  END') {
			break; // stop reading
		} else if (line == 'M  V30 BEGIN PRODUCT') {
			assert(current == null);
			current = molLinesProducts;
		} else if (line == 'M  V30 END PRODUCT') {
			assert(current === molLinesProducts);
			current = null;
		} else if (line == 'M  V30 BEGIN REACTANT') {
			assert(current == null);
			current = molLinesReactants;
		} else if (line == 'M  V30 END REACTANT') {
			assert(current === molLinesReactants);
			current = null;
		} else if (line.startsWith('M  V30 BEGIN RGROUP')) {
			assert(current == null);
			var j = findRGroupEnd(i);
			rGroups.push(ctabLines.slice(i,j + 1));
			i = j;
		} else if (line == 'M  V30 BEGIN CTAB') {
			var j = findCtabEnd(i);
			current.push(ctabLines.slice(i,j + 1));
			i = j;
		} else {
			throw new Error('line unrecognized: ' + line);
		}
	}
	var mols = [];
	var molLines = molLinesReactants.concat(molLinesProducts);
	for (var j = 0; j < molLines.length; ++j) {
		var mol = parseCTabV3000(molLines[j], countsSplit);
		mols.push(mol);
	}
	var ctab = rxnMerge(mols, nReactants, nProducts, nAgents);

	readRGroups3000(ctab, function (array) {
		var res = [];
		for (var k = 0; k < array.length; ++k) {
			res = res.concat(array[k]);
		}
		return res;
	}(rGroups));

	return ctab;
};

var rxnMerge = function (mols, nReactants, nProducts, nAgents) /* Struct */
{
    /* reader */
	var ret = new Struct();
	var bbReact = [],
	bbAgent = [],
	bbProd = [];
	var molReact = [],
	molAgent = [],
	molProd = [];
	var j;
	var bondLengthData = {cnt:0,totalLength:0};
	for (j = 0; j < mols.length; ++j) {
		var mol = mols[j];
		var bondLengthDataMol = mol.getBondLengthData();
		bondLengthData.cnt += bondLengthDataMol.cnt;
		bondLengthData.totalLength += bondLengthDataMol.totalLength;
	}
	var avgBondLength = 1 / (bondLengthData.cnt == 0 ? 1 : bondLengthData.totalLength / bondLengthData.cnt);
	for (j = 0; j < mols.length; ++j) {
		mol = mols[j];
		mol.scale(avgBondLength);
	}

	for (j = 0; j < mols.length; ++j) {
		mol = mols[j];
		var bb = mol.getCoordBoundingBoxObj();
		if (!bb)
			continue;

		var fragmentType = (j < nReactants ? FRAGMENT.REACTANT :
			(j < nReactants + nProducts ? FRAGMENT.PRODUCT :
					FRAGMENT.AGENT));
		if (fragmentType == FRAGMENT.REACTANT) {
			bbReact.push(bb);
			molReact.push(mol);
		} else if (fragmentType == FRAGMENT.AGENT) {
			bbAgent.push(bb);
			molAgent.push(mol);
		} else if (fragmentType == FRAGMENT.PRODUCT) {
			bbProd.push(bb);
			molProd.push(mol);
		}

		mol.atoms.each(function (aid, atom){
			atom.rxnFragmentType = fragmentType;
		});
	}

	// reaction fragment layout
	var xorig = 0;
	var shiftMol = function (ret, mol, bb, xorig, over) {
		var d = new Vec2(xorig - bb.min.x, over ? 1 - bb.min.y : -(bb.min.y + bb.max.y) / 2);
		mol.atoms.each(function (aid, atom){
			atom.pp.add_(d);
		});
		mol.sgroups.each(function (id, item){
			if (item.pp)
				item.pp.add_(d);
		});
		bb.min.add_(d);
		bb.max.add_(d);
		mol.mergeInto(ret);
		return bb.max.x - bb.min.x;
	};

	for (j = 0; j < molReact.length; ++j) {
		xorig += shiftMol(ret, molReact[j], bbReact[j], xorig, false) + 2.0;
	}
	xorig += 2.0;
	for (j = 0; j < molAgent.length; ++j) {
		xorig += shiftMol(ret, molAgent[j], bbAgent[j], xorig, true) + 2.0;
	}
	xorig += 2.0;

	for (j = 0; j < molProd.length; ++j) {
		xorig += shiftMol(ret, molProd[j], bbProd[j], xorig, false) + 2.0;
	}

	var bb1, bb2, x, y, bbReactAll = null, bbProdAll = null;
	for (j = 0; j <	bbReact.length - 1; ++j) {
		bb1 = bbReact[j];
		bb2 = bbReact[j + 1];

		x = (bb1.max.x + bb2.min.x) / 2;
		y = (bb1.max.y + bb1.min.y + bb2.max.y + bb2.min.y) / 4;

		ret.rxnPluses.add(new Struct.RxnPlus({'pp':new Vec2(x, y)}));
	}
	for (j = 0; j <	bbReact.length; ++j) {
		if (j == 0) {
			bbReactAll = {};
			bbReactAll.max = new Vec2(bbReact[j].max);
			bbReactAll.min = new Vec2(bbReact[j].min);
		} else {
			bbReactAll.max = Vec2.max(bbReactAll.max, bbReact[j].max);
			bbReactAll.min = Vec2.min(bbReactAll.min, bbReact[j].min);
		}
	}
	for (j = 0; j <	bbProd.length - 1; ++j) {
		bb1 = bbProd[j];
		bb2 = bbProd[j + 1];

		x = (bb1.max.x + bb2.min.x) / 2;
		y = (bb1.max.y + bb1.min.y + bb2.max.y + bb2.min.y) / 4;

		ret.rxnPluses.add(new Struct.RxnPlus({'pp':new Vec2(x, y)}));
	}
	for (j = 0; j <	bbProd.length; ++j) {
		if (j == 0) {
			bbProdAll = {};
			bbProdAll.max = new Vec2(bbProd[j].max);
			bbProdAll.min = new Vec2(bbProd[j].min);
		} else {
			bbProdAll.max = Vec2.max(bbProdAll.max, bbProd[j].max);
			bbProdAll.min = Vec2.min(bbProdAll.min, bbProd[j].min);
		}
	}
	bb1 = bbReactAll;
	bb2 = bbProdAll;
	if (!bb1 && !bb2) {
		ret.rxnArrows.add(new Struct.RxnArrow({'pp':new Vec2(0, 0)}));
	} else {
		var v1 = bb1 ? new Vec2(bb1.max.x, (bb1.max.y + bb1.min.y) / 2) : null;
		var v2 = bb2 ? new Vec2(bb2.min.x, (bb2.max.y + bb2.min.y) / 2) : null;
		var defaultOffset = 3;
		if (!v1)
			v1 = new Vec2(v2.x - defaultOffset, v2.y);
		if (!v2)
			v2 = new Vec2(v1.x + defaultOffset, v1.y);
		ret.rxnArrows.add(new Struct.RxnArrow({ 'pp': Vec2.lc2(v1, 0.5, v2, 0.5 ) }));
	}
	ret.isReaction = true;
	return ret;
};

var rgMerge = function (scaffold, rgroups) /* Struct */
{
    /* reader */
	var ret = new Struct();

	scaffold.mergeInto(ret, null, null, false, true);
	for (var rgid in rgroups) {
		for (var j = 0; j < rgroups[rgid].length; ++j) {
			var ctab = rgroups[rgid][j];
			ctab.rgroups.set(rgid, new Struct.RGroup());
			var frid = ctab.frags.add(new Struct.Fragment());
			ctab.rgroups.get(rgid).frags.add(frid);
			ctab.atoms.each(function (aid, atom) {atom.fragment = frid;});
			ctab.mergeInto(ret);
		}
	}

	return ret;
};

var parseRg2000 = function (/* string[] */ ctabLines) /* Struct */
{
	ctabLines = ctabLines.slice(7);
	if (ctabLines[0].strip() != '$CTAB')
		throw new Error('RGFile format invalid');
	var i = 1; while (ctabLines[i].charAt(0) != '$') i++;
	if (ctabLines[i].strip() != '$END CTAB')
		throw new Error('RGFile format invalid');
	var coreLines = ctabLines.slice(1, i);
	ctabLines = ctabLines.slice(i + 1);
	var fragmentLines = {};
	while (true) {
		if (ctabLines.length == 0)
			throw new Error('Unexpected end of file');
		var line = ctabLines[0].strip();
		if (line == '$END MOL') {
			ctabLines = ctabLines.slice(1);
			break;
		}
		if (line != '$RGP')
			throw new Error('RGFile format invalid');
		var rgid = ctabLines[1].strip() - 0;
		fragmentLines[rgid] = [];
		ctabLines = ctabLines.slice(2);
		while (true) {
			if (ctabLines.length == 0)
				throw new Error('Unexpected end of file');
			line = ctabLines[0].strip();
			if (line == '$END RGP') {
				ctabLines = ctabLines.slice(1);
				break;
			}
			if (line != '$CTAB')
				throw new Error('RGFile format invalid');
			i = 1; while (ctabLines[i].charAt(0) != '$') i++;
			if (ctabLines[i].strip() != '$END CTAB')
				throw new Error('RGFile format invalid');
			fragmentLines[rgid].push(ctabLines.slice(1, i));
			ctabLines = ctabLines.slice(i + 1);
		}
	}

	var core = parseCTab(coreLines), frag = {};
	if (Molfile.loadRGroupFragments) {
		for (var id in fragmentLines) {
			frag[id] = [];
			for (var j = 0; j < fragmentLines[id].length; ++j) {
				frag[id].push(parseCTab(fragmentLines[id][j]));
			}
		}
	}
	return rgMerge(core, frag);
};

module.exports = {
	stringify: function (molecule, options) {
		var opts = options || {};
		return new Molfile(opts.v3000).saveMolecule(molecule, opts.ignoreErrors,
		                                            opts.noRgroups, opts.preserveIndigoDesc);
	},
	parse: function (str) {
		return new Molfile().parseCTFile(str);
	}
};

},{"../util":40,"../util/map":41,"../util/set":43,"../util/vec2":44,"./atom":8,"./bond":9,"./element":12,"./sgroup":15,"./struct":18}],14:[function(require,module,exports){
var Map = require('../util/map');
var Set = require('../util/set');
var util = require('../util');

var SGroupForest = function (molecule) {
	this.parent = new Map(); // child id -> parent id
	this.children = new Map(); // parent id -> list of child ids
	this.children.set(-1, []); // extra root node
	this.molecule = molecule;
}

// returns an array or s-group ids in the order of breadth-first search
SGroupForest.prototype.getSGroupsBFS = function () {
	var order = [], queue = [], id = -1;
	queue = util.array(this.children.get(-1));
	while (queue.length > 0) {
		var id = queue.shift();
		queue = queue.concat(this.children.get(id));
		order.push(id);
	}
	return order;
}

SGroupForest.prototype.getAtomSets = function () {
	return this.molecule.sgroups.map(function (sgid, sgroup){
		return Set.fromList(sgroup.atoms);
	});
}

SGroupForest.prototype.getAtomSetRelations = function (newId, atoms /* Set */, atomSets /* Map of Set */) {
	// find the lowest superset in the hierarchy
	var isStrictSuperset = new Map(), isSubset = new Map();
	var atomSets = this.getAtomSets();
	atomSets.unset(newId);
	atomSets.each(function (id, atomSet) {
		isSubset.set(id, Set.subset(atoms, atomSet));
		isStrictSuperset.set(id, Set.subset(atomSet, atoms) && !Set.eq(atomSet, atoms));
	}, this);
	var parents = atomSets.findAll(function (id) {
		if (!isSubset.get(id))
			return false;
		if (util.findIndex(this.children.get(id), function (childId) {
			return isSubset.get(childId);
		}, this) >= 0) {
			return false;
		}
		return true;
	}, this);
	util.assert(parents.length <= 1); // there should be only one parent
	var children = atomSets.findAll(function (id, set) {
		return isStrictSuperset.get(id) && !isStrictSuperset.get(this.parent.get(id));
	}, this);
	return {
		'children': children,
		'parent': parents.length === 0 ? -1 : parents[0]
	};
}

SGroupForest.prototype.getPathToRoot = function (sgid) {
	var path = [];
	for (var id = sgid; id >= 0; id = this.parent.get(id)) {
		util.assert(path.indexOf(id) < 0, 'SGroupForest: loop detected');
		path.push(id);
	}
	return path;
}

SGroupForest.prototype.validate = function () {
	var atomSets = this.getAtomSets();
	this.molecule.sgroups.each(function (id) {
		this.getPathToRoot(id); // this will throw an exception if there is a loop in the path to root
	}, this);

	var valid = true;
	// 1) child group's atom set is a subset of the parent one's
	this.parent.each(function (id, parentId) {
		if (parentId >= 0 && !Set.subset(atomSets.get(id), atomSets.get(parentId)))
			valid = false;
	}, this);

	// 2) siblings have disjoint atom sets
	this.children.each(function (parentId) {
		var list = this.children.get(parentId);
		for (var i = 0; i < list.length; ++i)
			for (var j = i + 1; j < list.length; ++j)
				if (!Set.disjoint(atomSets.get(list[i]), atomSets.get(list[j])))
					valid = false;
	}, this);
	return valid;
}

SGroupForest.prototype.insert = function (id, parent /* int, optional */, children /* [int], optional */) {
	util.assert(!this.parent.has(id), 'sgid already present in the forest');
	util.assert(!this.children.has(id), 'sgid already present in the forest');

	util.assert(this.validate(), 's-group forest invalid');
	var atomSets = this.getAtomSets();
	var atoms = Set.fromList(this.molecule.sgroups.get(id).atoms);
	if (util.isUndefined(parent) || util.isUndefined(children)) { // if these are not provided, deduce automatically
		var guess = this.getAtomSetRelations(id, atoms, atomSets);
		parent = guess.parent;
		children = guess.children;
	}

	// TODO: make children Map<int, Set> instead of Map<int, []>?
	util.each(children, function (childId){ // reset parent links
		util.assert(util.arrayRemoveByValue(this.children.get(this.parent.get(childId)), childId) === 1);
		this.parent.set(childId, id);
	}, this);
	this.children.set(id, children);
	this.parent.set(id, parent);
	this.children.get(parent).push(id);
	util.assert(this.validate(), 's-group forest invalid');
	return {parent: parent, children: children};
}

SGroupForest.prototype.remove = function (id) {
	util.assert(this.parent.has(id), 'sgid is not in the forest');
	util.assert(this.children.has(id), 'sgid is not in the forest');

	util.assert(this.validate(), 's-group forest invalid');
	var parentId = this.parent.get(id);
	util.each(this.children.get(id), function (childId){ // reset parent links
		this.parent.set(childId, parentId);
		this.children.get(parentId).push(childId);
	}, this);
	util.assert(util.arrayRemoveByValue(this.children.get(parentId), id) === 1);
	this.children.unset(id);
	this.parent.unset(id);
	util.assert(this.validate(), 's-group forest invalid');
}

module.exports = SGroupForest;

},{"../util":40,"../util/map":41,"../util/set":43}],15:[function(require,module,exports){
(function (global){
var Box2Abs = require('../util/box2abs');
var Set = require('../util/set');
var Vec2 = require('../util/vec2');
var util = require('../util');

var Atom = require('./atom');
var Bond = require('./bond');

var rnd = global.rnd = global.rnd || {};

var SGroup = function (type) {
	if (!type || !(type in SGroup.TYPES))
		throw new Error('Invalid or unsupported s-group type');

	this.type = type;
	this.id = -1;
	SGroup.equip(this, type);
	this.label = -1;
	this.bracketBox = null;
	this.bracketDir = new Vec2(1,0);
	this.areas = [];

	this.highlight = false;
	this.highlighting = null;
	this.selected = false;
	this.selectionPlate = null;

	this.atoms = [];
	this.patoms = [];
	this.bonds = [];
	this.xBonds = [];
	this.neiAtoms = [];
	this.pp = null;
	this.data = {
		'mul': 1, // multiplication count for MUL group
		'connectivity': 'ht', // head-to-head, head-to-tail or either-unknown
		'name': '',
		'subscript': 'n',

		// data s-group fields
		'attached': false,
		'absolute': true,
		'showUnits': false,
		'nCharsToDisplay': -1,
		'tagChar': '',
		'daspPos': 1,
		'fieldType': 'F',
		'fieldName': '',
		'fieldValue': '',
		'units': '',
		'query': '',
		'queryOp': ''
	}
};

// TODO: these methods should be overridden
//      and should only accept valid attributes for each S-group type.
//      The attributes should be accessed via these methods only and not directly through this.data.
// stub
SGroup.prototype.getAttr = function (attr) {
	return this.data[attr];
};

// TODO: should be group-specific
SGroup.prototype.getAttrs = function () {
	var attrs = {};
	for (var attr in this.data)
		attrs[attr] = this.data[attr];
	return attrs;
};

// stub
SGroup.prototype.setAttr = function (attr, value) {
	var oldValue = this.data[attr];
	this.data[attr] = value;
	return oldValue;
};

// stub
SGroup.prototype.checkAttr = function (attr, value) {
	return this.data[attr] == value;
};

SGroup.equip = function (sgroup, type) {
	var impl = SGroup.TYPES[type];
	for (var method in impl)
		sgroup[method] = impl[method];
};

SGroup.numberArrayToString = function (numbers, map) {
	var str = util.stringPadded(numbers.length, 3);
	for (var i = 0; i < numbers.length; ++i) {
		str += ' ' + util.stringPadded(map[numbers[i]], 3);
	}
	return str;
};


SGroup.bracketsToMolfile = function (mol, sg, idstr) {
	var inBonds = [], xBonds = [];
	var atomSet = Set.fromList(sg.atoms);
	SGroup.getCrossBonds(inBonds, xBonds, mol, atomSet);
	SGroup.bracketPos(sg, null, mol, xBonds);
	var bb = sg.bracketBox;
	var d = sg.bracketDir, n = d.rotateSC(1, 0);
	var brackets = SGroup.getBracketParameters(mol, xBonds, atomSet, bb, d, n, null, sg.id);
	var lines = [];
	for (var i = 0; i < brackets.length; ++i) {
		var bracket = brackets[i];
		var a0 = bracket.c.addScaled(bracket.n, -0.5 * bracket.h).yComplement();
		var a1 = bracket.c.addScaled(bracket.n, 0.5 * bracket.h).yComplement();
		var line = 'M  SDI ' + idstr + util.paddedInt(4, 3);
		var coord = [a0.x, a0.y, a1.x, a1.y];
		for (var j = 0; j < coord.length; ++j) {
			line += util.paddedFloat(coord[j], 10, 4);
		}
		lines.push(line);
	}
	return lines;
};

var filterAtoms = function (atoms, map) {
	var newAtoms = [];
	for (var i = 0; i < atoms.length; ++i) {
		var aid = atoms[i];
		if (typeof(map[aid]) != 'number') {
			newAtoms.push(aid);
		} else if (map[aid] >= 0) {
			newAtoms.push(map[aid]);
		} else {
			newAtoms.push(-1);
		}
	}
	return newAtoms;
};

var removeNegative = function (atoms) {
    var newAtoms = [];
    for (var j = 0; j < atoms.length; ++j)
        if (atoms[j] >= 0)
            newAtoms.push(atoms[j]);
    return newAtoms;
};

SGroup.clone = function (sgroup, aidMap, bidMap)
{
	var cp = new SGroup(sgroup.type);

	for (var field in sgroup.data) { // TODO: remove all non-primitive properties from 'data'
		cp.data[field] = sgroup.data[field];
	}
	cp.atoms = util.mapArray(sgroup.atoms, aidMap);
	cp.pp = sgroup.pp;
	cp.bracketBox = sgroup.bracketBox;
	cp.patoms = null;
	cp.bonds = null;
	cp.allAtoms = sgroup.allAtoms;
	return cp;
};

SGroup.addAtom = function (sgroup, aid)
{
	sgroup.atoms.push(aid);
};

SGroup.removeAtom = function (sgroup, aid)
{
	for (var i = 0; i < sgroup.atoms.length; ++i) {
		if (sgroup.atoms[i] === aid) {
			sgroup.atoms.splice(i, 1);
			return;
		}
	}
	throw new Error('The atom is not found in the given s-group');
};

SGroup.getCrossBonds = function (inBonds, xBonds, mol, parentAtomSet) {
	mol.bonds.each(function (bid, bond){
		if (Set.contains(parentAtomSet, bond.begin) && Set.contains(parentAtomSet, bond.end)) {
			if (!util.isNull(inBonds))
				inBonds.push(bid);
		} else if (Set.contains(parentAtomSet, bond.begin) || Set.contains(parentAtomSet, bond.end)) {
			if (!util.isNull(xBonds))
				xBonds.push(bid);
		}
	}, this);
};

SGroup.bracketPos = function (sg, render, mol, xbonds) {
	var atoms = sg.atoms;
	if (!xbonds || xbonds.length !== 2) {
		sg.bracketDir = new Vec2(1, 0);
	} else {
		var b1 = mol.bonds.get(xbonds[0]), b2 = mol.bonds.get(xbonds[1]);
		var p1 = b1.getCenter(mol), p2 = b2.getCenter(mol);
		sg.bracketDir = Vec2.diff(p2, p1).normalized();
	}
	var d = sg.bracketDir;
	var n = d.rotateSC(1, 0);

	var bb = null;
	var contentBoxes = [];
	util.each(atoms, function (aid) {
		var atom = mol.atoms.get(aid);
		var bba = render ? render.ctab.atoms.get(aid).visel.boundingBox : null;
		var pos = new Vec2(atom.pp);
		if (util.isNull(bba)) {
			bba = new Box2Abs(pos, pos);
			var ext = new Vec2(0.05 * 3, 0.05 * 3);
			bba = bba.extend(ext, ext);
		} else {
			bba = bba.translate((render.offset || new Vec2()).negated()).transform(render.scaled2obj, render);
		}
		contentBoxes.push(bba);
	}, this);
	util.each(mol.sGroupForest.children.get(sg.id), function (sgid) {
		var bba = render ? render.ctab.sgroups.get(sgid).visel.boundingBox : null;
		if (util.isNull(bba))
			return; // TODO: use object box instead
		bba = bba.translate((render.offset || new Vec2()).negated()).transform(render.scaled2obj, render);
		contentBoxes.push(bba);
	}, this);
	util.each(contentBoxes, function (bba) {
		var bbb = null;
		util.each([bba.p0.x, bba.p1.x], function (x) {
			util.each([bba.p0.y, bba.p1.y], function (y) {
				var v = new Vec2(x, y);
				var p = new Vec2(Vec2.dot(v, d), Vec2.dot(v, n));
				bbb = util.isNull(bbb) ? new Box2Abs(p, p) : bbb.include(p);
			}, this);
		}, this);
		bb = util.isNull(bb) ? bbb : Box2Abs.union(bb, bbb);
	}, this);
	var vext = new Vec2(0.2, 0.4);
	if (!util.isNull(bb))
		bb = bb.extend(vext, vext);
	sg.bracketBox = bb;
};

SGroup.drawBrackets = function (set, render, sg, xbonds, atomSet, bb, d, n, lowerIndexText, upperIndexText, indexAttribute) {
	var brackets = SGroup.getBracketParameters(render.ctab.molecule, xbonds, atomSet, bb, d, n, render, sg.id);
	var ir = -1;
	for (var i = 0; i < brackets.length; ++i) {
		var bracket = brackets[i];
		var path = SGroup.drawBracket(render, render.paper, render.styles, bracket.d, bracket.n, bracket.c, bracket.w, bracket.h);
		set.push(path);
		if (ir < 0 || brackets[ir].d.x < bracket.d.x || (brackets[ir].d.x == bracket.d.x && brackets[ir].d.y > bracket.d.y))
			ir = i;
	}
	var bracketR = brackets[ir];
	var renderIndex = function (text, shift) {
		var indexPos = render.ps(bracketR.c.addScaled(bracketR.n, shift * bracketR.h));
		var indexPath = render.paper.text(indexPos.x, indexPos.y, text)
		.attr({
			'font': render.settings.font,
			'font-size': render.settings.fontszsub
		});
		if (indexAttribute)
			indexPath.attr(indexAttribute);
		var indexBox = Box2Abs.fromRelBox(util.relBox(indexPath.getBBox()));
		var t = Math.max(Vec2.shiftRayBox(indexPos, bracketR.d.negated(), indexBox), 3) + 2;
		indexPath.translateAbs(t * bracketR.d.x, t * bracketR.d.y);
		set.push(indexPath);
	};
	if (lowerIndexText) {
		renderIndex(lowerIndexText, 0.5);
	}
	if (upperIndexText) {
		renderIndex(upperIndexText, -0.5);
	}
};

SGroup.drawBracket = function (render, paper, styles, d, n, c, bracketWidth, bracketHeight) {
	bracketWidth = bracketWidth || 0.25;
	bracketHeight = bracketHeight || 1.0;
	var a0 = c.addScaled(n, -0.5 * bracketHeight);
	var a1 = c.addScaled(n, 0.5 * bracketHeight);
	var b0 = a0.addScaled(d, -bracketWidth);
	var b1 = a1.addScaled(d, -bracketWidth);

	a0 = render.obj2scaled(a0);
	a1 = render.obj2scaled(a1);
	b0 = render.obj2scaled(b0);
	b1 = render.obj2scaled(b1);

	return paper.path('M {0}, {1} L {2} , {3} L {4} , {5} L {6} , {7}',
		b0.x, b0.y, a0.x, a0.y, a1.x, a1.y, b1.x, b1.y)
	.attr(styles.sgroupBracketStyle);
};

SGroup.getBracketParameters = function (mol, xbonds, atomSet, bb, d, n, render, id) {
	var bracketParams = function (c, d, w, h) {
		this.c = c;
		this.d = d;
		this.n = d.rotateSC(1,0);
		this.w = w;
		this.h = h;
	};
	var brackets = [];
	if (xbonds.length < 2) {
		(function () {
			d = d || new Vec2(1, 0);
			n = n || d.rotateSC(1, 0);
			var bracketWidth = Math.min(0.25, bb.sz().x * 0.3);
			var cl = Vec2.lc2(d, bb.p0.x, n, 0.5 * (bb.p0.y + bb.p1.y));
			var cr = Vec2.lc2(d, bb.p1.x, n, 0.5 * (bb.p0.y + bb.p1.y));
			var bracketHeight = bb.sz().y;

			brackets.push(new bracketParams(cl, d.negated(), bracketWidth, bracketHeight), new bracketParams(cr, d, bracketWidth, bracketHeight));
		})();
	} else if (xbonds.length === 2) {
		(function () {
			var b1 = mol.bonds.get(xbonds[0]), b2 = mol.bonds.get(xbonds[1]);
			var cl0 = b1.getCenter(mol), cr0 = b2.getCenter(mol), tl = -1, tr = -1, tt = -1, tb = -1, cc = Vec2.centre(cl0, cr0);
			var dr = Vec2.diff(cr0, cl0).normalized(), dl = dr.negated(), dt = dr.rotateSC(1,0), db = dt.negated();

			util.each(mol.sGroupForest.children.get(id), function (sgid) {
				var bba = render ? render.ctab.sgroups.get(sgid).visel.boundingBox : null;
				if (util.isNull(bba))
					return; // TODO: use object box instead
				bba = bba.translate((render.offset || new Vec2()).negated()).transform(render.scaled2obj, render);
				tl = Math.max(tl, Vec2.shiftRayBox(cl0, dl, bba));
				tr = Math.max(tr, Vec2.shiftRayBox(cr0, dr, bba));
				tt = Math.max(tt, Vec2.shiftRayBox(cc, dt, bba));
				tb = Math.max(tb, Vec2.shiftRayBox(cc, db, bba));
			}, this);
			tl = Math.max(tl + 0.2, 0);
			tr = Math.max(tr + 0.2, 0);
			tt = Math.max(Math.max(tt, tb) + 0.1, 0);
			var bracketWidth = 0.25, bracketHeight = 1.5 + tt;
			brackets.push(new bracketParams(cl0.addScaled(dl, tl), dl, bracketWidth, bracketHeight),
			new bracketParams(cr0.addScaled(dr, tr), dr, bracketWidth, bracketHeight));
		})();

	} else {
		(function () {
			for (var i = 0; i < xbonds.length; ++i) {
				var b = mol.bonds.get(xbonds[i]);
				var c = b.getCenter(mol);
				var d = Set.contains(atomSet, b.begin) ? b.getDir(mol) : b.getDir(mol).negated();
				brackets.push(new bracketParams(c, d, 0.2, 1.0));
			}
		})();
	}
	return brackets;
};

SGroup.getObjBBox = function (atoms, mol)
{
	if (atoms.length == 0)
		throw new Error('Atom list is empty');

	var a0 = mol.atoms.get(atoms[0]).pp;
	var bb = new Box2Abs(a0, a0);
	for (var i = 1; i < atoms.length; ++i) {
		var aid = atoms[i];
		var atom = mol.atoms.get(aid);
		var p = atom.pp;
		bb = bb.include(p);
	}
	return bb;
};

SGroup.makeAtomBondLines = function (prefix, idstr, ids, map) {
	if (!ids)
		return [];
	var lines = [];
	for (var i = 0; i < Math.floor((ids.length + 14) / 15); ++i) {
		var rem = Math.min(ids.length - 15 * i, 15);
		var salLine = 'M  ' + prefix + ' ' + idstr + ' ' + util.paddedInt(rem, 2);
		for (var j = 0; j < rem; ++j) {
			salLine += ' ' + util.paddedInt(map[ids[i * 15 + j]], 3);
		}
		lines.push(salLine);
	}
	return lines;
};

SGroup.getAtoms = function (mol, sg) {
	if (!sg.allAtoms)
		return sg.atoms;
	var atoms = [];
	mol.atoms.each(function (aid){
		atoms.push(aid);
	});
	return atoms;
};

SGroup.getBonds = function (mol, sg) {
	var atoms = SGroup.getAtoms(mol, sg);
	var bonds = [];
	mol.bonds.each(function (bid, bond){
		if (atoms.indexOf(bond.begin) >= 0 && atoms.indexOf(bond.end) >= 0) bonds.push(bid);
	});
	return bonds;
};

var GroupMul = {
	draw: function (remol) {
		var render = remol.render;
		var set = render.paper.set();
		var inBonds = [], xBonds = [];
		var atomSet = Set.fromList(this.atoms);
		SGroup.getCrossBonds(inBonds, xBonds, remol.molecule, atomSet);
		SGroup.bracketPos(this, render, remol.molecule, xBonds);
		var bb = this.bracketBox;
		var d = this.bracketDir, n = d.rotateSC(1, 0);
		this.areas = [bb];
		SGroup.drawBrackets(set, render, this, xBonds, atomSet, bb, d, n, this.data.mul);
		return set;
	},

	saveToMolfile: function (mol, sgMap, atomMap, bondMap) {
		var idstr = util.stringPadded(sgMap[this.id], 3);

		var lines = [];
		lines = lines.concat(SGroup.makeAtomBondLines('SAL', idstr, util.idList(this.atomSet), atomMap)); // TODO: check atomSet
		lines = lines.concat(SGroup.makeAtomBondLines('SPA', idstr, util.idList(this.parentAtomSet), atomMap));
		lines = lines.concat(SGroup.makeAtomBondLines('SBL', idstr, this.bonds, bondMap));
		var smtLine = 'M  SMT ' + idstr + ' ' + this.data.mul;
		lines.push(smtLine);
		lines = lines.concat(SGroup.bracketsToMolfile(mol, this, idstr));
		return lines.join('\n');
	},

	prepareForSaving: function (mol) {
		var j;
		this.atoms.sort();
		this.atomSet = Set.fromList(this.atoms);
		this.parentAtomSet = Set.clone(this.atomSet);
		var inBonds = [];
		var xBonds = [];

		mol.bonds.each(function (bid, bond){
			if (Set.contains(this.parentAtomSet, bond.begin) && Set.contains(this.parentAtomSet, bond.end))
				inBonds.push(bid);
			else if (Set.contains(this.parentAtomSet, bond.begin) || Set.contains(this.parentAtomSet,bond.end))
				xBonds.push(bid);
		}, this);
		if (xBonds.length != 0 && xBonds.length != 2)
			throw {
				'id':this.id,
				'error-type':'cross-bond-number',
				'message':'Unsupported cross-bonds number'
			};

		var xAtom1 = -1,
		xAtom2 = -1;
		var crossBond = null;
		if (xBonds.length == 2) {
			var bond1 = mol.bonds.get(xBonds[0]);
			if (Set.contains(this.parentAtomSet, bond1.begin)) {
				xAtom1 = bond1.begin;
			} else {
				xAtom1 = bond1.end;
			}
			var bond2 = mol.bonds.get(xBonds[1]);
			if (Set.contains(this.parentAtomSet, bond2.begin)) {
				xAtom2 = bond2.begin;
			} else {
				xAtom2 = bond2.end;
			}
			crossBond = bond2;
		}

		var amap = null;
		var tailAtom = xAtom1;

		var newAtoms = [];
		for (j = 0; j < this.data.mul - 1; ++j) {
			amap = {};
			util.each(this.atoms, function (aid) {
				var atom = mol.atoms.get(aid);
				var aid2 = mol.atoms.add(new Atom(atom));
				newAtoms.push(aid2);
				this.atomSet[aid2] = 1;
				amap[aid] = aid2;
			}, this);
			util.each(inBonds, function (bid) {
				var bond = mol.bonds.get(bid);
				var newBond = new Bond(bond);
				newBond.begin = amap[newBond.begin];
				newBond.end = amap[newBond.end];
				mol.bonds.add(newBond);
			}, this);
			if (crossBond != null) {
				var newCrossBond = new Bond(crossBond);
				newCrossBond.begin = tailAtom;
				newCrossBond.end = amap[xAtom2];
				mol.bonds.add(newCrossBond);
				tailAtom = amap[xAtom1];
			}
		}

		util.each(newAtoms, function (aid) {
			util.each(mol.sGroupForest.getPathToRoot(this.id).reverse(), function (sgid) {
				mol.atomAddToSGroup(sgid, aid);
			}, this);
		}, this);
		if (tailAtom >= 0) {
			var xBond2 = mol.bonds.get(xBonds[0]);
			if (xBond2.begin == xAtom1)
				xBond2.begin = tailAtom;
			else
				xBond2.end = tailAtom;
		}

		this.bonds = xBonds;
	},

	postLoad: function (mol, atomMap)
	{
		this.data.mul = this.data.subscript - 0;
		var atomReductionMap = {};

		this.atoms = filterAtoms(this.atoms, atomMap);
		this.patoms = filterAtoms(this.patoms, atomMap);

		// mark repetitions for removal
		for (var k = 1; k < this.data.mul; ++k) {
			for (var m = 0; m < this.patoms.length; ++m) {
				var raid = this.atoms[k * this.patoms.length + m];
				if (raid < 0)
					continue;
				if (this.patoms[m] < 0) {
					throw new Error('parent atom missing');
				}
//                mol.atoms.get(raid).pp.y -= 3*k; // for debugging purposes
				atomReductionMap[raid] = this.patoms[m]; // "merge" atom in parent
			}
        }
        this.patoms = removeNegative(this.patoms);

		var patomsMap = util.identityMap(this.patoms);

		var bondsToRemove = [];
		mol.bonds.each(function (bid, bond){
			var beginIn = bond.begin in atomReductionMap;
			var endIn = bond.end in atomReductionMap;
			// if both adjacent atoms of a bond are to be merged, remove it
			if (beginIn && endIn
				 || beginIn && bond.end in patomsMap
				 || endIn && bond.begin in patomsMap) {
				bondsToRemove.push(bid);
				// if just one atom is merged, modify the bond accordingly
			} else if (beginIn) {
				bond.begin = atomReductionMap[bond.begin];
			} else if (endIn) {
				bond.end = atomReductionMap[bond.end];
			}
		}, this);

		// apply removal lists
		for (var b = 0; b < bondsToRemove.length; ++b) {
			mol.bonds.remove(bondsToRemove[b]);
		}
		for (var a in atomReductionMap) {
			mol.atoms.remove(a);
			atomMap[a] = -1;
		}
		this.atoms = this.patoms;
		this.patoms = null;
	}
};

var GroupSru = {
	draw: function (remol) {
		var render = remol.render;
		var set = render.paper.set();
		var inBonds = [], xBonds = [];
		var atomSet = Set.fromList(this.atoms);
		SGroup.getCrossBonds(inBonds, xBonds, remol.molecule, atomSet);
		SGroup.bracketPos(this, render, remol.molecule, xBonds);
		var bb = this.bracketBox;
		var d = this.bracketDir, n = d.rotateSC(1, 0);
		this.areas = [bb];
		var connectivity = this.data.connectivity || 'eu';
		if (connectivity == 'ht')
			connectivity = '';
		var subscript = this.data.subscript || 'n';
		SGroup.drawBrackets(set, render, this, xBonds, atomSet, bb, d, n, subscript, connectivity);
		return set;
	},

	saveToMolfile: function (mol, sgMap, atomMap, bondMap) {
		var idstr = util.stringPadded(sgMap[this.id], 3);

		var lines = [];
		lines = lines.concat(SGroup.makeAtomBondLines('SAL', idstr, this.atoms, atomMap));
		lines = lines.concat(SGroup.makeAtomBondLines('SBL', idstr, this.bonds, bondMap));
		lines = lines.concat(SGroup.bracketsToMolfile(mol, this, idstr));
		return lines.join('\n');
	},

	prepareForSaving: function (mol) {
		var xBonds = [];
		mol.bonds.each(function (bid, bond){
			var a1 = mol.atoms.get(bond.begin);
			var a2 = mol.atoms.get(bond.end);
			if (Set.contains(a1.sgs, this.id) && !Set.contains(a2.sgs, this.id) ||
			Set.contains(a2.sgs, this.id) && !Set.contains(a1.sgs, this.id))
				xBonds.push(bid);
		},this);
		if (xBonds.length != 0 && xBonds.length != 2)
			throw {'id':this.id, 'error-type':'cross-bond-number', 'message':'Unsupported cross-bonds number'};
		this.bonds = xBonds;
	},

	postLoad: function (mol, atomMap) {
		this.data.connectivity = (this.data.connectivity || 'EU').strip().toLowerCase();
	}
};

var GroupSup = {
	draw: function (remol) {
		var render = remol.render;
		var set = render.paper.set();
		var inBonds = [], xBonds = [];
		var atomSet = Set.fromList(this.atoms);
		SGroup.getCrossBonds(inBonds, xBonds, remol.molecule, atomSet);
		SGroup.bracketPos(this, render, remol.molecule, xBonds);
		var bb = this.bracketBox;
		var d = this.bracketDir, n = d.rotateSC(1, 0);
		this.areas = [bb];
		SGroup.drawBrackets(set, render, this, xBonds, atomSet, bb, d, n, this.data.name, null, {
			'font-style': 'italic'
		});
		return set;
	},

	saveToMolfile: function (mol, sgMap, atomMap, bondMap) {
		var idstr = util.stringPadded(sgMap[this.id], 3);

		var lines = [];
		lines = lines.concat(SGroup.makeAtomBondLines('SAL', idstr, this.atoms, atomMap));
		lines = lines.concat(SGroup.makeAtomBondLines('SBL', idstr, this.bonds, bondMap));
		if (this.data.name && this.data.name != '')
			lines.push('M  SMT ' + idstr + ' ' + this.data.name);
		return lines.join('\n');
	},

	prepareForSaving: function (mol) {
		// This code is also used for GroupSru and should be moved into a separate common method
		// It seems that such code should be used for any sgroup by this this should be checked
		var xBonds = [];
		mol.bonds.each(function (bid, bond){
			var a1 = mol.atoms.get(bond.begin);
			var a2 = mol.atoms.get(bond.end);
			if (Set.contains(a1.sgs, this.id) && !Set.contains(a2.sgs, this.id) ||
			Set.contains(a2.sgs, this.id) && !Set.contains(a1.sgs, this.id))
				xBonds.push(bid);
		},this);
		this.bonds = xBonds;
	},

	postLoad: function (mol, atomMap) {
		this.data.name = (this.data.subscript || '').strip();
		this.data.subscript = '';
	}
};

var GroupGen = {
	draw: function (remol) {
		var render = remol.render;
		var settings = render.settings;
		var styles = render.styles;
		var paper = render.paper;
		var set = paper.set();
		var inBonds = [], xBonds = [];
		var atomSet = Set.fromList(this.atoms);
		SGroup.getCrossBonds(inBonds, xBonds, remol.molecule, atomSet);
		SGroup.bracketPos(this, render, remol.molecule, xBonds);
		var bb = this.bracketBox;
		var d = this.bracketDir, n = d.rotateSC(1, 0);
		this.areas = [bb];
		SGroup.drawBrackets(set, render, this, xBonds, atomSet, bb, d, n);
		return set;
	},

	saveToMolfile: function (mol, sgMap, atomMap, bondMap) {
		var idstr = util.stringPadded(sgMap[this.id], 3);

		var lines = [];
		lines = lines.concat(SGroup.makeAtomBondLines('SAL', idstr, this.atoms, atomMap));
		lines = lines.concat(SGroup.makeAtomBondLines('SBL', idstr, this.bonds, bondMap));
		lines = lines.concat(SGroup.bracketsToMolfile(mol, this, idstr));
		return lines.join('\n');
	},

	prepareForSaving: function (mol) {
	},

	postLoad: function (mol, atomMap) {
	}
};

SGroup.getMassCentre = function (mol, atoms) {
	var c = new Vec2(); // mass centre
	for (var i = 0; i < atoms.length; ++i) {
		c = c.addScaled(mol.atoms.get(atoms[i]).pp, 1.0 / atoms.length);
	}
	return c;
};

SGroup.setPos = function (remol, sg, pos) {
	sg.pp = pos;
};

var GroupDat = {
	showValue: function (paper, pos, sg, settings) {
		var text = paper.text(pos.x, pos.y, sg.data.fieldValue)
		    .attr({
			    'font': settings.font,
			    'font-size': settings.fontsz
		    });
		var box = text.getBBox();
		var rect = paper.rect(box.x - 1, box.y - 1,
		                      box.width + 2, box.height + 2, 3, 3)
		    .attr({
			    fill: '#fff',
			    stroke: '#fff'
		    });
		var st = paper.set();
		st.push(
			rect,
			text.toFront()
		);
		return st;
	},

	draw: function (remol) {
		var render = remol.render;
		var settings = render.settings;
		var paper = render.paper;
		var set = paper.set();
		var atoms = SGroup.getAtoms(remol, this);
		var i;
		SGroup.bracketPos(this, render, remol.molecule);
		this.areas = this.bracketBox ? [this.bracketBox] : [];
		if (this.pp == null) {
			// NB: we did not pass xbonds parameter to the backetPos method above,
			//  so the result will be in the regular coordinate system
			SGroup.setPos(remol, this, this.bracketBox.p1.add(new Vec2(0.5, 0.5)));
		}
		var ps = this.pp.scaled(settings.scaleFactor);

		if (this.data.attached) {
			for (i = 0; i < atoms.length; ++i) {
				var atom = remol.atoms.get(atoms[i]);
				var p = render.ps(atom.a.pp);
				var bb = atom.visel.boundingBox;
				if (bb != null) {
					p.x = Math.max(p.x, bb.p1.x);
				}
				p.x += settings.lineWidth; // shift a bit to the right
				var name_i = this.showValue(paper, p, this, settings);
				var box_i = util.relBox(name_i.getBBox());
				name_i.translateAbs(0.5 * box_i.width, -0.3 * box_i.height);
				set.push(name_i);
				var sbox_i = Box2Abs.fromRelBox(util.relBox(name_i.getBBox()));
				sbox_i = sbox_i.transform(render.scaled2obj, render);
				this.areas.push(sbox_i);
			}
		} else {
			var name = this.showValue(paper, ps, this, settings);
			var box = util.relBox(name.getBBox());
			name.translateAbs(0.5 * box.width, -0.5 * box.height);
			set.push(name);
			var sbox = Box2Abs.fromRelBox(util.relBox(name.getBBox()));
			this.dataArea = sbox.transform(render.scaled2obj, render);
			if (!remol.sgroupData.has(this.id))
				remol.sgroupData.set(this.id, new rnd.ReDataSGroupData(this));
		}
		return set;
	},

	saveToMolfile: function (mol, sgMap, atomMap, bondMap) {
		var idstr = util.stringPadded(sgMap[this.id], 3);

		var data = this.data;
		var pp = this.pp;
		if (!data.absolute)
			pp = pp.sub(SGroup.getMassCentre(mol, this.atoms));
		var lines = [];
		lines = lines.concat(SGroup.makeAtomBondLines('SAL', idstr, this.atoms, atomMap));
		var sdtLine = 'M  SDT ' + idstr +
			' ' + util.stringPadded(data.fieldName, 30, true) +
		util.stringPadded(data.fieldType, 2) +
		util.stringPadded(data.units, 20, true) +
		util.stringPadded(data.query, 2) +
		util.stringPadded(data.queryOp, 3);
		lines.push(sdtLine);
		var sddLine = 'M  SDD ' + idstr +
			' ' + util.paddedFloat(pp.x, 10, 4) + util.paddedFloat(-pp.y, 10, 4) +
			'    ' + // ' eee'
			(data.attached ? 'A' : 'D') + // f
			(data.absolute ? 'A' : 'R') + // g
			(data.showUnits ? 'U' : ' ') + // h
			'   ' + //  i
			(data.nCharnCharsToDisplay >= 0 ? util.paddedInt(data.nCharnCharsToDisplay, 3) : 'ALL') + // jjj
			'  1   ' + // 'kkk ll '
		util.stringPadded(data.tagChar, 1) + // m
			'  ' + util.paddedInt(data.daspPos, 1) + // n
			'  '; // oo
			lines.push(sddLine);
		var val = util.normalizeNewlines(data.fieldValue).replace(/\n*$/, '');
		var charsPerLine = 69;
		val.split('\n').each(function (chars) {
			while (chars.length > charsPerLine) {
				lines.push('M  SCD ' + idstr + ' ' + chars.slice(0, charsPerLine));
				chars = chars.slice(charsPerLine);
			}
			lines.push('M  SED ' + idstr + ' ' + chars);
		});
		return lines.join('\n');
	},

	prepareForSaving: function (mol) {
		this.atoms = SGroup.getAtoms(mol, this);
	},

	postLoad: function (mol, atomMap) {
		if (!this.data.absolute)
			this.pp = this.pp.add(SGroup.getMassCentre(mol, this.atoms));
		// [NK] Temporary comment incoplete 'allAtoms' behavior
		// TODO: need ether remove 'allAtoms' flag or hadle it
		// consistently (other flags: *_KEY, *_RADICAL?)
		// var allAtomsInGroup = this.atoms.length == mol.atoms.count();
		// if (allAtomsInGroup &&
		//     (this.data.fieldName == 'MDLBG_FRAGMENT_STEREO' ||
		//      this.data.fieldName == 'MDLBG_FRAGMENT_COEFFICIENT' ||
		//      this.data.fieldName == 'MDLBG_FRAGMENT_CHARGE')) {
		// 	this.atoms = [];
		// 	this.allAtoms = true;
		// }
	}
};

SGroup.TYPES = {
	'MUL': GroupMul,
	'SRU': GroupSru,
	'SUP': GroupSup,
	'DAT': GroupDat,
	'GEN': GroupGen
};

module.exports = SGroup;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../util":40,"../util/box2abs":39,"../util/set":43,"../util/vec2":44,"./atom":8,"./bond":9}],16:[function(require,module,exports){
var Set = require('../util/set');
var Atom = require('./atom');
var Bond = require('./bond');
var CisTrans = require('./cis_trans');
var Dfs = require('./dfs');
var Stereocenters = require('./stereocenters');

var util = require('../util');

var Smiles = function ()
{
	this.smiles = '';
	this._written_atoms = [];
	this._written_components = 0;

	this.ignore_errors = false;
};

function _Atom(h_count) {
    return {
        neighbours: [],  // Array of integer pairs {a, b}
        aromatic:false,          // has aromatic bond
        lowercase:false,         // aromatic and has to be written lowercase
        chirality: 0,             // 0 means no chirality, 1 means CCW pyramid, 2 means CW pyramid
        branch_cnt: 0,            // runs from 0 to (branches - 1)
        paren_written:false,
        h_count:h_count,
        parent: 1
    };
};

// NB: only loops of length up to 6 are included here
Smiles.prototype.isBondInRing = function (bid) {
	if (util.isUndefined(this.inLoop) || util.isNull(this.inLoop))
		throw new Error('Init this.inLoop prior to calling this method');
	return this.inLoop[bid];
};

Smiles.prototype.saveMolecule = function (molecule, ignore_errors)
{
	var i, j, k;

	if (!Object.isUndefined(ignore_errors))
		this.ignore_errors = ignore_errors;

	//[RB]: KETCHER-498 (Incorrect smile-string for multiple Sgroup)
	//TODO the fix is temporary, still need to implement error handling/reporting
	//BEGIN
//    if (molecule.sgroups.count() > 0 && !this.ignore_errors)
//        throw new Error("SMILES doesn't support s-groups");
	molecule = molecule.clone();
	molecule.initHalfBonds();
	molecule.initNeighbors();
	molecule.sortNeighbors();
	molecule.setImplicitHydrogen();
	molecule.sgroups.each(function (sgid, sg) {
		if (sg.type == 'MUL') {
			try {
				sg.prepareForSaving(molecule);
			} catch(ex) {
					throw { message: 'Bad s-group (' + ex.message + ')' };
				}
		} else if (!this.ignore_errors) {
			throw new Error('SMILES data format doesn\'t support s-groups');
		}
	}, this);
	//END

	this.atoms = new Array(molecule.atoms.count());

	molecule.atoms.each(function (aid, atom)
	{
		this.atoms[aid] = _Atom(atom.implicitH);
	}, this);

	// From the SMILES specification:
	// Please note that only atoms on the following list
	// can be considered aromatic: C, N, O, P, S, As, Se, and * (wildcard).
	var allowed_lowercase = ['B', 'C', 'N', 'O', 'P', 'S', 'Se', 'As'];

	// Detect atoms that have aromatic bonds and count neighbours
	molecule.bonds.each(function (bid, bond)
	{
		if (bond.type == Bond.PATTERN.TYPE.AROMATIC)
		{
			this.atoms[bond.begin].aromatic = true;
			if (allowed_lowercase.indexOf(molecule.atoms.get(bond.begin).label) != -1)
				this.atoms[bond.begin].lowercase = true;
			this.atoms[bond.end].aromatic = true;
			if (allowed_lowercase.indexOf(molecule.atoms.get(bond.end).label) != -1)
				this.atoms[bond.end].lowercase = true;
		}
		this.atoms[bond.begin].neighbours.push({aid: bond.end, bid: bid});
		this.atoms[bond.end].neighbours.push({aid: bond.begin, bid: bid});
	}, this);

	this.inLoop = (function () {
		molecule.prepareLoopStructure();
		var bondsInLoops = Set.empty();
		molecule.loops.each(function (lid, loop) {
			if (loop.hbs.length <= 6)
				Set.mergeIn(bondsInLoops, Set.fromList(util.map(loop.hbs, function (hbid) {
					return molecule.halfBonds.get(hbid).bid;
				}, this)));
		}, this);
		var inLoop = {};
		Set.each(bondsInLoops, function (bid) {
			inLoop[bid] = 1;
		}, this);
		return inLoop;
	})();

	this._touched_cistransbonds = 0;
	this._markCisTrans(molecule);

	var components = molecule.getComponents();
	var componentsAll = components.reactants.concat(components.products);

	var walk = new Dfs(molecule, this.atoms, componentsAll, components.reactants.length);

	walk.walk();

	this.atoms.each(function (atom)
	{
		atom.neighbours.clear();
	}, this);

	// fill up neighbor lists for the stereocenters calculation
	for (i = 0; i < walk.v_seq.length; i++)
	{
		var seq_el = walk.v_seq[i];
		var v_idx = seq_el.idx;
		var e_idx = seq_el.parent_edge;
		var v_prev_idx = seq_el.parent_vertex;

		if (e_idx >= 0)
		{
			var atom = this.atoms[v_idx];

			var opening_cycles = walk.numOpeningCycles(e_idx);

			for (j = 0; j < opening_cycles; j++)
				this.atoms[v_prev_idx].neighbours.push({aid: -1, bid: -1});

			if (walk.edgeClosingCycle(e_idx))
			{
				for (k = 0; k < atom.neighbours.length; k++)
				{
					if (atom.neighbours[k].aid == -1)
					{
						atom.neighbours[k].aid = v_prev_idx;
						atom.neighbours[k].bid = e_idx;
						break;
					}
				}
				if (k == atom.neighbours.length)
					throw new Error('internal: can not put closing bond to its place');
			}
			else
			{
				atom.neighbours.push({aid: v_prev_idx, bid: e_idx});
				atom.parent = v_prev_idx;
			}
			this.atoms[v_prev_idx].neighbours.push({aid: v_idx, bid: e_idx});
		}
	}

	try {
		// detect chiral configurations
		var stereocenters = new Stereocenters(molecule, function (idx)
		{
			return this.atoms[idx].neighbours;
		}, this);
		stereocenters.buildFromBonds(this.ignore_errors);

		stereocenters.each (function (atom_idx, sc)
		{
			//if (sc.type < MoleculeStereocenters::ATOM_AND)
			//    continue;

			var implicit_h_idx = -1;

			if (sc.pyramid[3] == -1)
				implicit_h_idx = 3;
			/*
            else for (j = 0; j < 4; j++)
                if (ignored_vertices[pyramid[j]])
                {
                    implicit_h_idx = j;
                    break;
                }
                */

			var pyramid_mapping = new Array(4);
			var counter = 0;

			var atom = this.atoms[atom_idx];

			if (atom.parent != -1)
				for (k = 0; k < 4; k++)
					if (sc.pyramid[k] == atom.parent)
					{
						pyramid_mapping[counter++] = k;
						break;
					}

			if (implicit_h_idx != -1)
				pyramid_mapping[counter++] = implicit_h_idx;

			for (j = 0; j != atom.neighbours.length; j++)
			{
				if (atom.neighbours[j].aid == atom.parent)
					continue;

				for (k = 0; k < 4; k++)
					if (atom.neighbours[j].aid == sc.pyramid[k])
					{
						if (counter >= 4)
							throw new Error('internal: pyramid overflow');
						pyramid_mapping[counter++] = k;
						break;
					}
			}

			if (counter == 4)
			{
				// move the 'from' atom to the end
				counter = pyramid_mapping[0];
				pyramid_mapping[0] = pyramid_mapping[1];
				pyramid_mapping[1] = pyramid_mapping[2];
				pyramid_mapping[2] = pyramid_mapping[3];
				pyramid_mapping[3] = counter;
			}
			else if (counter != 3)
				throw new Error('cannot calculate chirality');

			if (Stereocenters.isPyramidMappingRigid(pyramid_mapping))
				this.atoms[atom_idx].chirality = 1;
			else
				this.atoms[atom_idx].chirality = 2;
		}, this);
	} catch (ex) {
			alert('Warning: ' + ex.message);
		}

	// write the SMILES itself

	// cycle_numbers[i] == -1 means that the number is available
	// cycle_numbers[i] == n means that the number is used by vertex n
	var cycle_numbers = [];

	cycle_numbers.push(0); // never used

	var first_component = true;

	for (i = 0; i < walk.v_seq.length; i++)
	{
		seq_el = walk.v_seq[i];
		v_idx = seq_el.idx;
		e_idx = seq_el.parent_edge;
		v_prev_idx = seq_el.parent_vertex;
		var write_atom = true;

		if (v_prev_idx >= 0)
		{
			if (walk.numBranches(v_prev_idx) > 1)
			if (this.atoms[v_prev_idx].branch_cnt > 0 && this.atoms[v_prev_idx].paren_written)
				this.smiles += ')';

			opening_cycles = walk.numOpeningCycles(e_idx);

			for (j = 0; j < opening_cycles; j++)
			{
				for (k = 1; k < cycle_numbers.length; k++)
					if (cycle_numbers[k] == -1)
						break;
				if (k == cycle_numbers.length)
					cycle_numbers.push(v_prev_idx);
				else
					cycle_numbers[k] = v_prev_idx;

				this._writeCycleNumber(k);
			}

			if (v_prev_idx >= 0)
			{
				var branches = walk.numBranches(v_prev_idx);

				if (branches > 1)
				if (this.atoms[v_prev_idx].branch_cnt < branches - 1)
				{
					if (walk.edgeClosingCycle(e_idx))
						this.atoms[v_prev_idx].paren_written = false;
					else
					{
						this.smiles += '(';
						this.atoms[v_prev_idx].paren_written = true;
					}
				}

				this.atoms[v_prev_idx].branch_cnt++;

				if (this.atoms[v_prev_idx].branch_cnt > branches)
					throw new Error('unexpected branch');
			}

			var bond = molecule.bonds.get(e_idx);
			var bond_written = true;

			var dir = 0;

			if (bond.type == Bond.PATTERN.TYPE.SINGLE)
				dir = this._calcBondDirection(molecule, e_idx, v_prev_idx);

			if ((dir == 1 && v_idx == bond.end) || (dir == 2 && v_idx == bond.begin))
				this.smiles += '/';
			else if ((dir == 2 && v_idx == bond.end) || (dir == 1 && v_idx == bond.begin))
				this.smiles += '\\';
			else if (bond.type == Bond.PATTERN.TYPE.ANY)
				this.smiles += '~';
			else if (bond.type == Bond.PATTERN.TYPE.DOUBLE)
				this.smiles += '=';
			else if (bond.type == Bond.PATTERN.TYPE.TRIPLE)
				this.smiles += '#';
			else if (bond.type == Bond.PATTERN.TYPE.AROMATIC &&
			(!this.atoms[bond.begin].lowercase || !this.atoms[bond.end].lowercase || !this.isBondInRing(e_idx)))
				this.smiles += ':'; // TODO: Check if this : is needed
			else if (bond.type == Bond.PATTERN.TYPE.SINGLE && this.atoms[bond.begin].aromatic && this.atoms[bond.end].aromatic)
				this.smiles += '-';
			else
				bond_written = false;


			if (walk.edgeClosingCycle(e_idx))
			{
				for (j = 1; j < cycle_numbers.length; j++)
					if (cycle_numbers[j] == v_idx)
						break;

				if (j == cycle_numbers.length)
					throw new Error('cycle number not found');

				this._writeCycleNumber(j);

				cycle_numbers[j] = -1;
				write_atom = false;
			}
		}
		else
		{
			if (!first_component)
				this.smiles += (this._written_components == walk.nComponentsInReactants) ? '>>' : '.';
			first_component = false;
			this._written_components++;
		}
		if (write_atom) {
			this._writeAtom(molecule, v_idx, this.atoms[v_idx].aromatic, this.atoms[v_idx].lowercase, this.atoms[v_idx].chirality);
			this._written_atoms.push(seq_el.idx);
		}
	}

	this.comma = false;

	//this._writeStereogroups(mol, atoms);
	this._writeRadicals(molecule);
	//this._writePseudoAtoms(mol);
	//this._writeHighlighting();

	if (this.comma)
		this.smiles += '|';

	return this.smiles;

};

Smiles.prototype._writeCycleNumber = function (n)
{
	if (n > 0 && n < 10)
		this.smiles += n;
	else if (n >= 10 && n < 100)
		this.smiles += '%' + n;
	else if (n >= 100 && n < 1000)
		this.smiles += '%%' + n;
	else
		throw new Error('bad cycle number: ' + n);
};

Smiles.prototype._writeAtom = function (mol, idx, aromatic, lowercase, chirality)
{
	var atom = mol.atoms.get(idx);
	var i;
	var need_brackets = false;
	var hydro = -1;
	var aam = 0;

	/*
    if (mol.haveQueryAtoms())
    {
      query_atom = &mol.getQueryAtom(idx);

      if (query_atom->type == QUERY_ATOM_RGROUP)
      {
         if (mol.getRGroups()->isRGroupAtom(idx))
         {
            const Array<int> &rg = mol.getRGroups()->getSiteRGroups(idx);

            if (rg.size() != 1)
               throw Error("rgroup count %d", rg.size());

            _output.printf("[&%d]", rg[0] + 1);
         }
         else
            _output.printf("[&%d]", 1);

         return;
      }
    }
    */

	if (atom.label == 'A')
	{
		this.smiles += '*';
		return;
	}

	if (atom.label == 'R' || atom.label == 'R#')
	{
		this.smiles += '[*]';
		return;
	}

	//KETCHER-598 (Ketcher does not save AAM into reaction SMILES)
	//BEGIN
//    if (this.atom_atom_mapping)
//        aam = atom_atom_mapping[idx];
	aam = atom.aam;
	//END

	if (atom.label != 'C' && atom.label != 'P' &&
	atom.label != 'N' && atom.label != 'S' &&
	atom.label != 'O' && atom.label != 'Cl' &&
	atom.label != 'F' && atom.label != 'Br' &&
	atom.label != 'B' && atom.label != 'I')
		need_brackets = true;

	if (atom.explicitValence >= 0 || atom.radical != 0 || chirality > 0 ||
		(aromatic && atom.label != 'C' && atom.label != 'O') ||
	(aromatic && atom.label == 'C' && this.atoms[idx].neighbours.length < 3 && this.atoms[idx].h_count == 0))
		hydro = this.atoms[idx].h_count;

	var label = atom.label;
	if (atom.atomList && !atom.atomList.notList) {
		label = atom.atomList.label();
		need_brackets = false; // atom list label already has brackets
	} else if (atom.isPseudo() || (atom.atomList && atom.atomList.notList)) {
		label = '*';
		need_brackets = true;
	} else if (chirality || atom.charge != 0 || atom.isotope > 0 || hydro >= 0 || aam > 0) {
		need_brackets = true;
	}

	if (need_brackets)
	{
		if (hydro == -1)
			hydro = this.atoms[idx].h_count;
		this.smiles += '[';
	}

	if (atom.isotope > 0)
		this.smiles += atom.isotope;

	if (lowercase)
		this.smiles += label.toLowerCase();
	else
		this.smiles += label;

	if (chirality > 0)
	{
		if (chirality == 1)
			this.smiles += '@';
		else // chirality == 2
			this.smiles += '@@';

		if (atom.implicitH > 1)
			throw new Error(atom.implicitH + ' implicit H near stereocenter');
	}

	if (atom.label != 'H') {
		if (hydro > 1 || (hydro == 0 && !need_brackets))
			this.smiles += 'H' + hydro;
		else if (hydro == 1)
			this.smiles += 'H';
	}

	if (atom.charge > 1)
		this.smiles += '+' + atom.charge;
	else if (atom.charge < -1)
		this.smiles += atom.charge;
	else if (atom.charge == 1)
		this.smiles += '+';
	else if (atom.charge == -1)
		this.smiles += '-';

	if (aam > 0)
		this.smiles += ':' + aam;

	if (need_brackets)
		this.smiles += ']';

	/*
    if (mol.getRGroupFragment() != 0)
    {
      for (i = 0; i < 2; i++)
      {
         int j;

         for (j = 0; mol.getRGroupFragment()->getAttachmentPoint(i, j) != -1; j++)
            if (idx == mol.getRGroupFragment()->getAttachmentPoint(i, j))
            {
               _output.printf("([*])");
               break;
            }

         if (mol.getRGroupFragment()->getAttachmentPoint(i, j) != -1)
            break;
      }
    }
    */
};

Smiles.prototype._markCisTrans = function (mol)
{
	this.cis_trans = new CisTrans (mol, function (idx)
	{
		return this.atoms[idx].neighbours;
	}, this);
	this.cis_trans.build();
	this._dbonds = new Array(mol.bonds.count());

	mol.bonds.each(function (bid)
	{
		this._dbonds[bid] =
		{
			ctbond_beg: -1,
			ctbond_end: -1,
			saved: 0
		}
	}, this);

	this.cis_trans.each(function (bid, ct)
	{
		var bond = mol.bonds.get(bid);

		if (ct.parity != 0 && !this.isBondInRing(bid))
		{
			var nei_beg = this.atoms[bond.begin].neighbours;
			var nei_end = this.atoms[bond.end].neighbours;
			var arom_fail_beg = true, arom_fail_end = true;

			nei_beg.each(function (nei)
			{
				if (nei.bid != bid && mol.bonds.get(nei.bid).type == Bond.PATTERN.TYPE.SINGLE)
					arom_fail_beg = false;
			}, this);

			nei_end.each(function (nei)
			{
				if (nei.bid != bid && mol.bonds.get(nei.bid).type == Bond.PATTERN.TYPE.SINGLE)
					arom_fail_end = false;
			}, this);

			if (arom_fail_beg || arom_fail_end)
				return;

			nei_beg.each(function (nei)
			{
				if (nei.bid != bid)
				{
					if (mol.bonds.get(nei.bid).begin == bond.begin)
						this._dbonds[nei.bid].ctbond_beg = bid;
					else
						this._dbonds[nei.bid].ctbond_end = bid;
				}
			}, this);

			nei_end.each(function (nei)
			{
				if (nei.bid != bid)
				{
					if (mol.bonds.get(nei.bid).begin == bond.end)
						this._dbonds[nei.bid].ctbond_beg = bid;
					else
						this._dbonds[nei.bid].ctbond_end = bid;
				}
			}, this);
		}
	}, this);
};

Smiles.prototype._updateSideBonds = function (mol, bond_idx)
{
	var bond = mol.bonds.get(bond_idx);
	var subst = this.cis_trans.getSubstituents(bond_idx);
	var parity = this.cis_trans.getParity(bond_idx);

	var sidebonds = [-1, -1, -1, -1];

	sidebonds[0] = mol.findBondId(subst[0], bond.begin);
	if (subst[1] != -1)
		sidebonds[1] = mol.findBondId(subst[1], bond.begin);

	sidebonds[2] = mol.findBondId(subst[2], bond.end);
	if (subst[3] != -1)
		sidebonds[3] = mol.findBondId(subst[3], bond.end);

	var n1 = 0, n2 = 0, n3 = 0, n4 = 0;

	if (this._dbonds[sidebonds[0]].saved != 0)
	{
		if ((this._dbonds[sidebonds[0]].saved == 1 && mol.bonds.get(sidebonds[0]).begin == bond.begin) ||
		(this._dbonds[sidebonds[0]].saved == 2 && mol.bonds.get(sidebonds[0]).end == bond.begin))
			n1++;
		else
			n2++;
	}
	if (sidebonds[1] != -1 && this._dbonds[sidebonds[1]].saved != 0)
	{
		if ((this._dbonds[sidebonds[1]].saved == 2 && mol.bonds.get(sidebonds[1]).begin == bond.begin) ||
		(this._dbonds[sidebonds[1]].saved == 1 && mol.bonds.get(sidebonds[1]).end == bond.begin))
			n1++;
		else
			n2++;
	}
	if (this._dbonds[sidebonds[2]].saved != 0)
	{
		if ((this._dbonds[sidebonds[2]].saved == 1 && mol.bonds.get(sidebonds[2]).begin == bond.end) ||
		(this._dbonds[sidebonds[2]].saved == 2 && mol.bonds.get(sidebonds[2]).end == bond.end))
			n3++;
		else
			n4++;
	}
	if (sidebonds[3] != -1 && this._dbonds[sidebonds[3]].saved != 0)
	{
		if ((this._dbonds[sidebonds[3]].saved == 2 && mol.bonds.get(sidebonds[3]).begin == bond.end) ||
		(this._dbonds[sidebonds[3]].saved == 1 && mol.bonds.get(sidebonds[3]).end == bond.end))
			n3++;
		else
			n4++;
	}

	if (parity == CisTrans.PARITY.CIS)
	{
		n1 += n3;
		n2 += n4;
	}
	else
	{
		n1 += n4;
		n2 += n3;
	}

	if (n1 > 0 && n2 > 0)
		throw new Error('incompatible cis-trans configuration');

	if (n1 == 0 && n2 == 0)
		return false;

	if (n1 > 0)
	{
		this._dbonds[sidebonds[0]].saved =
			(mol.bonds.get(sidebonds[0]).begin == bond.begin) ? 1 : 2;
		if (sidebonds[1] != -1)
			this._dbonds[sidebonds[1]].saved =
				(mol.bonds.get(sidebonds[1]).begin == bond.begin) ? 2 : 1;

		this._dbonds[sidebonds[2]].saved =
			((mol.bonds.get(sidebonds[2]).begin == bond.end) == (parity == CisTrans.PARITY.CIS)) ? 1 : 2;
		if (sidebonds[3] != -1)
			this._dbonds[sidebonds[3]].saved =
				((mol.bonds.get(sidebonds[3]).begin == bond.end) == (parity == CisTrans.PARITY.CIS)) ? 2 : 1;
	}
	if (n2 > 0)
	{
		this._dbonds[sidebonds[0]].saved =
			(mol.bonds.get(sidebonds[0]).begin == bond.begin) ? 2 : 1;
		if (sidebonds[1] != -1)
			this._dbonds[sidebonds[1]].saved =
				(mol.bonds.get(sidebonds[1]).begin == bond.begin) ? 1 : 2;

		this._dbonds[sidebonds[2]].saved =
			((mol.bonds.get(sidebonds[2]).begin == bond.end) == (parity == CisTrans.PARITY.CIS)) ? 2 : 1;
		if (sidebonds[3] != -1)
			this._dbonds[sidebonds[3]].saved =
				((mol.bonds.get(sidebonds[3]).begin == bond.end) == (parity == CisTrans.PARITY.CIS)) ? 1 : 2;
	}

	return true;
};

Smiles.prototype._calcBondDirection = function (mol, idx, vprev)
{
	var ntouched;

	if (this._dbonds[idx].ctbond_beg == -1 && this._dbonds[idx].ctbond_end == -1)
		return 0;

	if (mol.bonds.get(idx).type != Bond.PATTERN.TYPE.SINGLE)
		throw new Error('internal: directed bond type ' + mol.bonds.get(idx).type);

	while (true)
	{
		ntouched = 0;
		this.cis_trans.each(function (bid, ct)
		{
			if (ct.parity != 0 && !this.isBondInRing(bid))
			{
				if (this._updateSideBonds(mol, bid))
					ntouched++;
			}
		}, this);
		if (ntouched == this._touched_cistransbonds)
			break;
		this._touched_cistransbonds = ntouched;
	}

	if (this._dbonds[idx].saved == 0)
	{
		if (vprev == mol.bonds.get(idx).begin)
			this._dbonds[idx].saved = 1;
		else
			this._dbonds[idx].saved = 2;
	}

	return this._dbonds[idx].saved;
};

Smiles.prototype._writeRadicals = function (mol)
{
	var marked = new Array(this._written_atoms.length);
	var i, j;

	for (i = 0; i < this._written_atoms.size(); i++)
	{
		if (marked[i])
			continue;

		var radical = mol.atoms.get(this._written_atoms[i]).radical;

		if (radical == 0)
			continue;

		if (this.comma)
			this.smiles += ',';
		else
		{
			this.smiles += ' |';
			this.comma = true;
		}

		if (radical == Atom.PATTERN.RADICAL.SINGLET)
			this.smiles += '^3:';
		else if (radical == Atom.PATTERN.RADICAL.DOUPLET)
			this.smiles += '^1:';
		else // RADICAL_TRIPLET
			this.smiles += '^4:';

		this.smiles += i;

		for (j = i + 1; j < this._written_atoms.length; j++)
			if (mol.atoms.get(this._written_atoms[j]).radical == radical)
			{
				marked[j] = true;
				this.smiles += ',' + j;
			}
	}
};

/*
void Smiles::_writeStereogroups (const Struct &mol, const Array<_Atom> &atoms)
{
   MoleculeStereocenters &stereocenters = mol.getStereocenters();
   int i, j;
   int single_and_group = -1;

   for (i = stereocenters.begin(); i != stereocenters.end(); i = stereocenters.next(i))
   {
      int idx, type, group;

      stereocenters.get(i, idx, type, group, 0);

      if (type < MoleculeStereocenters::ATOM_ANY)
         continue;
      if (type != MoleculeStereocenters::ATOM_AND)
         break;
      if (single_and_group == -1)
         single_and_group = group;
      else if (single_and_group != group)
         break;
   }

   if (i == stereocenters.end())
      return;

   int and_group_idx = 1;
   int or_group_idx = 1;

   QS_DEF(Array<int>, marked);

   marked.clear_resize(_written_atoms.size());
   marked.zerofill();

   for (i = 0; i < _written_atoms.size(); i++)
   {
      if (marked[i])
         continue;

      int type = stereocenters.getType(_written_atoms[i]);

      if (type > 0)
      {
         if (_comma)
            _output.writeChar(',');
         else
         {
            _output.writeString(" |");
            _comma = true;
         }
      }

      if (type == MoleculeStereocenters::ATOM_ANY)
      {
         _output.printf("w:%d", i);

         for (j = i + 1; j < _written_atoms.size(); j++)
            if (stereocenters.getType(_written_atoms[j]) == MoleculeStereocenters::ATOM_ANY)
            {
               marked[j] = 1;
               _output.printf(",%d", j);
            }
      }
      else if (type == MoleculeStereocenters::ATOM_ABS)
      {
         _output.printf("a:%d", i);

         for (j = i + 1; j < _written_atoms.size(); j++)
            if (stereocenters.getType(_written_atoms[j]) == MoleculeStereocenters::ATOM_ABS)
            {
               marked[j] = 1;
               _output.printf(",%d", j);
            }
      }
      else if (type == MoleculeStereocenters::ATOM_AND)
      {
         int group = stereocenters.getGroup(_written_atoms[i]);

         _output.printf("&%d:%d", and_group_idx++, i);
         for (j = i + 1; j < _written_atoms.size(); j++)
            if (stereocenters.getType(_written_atoms[j]) == MoleculeStereocenters::ATOM_AND &&
                stereocenters.getGroup(_written_atoms[j]) == group)
            {
               marked[j] = 1;
               _output.printf(",%d", j);
            }
      }
      else if (type == MoleculeStereocenters::ATOM_OR)
      {
         int group = stereocenters.getGroup(_written_atoms[i]);

         _output.printf("o%d:%d", or_group_idx++, i);
         for (j = i + 1; j < _written_atoms.size(); j++)
            if (stereocenters.getType(_written_atoms[j]) == MoleculeStereocenters::ATOM_OR &&
                stereocenters.getGroup(_written_atoms[j]) == group)
            {
               marked[j] = 1;
               _output.printf(",%d", j);
            }
      }
   }
}
*/

module.exports = {
	stringify: function (molecule, options) {
		var opts = options || {};
		return new Smiles().saveMolecule(molecule, opts.ignoreErrors);
	}
};

},{"../util":40,"../util/set":43,"./atom":8,"./bond":9,"./cis_trans":10,"./dfs":11,"./stereocenters":17}],17:[function(require,module,exports){
var Map = require('../util/map');
var Set = require('../util/set');
var Vec2 = require('../util/vec2');
var util = require('../util');
var Bond = require('./bond');

var Stereocenters = function (mol, neighbors_func, context)
{
	this.molecule = mol;
	this.atoms = new Map();
	this.getNeighbors = neighbors_func;
	this.context = context;
};

Stereocenters.prototype.each = function (func, context)
{
	this.atoms.each(func, context);
};

Stereocenters.prototype.buildFromBonds = function (/*const int *atom_types, const int *atom_groups, const int *bond_orientations, */ignore_errors)
{
	var atoms = this.molecule.atoms;
	var bonds = this.molecule.bonds;

	// this is a set of atoms that are likely to belong to allene structures and
	//  therefore should not be considered as potential stereocenters in the code below,
	//  as allenes cannot be encoded in the SMILES notation
	var alleneMask = Set.empty();
	atoms.each(function (aid, atom) {
		var nei_list = this.getNeighbors.call(this.context, aid);
		if (nei_list.length != 2)
			return false;
		var nei1 = nei_list[0];
		var nei2 = nei_list[1];
		// check atom labels
		if (util.findIndex([aid, nei1.aid, nei2.aid], function (aid) {
			return ['C', 'Si'].indexOf(atoms.get(aid).label) < 0;
		}, this) >= 0)
			return false;

		// check adjacent bond types
		if (util.findIndex([nei1.bid, nei2.bid], function (bid) {
			return bonds.get(bid).type != Bond.PATTERN.TYPE.DOUBLE;
		}, this) >= 0)
			return false;

		// get the other neighbors of the two adjacent atoms except for the central atom
		var nei1nei = util.findAll(this.getNeighbors.call(this.context, nei1.aid), function (nei) {
			return nei.aid != aid;
		}, this);
		var nei2nei = util.findAll(this.getNeighbors.call(this.context, nei2.aid), function (nei) {
			return nei.aid != aid;
		}, this);
		if (nei1nei.length < 1 || nei1nei.length > 2 || nei2nei.length < 1 || nei2nei.length > 2)
			return false;

		if (util.findIndex(nei1nei.concat(nei2nei), function (nei) {
			return bonds.get(nei.bid).type != Bond.PATTERN.TYPE.SINGLE;
		}, this) >= 0)
			return false;

		if (util.findIndex(nei1nei.concat(nei2nei), function (nei) {
			return bonds.get(nei.bid).stereo == Bond.PATTERN.STEREO.EITHER;
		}, this) >= 0)
			return false;
		Set.add(alleneMask, nei1.aid);
		Set.add(alleneMask, nei2.aid);
	}, this);

	if (Set.size(alleneMask) > 0)
		alert('This structure may contain allenes, which cannot be represented in the SMILES notation. Relevant stereo-information will be discarded.');

	atoms.each(function (aid)
	{
		if (Set.contains(alleneMask, aid))
			return;
		/*
      if (atom_types[atom_idx] == 0)
         continue;
         */
		var nei_list = this.getNeighbors.call(this.context, aid);
		var stereocenter = false;

		nei_list.find(function (nei)
		{
			var bond = this.molecule.bonds.get(nei.bid);

			if (bond.type == Bond.PATTERN.TYPE.SINGLE && bond.begin == aid)
			if (bond.stereo == Bond.PATTERN.STEREO.UP || bond.stereo == Bond.PATTERN.STEREO.DOWN)
			{
				stereocenter = true;
				return true;
			}
			return false;
		}, this);

		if (!stereocenter)
			return;

		if (ignore_errors)
		{
//         try
//         {
			this._buildOneCenter(aid/*, atom_groups[atom_idx], atom_types[atom_idx], bond_orientations*/);
//         }
//         catch (er)
//         {
//         }
		}
		else
			this._buildOneCenter(aid/*, atom_groups[atom_idx], atom_types[atom_idx], bond_orientations*/);
	}, this);
};

Stereocenters.allowed_stereocenters =
	[
	{elem: 'C',  charge: 0, degree: 3, n_double_bonds: 0, implicit_degree: 4},
	{elem: 'C',  charge: 0, degree: 4, n_double_bonds: 0, implicit_degree: 4},
	{elem: 'Si', charge: 0, degree: 3, n_double_bonds: 0, implicit_degree: 4},
	{elem: 'Si', charge: 0, degree: 4, n_double_bonds: 0, implicit_degree: 4},
	{elem: 'N',  charge: 1, degree: 3, n_double_bonds: 0, implicit_degree: 4},
	{elem: 'N',  charge: 1, degree: 4, n_double_bonds: 0, implicit_degree: 4},
	{elem: 'N',  charge: 0, degree: 3, n_double_bonds: 0, implicit_degree: 3},
	{elem: 'S',  charge: 0, degree: 4, n_double_bonds: 2, implicit_degree: 4},
	{elem: 'S',  charge: 1, degree: 3, n_double_bonds: 0, implicit_degree: 3},
	{elem: 'S',  charge: 0, degree: 3, n_double_bonds: 1, implicit_degree: 3},
	{elem: 'P',  charge: 0, degree: 3, n_double_bonds: 0, implicit_degree: 3},
	{elem: 'P',  charge: 1, degree: 4, n_double_bonds: 0, implicit_degree: 4},
	{elem: 'P',  charge: 0, degree: 4, n_double_bonds: 1, implicit_degree: 4}
	];


Stereocenters.prototype._buildOneCenter = function (atom_idx/*, int group, int type, const int *bond_orientations*/)
{
	var atom = this.molecule.atoms.get(atom_idx);

	var nei_list = this.getNeighbors.call(this.context, atom_idx);
	var degree = nei_list.length;
	var implicit_degree = -1;

	var stereocenter =
	{
		group: 0, // = group;
		type: 0, // = type;
		pyramid: new Array(4)
	};

	var nei_idx = 0;
	var edge_ids = new Array(4);

	var last_atom_dir = 0;
	var n_double_bonds = 0;

	stereocenter.pyramid[0] = -1;
	stereocenter.pyramid[1] = -1;
	stereocenter.pyramid[2] = -1;
	stereocenter.pyramid[3] = -1;

	var n_pure_hydrogens = 0;

	if (degree > 4)
		throw new Error('stereocenter with %d bonds are not supported' + degree);

	nei_list.each(function (nei)
	{
		var nei_atom = this.molecule.atoms.get(nei.aid);
		var bond = this.molecule.bonds.get(nei.bid);

		edge_ids[nei_idx] =
		{
			edge_idx: nei.bid,
			nei_idx: nei.aid,
			rank: nei.aid,
			vec: Vec2.diff(nei_atom.pp, atom.pp).yComplement()
		};

		if (nei_atom.pureHydrogen())
		{
			n_pure_hydrogens++;
			edge_ids[nei_idx].rank = 10000;
		} else if (nei_atom.label == 'H')
			edge_ids[nei_idx].rank = 5000;

		if (!edge_ids[nei_idx].vec.normalize())
			throw new Error('zero bond length');

		if (bond.type == Bond.PATTERN.TYPE.TRIPLE)
			throw new Error('non-single bonds not allowed near stereocenter');
		else if (bond.type == Bond.PATTERN.TYPE.AROMATIC)
			throw new Error('aromatic bonds not allowed near stereocenter');
		else if (bond.type == Bond.PATTERN.TYPE.DOUBLE)
			n_double_bonds++;

		nei_idx++;
	}, this);

	Stereocenters.allowed_stereocenters.find(function (as)
	{
		if (as.elem == atom.label && as.charge == atom.charge &&
		as.degree == degree && as.n_double_bonds == n_double_bonds)
		{
			implicit_degree = as.implicit_degree;
			return true;
		}
		return false;
	}, this);

	if (implicit_degree == -1)
		throw new Error('unknown stereocenter configuration: ' + atom.label + ', charge ' + atom.charge + ', ' + degree + ' bonds (' + n_double_bonds + ' double)');

	if (degree == 4 && n_pure_hydrogens > 1)
		throw new Error(n_pure_hydrogens + ' hydrogens near stereocenter');

	if (degree == 3 && implicit_degree == 4 && n_pure_hydrogens > 0)
		throw new Error('have hydrogen(s) besides implicit hydrogen near stereocenter');

	/*
   if (stereocenter.type == ATOM_ANY)
   {
      _stereocenters.insert(atom_idx, stereocenter);
      return;
   }
   */

	if (degree == 4)
	{
		// sort by neighbor atom index (ascending)
		if (edge_ids[0].rank > edge_ids[1].rank)
			edge_ids.swap(0, 1);
		if (edge_ids[1].rank > edge_ids[2].rank)
			edge_ids.swap(1, 2);
		if (edge_ids[2].rank > edge_ids[3].rank)
			edge_ids.swap(2, 3);
		if (edge_ids[1].rank > edge_ids[2].rank)
			edge_ids.swap(1, 2);
		if (edge_ids[0].rank > edge_ids[1].rank)
			edge_ids.swap(0, 1);
		if (edge_ids[1].rank > edge_ids[2].rank)
			edge_ids.swap(1, 2);

		var main1 = -1, main2 = -1, side1 = -1, side2 = -1;
		var main_dir = 0;

		for (nei_idx = 0; nei_idx < 4; nei_idx++)
		{
			var stereo = this._getBondStereo(atom_idx, edge_ids[nei_idx].edge_idx);

			if (stereo == Bond.PATTERN.STEREO.UP || stereo == Bond.PATTERN.STEREO.DOWN)
			{
				main1 = nei_idx;
				main_dir = stereo;
				break;
			}
		}

		if (main1 == -1)
			throw new Error('none of 4 bonds going from stereocenter is stereobond');

		var xyz1, xyz2;

		// find main2 as opposite to main1
		if (main2 == -1)
		{
			xyz1 = Stereocenters._xyzzy(edge_ids[main1].vec, edge_ids[(main1 + 1) % 4].vec, edge_ids[(main1 + 2) % 4].vec);
			xyz2 = Stereocenters._xyzzy(edge_ids[main1].vec, edge_ids[(main1 + 1) % 4].vec, edge_ids[(main1 + 3) % 4].vec);

			if (xyz1 + xyz2 == 3 || xyz1 + xyz2 == 12)
			{
				main2 = (main1 + 1) % 4;
				side1 = (main1 + 2) % 4;
				side2 = (main1 + 3) % 4;
			}
		}
		if (main2 == -1)
		{
			xyz1 = Stereocenters._xyzzy(edge_ids[main1].vec, edge_ids[(main1 + 2) % 4].vec, edge_ids[(main1 + 1) % 4].vec);
			xyz2 = Stereocenters._xyzzy(edge_ids[main1].vec, edge_ids[(main1 + 2) % 4].vec, edge_ids[(main1 + 3) % 4].vec);

			if (xyz1 + xyz2 == 3 || xyz1 + xyz2 == 12)
			{
				main2 = (main1 + 2) % 4;
				side1 = (main1 + 1) % 4;
				side2 = (main1 + 3) % 4;
			}
		}
		if (main2 == -1)
		{
			xyz1 = Stereocenters._xyzzy(edge_ids[main1].vec, edge_ids[(main1 + 3) % 4].vec, edge_ids[(main1 + 1) % 4].vec);
			xyz2 = Stereocenters._xyzzy(edge_ids[main1].vec, edge_ids[(main1 + 3) % 4].vec, edge_ids[(main1 + 2) % 4].vec);

			if (xyz1 + xyz2 == 3 || xyz1 + xyz2 == 12)
			{
				main2 = (main1 + 3) % 4;
				side1 = (main1 + 2) % 4;
				side2 = (main1 + 1) % 4;
			}
		}

		if (main2 == -1)
			throw new Error('internal error: can not find opposite bond');

		if (main_dir == Bond.PATTERN.STEREO.UP && this._getBondStereo(atom_idx, edge_ids[main2].edge_idx) == Bond.PATTERN.STEREO.DOWN)
			throw new Error('stereo types of the opposite bonds mismatch');
		if (main_dir == Bond.PATTERN.STEREO.DOWN && this._getBondStereo(atom_idx, edge_ids[main2].edge_idx) == Bond.PATTERN.STEREO.UP)
			throw new Error('stereo types of the opposite bonds mismatch');

		if (main_dir == this._getBondStereo(atom_idx, edge_ids[side1].edge_idx))
			throw new Error('stereo types of non-opposite bonds match');
		if (main_dir == this._getBondStereo(atom_idx, edge_ids[side2].edge_idx))
			throw new Error('stereo types of non-opposite bonds match');

		if (main1 == 3 || main2 == 3)
			last_atom_dir = main_dir;
		else
			last_atom_dir = (main_dir == Bond.PATTERN.STEREO.UP ? Bond.PATTERN.STEREO.DOWN : Bond.PATTERN.STEREO.UP);

		sign = Stereocenters._sign(edge_ids[0].vec, edge_ids[1].vec, edge_ids[2].vec);

		if ((last_atom_dir == Bond.PATTERN.STEREO.UP && sign > 0) ||
		(last_atom_dir == Bond.PATTERN.STEREO.DOWN && sign < 0))
		{
			stereocenter.pyramid[0] = edge_ids[0].nei_idx;
			stereocenter.pyramid[1] = edge_ids[1].nei_idx;
			stereocenter.pyramid[2] = edge_ids[2].nei_idx;
		}
		else
		{
			stereocenter.pyramid[0] = edge_ids[0].nei_idx;
			stereocenter.pyramid[1] = edge_ids[2].nei_idx;
			stereocenter.pyramid[2] = edge_ids[1].nei_idx;
		}

		stereocenter.pyramid[3] = edge_ids[3].nei_idx;
	}
	else if (degree == 3)
	{
		// sort by neighbor atom index (ascending)
		if (edge_ids[0].rank > edge_ids[1].rank)
			edge_ids.swap(0, 1);
		if (edge_ids[1].rank > edge_ids[2].rank)
			edge_ids.swap(1, 2);
		if (edge_ids[0].rank > edge_ids[1].rank)
			edge_ids.swap(0, 1);

		var stereo0 = this._getBondStereo(atom_idx, edge_ids[0].edge_idx);
		var stereo1 = this._getBondStereo(atom_idx, edge_ids[1].edge_idx);
		var stereo2 = this._getBondStereo(atom_idx, edge_ids[2].edge_idx);

		var n_up = 0, n_down = 0;

		n_up += ((stereo0 == Bond.PATTERN.STEREO.UP) ? 1 : 0);
		n_up += ((stereo1 == Bond.PATTERN.STEREO.UP) ? 1 : 0);
		n_up += ((stereo2 == Bond.PATTERN.STEREO.UP) ? 1 : 0);

		n_down += ((stereo0 == Bond.PATTERN.STEREO.DOWN) ? 1 : 0);
		n_down += ((stereo1 == Bond.PATTERN.STEREO.DOWN) ? 1 : 0);
		n_down += ((stereo2 == Bond.PATTERN.STEREO.DOWN) ? 1 : 0);

		if (implicit_degree == 4) // have implicit hydrogen
		{
			if (n_up == 3)
				throw new Error('all 3 bonds up near stereoatom');
			if (n_down == 3)
				throw new Error('all 3 bonds down near stereoatom');

			if (n_up == 0 && n_down == 0)
				throw new Error('no up/down bonds near stereoatom -- indefinite case');
			if (n_up == 1 && n_down == 1)
				throw new Error('one bond up, one bond down -- indefinite case');

			main_dir = 0;

			if (n_up == 2)
				last_atom_dir = Bond.PATTERN.STEREO.DOWN;
			else if (n_down == 2)
				last_atom_dir = Bond.PATTERN.STEREO.UP;
			else
			{
				main1 = -1;
				side1 = -1;
				side2 = -1;

				for (nei_idx = 0; nei_idx < 3; nei_idx++)
				{
					dir = this._getBondStereo(atom_idx, edge_ids[nei_idx].edge_idx);

					if (dir == Bond.PATTERN.STEREO.UP || dir == Bond.PATTERN.STEREO.DOWN)
					{
						main1 = nei_idx;
						main_dir = dir;
						side1 = (nei_idx + 1) % 3;
						side2 = (nei_idx + 2) % 3;
						break;
					}
				}

				if (main1 == -1)
					throw new Error('internal error: can not find up or down bond');

				var xyz = Stereocenters._xyzzy(edge_ids[side1].vec, edge_ids[side2].vec, edge_ids[main1].vec);

				if (xyz == 3 || xyz == 4)
					throw new Error('degenerate case for 3 bonds near stereoatom');

				if (xyz == 1)
					last_atom_dir = main_dir;
				else
					last_atom_dir = (main_dir == Bond.PATTERN.STEREO.UP ? Bond.PATTERN.STEREO.DOWN : Bond.PATTERN.STEREO.UP);
			}

			var sign = Stereocenters._sign(edge_ids[0].vec, edge_ids[1].vec, edge_ids[2].vec);

			if ((last_atom_dir == Bond.PATTERN.STEREO.UP && sign > 0) ||
			(last_atom_dir == Bond.PATTERN.STEREO.DOWN && sign < 0))
			{
				stereocenter.pyramid[0] = edge_ids[0].nei_idx;
				stereocenter.pyramid[1] = edge_ids[1].nei_idx;
				stereocenter.pyramid[2] = edge_ids[2].nei_idx;
			}
			else
			{
				stereocenter.pyramid[0] = edge_ids[0].nei_idx;
				stereocenter.pyramid[1] = edge_ids[2].nei_idx;
				stereocenter.pyramid[2] = edge_ids[1].nei_idx;
			}

			stereocenter.pyramid[3] = -1;
		}
		else // 3-connected P, N or S; no implicit hydrogens
		{
			var dir;

			if (n_down > 0 && n_up > 0)
				throw new Error('one bond up, one bond down -- indefinite case');
			else if (n_down == 0 && n_up == 0)
				throw new Error('no up-down bonds attached to stereocenter');
			else if (n_up > 0)
				dir = 1;
			else
				dir = -1;

			if (Stereocenters._xyzzy(edge_ids[0].vec, edge_ids[1].vec, edge_ids[2].vec) == 1 ||
			Stereocenters._xyzzy(edge_ids[0].vec, edge_ids[2].vec, edge_ids[1].vec) == 1 ||
			Stereocenters._xyzzy(edge_ids[2].vec, edge_ids[1].vec, edge_ids[0].vec) == 1)
				// all bonds belong to the same half-plane
				dir = -dir;

			sign = Stereocenters._sign(edge_ids[0].vec, edge_ids[1].vec, edge_ids[2].vec);

			if (sign == dir)
			{
				stereocenter.pyramid[0] = edge_ids[0].nei_idx;
				stereocenter.pyramid[1] = edge_ids[2].nei_idx;
				stereocenter.pyramid[2] = edge_ids[1].nei_idx;
			}
			else
			{
				stereocenter.pyramid[0] = edge_ids[0].nei_idx;
				stereocenter.pyramid[1] = edge_ids[1].nei_idx;
				stereocenter.pyramid[2] = edge_ids[2].nei_idx;
			}
			stereocenter.pyramid[3] = -1;
		}
	}

	this.atoms.set(atom_idx, stereocenter);
};

Stereocenters.prototype._getBondStereo = function (center_idx, edge_idx)
{
	var bond = this.molecule.bonds.get(edge_idx);

	if (center_idx != bond.begin) // TODO: check this
		return 0;

	return bond.stereo;
};

// 1 -- in the smaller angle, 2 -- in the bigger angle,
// 4 -- in the 'positive' straight angle, 8 -- in the 'negative' straight angle
Stereocenters._xyzzy = function (v1, v2, u)
{
	var eps = 0.001;

	var sine1 = Vec2.cross(v1, v2);
	var cosine1 = Vec2.dot(v1, v2);

	var sine2 = Vec2.cross(v1, u);
	var cosine2 = Vec2.dot(v1, u);

	if (Math.abs(sine1) < eps)
	{
		if (Math.abs(sine2) < eps)
			throw new Error('degenerate case -- bonds overlap');

		return (sine2 > 0) ? 4 : 8;
	}

	if (sine1 * sine2 < -eps * eps)
		return 2;

	if (cosine2 < cosine1)
		return 2;

	return 1;
};

Stereocenters._sign = function (v1, v2, v3)
{
	var res = (v1.x - v3.x) * (v2.y - v3.y) - (v1.y - v3.y) * (v2.x - v3.x);
	var eps = 0.001;

	if (res > eps)
		return 1;
	if (res < -eps)
		return -1;

	throw new Error('degenerate triangle');
};

Stereocenters.isPyramidMappingRigid = function (mapping)
{
	var arr = mapping.clone();
	var rigid = true;

	if (arr[0] > arr[1])
		arr.swap(0, 1), rigid = !rigid;
	if (arr[1] > arr[2])
		arr.swap(1, 2), rigid = !rigid;
	if (arr[2] > arr[3])
		arr.swap(2, 3), rigid = !rigid;
	if (arr[1] > arr[2])
		arr.swap(1, 2), rigid = !rigid;
	if (arr[0] > arr[1])
		arr.swap(0, 1), rigid = !rigid;
	if (arr[1] > arr[2])
		arr.swap(1, 2), rigid = !rigid;

	return rigid;
};

module.exports = Stereocenters;

},{"../util":40,"../util/map":41,"../util/set":43,"../util/vec2":44,"./bond":9}],18:[function(require,module,exports){
var Map = require('../util/map');
var Pool = require('../util/pool');
var Set = require('../util/set');
var Vec2 = require('../util/vec2');
var util = require('../util');

var element = require('./element');
var Bond = require('./bond');
var SGroup = require('./sgroup');
var SGroupForest = require('./sgforest');

var Struct = function () {
	this.atoms = new Pool();
	this.bonds = new Pool();
	this.sgroups = new Pool();
	this.halfBonds = new Map();
	this.loops = new Pool();
	this.isChiral = false;
	this.isReaction = false;
	this.rxnArrows = new Pool();
	this.rxnPluses = new Pool();
	this.frags = new Pool();
	this.rgroups = new Map();
	this.name = '';
	this.sGroupForest = new SGroupForest(this);
};

Struct.prototype.hasRxnProps = function () {
	return this.atoms.find(function (aid, atom) {
		return atom.hasRxnProps();
	}, this) >= 0 || this.bonds.find(function (bid, bond) {
		return bond.hasRxnProps();
	}, this) >= 0;
};

Struct.prototype.hasRxnArrow = function () {
	return this.rxnArrows.count() > 0;
};

Struct.prototype.addRxnArrowIfNecessary = function () {
	var implicitReaction = !this.hasRxnArrow() && this.hasRxnProps();
	if (implicitReaction) {
		this.rxnArrows.add(new Struct.RxnArrow());
	}
	return implicitReaction;
};

// returns a list of id's of s-groups, which contain only atoms in the given list
Struct.prototype.getSGroupsInAtomSet = function (atoms/*Array*/) {
	var sgroupCounts = new Hash();

	util.each(atoms, function (aid) {
		var sg = Set.list(this.atoms.get(aid).sgs);

		sg.each(function (sid) {
			var n = sgroupCounts.get(sid);
			if (Object.isUndefined(n)) {
				n = 1;
			} else {
				n++;
			}
			sgroupCounts.set(sid, n);
		}, this);
	}, this);

	var sgroupList = [];
	sgroupCounts.each(function (sg) {
		var sid = parseInt(sg.key, 10);
		var sgroup = this.sgroups.get(sid);
		var sgAtoms = SGroup.getAtoms(this, sgroup);
		if (sg.value == sgAtoms.length) {
			sgroupList.push(sid);
		}
	}, this);
	return sgroupList;
};

Struct.prototype.isBlank = function () {
	return this.atoms.count() === 0 &&
	this.rxnArrows.count() === 0 &&
	this.rxnPluses.count() === 0 && !this.isChiral;
};

Struct.prototype.toLists = function () {
	var aidMap = {};
	var atomList = [];
	this.atoms.each(function (aid, atom) {
		aidMap[aid] = atomList.length;
		atomList.push(atom);
	});

	var bondList = [];
	this.bonds.each(function (bid, bond) {
		var b = new Bond(bond);
		b.begin = aidMap[bond.begin];
		b.end = aidMap[bond.end];
		bondList.push(b);
	});

	return {
		'atoms': atomList,
		'bonds': bondList
	};
};

Struct.prototype.clone = function (atomSet, bondSet, dropRxnSymbols, aidMap) {
	var cp = new Struct();
	return this.mergeInto(cp, atomSet, bondSet, dropRxnSymbols, false, aidMap);
};

Struct.prototype.getScaffold = function () {
	var atomSet = Set.empty();
	this.atoms.each(function (aid) {
		Set.add(atomSet, aid);
	}, this);
	this.rgroups.each(function (rgid, rg) {
		rg.frags.each(function (fnum, fid) {
			this.atoms.each(function (aid, atom) {
				if (atom.fragment == fid) {
					Set.remove(atomSet, aid);
				}
			}, this);
		}, this);
	}, this);
	return this.clone(atomSet);
};

Struct.prototype.getFragmentIds = function (fid) {
	var atomSet = Set.empty();
	this.atoms.each(function (aid, atom) {
		if (atom.fragment == fid) {
			Set.add(atomSet, aid);
		}
	}, this);
	return atomSet;
};

Struct.prototype.getFragment = function (fid) {
	return this.clone(this.getFragmentIds(fid));
};

Struct.prototype.mergeInto = function (cp, atomSet, bondSet, dropRxnSymbols, keepAllRGroups, aidMap) {
	atomSet = atomSet || Set.keySetInt(this.atoms);
	bondSet = bondSet || Set.keySetInt(this.bonds);
	bondSet = Set.filter(bondSet, function (bid){
		var bond = this.bonds.get(bid);
		return Set.contains(atomSet, bond.begin) && Set.contains(atomSet, bond.end);
	}, this);

	var fidMask = {};
	this.atoms.each(function (aid, atom) {
		if (Set.contains(atomSet, aid))
			fidMask[atom.fragment] = 1;
	});
	var fidMap = {};
	this.frags.each(function (fid, frag) {
		if (fidMask[fid])
			fidMap[fid] = cp.frags.add(frag.clone());
	});

	this.rgroups.each(function (rgid, rgroup) {
		var keepGroup = keepAllRGroups;
		if (!keepGroup) {
			rgroup.frags.each(function (fnum, fid) {
				if (fidMask[fid])
					keepGroup = true;
			});
			if (!keepGroup)
				return;
		}
		var rg = cp.rgroups.get(rgid);
		if (rg) {
			rgroup.frags.each(function (fnum, fid) {
				if (fidMask[fid])
					rg.frags.add(fidMap[fid]);
			});
		} else {
			cp.rgroups.set(rgid, rgroup.clone(fidMap));
		}
	});

	if (typeof aidMap === 'undefined' || aidMap === null)
		aidMap = {};
	this.atoms.each(function (aid, atom) {
		if (Set.contains(atomSet, aid))
			aidMap[aid] = cp.atoms.add(atom.clone(fidMap));
	});

	var bidMap = {};
	this.bonds.each(function (bid, bond) {
		if (Set.contains(bondSet, bid))
			bidMap[bid] = cp.bonds.add(bond.clone(aidMap));
	});

	this.sgroups.each(function (sid, sg) {
		var i;
		for (i = 0; i < sg.atoms.length; ++i)
			if (!Set.contains(atomSet, sg.atoms[i]))
				return;
		sg = SGroup.clone(sg, aidMap, bidMap);
		var id = cp.sgroups.add(sg);
		sg.id = id;
		for (i = 0; i < sg.atoms.length; ++i) {
			Set.add(cp.atoms.get(sg.atoms[i]).sgs, id);
		}
		cp.sGroupForest.insert(sg.id);
	});
	cp.isChiral = this.isChiral;
	if (!dropRxnSymbols) {
		cp.isReaction = this.isReaction;
		this.rxnArrows.each(function (id, item) {
			cp.rxnArrows.add(item.clone());
		});
		this.rxnPluses.each(function (id, item) {
			cp.rxnPluses.add(item.clone());
		});
	}
	return cp;
};

Struct.prototype.findBondId = function (begin, end)
{
	var id = -1;

	this.bonds.find(function (bid, bond)
	{
		if ((bond.begin == begin && bond.end == end) ||
		(bond.begin == end && bond.end == begin))
		{
			id = bid;
			return true;
		}
		return false;
	}, this);

	return id;
};

var HalfBond = function (/*num*/begin, /*num*/end, /*num*/bid)
{
	if (arguments.length != 3)
		throw new Error('Invalid parameter number!');

	this.begin = begin - 0;
	this.end = end - 0;
	this.bid = bid - 0;

	// rendering properties
	this.dir = new Vec2(); // direction
	this.norm = new Vec2(); // left normal
	this.ang = 0; // angle to (1,0), used for sorting the bonds
	this.p = new Vec2(); // corrected origin position
	this.loop = -1; // left loop id if the half-bond is in a loop, otherwise -1
	this.contra = -1; // the half bond contrary to this one
	this.next = -1; // the half-bond next ot this one in CCW order
	this.leftSin = 0;
	this.leftCos = 0;
	this.leftNeighbor = 0;
	this.rightSin = 0;
	this.rightCos = 0;
	this.rightNeighbor = 0;
};

Struct.prototype.initNeighbors = function ()
{
	this.atoms.each(function (aid, atom){
		atom.neighbors = [];
	});
	this.bonds.each(function (bid, bond){
		var a1 = this.atoms.get(bond.begin);
		var a2 = this.atoms.get(bond.end);
		a1.neighbors.push(bond.hb1);
		a2.neighbors.push(bond.hb2);
	}, this);
};

Struct.prototype.bondInitHalfBonds = function (bid, /*opt*/ bond)
{
	bond = bond || this.bonds.get(bid);
	bond.hb1 = 2 * bid;
	bond.hb2 = 2 * bid + 1;
	this.halfBonds.set(bond.hb1, new HalfBond(bond.begin, bond.end, bid));
	this.halfBonds.set(bond.hb2, new HalfBond(bond.end, bond.begin, bid));
	var hb1 = this.halfBonds.get(bond.hb1);
	var hb2 = this.halfBonds.get(bond.hb2);
	hb1.contra = bond.hb2;
	hb2.contra = bond.hb1;
};

Struct.prototype.halfBondUpdate = function (hbid)
{
	var hb = this.halfBonds.get(hbid);
	var p1 = this.atoms.get(hb.begin).pp;
	var p2 = this.atoms.get(hb.end).pp;
	var d = Vec2.diff(p2, p1).normalized();
	hb.dir = Vec2.dist(p2, p1) > 1e-4 ? d : new Vec2(1, 0);
	hb.norm = hb.dir.turnLeft();
	hb.ang = hb.dir.oxAngle();
	if (hb.loop < 0)
		hb.loop = -1;
};

Struct.prototype.initHalfBonds = function ()
{
	this.halfBonds.clear();
	this.bonds.each(this.bondInitHalfBonds, this);
};

Struct.prototype.setHbNext = function (hbid, next)
{
	this.halfBonds.get(this.halfBonds.get(hbid).contra).next = next;
};

Struct.prototype.halfBondSetAngle = function (hbid, left)
{
	var hb = this.halfBonds.get(hbid);
	var hbl = this.halfBonds.get(left);
	hbl.rightCos = hb.leftCos = Vec2.dot(hbl.dir, hb.dir);
	hbl.rightSin = hb.leftSin = Vec2.cross(hbl.dir, hb.dir);
	hb.leftNeighbor = left;
	hbl.rightNeighbor = hbid;
};

Struct.prototype.atomAddNeighbor = function (hbid)
{
	var hb = this.halfBonds.get(hbid);
	var atom = this.atoms.get(hb.begin);
	var i = 0;
	for (i = 0; i < atom.neighbors.length; ++i)
		if (this.halfBonds.get(atom.neighbors[i]).ang > hb.ang)
			break;
	atom.neighbors.splice(i, 0, hbid);
	var ir = atom.neighbors[(i + 1) % atom.neighbors.length];
	var il = atom.neighbors[(i + atom.neighbors.length - 1)
			 % atom.neighbors.length];
	this.setHbNext(il, hbid);
	this.setHbNext(hbid, ir);
	this.halfBondSetAngle(hbid, il);
	this.halfBondSetAngle(ir, hbid);
};

Struct.prototype.atomSortNeighbors = function (aid) {
	var atom = this.atoms.get(aid);
	atom.neighbors = atom.neighbors.sortBy(function (nei){
		return this.halfBonds.get(nei).ang;
	}, this);

	var i;
	for (i = 0; i < atom.neighbors.length; ++i)
		this.halfBonds.get(this.halfBonds.get(atom.neighbors[i]).contra).next =
			atom.neighbors[(i + 1) % atom.neighbors.length];
	for (i = 0; i < atom.neighbors.length; ++i)
		this.halfBondSetAngle(atom.neighbors[(i + 1) % atom.neighbors.length],
			atom.neighbors[i]);
};

Struct.prototype.sortNeighbors = function (list) {
	var f = function (aid) { this.atomSortNeighbors(aid); };
	if (util.isNullOrUndefined(list))
		this.atoms.each(f, this);
	else
		util.each(list, f, this);
};

Struct.prototype.atomUpdateHalfBonds = function (aid) {
	var nei = this.atoms.get(aid).neighbors;
	for (var i = 0; i < nei.length; ++i) {
		var hbid = nei[i];
		this.halfBondUpdate(hbid);
		this.halfBondUpdate(this.halfBonds.get(hbid).contra);
	}
};

Struct.prototype.updateHalfBonds = function (list) {
	var f = function (aid) { this.atomUpdateHalfBonds(aid); };
	if (util.isNullOrUndefined(list))
		this.atoms.each(f, this);
	else
		util.each(list, f, this);
};

Struct.prototype.sGroupsRecalcCrossBonds = function () {
	this.sgroups.each(function (sgid, sg){
		sg.xBonds = [];
		sg.neiAtoms = [];
	},this);
	this.bonds.each(function (bid, bond){
		var a1 = this.atoms.get(bond.begin);
		var a2 = this.atoms.get(bond.end);
		Set.each(a1.sgs, function (sgid){
			if (!Set.contains(a2.sgs, sgid)) {
				var sg = this.sgroups.get(sgid);
				sg.xBonds.push(bid);
				util.arrayAddIfMissing(sg.neiAtoms, bond.end);
			}
		}, this);
		Set.each(a2.sgs, function (sgid){
			if (!Set.contains(a1.sgs, sgid)) {
				var sg = this.sgroups.get(sgid);
				sg.xBonds.push(bid);
				util.arrayAddIfMissing(sg.neiAtoms, bond.begin);
			}
		}, this);
	},this);
};

Struct.prototype.sGroupDelete = function (sgid)
{
	var sg = this.sgroups.get(sgid);
	for (var i = 0; i < sg.atoms.length; ++i) {
		Set.remove(this.atoms.get(sg.atoms[i]).sgs, sgid);
	}
	this.sGroupForest.remove(sgid);
	this.sgroups.remove(sgid);
};

Struct.itemSetPos = function (item, pp) // TODO: remove
{
	item.pp = pp;
};

Struct.prototype._itemSetPos = function (map, id, pp, scaleFactor)
{
	Struct.itemSetPos(this[map].get(id), pp, scaleFactor);
};

Struct.prototype._atomSetPos = function (id, pp, scaleFactor)
{
	this._itemSetPos('atoms', id, pp, scaleFactor);
};

Struct.prototype._rxnPlusSetPos = function (id, pp, scaleFactor)
{
	this._itemSetPos('rxnPluses', id, pp, scaleFactor);
};

Struct.prototype._rxnArrowSetPos = function (id, pp, scaleFactor)
{
	this._itemSetPos('rxnArrows', id, pp, scaleFactor);
};

Struct.prototype.getCoordBoundingBox = function (atomSet)
{
	var bb = null;
	var extend = function (pp) {
		if (!bb)
			bb = {
				min: pp,
				max: pp
			};
		else {
			bb.min = Vec2.min(bb.min, pp);
			bb.max = Vec2.max(bb.max, pp);
		}
	};

	var global = typeof(atomSet) == 'undefined';

	this.atoms.each(function (aid, atom) {
		if (global || Set.contains(atomSet, aid))
			extend(atom.pp);
	});
	if (global) {
		this.rxnPluses.each(function (id, item) {
			extend(item.pp);
		});
		this.rxnArrows.each(function (id, item) {
			extend(item.pp);
		});
	}
	if (!bb && global)
		bb = {
			min: new Vec2(0, 0),
			max: new Vec2(1, 1)
		};
	return bb;
};

Struct.prototype.getCoordBoundingBoxObj = function ()
{
	var bb = null;
	var extend = function (pp) {
		if (!bb)
			bb = {
				min: new Vec2(pp),
				max: new Vec2(pp)
			};
		else {
			bb.min = Vec2.min(bb.min, pp);
			bb.max = Vec2.max(bb.max, pp);
		}
	};

	this.atoms.each(function (aid, atom) {
		extend(atom.pp);
	});
	return bb;
};

Struct.prototype.getBondLengthData = function ()
{
	var totalLength = 0;
	var cnt = 0;
	this.bonds.each(function (bid, bond){
		totalLength += Vec2.dist(
			this.atoms.get(bond.begin).pp,
			this.atoms.get(bond.end).pp);
		cnt++;
	}, this);
	return {cnt:cnt, totalLength:totalLength};
};

Struct.prototype.getAvgBondLength = function ()
{
	var bld = this.getBondLengthData();
	return bld.cnt > 0 ? bld.totalLength / bld.cnt : -1;
};

Struct.prototype.getAvgClosestAtomDistance = function ()
{
	var totalDist = 0, minDist, dist = 0;
	var keys = this.atoms.keys(), k, j;
	for (k = 0; k < keys.length; ++k) {
		minDist = -1;
		for (j = 0; j < keys.length; ++j) {
			if (j == k)
				continue;
			dist = Vec2.dist(this.atoms.get(keys[j]).pp, this.atoms.get(keys[k]).pp);
			if (minDist < 0 || minDist > dist)
				minDist = dist;
		}
		totalDist += minDist;
	}

	return keys.length > 0 ? totalDist / keys.length : -1;
};

Struct.prototype.checkBondExists = function (begin, end)
{
	var bondExists = false;
	this.bonds.each(function (bid, bond){
		if ((bond.begin == begin && bond.end == end) ||
		(bond.end == begin && bond.begin == end))
			bondExists = true;
	}, this);
	return bondExists;
};

var Loop = function (/*Array of num*/hbs, /*Struct*/struct, /*bool*/convex)
{
	this.hbs = hbs; // set of half-bonds involved
	this.dblBonds = 0; // number of double bonds in the loop
	this.aromatic = true;
	this.convex = convex || false;

	hbs.each(function (hb){
		var bond = struct.bonds.get(struct.halfBonds.get(hb).bid);
		if (bond.type != Bond.PATTERN.TYPE.AROMATIC)
			this.aromatic = false;
		if (bond.type == Bond.PATTERN.TYPE.DOUBLE)
			this.dblBonds++;
	}, this);
};

Struct.RxnPlus = function (params)
{
	params = params || {};
	this.pp = params.pp ? new Vec2(params.pp) : new Vec2();
};

Struct.RxnPlus.prototype.clone = function ()
{
	return new Struct.RxnPlus(this);
};

Struct.RxnArrow = function (params)
{
	params = params || {};
	this.pp = params.pp ? new Vec2(params.pp) : new Vec2();
};

Struct.RxnArrow.prototype.clone = function ()
{
	return new Struct.RxnArrow(this);
};

Struct.prototype.findConnectedComponent = function (aid) {
	var map = {};
	var list = [aid];
	var ids = Set.empty();
	while (list.length > 0) {
		(function () {
			var aid = list.pop();
			map[aid] = 1;
			Set.add(ids, aid);
			var atom = this.atoms.get(aid);
			for (var i = 0; i < atom.neighbors.length; ++i) {
				var neiId = this.halfBonds.get(atom.neighbors[i]).end;
				if (!Set.contains(ids, neiId))
					list.push(neiId);
			}
		}).apply(this);
	}
	return ids;
};

Struct.prototype.findConnectedComponents = function (discardExistingFragments) {
	// NB: this is a hack
	// TODO: need to maintain half-bond and neighbor structure permanently
	if (!this.halfBonds.count()) {
		this.initHalfBonds();
		this.initNeighbors();
		this.updateHalfBonds(this.atoms.keys());
		this.sortNeighbors(this.atoms.keys());
	}

	var map = {};
	this.atoms.each(function (aid) {
		map[aid] = -1;
	}, this);
	var components = [];
	this.atoms.each(function (aid,atom){
		if ((discardExistingFragments || atom.fragment < 0) && map[aid] < 0) {
			var component = this.findConnectedComponent(aid);
			components.push(component);
			Set.each(component, function (aid){
				map[aid] = 1;
			}, this);
		}
	}, this);
	return components;
};

Struct.prototype.markFragment = function (ids) {
	var fid = this.frags.add(new Struct.Fragment());
	Set.each(ids, function (aid){
		this.atoms.get(aid).fragment = fid;
	}, this);
};

Struct.prototype.markFragmentByAtomId = function (aid) {
	this.markFragment(this.findConnectedComponent(aid));
};

Struct.prototype.markFragments = function () {
	var components = this.findConnectedComponents();
	for (var i = 0; i < components.length; ++i) {
		this.markFragment(components[i]);
	}
};

Struct.Fragment = function () {
};
Struct.Fragment.prototype.clone = function () {
	return Object.clone(this);
};

Struct.Fragment.getAtoms = function (struct, frid) {
	var atoms = [];
	struct.atoms.each(function (aid, atom) {
		if (atom.fragment == frid)
			atoms.push(aid);
	}, this);
	return atoms;
}

Struct.RGroup = function (logic) {
	logic = logic || {};
	this.frags = new Pool();
	this.resth = logic.resth || false;
	this.range = logic.range || '';
	this.ifthen = logic.ifthen || 0;
};

Struct.RGroup.prototype.getAttrs = function () {
	return {
		resth: this.resth,
		range: this.range,
		ifthen: this.ifthen
	};
};

Struct.RGroup.findRGroupByFragment = function (rgroups, frid) {
	var ret;
	rgroups.each(function (rgid, rgroup) {
		if (!Object.isUndefined(rgroup.frags.keyOf(frid))) ret = rgid;
	});
	return ret;
};
Struct.RGroup.prototype.clone = function (fidMap) {
	var ret = new Struct.RGroup(this);
	this.frags.each(function (fnum, fid) {
		ret.frags.add(fidMap ? fidMap[fid] : fid);
	});
	return ret;
};

Struct.prototype.scale = function (scale)
{
	if (scale != 1) {
		this.atoms.each(function (aid, atom){
			atom.pp = atom.pp.scaled(scale);
		}, this);
		this.rxnPluses.each(function (id, item){
			item.pp = item.pp.scaled(scale);
		}, this);
		this.rxnArrows.each(function (id, item){
			item.pp = item.pp.scaled(scale);
		}, this);
		this.sgroups.each(function (id, item){
			item.pp = item.pp ? item.pp.scaled(scale) : null;
		}, this);
	}
};

Struct.prototype.rescale = function ()
{
	var avg = this.getAvgBondLength();
	if (avg < 0 && !this.isReaction) // TODO [MK] this doesn't work well for reactions as the distances between
		// the atoms in different components are generally larger than those between atoms of a single component
		// (KETCHER-341)
		avg = this.getAvgClosestAtomDistance();
	if (avg < 1e-3)
		avg = 1;
	var scale = 1 / avg;
	this.scale(scale);
};

Struct.prototype.loopHasSelfIntersections = function (hbs)
{
	for (var i = 0; i < hbs.length; ++i) {
		var hbi = this.halfBonds.get(hbs[i]);
		var ai = this.atoms.get(hbi.begin).pp;
		var bi = this.atoms.get(hbi.end).pp;
		var set = Set.fromList([hbi.begin, hbi.end]);
		for (var j = i + 2; j < hbs.length; ++j) {
			var hbj = this.halfBonds.get(hbs[j]);
			if (Set.contains(set, hbj.begin) || Set.contains(set, hbj.end))
				continue; // skip edges sharing an atom
			var aj = this.atoms.get(hbj.begin).pp;
			var bj = this.atoms.get(hbj.end).pp;
			if (Vec2.segmentIntersection(ai, bi, aj, bj)) {
				return true;
			}
		}
	}
	return false;
}

// partition a cycle into simple cycles
// TODO: [MK] rewrite the detection algorithm to only find simple ones right away?
Struct.prototype.partitionLoop = function (loop) {
	var subloops = [];
	var continueFlag = true;
	search: while (continueFlag) {
			var atomToHalfBond = {}; // map from every atom in the loop to the index of the first half-bond starting from that atom in the uniqHb array
			for (var l = 0; l < loop.length; ++l) {
				var hbid = loop[l];
				var aid1 = this.halfBonds.get(hbid).begin;
				var aid2 = this.halfBonds.get(hbid).end;
				if (aid2 in atomToHalfBond) { // subloop found
					var s = atomToHalfBond[aid2]; // where the subloop begins
					var subloop = loop.slice(s, l + 1);
					subloops.push(subloop);
					if (l < loop.length) // remove half-bonds corresponding to the subloop
						loop.splice(s, l - s + 1);
					continue search;
				}
				atomToHalfBond[aid1] = l;
			}
			continueFlag = false; // we're done, no more subloops found
			subloops.push(loop);
		}
	return subloops;
}

Struct.prototype.halfBondAngle = function (hbid1, hbid2) {
	var hba = this.halfBonds.get(hbid1);
	var hbb = this.halfBonds.get(hbid2);
	return Math.atan2(
	Vec2.cross(hba.dir, hbb.dir),
	Vec2.dot(hba.dir, hbb.dir));
}

Struct.prototype.loopIsConvex = function (loop) {
	for (var k = 0; k < loop.length; ++k) {
		var angle = this.halfBondAngle(loop[k], loop[(k + 1) % loop.length]);
		if (angle > 0)
			return false;
	}
	return true;
}

// check whether a loop is on the inner or outer side of the polygon
//  by measuring the total angle between bonds
Struct.prototype.loopIsInner = function (loop) {
	var totalAngle = 2 * Math.PI;
	for (var k = 0; k < loop.length; ++k) {
		var hbida = loop[k];
		var hbidb = loop[(k + 1) % loop.length];
		var hbb = this.halfBonds.get(hbidb);
		var angle = this.halfBondAngle(hbida, hbidb);
		if (hbb.contra == loop[k]) // back and forth along the same edge
			totalAngle += Math.PI;
		else
			totalAngle += angle;
	}
	return Math.abs(totalAngle) < Math.PI;
}

Struct.prototype.findLoops = function ()
{
	var newLoops = [];
	var bondsToMark = Set.empty();

	// Starting from each half-bond not known to be in a loop yet,
	//  follow the 'next' links until the initial half-bond is reached or
	//  the length of the sequence exceeds the number of half-bonds available.
	// In a planar graph, as long as every bond is a part of some "loop" -
	//  either an outer or an inner one - every iteration either yields a loop
	//  or doesn't start at all. Thus this has linear complexity in the number
	//  of bonds for planar graphs.
	var j, c, loop, loopId;
	this.halfBonds.each(function (i, hb) {
		if (hb.loop == -1) {
			for (j = i, c = 0, loop = [];
				c <= this.halfBonds.count();
				j = this.halfBonds.get(j).next, ++c) {
				if (c > 0 && j == i) { // loop found
					var subloops = this.partitionLoop(loop);
					util.each(subloops, function (loop) {
						if (this.loopIsInner(loop) && !this.loopHasSelfIntersections(loop)) { // loop is internal
							// use lowest half-bond id in the loop as the loop id
							// this ensures that the loop gets the same id if it is discarded and then recreated,
							// which in turn is required to enable redrawing while dragging, as actions store item id's
							loopId = util.arrayMin(loop);
							this.loops.set(loopId, new Loop(loop, this, this.loopIsConvex(loop)));
						} else {
							loopId = -2;
						}
						loop.each(function (hbid){
							this.halfBonds.get(hbid).loop = loopId;
							Set.add(bondsToMark, this.halfBonds.get(hbid).bid);
						}, this);
						if (loopId >= 0) {
							newLoops.push(loopId);
						}
					}, this);
					break;
				} else {
					loop.push(j);
				}
			}
		}
	}, this);
	return {
		newLoops: newLoops,
		bondsToMark: Set.list(bondsToMark)
	};
};

// NB: this updates the structure without modifying the corresponding ReStruct.
//  To be applied to standalone structures only.
Struct.prototype.prepareLoopStructure = function () {
    this.initHalfBonds();
    this.initNeighbors();
    this.updateHalfBonds(this.atoms.keys());
    this.sortNeighbors(this.atoms.keys());
    this.findLoops();
};

Struct.prototype.atomAddToSGroup = function (sgid, aid) {
    // TODO: [MK] make sure the addition does not break the hierarchy?
    SGroup.addAtom(this.sgroups.get(sgid), aid);
    Set.add(this.atoms.get(aid).sgs, sgid);
};

Struct.prototype.calcConn = function (aid) {
    var conn = 0;
    var atom = this.atoms.get(aid);
    var hasAromatic = false;
    for (var i = 0; i < atom.neighbors.length; ++i) {
        var hb = this.halfBonds.get(atom.neighbors[i]);
        var bond = this.bonds.get(hb.bid);
        switch (bond.type) {
            case Bond.PATTERN.TYPE.SINGLE:
                conn += 1;
                break;
            case Bond.PATTERN.TYPE.DOUBLE:
                conn += 2;
                break;
            case Bond.PATTERN.TYPE.TRIPLE:
                conn += 3;
                break;
            case Bond.PATTERN.TYPE.AROMATIC:
                conn += 1;
                hasAromatic = true;
                break;
            default:
                return -1;
        }
    }
    if (hasAromatic)
        conn += 1;
    return conn;
};

Struct.prototype.calcImplicitHydrogen = function (aid) {
    var conn = this.calcConn(aid);
    var atom = this.atoms.get(aid);
    atom.badConn = false;
    if (conn < 0 || atom.isQuery()) {
        atom.implicitH = 0;
        return;
    }
    if (atom.explicitValence >= 0) {
        var elem = element.getElementByLabel(atom.label);
        atom.implicitH = 0;
        if (elem != null) {
            atom.implicitH = atom.explicitValence - atom.calcValenceMinusHyd(conn);
            if (atom.implicitH < 0) {
                atom.implicitH = 0;
                atom.badConn = true;
            }
        }
    } else {
        atom.calcValence(conn);
    }
};

Struct.prototype.setImplicitHydrogen = function (list) {
    var f = function (aid) { this.calcImplicitHydrogen(aid); };
    if (util.isNullOrUndefined(list))
        this.atoms.each(f, this);
    else
        util.each(list, f, this);
};

Struct.prototype.getComponents = function () {
    /* saver */
    var ccs = this.findConnectedComponents(true);
    var submols = [];
    var barriers = [];
    var arrowPos = null;
    this.rxnArrows.each(function (id, item) { // there's just one arrow
        arrowPos = item.pp.x;
    });
    this.rxnPluses.each(function (id, item) {
        barriers.push(item.pp.x);
    });
    if (arrowPos != null)
        barriers.push(arrowPos);
    barriers.sort(function (a, b) { return a - b; });
    var components = [];

    var i;
    for (i = 0; i < ccs.length; ++i) {
        var bb = this.getCoordBoundingBox(ccs[i]);
        var c = Vec2.lc2(bb.min, 0.5, bb.max, 0.5);
        var j = 0;
        while (c.x > barriers[j])
            ++j;
        components[j] = components[j] || {};
        Set.mergeIn(components[j], ccs[i]);
    }
    var submolTexts = [];
    var reactants = [], products = [];
    for (i = 0; i < components.length; ++i) {
        if (!components[i]) {
            submolTexts.push('');
            continue;
        }
        bb = this.getCoordBoundingBox(components[i]);
        c = Vec2.lc2(bb.min, 0.5, bb.max, 0.5);
        if (c.x < arrowPos)
            reactants.push(components[i]);
        else
            products.push(components[i]);
    }

    return {
        'reactants': reactants,
        'products': products
    };
};

module.exports = Struct;

},{"../util":40,"../util/map":41,"../util/pool":42,"../util/set":43,"../util/vec2":44,"./bond":9,"./element":12,"./sgforest":14,"./sgroup":15}],19:[function(require,module,exports){
(function (global){
var queryString = require('query-string');

var util = require('./util');
var api = require('./api.js');

require('./ui');
var molfile = require('./chem/molfile');
var smiles = require('./chem/smiles');

require('./rnd');

var ui = global.ui;
var rnd = global.rnd;

function getSmiles() {
	return smiles.stringify(ui.ctab, { ignoreErrors: true });
};

function getMolfile() {
	return molfile.stringify(ui.ctab, { ignoreErrors: true });
};

function setMolecule(molString) {
	if (!Object.isString(molString)) {
		return;
	}
	ui.loadMolecule(molString);
};

function addFragment(molString) {
	if (!Object.isString(molString)) {
		return;
	}
	ui.loadFragment(molString);
};

function showMolfile(clientArea, molString, options) {
	var opts = util.extend({
		bondLength: 75,
		showSelectionRegions: false,
		showBondIds: false,
		showHalfBondIds: false,
		showLoopIds: false,
		showAtomIds: false,
		autoScale: false,
		autoScaleMargin: 4,
		hideImplicitHydrogen: false
	}, options);
	var render = new rnd.Render(clientArea, opts.bondLength, opts);
	if (molString) {
		var mol = molfile.parse(molString);
		render.setMolecule(mol);
	}
	render.update();
	// not sure we need to expose guts
	return render;
};

function onStructChange(handler) {
	util.assert(handler);
	ui.render.addStructChangeHandler(handler);
};

// TODO: replace window.onload with something like <https://github.com/ded/domready>
// to start early
window.onload = function () {
	var params = queryString.parse(document.location.search);
	if (params.api_path)
		ketcher.api_path = params.api_path;
	ketcher.server = api(ketcher.api_path);
	ui.init(util.extend({}, params), ketcher.server);
};

var ketcher = module.exports = {
	version: '2.0.0-alpha.3+r27',
	api_path: '',
	build_date: '2015-12-08 09-14-33',
	build_number: '' || null,
	build_options: '__BUILD_OPTIONS__',

	getSmiles: getSmiles,
	getMolfile: getMolfile,
	setMolecule: setMolecule,
	addFragment: addFragment,
	showMolfile: showMolfile,
	onStructChange: onStructChange
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./api.js":7,"./chem/molfile":13,"./chem/smiles":16,"./rnd":22,"./ui":35,"./util":40,"query-string":4}],20:[function(require,module,exports){
(function (global){
// Single entry point to Raphaël library

var Raphael = (typeof window !== "undefined" ? window['Raphael'] : typeof global !== "undefined" ? global['Raphael'] : null);
var Vec2 = require('./util/vec2');

// TODO: refactor ugly prototype extensions to plain old functions
Raphael.el.translateAbs = function (x,y) {
	this.delta = this.delta || new Vec2();
	this.delta.x += x - 0;
	this.delta.y += y - 0;
	this.transform('t' + this.delta.x.toString() + ',' + this.delta.y.toString());
};

Raphael.st.translateAbs = function (x,y) {
	this.forEach(function (el) {
		el.translateAbs(x,y);
	});
};

module.exports = Raphael;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./util/vec2":44}],21:[function(require,module,exports){
(function (global){
var Set = require('../util/set');
var Vec2 = require('../util/vec2');
var Action = require('../ui/action');

var element = require('../chem/element');
var Struct = require('../chem/struct');
var Atom = require('../chem/atom');
var Bond = require('../chem/bond');
var molfile = require('../chem/molfile');
var SGroup = require('../chem/sgroup');

require('./restruct');

var rnd = global.rnd = global.rnd || {}; // jshint ignore:line
var ui = global.ui;

var Editor = function (render)
{
	this.render = render;
	this._selectionHelper = new Editor.SelectionHelper(this);
};

Editor.prototype.selectAll = function () {
	var selection = {};
	for (var map in rnd.ReStruct.maps) {
		selection[map] = ui.render.ctab[map].ikeys();
	}
	this._selectionHelper.setSelection(selection);
};
Editor.prototype.deselectAll = function () {
	this._selectionHelper.setSelection();
};
Editor.prototype.hasSelection = function (copyable) {
	if ('selection' in this._selectionHelper)
		for (var map in this._selectionHelper.selection)
			if (this._selectionHelper.selection[map].length > 0)
			if (!copyable || map !== 'sgroupData')
				return true;
	return false;
};
Editor.prototype.getSelection = function (explicit) {
	var selection = {};
	if ('selection' in this._selectionHelper) {
		for (var map in this._selectionHelper.selection) {
			selection[map] = this._selectionHelper.selection[map].slice(0);
		}
	}
	if (explicit) {
		var struct = this.render.ctab.molecule;
		// "auto-select" the atoms for the bonds in selection
		if ('bonds' in selection) {
			selection.bonds.each(
			function (bid) {
				var bond = struct.bonds.get(bid);
				selection.atoms = selection.atoms || [];
				if (selection.atoms.indexOf(bond.begin) < 0) selection.atoms.push(bond.begin);
				if (selection.atoms.indexOf(bond.end) < 0) selection.atoms.push(bond.end);
			},
				this
			);
		}
		// "auto-select" the bonds with both atoms selected
		if ('atoms' in selection && 'bonds' in selection) {
			struct.bonds.each(
			function (bid) {
				if (!('bonds' in selection) || selection.bonds.indexOf(bid) < 0) {
					var bond = struct.bonds.get(bid);
					if (selection.atoms.indexOf(bond.begin) >= 0 && selection.atoms.indexOf(bond.end) >= 0) {
						selection.bonds = selection.bonds || [];
						selection.bonds.push(bid);
					}
				}
			},
				this
			);
		}
	}
	return selection;
};

Editor.prototype.getSelectionStruct = function () {
	console.assert(ui.ctab == this.render.ctab.molecule,
	               'Another ctab');
	var src = ui.ctab;
	var selection = this.getSelection(true);
	var dst = src.clone(Set.fromList(selection.atoms),
	                    Set.fromList(selection.bonds), true);

	// Copy by its own as Struct.clone doesn't support
	// arrows/pluses id sets
	src.rxnArrows.each(function (id, item) {
		if (selection.rxnArrows.indexOf(id) != -1)
			dst.rxnArrows.add(item.clone());
	});
	src.rxnPluses.each(function (id, item) {
		if (selection.rxnPluses.indexOf(id) != -1)
			dst.rxnPluses.add(item.clone());
	});

	// TODO: should be reaction only if arrwos? check this logic
	dst.isReaction = src.isReaction &&
		(dst.rxnArrows.count() || dst.rxnPluses.count());

	return dst;
};

Editor.SelectionHelper = function (editor) {
	this.editor = editor;
};
Editor.SelectionHelper.prototype.setSelection = function (selection, add) {
	if (!('selection' in this) || !add) {
		this.selection = {};
		for (var map1 in rnd.ReStruct.maps) this.selection[map1] = []; // TODO it should NOT be mandatory
	}
	if (selection && 'id' in selection && 'map' in selection) {
		(selection[selection.map] = selection[selection.map] || []).push(selection.id);
	}
	if (selection) {
		for (var map2 in this.selection) {
			if (map2 in selection) {
				for (var i = 0; i < selection[map2].length; i++) {
					if (this.selection[map2].indexOf(selection[map2][i]) < 0) {
						this.selection[map2].push(selection[map2][i]);
					}
				}
			}
		}
	}
	this.editor.render.setSelection(this.selection);
	this.editor.render.update();

	ui.updateClipboardButtons(); // TODO notify ui about selection
};
Editor.SelectionHelper.prototype.isSelected = function (item) {
	var render = this.editor.render;
	var ctab = render.ctab;
	if (item.map == 'frags' || item.map == 'rgroups') {
		var atoms = item.map == 'frags' ?
			ctab.frags.get(item.id).fragGetAtoms(render, item.id) :
			ctab.rgroups.get(item.id).getAtoms(render);
		return !Object.isUndefined(this.selection['atoms'])
			 && Set.subset(Set.fromList(atoms), Set.fromList(this.selection['atoms']));
	}
	return 'selection' in this && !Object.isUndefined(this.selection[item.map]) &&
	this.selection[item.map].indexOf(item.id) > -1;
};


Editor.EditorTool = function (editor) {
	this.editor = editor;
};
Editor.EditorTool.prototype.processEvent = function (name, event, action) {
	if (!('touches' in event) || event.touches.length == 1) {
		if (name + '0' in this)
			return this[name + '0'](event, action);
		else if (name in this)
			return this[name](event, action);
		console.log('EditorTool.dispatchEvent: event \'' + name + '\' is not handled.');
	} else if ('lastEvent' in this.OnMouseDown0) {
		// here we finish previous MouseDown and MouseMoves with simulated MouseUp
		// before gesture (canvas zoom, scroll, rotate) started
		return this.OnMouseUp0(event, action);
	}
};
Editor.EditorTool.prototype.OnMouseDown = function () {};
Editor.EditorTool.prototype.OnMouseMove = function () {};
Editor.EditorTool.prototype.OnMouseUp = function () {};
Editor.EditorTool.prototype.OnClick = function () {};
Editor.EditorTool.prototype.OnDblClick = function () {};
Editor.EditorTool.prototype.OnMouseLeave = function () { this.OnCancel();};
Editor.EditorTool.prototype.OnKeyPress = function () {};
Editor.EditorTool.prototype.OnCancel = function () {}; // called when we abandon the tool
Editor.EditorTool.prototype.OnMouseDown0 = function (event) {
	if (ui.hideBlurredControls()) return true; // TODO review (don't stop propagation to handle dropdown closing)

	this.OnMouseDown0.lastEvent = event;
	this.OnMouseMove0.lastEvent = event;

	if ('OnMouseDown' in this) return this.OnMouseDown(event);
};
Editor.EditorTool.prototype.OnMouseMove0 = function (event) {
	this.OnMouseMove0.lastEvent = event;

	if ('OnMouseMove' in this) return this.OnMouseMove(event);
};
Editor.EditorTool.prototype.OnMouseUp0 = function (event) {
	// here we suppress event we got when second touch released in guesture
	if (!('lastEvent' in this.OnMouseDown0)) return true;

	if ('lastEvent' in this.OnMouseMove0) {
		// this data is missing for 'touchend' event when last finger is out
		event = Object.clone(event); // pageX & pageY properties are readonly in Opera
		event.pageX = this.OnMouseMove0.lastEvent.pageX;
		event.pageY = this.OnMouseMove0.lastEvent.pageY;
	}

	try {
		if ('OnMouseUp' in this) return this.OnMouseUp(event);
	} finally {
		delete this.OnMouseDown0.lastEvent;
	}
};

Editor.EditorTool.atom_label_map = {
	atom_tool_any: 'A',
	atom_tool_h: 'H',
	atom_tool_c: 'C',
	atom_tool_n: 'N',
	atom_tool_o: 'O',
	atom_tool_s: 'S',
	atom_tool_p: 'P',
	atom_tool_f: 'F',
	atom_tool_br: 'Br',
	atom_tool_cl: 'Cl',
	atom_tool_i: 'I'
};

Editor.EditorTool.prototype.OnKeyPress0 = function (event, action) {
	if (action === 'rgroup_tool_label' && 'lastEvent' in this.OnMouseMove0) {
		return Editor.RGroupAtomTool.prototype.OnMouseUp.call(this,
			this.OnMouseMove0.lastEvent);
	} else if (action in Editor.EditorTool.atom_label_map) {
		var label = Editor.EditorTool.atom_label_map[action];
		var selection = this.editor.getSelection();
		if (selection && 'atoms' in selection && selection.atoms.length > 0) {
			ui.addUndoAction(Action.fromAtomsAttrs(
				selection.atoms, {label: label}, true), true);
			ui.render.update();
			return true;
		} else {
			var ci = this.editor.render.findItem(this.OnMouseMove0.lastEvent);
			if (ci) {
				ci.label = {label: label};
				if (ci.map === 'atoms') {
					ui.addUndoAction(Action.fromAtomsAttrs(
						ci.id, ci.label, true), true);
				} else if (ci.id == -1) {
					ui.addUndoAction(
					Action.fromAtomAddition(
					ui.page2obj(
						this.OnMouseMove0.lastEvent), ci.label), true);
				}
				ui.render.update();
				return true;
			}
		}
	}
	if ('OnKeyPress' in this)
		return this.OnKeyPress(event);
	return false;
};

Editor.EditorTool.prototype._calcAngle = function (pos0, pos1) {
	var v = Vec2.diff(pos1, pos0);
	var angle = Math.atan2(v.y, v.x);
	var sign = angle < 0 ? -1 : 1;
	var floor = Math.floor(Math.abs(angle) / (Math.PI / 12)) * (Math.PI / 12);
	angle = sign * (floor + ((Math.abs(angle) - floor < Math.PI / 24) ? 0 : Math.PI / 12));
	return angle;
};
Editor.EditorTool.prototype._calcNewAtomPos = function (pos0, pos1) {
	var v = new Vec2(1, 0).rotate(this._calcAngle(pos0, pos1));
	v.add_(pos0);
	return v;
};


Editor.EditorTool.HoverHelper = function (editorTool) {
	this.editorTool = editorTool;
};
Editor.EditorTool.HoverHelper.prototype.hover = function (ci) {
	if (ci && ci.type == 'Canvas')
		ci = null;
	// TODO add custom highlight style parameter, to be used when fusing atoms, sgroup children highlighting, etc
	if ('ci' in this && (!ci || this.ci.type != ci.type || this.ci.id != ci.id)) {
		this.editorTool.editor.render.highlightObject(this.ci, false);
		delete this.ci;
	}
	if (ci && this.editorTool.editor.render.highlightObject(ci, true)) {
		this.ci = ci;
	}
};

Editor.LassoTool = function (editor, mode, fragment) {
	this.editor = editor;

	this._hoverHelper = new Editor.EditorTool.HoverHelper(this);
	this._lassoHelper = new Editor.LassoTool.LassoHelper(mode || 0, editor, fragment);
	this._sGroupHelper = new Editor.SGroupTool.SGroupHelper(editor);
};
Editor.LassoTool.prototype = new Editor.EditorTool();
Editor.LassoTool.prototype.OnMouseDown = function (event) {
	var render = this.editor.render;
	var ctab = render.ctab, mol = ctab.molecule;
	this._hoverHelper.hover(null); // TODO review hovering for touch devices
	var selectFragment = (this._lassoHelper.fragment || event.ctrlKey);
	var ci = this.editor.render.findItem(
		event,
		selectFragment ?
			['frags', 'sgroups', 'sgroupData', 'rgroups', 'rxnArrows', 'rxnPluses', 'chiralFlags'] :
			['atoms', 'bonds', 'sgroups', 'sgroupData', 'rgroups', 'rxnArrows', 'rxnPluses', 'chiralFlags']
	);
	if (!ci || ci.type == 'Canvas') {
		if (!this._lassoHelper.fragment)
			this._lassoHelper.begin(event);
	} else {
		this._hoverHelper.hover(null);
		if ('onShowLoupe' in this.editor.render)
			this.editor.render.onShowLoupe(true);
		if (!this.editor._selectionHelper.isSelected(ci)) {
			if (ci.map == 'frags') {
				var frag = ctab.frags.get(ci.id);
				this.editor._selectionHelper.setSelection(
				{ 'atoms': frag.fragGetAtoms(render, ci.id), 'bonds': frag.fragGetBonds(render, ci.id) },
					event.shiftKey
				);
			} else if (ci.map == 'sgroups') {
				var sgroup = ctab.sgroups.get(ci.id).item;
				this.editor._selectionHelper.setSelection(
				{ 'atoms': SGroup.getAtoms(mol, sgroup), 'bonds': SGroup.getBonds(mol, sgroup) },
					event.shiftKey
				);
			} else if (ci.map == 'rgroups') {
				var rgroup = ctab.rgroups.get(ci.id);
				this.editor._selectionHelper.setSelection(
				{ 'atoms': rgroup.getAtoms(render), 'bonds': rgroup.getBonds(render) },
					event.shiftKey
				);
			} else {
				this.editor._selectionHelper.setSelection(ci, event.shiftKey);
			}
		}
		this.dragCtx = {
			item: ci,
			xy0: ui.page2obj(event)
		};
		if (ci.map == 'atoms' && !ui.is_touch) {
			var self = this;
			this.dragCtx.timeout = setTimeout(
			function () {
				delete self.dragCtx;
				self.editor._selectionHelper.setSelection(null);
				ui.showLabelEditor(ci.id);
			},
				750
			);
			this.dragCtx.stopTapping = function () {
				if ('timeout' in self.dragCtx) {
					clearTimeout(self.dragCtx.timeout);
					delete self.dragCtx.timeout;
				}
			};
		}
	}
	return true;
};

Editor.LassoTool.prototype.OnMouseMove = function (event) {
	if ('dragCtx' in this) {
		if ('stopTapping' in this.dragCtx) this.dragCtx.stopTapping();
		// moving selected objects
		if (this.dragCtx.action) {
			this.dragCtx.action.perform();
			this.editor.render.update(); // redraw the elements in unshifted position, lest the have different offset
		}
		this.dragCtx.action = Action.fromMultipleMove(
		this.editor.getSelection(true),
		ui.page2obj(event).sub(this.dragCtx.xy0));
		// finding & highlighting object to stick to
		if (['atoms'/*, 'bonds'*/].indexOf(this.dragCtx.item.map) >= 0) {
			// TODO add bond-to-bond fusing
			var ci = this.editor.render.findItem(event, [this.dragCtx.item.map], this.dragCtx.item);
			this._hoverHelper.hover(ci.map == this.dragCtx.item.map ? ci : null);
		}
		this.editor.render.update();
	} else if (this._lassoHelper.running()) {
		this.editor._selectionHelper.setSelection(this._lassoHelper.addPoint(event), event.shiftKey);
	} else {
		this._hoverHelper.hover(
		this.editor.render.findItem(
			event,
			(this._lassoHelper.fragment || event.ctrlKey) ?
				['frags', 'sgroups', 'sgroupData', 'rgroups', 'rxnArrows', 'rxnPluses', 'chiralFlags'] :
				['atoms', 'bonds', 'sgroups', 'sgroupData', 'rgroups', 'rxnArrows', 'rxnPluses', 'chiralFlags']
		)
		);
	}
	return true;
};
Editor.LassoTool.prototype.OnMouseUp = function (event) {
	if ('dragCtx' in this) {
		if ('stopTapping' in this.dragCtx) this.dragCtx.stopTapping();
		if (['atoms'/*, 'bonds'*/].indexOf(this.dragCtx.item.map) >= 0) {
			// TODO add bond-to-bond fusing
			var ci = this.editor.render.findItem(event, [this.dragCtx.item.map], this.dragCtx.item);
			if (ci.map == this.dragCtx.item.map) {
				this._hoverHelper.hover(null);
				this.editor._selectionHelper.setSelection();
				this.dragCtx.action = this.dragCtx.action
						 ? Action.fromAtomMerge(this.dragCtx.item.id, ci.id).mergeWith(this.dragCtx.action)
						 : Action.fromAtomMerge(this.dragCtx.item.id, ci.id);
			}
		}
		ui.addUndoAction(this.dragCtx.action, true);
		this.editor.render.update();
		delete this.dragCtx;
	} else {
		if (this._lassoHelper.running()) { // TODO it catches more events than needed, to be re-factored
			this.editor._selectionHelper.setSelection(this._lassoHelper.end(), event.shiftKey);
		} else if (this._lassoHelper.fragment) {
			this.editor._selectionHelper.setSelection();
		}
	}
	return true;
};
Editor.LassoTool.prototype.OnDblClick = function (event) {
	var ci = this.editor.render.findItem(event);
	if (ci.map == 'atoms') {
		this.editor._selectionHelper.setSelection(ci);
		// TODO [RB] re-factoring needed. we probably need to intoduce "custom" element sets, some of them might be "special" (lists, r-groups), some of them might be "pluggable" (reaxys generics)
		var atom = ui.ctab.atoms.get(ci.id);
		if (atom.label == 'R#') {
			Editor.RGroupAtomTool.prototype.OnMouseUp.call(this, event);
		} else if (atom.label == 'L#') {
			ui.showElemTable({
				selection: atom,
				onOk: function (attrs) {
					if (atom.label != attrs.label || !atom.atomList.equals(attrs.atomList)) {
						ui.addUndoAction(Action.fromAtomsAttrs(ci.id, attrs));
						ui.render.update();
					}
					return true;
				}.bind(this)
			});
		} else if ((element.getElementByLabel(atom.label) || 121) < 120) {
			ui.showAtomProperties(ci.id);
		} else {
			ui.showReaGenericsTable({
				values: [atom.label],
				onOk: function (res) {
					var label = res.values[0];
					if (atom.label != label) {
						ui.addUndoAction(Action.fromAtomsAttrs(ci.id, {label: label}));
						ui.render.update();
					}
					return true;
				}.bind(this)
			});
		}
	} else if (ci.map == 'bonds') {
		this.editor._selectionHelper.setSelection(ci);
		ui.showBondProperties(ci.id);
	} else if (ci.map == 'sgroups') {
		this.editor._selectionHelper.setSelection(ci);
		this._sGroupHelper.showPropertiesDialog(ci.id);
//    } else if (ci.map == 'sgroupData') {
//        this._sGroupHelper.showPropertiesDialog(ci.sgid);
	}
	return true;
};
Editor.LassoTool.prototype.OnCancel = function () {
	if ('dragCtx' in this) {
		if ('stopTapping' in this.dragCtx) this.dragCtx.stopTapping();
		ui.addUndoAction(this.dragCtx.action, true);
		this.editor.render.update();
		delete this.dragCtx;
	} else if (this._lassoHelper.running()) {
		this.editor._selectionHelper.setSelection(this._lassoHelper.end());
	}
	this._hoverHelper.hover(null);
};


Editor.LassoTool.LassoHelper = function (mode, editor, fragment) {
	this.mode = mode;
	this.fragment = fragment;
	this.editor = editor;
};
Editor.LassoTool.LassoHelper.prototype.getSelection = function () {
	if (this.mode == 0) {
		return ui.render.getElementsInPolygon(this.points);
	} else if (this.mode == 1) {
		return ui.render.getElementsInRectangle(this.points[0], this.points[1]);
	} else {
		throw new Error('Selector mode unknown');
	}
};
Editor.LassoTool.LassoHelper.prototype.begin = function (event) {
	this.points = [ ui.page2obj(event) ];
	if (this.mode == 1) {
		this.points.push(this.points[0]);
	}
};
Editor.LassoTool.LassoHelper.prototype.running = function () {
	return 'points' in this;
};
Editor.LassoTool.LassoHelper.prototype.addPoint = function (event) {
	if (!this.running()) return false;
	if (this.mode == 0) {
		this.points.push(ui.page2obj(event));
		this.editor.render.drawSelectionPolygon(this.points);
	} else if (this.mode == 1) {
		this.points = [ this.points[0], ui.page2obj(event) ];
		this.editor.render.drawSelectionRectangle(this.points[0], this.points[1]);
	}
	return this.getSelection();
};
Editor.LassoTool.LassoHelper.prototype.end = function () {
	var ret = this.getSelection();
	if ('points' in this) {
		this.editor.render.drawSelectionPolygon(null);
		delete this.points;
	}
	return ret;
};


Editor.EraserTool = function (editor, mode) {
	this.editor = editor;

	this.maps = ['atoms', 'bonds', 'rxnArrows', 'rxnPluses', 'sgroups', 'sgroupData', 'chiralFlags'];
	this._hoverHelper = new Editor.EditorTool.HoverHelper(this);
	this._lassoHelper = new Editor.LassoTool.LassoHelper(mode || 0, editor);
};
Editor.EraserTool.prototype = new Editor.EditorTool();
Editor.EraserTool.prototype.OnMouseDown = function (event) {
	var ci = this.editor.render.findItem(event, this.maps);
	if (!ci || ci.type == 'Canvas') {
		this._lassoHelper.begin(event);
	}
};
Editor.EraserTool.prototype.OnMouseMove = function (event) {
	if (this._lassoHelper.running()) {
		this.editor._selectionHelper.setSelection(
		this._lassoHelper.addPoint(event)
		);
	} else {
		this._hoverHelper.hover(this.editor.render.findItem(event, this.maps));
	}
};
Editor.EraserTool.prototype.OnMouseUp = function (event) {
	if (this._lassoHelper.running()) { // TODO it catches more events than needed, to be re-factored
		ui.addUndoAction(Action.fromFragmentDeletion(this._lassoHelper.end(event)));
		this.editor.deselectAll();
		ui.render.update();
	} else {
		var ci = this.editor.render.findItem(event, this.maps);
		if (ci && ci.type != 'Canvas') {
			this._hoverHelper.hover(null);
			if (ci.map == 'atoms') {
				ui.addUndoAction(Action.fromAtomDeletion(ci.id));
			} else if (ci.map == 'bonds') {
				ui.addUndoAction(Action.fromBondDeletion(ci.id));
			} else if (ci.map == 'sgroups' || ci.map == 'sgroupData') {
				ui.addUndoAction(Action.fromSgroupDeletion(ci.id));
			} else if (ci.map == 'rxnArrows') {
				ui.addUndoAction(Action.fromArrowDeletion(ci.id));
			} else if (ci.map == 'rxnPluses') {
				ui.addUndoAction(Action.fromPlusDeletion(ci.id));
			} else if (ci.map == 'chiralFlags') {
				ui.addUndoAction(Action.fromChiralFlagDeletion());
			} else {
				// TODO re-factoring needed - should be "map-independent"
				console.log('EraserTool: unable to delete the object ' + ci.map + '[' + ci.id + ']');
				return;
			}
			this.editor.deselectAll();
			ui.render.update();
		}
	}
};


Editor.AtomTool = function (editor, atomProps) {
	this.editor = editor;
	this.atomProps = atomProps;
	this.bondProps = { type: 1, stereo: Bond.PATTERN.STEREO.NONE };

	this._hoverHelper = new Editor.EditorTool.HoverHelper(this);
};
Editor.AtomTool.prototype = new Editor.EditorTool();
Editor.AtomTool.prototype.OnMouseDown = function (event) {
	this._hoverHelper.hover(null);
	var ci = this.editor.render.findItem(event, ['atoms']);
	if (!ci || ci.type == 'Canvas') {
		this.dragCtx = {
			xy0: ui.page2obj(event)
		};
	} else if (ci.map == 'atoms') {
		this.dragCtx = {
			item: ci,
			xy0: ui.page2obj(event)
		};
	}
};
Editor.AtomTool.prototype.OnMouseMove = function (event) {
	var _E_ = this.editor, _R_ = _E_.render;
	if ('dragCtx' in this && 'item' in this.dragCtx) {
		var _DC_ = this.dragCtx;
		var newAtomPos = this._calcNewAtomPos(
		_R_.atomGetPos(_DC_.item.id), ui.page2obj(event)
		);
		if ('action' in _DC_) {
			_DC_.action.perform();
		}
		// TODO [RB] kludge fix for KETCHER-560. need to review
		//BEGIN
		/*
         var action_ret = Action.fromBondAddition(
         this.bondProps, _DC_.item.id, this.atomProps, newAtomPos, newAtomPos
         );
         */
		var action_ret = Action.fromBondAddition(
			this.bondProps, _DC_.item.id, Object.clone(this.atomProps), newAtomPos, newAtomPos
		);
		//END
		_DC_.action = action_ret[0];
		_DC_.aid2 = action_ret[2];
		_R_.update();
	} else {
		this._hoverHelper.hover(_R_.findItem(event, ['atoms']));
	}
};
Editor.AtomTool.prototype.OnMouseUp = function (event) {
	if ('dragCtx' in this) {
		var _DC_ = this.dragCtx;
		ui.addUndoAction(
				'action' in _DC_
				 ? _DC_.action
				 : 'item' in _DC_
					 ? Action.fromAtomsAttrs(_DC_.item.id, this.atomProps, true)
					 : Action.fromAtomAddition(ui.page2obj(event), this.atomProps),
			true
		);
		this.editor.render.update();
		delete this.dragCtx;
	}
};


Editor.BondTool = function (editor, bondProps) {
	this.editor = editor;
	this.atomProps = { label: 'C' };
	this.bondProps = bondProps;
	this.plainBondTypes = [
			Bond.PATTERN.TYPE.SINGLE,
			Bond.PATTERN.TYPE.DOUBLE,
			Bond.PATTERN.TYPE.TRIPLE];

	this._hoverHelper = new Editor.EditorTool.HoverHelper(this);
};
Editor.BondTool.prototype = new Editor.EditorTool();

Editor.BondTool.prototype.OnMouseDown = function (event) {
	this._hoverHelper.hover(null);
	this.dragCtx = {
		xy0: ui.page2obj(event),
		item: this.editor.render.findItem(event, ['atoms', 'bonds'])
	};
	if (!this.dragCtx.item || this.dragCtx.item.type == 'Canvas') delete this.dragCtx.item;
	return true;
};

Editor.BondTool.prototype.OnMouseMove = function (event) {
	var _E_ = this.editor, _R_ = _E_.render;
	if ('dragCtx' in this) {
		var _DC_ = this.dragCtx;
		if (!('item' in _DC_) || _DC_.item.map == 'atoms') {
			if ('action' in _DC_) _DC_.action.perform();
			var i1, i2, p1, p2;
			if (('item' in _DC_ && _DC_.item.map == 'atoms')) {
				i1 = _DC_.item.id;
				i2 = _R_.findItem(event, ['atoms'], _DC_.item);
			} else {
				i1 = this.atomProps;
				p1 = _DC_.xy0;
				i2 = _R_.findItem(event, ['atoms']);
			}
			var dist = Number.MAX_VALUE;
			if (i2 && i2.map == 'atoms') {
				i2 = i2.id;
			} else {
				i2 = this.atomProps;
				var xy1 = ui.page2obj(event);
				dist = Vec2.dist(_DC_.xy0, xy1);
				if (p1) {
					p2 = this._calcNewAtomPos(p1, xy1);
				} else {
					p1 = this._calcNewAtomPos(_R_.atomGetPos(i1), xy1);
				}
			}
			// don't rotate the bond if the distance between the start and end point is too small
			if (dist > 0.3) {
				_DC_.action = Action.fromBondAddition(this.bondProps, i1, i2, p1, p2)[0];
			} else {
				delete _DC_.action;
			}
			_R_.update();
			return true;
		}
	}
	this._hoverHelper.hover(_R_.findItem(event, ['atoms', 'bonds']));
	return true;
};

Editor.BondTool.prototype.OnMouseUp = function (event) {
	if ('dragCtx' in this) {
		var _DC_ = this.dragCtx;
		if ('action' in _DC_) {
			ui.addUndoAction(_DC_.action);
		} else if (!('item' in _DC_)) {
			var xy = ui.page2obj(event);
			var v = new Vec2(1.0 / 2, 0).rotate(
				this.bondProps.type == Bond.PATTERN.TYPE.SINGLE ? -Math.PI / 6 : 0
			);
			var bondAddition = Action.fromBondAddition(
				this.bondProps,
			{ label: 'C' },
			{ label: 'C' },
			{ x: xy.x - v.x, y: xy.y - v.y},
			{ x: xy.x + v.x, y: xy.y + v.y}
			);
			ui.addUndoAction(bondAddition[0]);
		} else if (_DC_.item.map == 'atoms') {
			ui.addUndoAction(Action.fromBondAddition(this.bondProps, _DC_.item.id)[0]);
		} else if (_DC_.item.map == 'bonds') {
			var bondProps = Object.clone(this.bondProps);
			var bond = ui.ctab.bonds.get(_DC_.item.id);

			if (
			bondProps.stereo != Bond.PATTERN.STEREO.NONE &&
			bond.type == Bond.PATTERN.TYPE.SINGLE &&
			bondProps.type == Bond.PATTERN.TYPE.SINGLE &&
			bond.stereo == bondProps.stereo
			) {
				ui.addUndoAction(Action.fromBondFlipping(_DC_.item.id));
			} else {
				if (
				bondProps.type === Bond.PATTERN.TYPE.SINGLE &&
				bond.stereo === Bond.PATTERN.STEREO.NONE &&
				bondProps.stereo === Bond.PATTERN.STEREO.NONE
				) {
					var loop = this.plainBondTypes.indexOf(bondProps.type) >= 0 ? this.plainBondTypes : null;
					if (loop) {
						bondProps.type = loop[(loop.indexOf(bond.type) + 1) % loop.length];
					}
				}
				ui.addUndoAction(
				Action.fromBondAttrs(_DC_.item.id, bondProps, bondFlipRequired(bond, bondProps)),
					true
				);
			}
		}
		this.editor.render.update();
		delete this.dragCtx;
	}
	return true;
};

Editor.ChainTool = function (editor) {
	this.editor = editor;

	this._hoverHelper = new Editor.EditorTool.HoverHelper(this);
};
Editor.ChainTool.prototype = new Editor.EditorTool();
Editor.ChainTool.prototype.OnMouseDown = function (event) {
	this._hoverHelper.hover(null);
	this.dragCtx = {
		xy0: ui.page2obj(event),
		item: this.editor.render.findItem(event, ['atoms'])
	};
	if (!this.dragCtx.item || this.dragCtx.item.type == 'Canvas') delete this.dragCtx.item;
	return true;
};
Editor.ChainTool.prototype.OnMouseMove = function (event) {
	var _E_ = this.editor, _R_ = _E_.render;
	if ('dragCtx' in this) {
		var _DC_ = this.dragCtx;
		if ('action' in _DC_) _DC_.action.perform();
		var pos0 = 'item' in _DC_ ? _R_.atomGetPos(_DC_.item.id) : _DC_.xy0;
		var pos1 = ui.page2obj(event);
		_DC_.action = Action.fromChain(
			pos0,
		this._calcAngle(pos0, pos1),
		Math.ceil(Vec2.diff(pos1, pos0).length()),
				'item' in _DC_ ? _DC_.item.id : null
		);
		_R_.update();
		return true;
	}
	this._hoverHelper.hover(_R_.findItem(event, ['atoms']));
	return true;
};
Editor.ChainTool.prototype.OnMouseUp = function () {
	if ('dragCtx' in this) {
		if ('action' in this.dragCtx) {
			ui.addUndoAction(this.dragCtx.action);
		}
		delete this.dragCtx;
	}
	return true;
};
Editor.ChainTool.prototype.OnCancel = function () {
	this.OnMouseUp();
};


Editor.TemplateTool = function (editor, template) {
	this.editor = editor;
	this.template = template;

	// load template molfile in advance
	if (!this.template.molecule) {
		var frag = molfile.parse(this.template.molfile);
		frag.rescale();

		var xy0 = new Vec2();

		frag.atoms.each(function (aid, atom) {
			xy0.add_(atom.pp);
		});

		this.template.molecule = frag; // preloaded struct
		this.template.xy0 = xy0.scaled(1 / frag.atoms.count()); // template center
		this.template.angle0 = this._calcAngle(frag.atoms.get(this.template.aid).pp, this.template.xy0); // center tilt

		var bond = frag.bonds.get(this.template.bid);
		this.template.sign = this._getSign(frag, bond, this.template.xy0); // template location sign against attachment bond
	}

	this._hoverHelper = new Editor.EditorTool.HoverHelper(this);
};
Editor.TemplateTool.prototype = new Editor.EditorTool();
Editor.TemplateTool.prototype._getSign = function (molecule, bond, v) {
	var begin = molecule.atoms.get(bond.begin).pp;
	var end = molecule.atoms.get(bond.end).pp;

	var sign = Vec2.cross(Vec2.diff(begin, end), Vec2.diff(v, end));

	if (sign > 0) return 1;
	if (sign < 0) return -1;
	return 0;
};
Editor.TemplateTool.prototype.OnMouseDown = function (event) {
	var _E_ = this.editor, _R_ = _E_.render;
	this._hoverHelper.hover(null);
	this.dragCtx = {
		xy0: ui.page2obj(event),
		item: _R_.findItem(event, ['atoms', 'bonds'])
	};
	var _DC_ = this.dragCtx;
	var ci = _DC_.item;
	if (!ci || ci.type == 'Canvas') {
		delete _DC_.item;
	} else if (ci.map == 'bonds') {
		// calculate fragment center
		var molecule = _R_.ctab.molecule;
		var xy0 = new Vec2();
		var bond = molecule.bonds.get(ci.id);
		var frid = _R_.atomGetAttr(bond.begin, 'fragment');
		var fr_ids = molecule.getFragmentIds(frid);
		var count = 0;

		var loop = molecule.halfBonds.get(bond.hb1).loop;

		if (loop < 0) {
			loop = molecule.halfBonds.get(bond.hb2).loop;
		}

		if (loop >= 0) {
			var loop_hbs = molecule.loops.get(loop).hbs;
			loop_hbs.each(function (hb) {
				xy0.add_(molecule.atoms.get(molecule.halfBonds.get(hb).begin).pp);
				count++;
			});
		} else {
			Set.each(fr_ids, function (id) {
				xy0.add_(molecule.atoms.get(id).pp);
				count++;
			});
		}

		_DC_.v0 = xy0.scaled(1 / count);

		var sign = this._getSign(molecule, bond, _DC_.v0);

		// calculate default template flip
		_DC_.sign1 = sign || 1;
		_DC_.sign2 = this.template.sign;
	}
	return true;
};
Editor.TemplateTool.prototype.OnMouseMove = function (event) {
	var _E_ = this.editor, _R_ = _E_.render;
	if ('dragCtx' in this) {
		var _DC_ = this.dragCtx;
		var ci = _DC_.item;
		var pos0;
		var pos1 = ui.page2obj(event);
		var angle, extra_bond;
		var self = this;

		_DC_.mouse_moved = true;

		// calc initial pos and is extra bond needed
		if (!ci || ci.type == 'Canvas') {
			pos0 = _DC_.xy0;
		} else if (ci.map == 'atoms') {
			pos0 = _R_.atomGetPos(ci.id);
			extra_bond = Vec2.dist(pos0, pos1) > 1;
		} else if (ci.map == 'bonds') {
			var molecule = _R_.ctab.molecule;
			var bond = molecule.bonds.get(ci.id);
			var sign = this._getSign(molecule, bond, pos1);

			if (_DC_.sign1 * this.template.sign > 0) {
				sign = -sign;
			}

			if (sign != _DC_.sign2 || !_DC_.action) {
				// undo previous action
				if ('action' in _DC_) _DC_.action.perform();
				_DC_.sign2 = sign;
				_DC_.action = Action.fromTemplateOnBond(ci.id, this.template, this._calcAngle, _DC_.sign1 * _DC_.sign2 > 0);
				_R_.update();
			}

			return true;
		}

		angle = this._calcAngle(pos0, pos1);
		var degrees = Math.round(180 / Math.PI * angle);
		// check if anything changed since last time
		if ('angle' in _DC_ && _DC_.angle == degrees) {
			if ('extra_bond' in _DC_) {
				if (_DC_.extra_bond == extra_bond)
					return true;
			} else {
				return true;
			}
		}
		// undo previous action
		if ('action' in _DC_) _DC_.action.perform();
		// create new action
		_DC_.angle = degrees;
		if (!ci || ci.type == 'Canvas') {
			_DC_.action = Action.fromTemplateOnCanvas(
				pos0,
				angle,
				this.template
			);
		} else if (ci.map == 'atoms') {
			_DC_.action = Action.fromTemplateOnAtom(
				ci.id,
				angle,
				extra_bond,
				this.template,
				this._calcAngle
			);
			_DC_.extra_bond = extra_bond;
		}
		_R_.update();
		return true;
	}
	this._hoverHelper.hover(_R_.findItem(event, ['atoms', 'bonds']));
	return true;
};
Editor.TemplateTool.prototype.OnMouseUp = function (event) {
	var _E_ = this.editor, _R_ = _E_.render;
	if ('dragCtx' in this) {
		var _DC_ = this.dragCtx;
		var ci = _DC_.item;

		if (!_DC_.action) {
			if (!ci || ci.type == 'Canvas') {
				_DC_.action = Action.fromTemplateOnCanvas(_DC_.xy0, 0, this.template);
			} else if (ci.map == 'atoms') {
				var degree = _R_.atomGetDegree(ci.id);

				if (degree > 1) { // common case
					_DC_.action = Action.fromTemplateOnAtom(
						ci.id,
						null,
						true,
						this.template,
						this._calcAngle
					);
				} else if (degree == 1) { // on chain end
					var molecule = _R_.ctab.molecule;
					var nei_id = molecule.halfBonds.get(molecule.atoms.get(ci.id).neighbors[0]).end;
					var atom = molecule.atoms.get(ci.id);
					var nei = molecule.atoms.get(nei_id);

					_DC_.action = Action.fromTemplateOnAtom(
						ci.id,
					this._calcAngle(nei.pp, atom.pp),
						false,
						this.template,
						this._calcAngle
					);
				} else { // on single atom
					_DC_.action = Action.fromTemplateOnAtom(
						ci.id,
						0,
						false,
						this.template,
						this._calcAngle
					);
				}
			} else if (ci.map == 'bonds') {
				_DC_.action = Action.fromTemplateOnBond(ci.id, this.template, this._calcAngle, _DC_.sign1 * _DC_.sign2 > 0);
			}

			_R_.update();
		}

		if ('action' in this.dragCtx) {
			if (!this.dragCtx.action.isDummy())
				ui.addUndoAction(this.dragCtx.action);
		}
		delete this.dragCtx;
	}
};
Editor.TemplateTool.prototype.OnCancel = function () {
	this.OnMouseUp();
};

Editor.ChargeTool = function (editor, charge) { // TODO [RB] should be "pluggable"
	this.editor = editor;
	this.charge = charge;

	this._hoverHelper = new Editor.EditorTool.HoverHelper(this);
};
Editor.ChargeTool.prototype = new Editor.EditorTool();
Editor.ChargeTool.prototype.OnMouseMove = function (event) {
	var ci = this.editor.render.findItem(event, ['atoms']);
	if (ci && ci.map == 'atoms' && element.getElementByLabel(ui.ctab.atoms.get(ci.id).label) != null) {
		this._hoverHelper.hover(ci);
	} else {
		this._hoverHelper.hover(null);
	}
	return true;
};
Editor.ChargeTool.prototype.OnMouseUp = function (event) {
	var _E_ = this.editor, _R_ = _E_.render;
	var ci = _R_.findItem(event, ['atoms']);
	if (ci && ci.map == 'atoms' && element.getElementByLabel(ui.ctab.atoms.get(ci.id).label) != null) {
		this._hoverHelper.hover(null);
		ui.addUndoAction(
		Action.fromAtomsAttrs(ci.id, { charge: _R_.ctab.molecule.atoms.get(ci.id).charge + this.charge })
		);
		_R_.update();
	}
	return true;
};


Editor.RGroupAtomTool = function (editor) {
	this.editor = editor;

	this._hoverHelper = new Editor.EditorTool.HoverHelper(this);
};
Editor.RGroupAtomTool.prototype = new Editor.EditorTool();
Editor.RGroupAtomTool.prototype.OnMouseMove = function (event) {
	this._hoverHelper.hover(this.editor.render.findItem(event, ['atoms']));
};
Editor.RGroupAtomTool.prototype.OnMouseUp = function (event) {
	function sel2Values(rg) {
		var res = [];
		for (var rgi = 0; rgi < 32; rgi++)
			if (rg & (1 << rgi)) {
				var val = 'R' + (rgi + 1);
				res.push(val); // push the string
			}
		return res;
	}
	function values2Sel(vals) {
		var res = 0;
		vals.values.forEach(function (val) {
			var rgi = val.substr(1) - 1;
			res |= 1 << rgi;
		});
		return res;
	}
	var ci = this.editor.render.findItem(event, ['atoms']);
	if (!ci || ci.type == 'Canvas') {
		this._hoverHelper.hover(null);
		ui.showRGroupTable({
			mode: 'multiple',
			onOk: function (rgNew) {
				rgNew = values2Sel(rgNew);
				if (rgNew) {
					ui.addUndoAction(
					Action.fromAtomAddition(
					ui.page2obj(this.OnMouseMove0.lastEvent),
					{ label: 'R#', rglabel: rgNew}
					),
						true
					);
					ui.render.update();
				}
			}.bind(this)
		});
		return true;
	} else if (ci && ci.map == 'atoms') {
		this._hoverHelper.hover(null);
		var atom = this.editor.render.ctab.molecule.atoms.get(ci.id);
		var lbOld = atom.label;
		var rgOld = atom.rglabel;
		ui.showRGroupTable({
			mode: 'multiple',
			values: sel2Values(rgOld),
			onOk: function (rgNew) {
				rgNew = values2Sel(rgNew);
				if (rgOld != rgNew || lbOld != 'R#') {
					var newProps = Object.clone(Atom.attrlist); // TODO review: using Atom.attrlist as a source of default property values
					if (rgNew) {
						newProps.label = 'R#';
						newProps.rglabel = rgNew;
						newProps.aam = atom.aam;
					} else {
						newProps.label = 'C';
						newProps.aam = atom.aam;
					}
					ui.addUndoAction(Action.fromAtomsAttrs(ci.id, newProps), true);
					ui.render.update();
				}
			}.bind(this)
		});
		return true;
	}
};


Editor.RGroupFragmentTool = function (editor) {
	this.editor = editor;

	this._hoverHelper = new Editor.EditorTool.HoverHelper(this);
};

Editor.RGroupFragmentTool.prototype = new Editor.EditorTool();
Editor.RGroupFragmentTool.prototype.OnMouseMove = function (event) {
	this._hoverHelper.hover(this.editor.render.findItem(event, ['frags', 'rgroups']));
};

Editor.RGroupFragmentTool.prototype.OnMouseUp = function (event) {
	var ci = this.editor.render.findItem(event, ['frags', 'rgroups']);
	if (ci && ci.map == 'frags') {
		this._hoverHelper.hover(null);
		var rgOld = Struct.RGroup.findRGroupByFragment(this.editor.render.ctab.molecule.rgroups, ci.id);
		ui.showRGroupTable({
			values: rgOld && ['R' + rgOld],
			onOk: function (rgNew) {
				console.assert(rgNew.values.length <= 1, 'Too much elements');
				rgNew = rgNew.values.length ? rgNew.values[0].substr(1) - 0 : 0;
				if (rgOld != rgNew) {
					ui.addUndoAction(
					Action.fromRGroupFragment(rgNew, ci.id),
						true
					);
					ui.render.update();
				}
			}.bind(this)
		});
		return true;
	}
	else if (ci && ci.map == 'rgroups') {
		this._hoverHelper.hover(null);
		var rg = this.editor.render.ctab.molecule.rgroups.get(ci.id);
		var rgmask = 0; this.editor.render.ctab.molecule.rgroups.each(function (rgid) { rgmask |= (1 << (rgid - 1)); });
		var oldLogic = {
			occurrence: rg.range,
			resth: rg.resth,
			ifthen: rg.ifthen
		};
		ui.showRLogicTable({
			rgid: ci.id,
			rlogic: oldLogic,
			rgmask: rgmask,
			onOk: function (newLogic) {
				var props = {};
				if (oldLogic.occurrence != newLogic.occurrence) {
					var isValid = newLogic.occurrence.split(',').all(function (s){
						return s.match(/^[>,<,=]?[0-9]+$/g) || s.match(/^[0-9]+\-[0-9]+$/g);
					});
					if (!isValid) {
						alert('Bad occurrence value');
						return false;
					}
					props.range = newLogic.occurrence;
				}
				if (oldLogic.resth != newLogic.resth) props.resth = newLogic.resth;
				if (oldLogic.ifthen != newLogic.ifthen) props.ifthen = newLogic.ifthen;
				if ('range' in props || 'resth' in props || 'ifthen' in props) {
					ui.addUndoAction(Action.fromRGroupAttrs(ci.id, props));
					this.editor.render.update();
				}
				return true;
			}.bind(this)
		});
		return true;
	}
};

Editor.APointTool = function (editor) {
	this.editor = editor;

	this._hoverHelper = new Editor.EditorTool.HoverHelper(this);
};
Editor.APointTool.prototype = new Editor.EditorTool();
Editor.APointTool.prototype.OnMouseMove = function (event) {
	this._hoverHelper.hover(this.editor.render.findItem(event, ['atoms']));
};
Editor.APointTool.prototype.OnMouseUp = function (event) {
	var ci = this.editor.render.findItem(event, ['atoms']);
	if (ci && ci.map == 'atoms') {
		this._hoverHelper.hover(null);
		var apOld = this.editor.render.ctab.molecule.atoms.get(ci.id).attpnt;
		ui.showAtomAttachmentPoints({
			selection: apOld,
			onOk: function (apNew) {
				if (apOld != apNew) {
					ui.addUndoAction(Action.fromAtomsAttrs(ci.id, { attpnt: apNew }), true);
					ui.render.update();
				}
			}.bind(this)
		});
		return true;
	}
};


Editor.ReactionArrowTool = function (editor) {
	this.editor = editor;

	this._hoverHelper = new Editor.EditorTool.HoverHelper(this);
};
Editor.ReactionArrowTool.prototype = new Editor.EditorTool();
Editor.ReactionArrowTool.prototype.OnMouseDown = function (event) {
	var ci = this.editor.render.findItem(event, ['rxnArrows']);
	if (ci && ci.map == 'rxnArrows') {
		this._hoverHelper.hover(null);
		this.editor._selectionHelper.setSelection(ci);
		this.dragCtx = {
			xy0: ui.page2obj(event)
		};
	}
};
Editor.ReactionArrowTool.prototype.OnMouseMove = function (event) {
	if ('dragCtx' in this) {
		if (this.dragCtx.action)
			this.dragCtx.action.perform();
		this.dragCtx.action = Action.fromMultipleMove(
			this.editor._selectionHelper.selection,
		ui.page2obj(event).sub(this.dragCtx.xy0)
		);
		ui.render.update();
	} else {
		this._hoverHelper.hover(this.editor.render.findItem(event, ['rxnArrows']));
	}
};
Editor.ReactionArrowTool.prototype.OnMouseUp = function (event) {
	if ('dragCtx' in this) {
		ui.addUndoAction(this.dragCtx.action, false); // TODO investigate, subsequent undo/redo fails
		this.editor.render.update();
		delete this.dragCtx;
	} else if (this.editor.render.ctab.molecule.rxnArrows.count() < 1) {
		ui.addUndoAction(Action.fromArrowAddition(ui.page2obj(event)));
		this.editor.render.update();
	}
};


Editor.ReactionPlusTool = function (editor) {
	this.editor = editor;

	this._hoverHelper = new Editor.EditorTool.HoverHelper(this);
};
Editor.ReactionPlusTool.prototype = new Editor.EditorTool();
Editor.ReactionPlusTool.prototype.OnMouseDown = function (event) {
	var ci = this.editor.render.findItem(event, ['rxnPluses']);
	if (ci && ci.map == 'rxnPluses') {
		this._hoverHelper.hover(null);
		this.editor._selectionHelper.setSelection(ci);
		this.dragCtx = {
			xy0: ui.page2obj(event)
		};
	}
};
Editor.ReactionPlusTool.prototype.OnMouseMove = function (event) {
	if ('dragCtx' in this) {
		if (this.dragCtx.action)
			this.dragCtx.action.perform();
		this.dragCtx.action = Action.fromMultipleMove(
			this.editor._selectionHelper.selection,
		ui.page2obj(event).sub(this.dragCtx.xy0)
		);
		ui.render.update();
	} else {
		this._hoverHelper.hover(this.editor.render.findItem(event, ['rxnPluses']));
	}
};
Editor.ReactionPlusTool.prototype.OnMouseUp = function (event) {
	if ('dragCtx' in this) {
		ui.addUndoAction(this.dragCtx.action, false); // TODO investigate, subsequent undo/redo fails
		this.editor.render.update();
		delete this.dragCtx;
	} else {
		ui.addUndoAction(Action.fromPlusAddition(ui.page2obj(event)));
		this.editor.render.update();
	}
};


Editor.ReactionMapTool = function (editor) {
	this.editor = editor;

	this._hoverHelper = new Editor.EditorTool.HoverHelper(this);

	this.editor._selectionHelper.setSelection(null);

	this.rcs = this.editor.render.ctab.molecule.getComponents();
};
Editor.ReactionMapTool.prototype = new Editor.EditorTool();
Editor.ReactionMapTool.prototype.OnMouseDown = function (event) {
	var ci = this.editor.render.findItem(event, ['atoms']);
	if (ci && ci.map == 'atoms') {
		this._hoverHelper.hover(null);
		this.dragCtx = {
			item: ci,
			xy0: ui.page2obj(event)
		}
	}
};
Editor.ReactionMapTool.prototype.OnMouseMove = function (event) {
	var rnd = this.editor.render;
	if ('dragCtx' in this) {
		var ci = rnd.findItem(event, ['atoms'], this.dragCtx.item);
		if (ci && ci.map == 'atoms' && this._isValidMap(this.dragCtx.item.id, ci.id)) {
			this._hoverHelper.hover(ci);
			rnd.drawSelectionLine(rnd.atomGetPos(this.dragCtx.item.id), rnd.atomGetPos(ci.id));
		} else {
			this._hoverHelper.hover(null);
			rnd.drawSelectionLine(rnd.atomGetPos(this.dragCtx.item.id), ui.page2obj(event));
		}
	} else {
		this._hoverHelper.hover(rnd.findItem(event, ['atoms']));
	}
};
Editor.ReactionMapTool.prototype.OnMouseUp = function (event) {
	if ('dragCtx' in this) {
		var rnd = this.editor.render;
		var ci = rnd.findItem(event, ['atoms'], this.dragCtx.item);
		if (ci && ci.map == 'atoms' && this._isValidMap(this.dragCtx.item.id, ci.id)) {
			var action = new Action();
			var atoms = rnd.ctab.molecule.atoms;
			var atom1 = atoms.get(this.dragCtx.item.id), atom2 = atoms.get(ci.id);
			var aam1 = atom1.aam, aam2 = atom2.aam;
			if (!aam1 || aam1 != aam2) {
				if (aam1 && aam1 != aam2 || !aam1 && aam2) {
					atoms.each(
					function (aid, atom) {
						if (aid != this.dragCtx.item.id && (aam1 && atom.aam == aam1 || aam2 && atom.aam == aam2)) {
							action.mergeWith(Action.fromAtomsAttrs(aid, { aam: 0 }));
						}
					},
						this
					);
				}
				if (aam1) {
					action.mergeWith(Action.fromAtomsAttrs(ci.id, { aam: aam1 }));
				} else {
					var aam = 0; atoms.each(function (aid, atom) { aam = Math.max(aam, atom.aam || 0); });
					action.mergeWith(Action.fromAtomsAttrs(this.dragCtx.item.id, { aam: aam + 1 }));
					action.mergeWith(Action.fromAtomsAttrs(ci.id, { aam: aam + 1 }));
				}
				ui.addUndoAction(action, true);
				rnd.update();
			}
		}
		rnd.drawSelectionLine(null);
		delete this.dragCtx;
	}
	this._hoverHelper.hover(null);
};

Editor.ReactionMapTool.prototype._isValidMap = function (aid1, aid2) {
	var t1, t2;
	for (var ri = 0; (!t1 || !t2) && ri < this.rcs.reactants.length; ri++) {
		var ro = Set.list(this.rcs.reactants[ri]);
		if (!t1 && ro.indexOf(aid1) >= 0) t1 = 'r';
		if (!t2 && ro.indexOf(aid2) >= 0) t2 = 'r';
	}
	for (var pi = 0; (!t1 || !t2) && pi < this.rcs.products.length; pi++) {
		var po = Set.list(this.rcs.products[pi]);
		if (!t1 && po.indexOf(aid1) >= 0) t1 = 'p';
		if (!t2 && po.indexOf(aid2) >= 0) t2 = 'p';
	}
	return t1 && t2 && t1 != t2;
};


Editor.ReactionUnmapTool = function (editor) {
	this.editor = editor;

	this._hoverHelper = new Editor.EditorTool.HoverHelper(this);

	this.editor._selectionHelper.setSelection(null);
};
Editor.ReactionUnmapTool.prototype = new Editor.EditorTool();
Editor.ReactionUnmapTool.prototype.OnMouseMove = function (event) {
	var ci = this.editor.render.findItem(event, ['atoms']);
	if (ci && ci.map == 'atoms') {
		this._hoverHelper.hover(this.editor.render.ctab.molecule.atoms.get(ci.id).aam ? ci : null);
	} else {
		this._hoverHelper.hover(null);
	}
};
Editor.ReactionUnmapTool.prototype.OnMouseUp = function (event) {
	var ci = this.editor.render.findItem(event, ['atoms']);
	var atoms = this.editor.render.ctab.molecule.atoms;
	if (ci && ci.map == 'atoms' && atoms.get(ci.id).aam) {
		var action = new Action();
		var aam = atoms.get(ci.id).aam;
		atoms.each(
		function (aid, atom) {
			if (atom.aam == aam) {
				action.mergeWith(Action.fromAtomsAttrs(aid, { aam: 0 }));
			}
		},
			this
		);
		ui.addUndoAction(action, true);
		this.editor.render.update();
	}
	this._hoverHelper.hover(null);
};

Editor.SGroupTool = function (editor) {
	this.editor = editor;

	this.maps = ['atoms', 'bonds', 'sgroups', 'sgroupData'];
	this._hoverHelper = new Editor.EditorTool.HoverHelper(this);
	this._lassoHelper = new Editor.LassoTool.LassoHelper(1, editor);
	this._sGroupHelper = new Editor.SGroupTool.SGroupHelper(editor);

	var selection = this.editor.getSelection();
	if (selection.atoms && selection.atoms.length > 0) {
		// if the selection contains atoms, create an s-group out of those
		this._sGroupHelper.showPropertiesDialog(null, selection);
	} else {
		// otherwise, clear selection
		this.editor.deselectAll();
	}
};
Editor.SGroupTool.prototype = new Editor.EditorTool();
Editor.SGroupTool.prototype.OnMouseDown = function (event) {
	var ci = this.editor.render.findItem(event, this.maps);
	if (!ci || ci.type == 'Canvas') {
		this._lassoHelper.begin(event);
	}
};
Editor.SGroupTool.prototype.OnMouseMove = function (event) {
	if (this._lassoHelper.running()) {
		this.editor._selectionHelper.setSelection(
		this._lassoHelper.addPoint(event)
		);
	} else {
		this._hoverHelper.hover(this.editor.render.findItem(event, this.maps));
	}
};

Editor.SGroupTool.SGroupHelper = function (editor) {
	this.editor = editor;
	this.selection = null;
};

Editor.SGroupTool.SGroupHelper.prototype.showPropertiesDialog = function (id, selection) {
	this.selection = selection;

	var render = this.editor.render;
	// check s-group overlappings
	if (id == null)
	{
		var verified = {};
		var atoms_hash = {};

		selection.atoms.each(function (id)
		{
			atoms_hash[id] = true;
		}, this);

		if (!Object.isUndefined(selection.atoms.detect(function (id)
		{
			var sgroups = render.atomGetSGroups(id);

			return !Object.isUndefined(sgroups.detect(function (sid)
			{
				if (sid in verified)
					return false;

				var sg_atoms = render.sGroupGetAtoms(sid);

				if (sg_atoms.length < selection.atoms.length)
				{
					if (!Object.isUndefined(sg_atoms.detect(function (aid)
					{
						return !(aid in atoms_hash);
					}, this)))
					{
						return true;
					}
				} else if (!Object.isUndefined(selection.atoms.detect(function (aid)
				{
					return (sg_atoms.indexOf(aid) == -1);
				}, this)))
				{
					return true;
				}

				return false;
			}, this));
		}, this)))
		{
			alert('Partial S-group overlapping is not allowed.');
			return;
		}
	}

	ui.showSGroupProperties({
		type: id !== null ? ui.render.sGroupGetType(id) : null,
		attrs: id !== null ? ui.render.sGroupGetAttrs(id) : {},
		onCancel: function () {
			this.editor.deselectAll();
		}.bind(this),
		onOk: function (params) {
			if (id == null) {
				id = ui.render.ctab.molecule.sgroups.newId();
				ui.addUndoAction(Action.fromSgroupAddition(params.type, this.selection.atoms,
				                                           params.attrs, id), true);
			} else {
				ui.addUndoAction(Action.fromSgroupType(id, params.type)
				                 .mergeWith(Action.fromSgroupAttrs(id, params.attrs)), true);
			}
			this.editor.deselectAll();
			this.editor.render.update();

		}.bind(this)
	});
};

Editor.SGroupTool.prototype.OnMouseUp = function (event) {
	var id = null; // id of an existing group, if we're editing one
	var selection = null; // atoms to include in a newly created group
	if (this._lassoHelper.running()) { // TODO it catches more events than needed, to be re-factored
		selection = this._lassoHelper.end(event);
	} else {
		var ci = this.editor.render.findItem(event, this.maps);
		if (!ci || ci.type == 'Canvas')
			return;
		this._hoverHelper.hover(null);

		if (ci.map == 'atoms') {
			// if we click the SGroup tool on a single atom or bond, make a group out of those
			selection = {'atoms': [ci.id]};
		} else if (ci.map == 'bonds') {
			var bond = this.editor.render.ctab.bonds.get(ci.id);
			selection = {'atoms': [bond.b.begin, bond.b.end]};
		} else if (ci.map == 'sgroups') {
			id = ci.id;
		} else {
			return;
		}
	}
	// TODO: handle click on an existing group?
	if (id != null || (selection && selection.atoms && selection.atoms.length > 0))
		this._sGroupHelper.showPropertiesDialog(id, selection);
};

Editor.PasteTool = function (editor, struct) {
	this.editor = editor;
	this.struct = struct;
	this.action = Action.fromPaste(
		this.struct, 'lastEvent' in this.OnMouseMove0 ?
			ui.page2obj(this.OnMouseMove0.lastEvent) : undefined);
	this.editor.render.update();
};
Editor.PasteTool.prototype = new Editor.EditorTool();
Editor.PasteTool.prototype.OnMouseMove = function (event) {
	if ('action' in this) {
		this.action.perform(this.editor);
	}
	this.action = Action.fromPaste(this.struct, ui.page2obj(event));
	this.editor.render.update();
};
Editor.PasteTool.prototype.OnMouseUp = function () {
	ui.addUndoAction(this.action);
	delete this.action;
	ui.selectAction(null);
};
Editor.PasteTool.prototype.OnCancel = function () {
	if ('action' in this) {
		this.action.perform(this.editor);
		delete this.action;
	}
};

Editor.RotateTool = function (editor) {
	this.editor = editor;
	this._lassoHelper = new Editor.LassoTool.LassoHelper(1, editor);

	var selection = this.editor._selectionHelper.selection;
	if (!selection.atoms || !selection.atoms.length) {
		// otherwise, clear selection
		this.editor._selectionHelper.setSelection(null);
	}
};
Editor.RotateTool.prototype = new Editor.EditorTool();

Editor.RotateTool.prototype.OnMouseDown = function (event) {

	var selection = this.editor._selectionHelper.selection;
	if (selection.atoms && selection.atoms.length) {
		var molecule = this.editor.render.ctab.molecule;
		var xy0 = new Vec2();

		if (!selection.atoms || !selection.atoms.length) {
			return true;
		}

		var rot_id = null, rot_all = false;

		selection.atoms.each(function (aid) {
			var atom = molecule.atoms.get(aid);

			xy0.add_(atom.pp);

			if (rot_all) {
				return;
			}

			atom.neighbors.find(function (nei) {
				var hb = molecule.halfBonds.get(nei);

				if (selection.atoms.indexOf(hb.end) == -1) {
					if (hb.loop >= 0) {
						var nei_atom = molecule.atoms.get(aid);
						if (!Object.isUndefined(nei_atom.neighbors.find(function (nei_nei) {
							var nei_hb = molecule.halfBonds.get(nei_nei);
							return nei_hb.loop >= 0 && selection.atoms.indexOf(nei_hb.end) != -1;
						}))) {
							rot_all = true;
							return true;
						}
					}
					if (rot_id == null) {
						rot_id = aid;
					} else if (rot_id != aid) {
						rot_all = true;
						return true;
					}
				}
				return false;
			});
		});

		if (!rot_all && rot_id != null) {
			xy0 = molecule.atoms.get(rot_id).pp;
		} else {
			xy0 = xy0.scaled(1 / selection.atoms.length);
		}

		this.dragCtx = {
			xy0: xy0,
			angle1: this._calcAngle(xy0, ui.page2obj(event)),
			all: rot_all
		};
	} else {
		this._lassoHelper.begin(event);
	}
	return true;
};
Editor.RotateTool.prototype.OnMouseMove = function (event) {
	if (this._lassoHelper.running()) {
		this.editor._selectionHelper.setSelection(
		this._lassoHelper.addPoint(event)
		);
	} else if ('dragCtx' in this) {
		var _E_ = this.editor, _R_ = _E_.render;
		var _DC_ = this.dragCtx;

		var pos = ui.page2obj(event);
		var angle = this._calcAngle(_DC_.xy0, pos) - _DC_.angle1;

		var degrees = Math.round(angle / Math.PI * 180);

		if (degrees > 180) {
			degrees -= 360;
		} else if (degrees <= -180) {
			degrees += 360;
		}

		if ('angle' in _DC_ && _DC_.angle == degrees) return true;
		if ('action' in _DC_) _DC_.action.perform();

		_DC_.angle = degrees;
		_DC_.action = Action.fromRotate(
			_DC_.all ? _R_.ctab.molecule : this.editor.getSelection(),
			_DC_.xy0,
			angle
		);

		$('toolText').update(degrees + 'º');

		_R_.update();
	}
	return true;
};

Editor.RotateTool.prototype.OnMouseUp = function (event) {
	var id = null; // id of an existing group, if we're editing one
	var selection = null; // atoms to include in a newly created group
	if (this._lassoHelper.running()) { // TODO it catches more events than needed, to be re-factored
		selection = this._lassoHelper.end(event);
	} else if ('dragCtx' in this) {
		if ('action' in this.dragCtx) {
			ui.addUndoAction(this.dragCtx.action, true);
			$('toolText').update('');
		} else {
			this.editor._selectionHelper.setSelection();
		}
		delete this.dragCtx;
	}
	return true;
};

Editor.RotateTool.prototype.OnCancel = function () {
	if ('dragCtx' in this) {
		if ('action' in this.dragCtx) {
			ui.addUndoAction(this.dragCtx.action, true);
			$('toolText').update('');
		}
		delete this.dragCtx;
	}

	// don't reset the selection when leaving the canvas, see KETCHER-632
	// this.editor._selectionHelper.setSelection();
};

function bondFlipRequired (bond, attrs) {
	return attrs.type == Bond.PATTERN.TYPE.SINGLE &&
	       bond.stereo == Bond.PATTERN.STEREO.NONE &&
	       attrs.stereo != Bond.PATTERN.STEREO.NONE &&
	       ui.ctab.atoms.get(bond.begin).neighbors.length <
	       ui.ctab.atoms.get(bond.end).neighbors.length;
}

module.exports = Editor;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../chem/atom":8,"../chem/bond":9,"../chem/element":12,"../chem/molfile":13,"../chem/sgroup":15,"../chem/struct":18,"../ui/action":27,"../util/set":43,"../util/vec2":44,"./restruct":24}],22:[function(require,module,exports){
(function (global){
require('./restruct');
require('./render');
require('./restruct_rendering');

global.rnd = global.rnd || {};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./render":23,"./restruct":24,"./restruct_rendering":25}],23:[function(require,module,exports){
(function (global){
var Raphael = require('../raphael-ext.js');
var Box2Abs = require('../util/box2abs');
var Set = require('../util/set');
var Vec2 = require('../util/vec2');
var util = require('../util');

var Struct = require('../chem/struct');
var SGroup = require('../chem/sgroup');

require('./restruct');
require('./restruct_rendering');

var rnd = global.rnd = global.rnd || {}; // jshint ignore:line
var ui = global.ui;
var tfx = util.tfx;

rnd.DEBUG = false;

rnd.logcnt = 0;
rnd.logmouse = false;
rnd.hl = false;

var EventMap = {
	mousemove: 'mousemove',
	mousedown: 'mousedown',
	mouseup: 'mouseup'
};

rnd.logMethod = function () { };
//rnd.logMethod = function (method) {console.log("METHOD: " + method);}

rnd.RenderOptions = function (opt)
{
	opt = opt || {};

	// flags for debugging
	this.showSelectionRegions = opt.showSelectionRegions || false;
	this.showAtomIds = opt.showAtomIds || false;
	this.showBondIds = opt.showBondIds || false;
	this.showHalfBondIds = opt.showHalfBondIds || false;
	this.showLoopIds = opt.showLoopIds || false;
	this.hideChiralFlag = opt.hideChiralFlag || false;

	// rendering customization flags
	this.showValenceWarnings = !Object.isUndefined(opt.showValenceWarnings) ? opt.showValenceWarnings : true;
	this.autoScale = opt.autoScale || false; // scale structure to fit into the given view box, used in view mode
	this.autoScaleMargin = opt.autoScaleMargin || 0;
	this.maxBondLength = opt.maxBondLength || 0; // 0 stands for "not specified"
	this.atomColoring = opt.atomColoring || 0;
	this.hideImplicitHydrogen = opt.hideImplicitHydrogen || false;
	this.hideTerminalLabels = opt.hideTerminalLabels || false;
	this.ignoreMouseEvents = opt.ignoreMouseEvents || false; // for view mode
	this.selectionDistanceCoefficient = (opt.selectionDistanceCoefficient || 0.4) - 0;
};

rnd.Render = function (clientArea, scale, opt, viewSz)
{
	this.opt = new rnd.RenderOptions(opt);

	this.useOldZoom = Prototype.Browser.IE;
	this.scale = scale || 100;
	this.baseScale = this.scale;
	this.offset = new Vec2();
	this.clientArea = clientArea = $(clientArea);
	clientArea.innerHTML = '';
	this.paper = new Raphael(clientArea);
	this.size = new Vec2();
	this.viewSz = viewSz || new Vec2(clientArea['clientWidth'] || 100, clientArea['clientHeight'] || 100);
	this.bb = new Box2Abs(new Vec2(), this.viewSz);
	this.dirty = true;
	this.selectionRect = null;
	this.rxnArrow = null;
	this.rxnMode = false;
	this.zoom = 1.0;
	this.structChangeHandlers = [];

	var render = this;
	var valueT = 0, valueL = 0;
	var element = clientArea;
	do {
		valueT += element.offsetTop  || 0;
		valueL += element.offsetLeft || 0;
		element = element.offsetParent;
	} while (element);

	this.clientAreaPos = new Vec2(valueL, valueT);

	// rbalabanov: two-fingers scrolling & zooming for iPad
	// TODO should be moved to touch.js module, re-factoring needed
	//BEGIN
	var self = this;
	self.longTapFlag = false;
	self.longTapTimeout = null;
	self.longTapTouchstart = null;

	self.setLongTapTimeout = function (event) {
		self.longTapFlag = false;
		self.longTapTouchstart = event;
		self.longTapTimeout = setTimeout(function () {
			self.longTapFlag = true;
			self.longTapTimeout = null;
		}, 500);
	};

	self.resetLongTapTimeout = function (resetFlag) {
		clearTimeout(self.longTapTimeout);
		self.longTapTimeout = null;
		if (resetFlag) {
			self.longTapTouchstart = null;
			self.longTapFlag = false;
		}
	};
	//END

	// rbalabanov: here is temporary fix for "drag issue" on iPad
	//BEGIN
	if ('hiddenPaths' in rnd.ReStruct.prototype) {
		clientArea.observe('touchend', function (event) {
			if (event.touches.length == 0) {
				while (rnd.ReStruct.prototype.hiddenPaths.length > 0) rnd.ReStruct.prototype.hiddenPaths.pop().remove();
			}
		});
	}
	//END

	if (!this.opt.ignoreMouseEvents) {
		// [RB] KETCHER-396 (Main toolbar is grayed after the Shift-selection of some atoms/bonds)
		// here we prevent that freaking "accelerators menu" on IE8
		//BEGIN
		clientArea.observe('selectstart', function (event) {
			util.stopEventPropagation(event);
			return util.preventDefault(event);
		});
		//END

		clientArea.observe('touchstart', function (event) {
			self.resetLongTapTimeout(true);
			if (event.touches.length == 2) {
				this._tui = this._tui || {};
				this._tui.center = {
					pageX: (event.touches[0].pageX + event.touches[1].pageX) / 2,
					pageY: (event.touches[0].pageY + event.touches[1].pageY) / 2
				};
				ui.setZoomStaticPointInit(ui.page2obj(this._tui.center));
			} else if (event.touches.length == 1) {
				self.setLongTapTimeout(event);
			}
		});
		clientArea.observe('touchmove', function (event) {
			self.resetLongTapTimeout(true);
			if ('_tui' in this && event.touches.length == 2) {
				this._tui.center = {
					pageX: (event.touches[0].pageX + event.touches[1].pageX) / 2,
					pageY: (event.touches[0].pageY + event.touches[1].pageY) / 2
				};
			}
		});
		clientArea.observe('gesturestart', function (event) {
			this._tui = this._tui || {};
			this._tui.scale0 = ui.render.zoom;
			event.preventDefault();
		});
		clientArea.observe('gesturechange', function (event) {
			ui.setZoomStaticPoint(this._tui.scale0 * event.scale, ui.page2canvas2(this._tui.center));
			ui.render.update();
			event.preventDefault();
		});
		clientArea.observe('gestureend', function (event) {
			delete this._tui;
			event.preventDefault();
		});
		//END

		clientArea.observe('onresize', function (event) {
			render.onResize();
		});

		// assign canvas events handlers
		['Click', 'DblClick', 'MouseDown', 'MouseMove', 'MouseUp', 'MouseLeave'].each(function (eventName){
			var bindEventName = eventName.toLowerCase();
			bindEventName = EventMap[bindEventName] || bindEventName;
			clientArea.observe(bindEventName, function (event) {
				if (eventName != 'MouseLeave') if (!ui || !ui.is_touch) {
					// TODO: karulin: fix this on touch devices if needed
					var co = clientArea.cumulativeOffset();
					co = new Vec2(co[0], co[1]);
					var vp = new Vec2(event.clientX, event.clientY).sub(co);
					var sz = new Vec2(clientArea.clientWidth, clientArea.clientHeight);
					if (!(vp.x > 0 && vp.y > 0 && vp.x < sz.x && vp.y < sz.y)) {// ignore events on the hidden part of the canvas
						if (eventName == 'MouseMove') {
							// [RB] here we alse emulate mouseleave when user drags mouse over toolbar (see KETCHER-433)
							ui.render.current_tool.processEvent('OnMouseLeave', event);
						}
						return util.preventDefault(event);
					}
				}

				ui.render.current_tool.processEvent('On' + eventName, event);
				if (eventName != 'MouseUp') {
					// [NK] do not stop mouseup propagation
					// to maintain cliparea focus.
					// Do we really need total stop here?
					util.stopEventPropagation(event);
				}
				if (bindEventName != 'touchstart' && (bindEventName != 'touchmove' || event.touches.length != 2))
					return util.preventDefault(event);
			});
		}, this);
	}

	this.ctab = new rnd.ReStruct(new Struct(), this);
	this.settings = null;
	this.styles = null;

	this.onCanvasOffsetChanged = null; //function(newOffset, oldOffset){};
	this.onCanvasSizeChanged = null; //function(newSize, oldSize){};
};

rnd.Render.prototype.addStructChangeHandler = function (handler)
{
	if (handler in this.structChangeHandlers)
		throw new Error('handler already present');
	this.structChangeHandlers.push(handler);
};

rnd.Render.prototype.view2scaled = function (p, isRelative) {
	var scroll = ui.scrollPos();
	if (!this.useOldZoom) {
		p = p.scaled(1 / this.zoom);
		scroll = scroll.scaled(1 / this.zoom);
	}
	p = isRelative ? p : p.add(scroll).sub(this.offset);
	return p;
};

rnd.Render.prototype.scaled2view = function (p, isRelative) {
	p = isRelative ? p : p.add(this.offset).sub(ui.scrollPos().scaled(1 / this.zoom));
	if (!this.useOldZoom)
		p = p.scaled(this.zoom);
	return p;
};

rnd.Render.prototype.scaled2obj = function (v) {
	return v.scaled(1 / this.settings.scaleFactor);
};

rnd.Render.prototype.obj2scaled = function (v) {
	return v.scaled(this.settings.scaleFactor);
};

rnd.Render.prototype.view2obj = function (v, isRelative) {
	return this.scaled2obj(this.view2scaled(v, isRelative));
};

rnd.Render.prototype.obj2view = function (v, isRelative) {
	return this.scaled2view(this.obj2scaled(v, isRelative));
};

rnd.Render.prototype.findItem = function (event, maps, skip) {
	var ci = this.findClosestItem(
			'ui' in window && 'page2obj' in ui ? new Vec2(ui.page2obj(event)) :
		new Vec2(event.pageX, event.pageY).sub(this.clientAreaPos),
		maps,
		skip
	);
	//rbalabanov: let it be this way at the moment
	if (ci.type == 'Atom') ci.map = 'atoms';
	else if (ci.type == 'Bond') ci.map = 'bonds';
	else if (ci.type == 'SGroup') ci.map = 'sgroups';
	else if (ci.type == 'DataSGroupData') ci.map = 'sgroupData';
	else if (ci.type == 'RxnArrow') ci.map = 'rxnArrows';
	else if (ci.type == 'RxnPlus') ci.map = 'rxnPluses';
	else if (ci.type == 'Fragment') ci.map = 'frags';
	else if (ci.type == 'RGroup') ci.map = 'rgroups';
	else if (ci.type == 'ChiralFlag') ci.map = 'chiralFlags';
	return ci;
};

rnd.Render.prototype.client2Obj = function (clientPos) {
	return new Vec2(clientPos).sub(this.offset);
};

rnd.Render.prototype.setMolecule = function (ctab, norescale)
{
	rnd.logMethod('setMolecule');
	this.paper.clear();
	this.ctab = new rnd.ReStruct(ctab, this, norescale);
	this.offset = null;
	this.size = null;
	this.bb = null;
	this.rxnMode = ctab.isReaction;
};

// molecule manipulation interface
rnd.Render.prototype.atomGetAttr = function (aid, name)
{
	rnd.logMethod('atomGetAttr');
	// TODO: check attribute names
	return this.ctab.molecule.atoms.get(aid)[name];
};

rnd.Render.prototype.invalidateAtom = function (aid, level)
{
	var atom = this.ctab.atoms.get(aid);
	this.ctab.markAtom(aid, level ? 1 : 0);
	var hbs = this.ctab.molecule.halfBonds;
	for (var i = 0; i < atom.a.neighbors.length; ++i) {
		var hbid = atom.a.neighbors[i];
		if (hbs.has(hbid)) {
			var hb = hbs.get(hbid);
			this.ctab.markBond(hb.bid, 1);
			this.ctab.markAtom(hb.end, 0);
			if (level)
				this.invalidateLoop(hb.bid);
		}
	}
};

rnd.Render.prototype.invalidateLoop = function (bid)
{
	var bond = this.ctab.bonds.get(bid);
	var lid1 = this.ctab.molecule.halfBonds.get(bond.b.hb1).loop;
	var lid2 = this.ctab.molecule.halfBonds.get(bond.b.hb2).loop;
	if (lid1 >= 0)
		this.ctab.loopRemove(lid1);
	if (lid2 >= 0)
		this.ctab.loopRemove(lid2);
};

rnd.Render.prototype.invalidateBond = function (bid)
{
	var bond = this.ctab.bonds.get(bid);
	this.invalidateLoop(bid);
	this.invalidateAtom(bond.b.begin, 0);
	this.invalidateAtom(bond.b.end, 0);
};

rnd.Render.prototype.invalidateItem = function (map, id, level)
{
	if (map == 'atoms') {
		this.invalidateAtom(id, level);
	} else if (map == 'bonds') {
		this.invalidateBond(id);
		if (level > 0)
			this.invalidateLoop(id);
	} else {
		this.ctab.markItem(map, id, level);
	}
};

rnd.Render.prototype.atomGetDegree = function (aid)
{
	rnd.logMethod('atomGetDegree');
	return this.ctab.atoms.get(aid).a.neighbors.length;
};

rnd.Render.prototype.isBondInRing = function (bid) {
	var bond = this.ctab.bonds.get(bid);
	return this.ctab.molecule.halfBonds.get(bond.b.hb1).loop >= 0 ||
	this.ctab.molecule.halfBonds.get(bond.b.hb2).loop >= 0;
};

rnd.Render.prototype.atomGetNeighbors = function (aid)
{
	var atom = this.ctab.atoms.get(aid);
	var neiAtoms = [];
	for (var i = 0; i < atom.a.neighbors.length; ++i) {
		var hb = this.ctab.molecule.halfBonds.get(atom.a.neighbors[i]);
		neiAtoms.push({
			'aid': hb.end - 0,
			'bid': hb.bid - 0
		});
	}
	return neiAtoms;
};

// returns an array of s-group id's
rnd.Render.prototype.atomGetSGroups = function (aid)
{
	rnd.logMethod('atomGetSGroups');
	var atom = this.ctab.atoms.get(aid);
	return Set.list(atom.a.sgs);
};

rnd.Render.prototype.sGroupGetAttr = function (sgid, name)
{
	rnd.logMethod('sGroupGetAttr');
	return this.ctab.sgroups.get(sgid).item.getAttr(name);
};

rnd.Render.prototype.sGroupGetAttrs = function (sgid)
{
	rnd.logMethod('sGroupGetAttrs');
	return this.ctab.sgroups.get(sgid).item.getAttrs();
};

// TODO: move to SGroup
rnd.Render.prototype.sGroupGetAtoms = function (sgid)
{
	rnd.logMethod('sGroupGetAtoms');
	var sg = this.ctab.sgroups.get(sgid).item;
	return SGroup.getAtoms(this.ctab.molecule, sg);
};

rnd.Render.prototype.sGroupGetType = function (sgid)
{
	rnd.logMethod('sGroupGetType');
	var sg = this.ctab.sgroups.get(sgid).item;
	return sg.type;
};

rnd.Render.prototype.sGroupsFindCrossBonds = function ()
{
	rnd.logMethod('sGroupsFindCrossBonds');
	this.ctab.molecule.sGroupsRecalcCrossBonds();
};

// TODO: move to ReStruct
rnd.Render.prototype.sGroupGetNeighborAtoms = function (sgid)
{
	rnd.logMethod('sGroupGetNeighborAtoms');
	var sg = this.ctab.sgroups.get(sgid).item;
	return sg.neiAtoms;
};

// TODO: move to ReStruct
rnd.Render.prototype.atomIsPlainCarbon = function (aid)
{
	rnd.logMethod('atomIsPlainCarbon');
	return this.ctab.atoms.get(aid).a.isPlainCarbon();
};

rnd.Render.prototype.highlightObject = function (obj, visible) {
	if (['atoms', 'bonds', 'rxnArrows', 'rxnPluses', 'chiralFlags', 'frags', 'rgroups', 'sgroups', 'sgroupData'].indexOf(obj.map) > -1) {
		var item = this.ctab[obj.map].get(obj.id);
		if (item == null)
			return true; // TODO: fix, attempt to highlight a deleted item
		if ((obj.map == 'sgroups' && item.item.type == 'DAT') || obj.map == 'sgroupData') {
			// set highlight for both the group and the data item
			var item1 = this.ctab.sgroups.get(obj.id);
			var item2 = this.ctab.sgroupData.get(obj.id);
			if (item1 != null)
				item1.setHighlight(visible, this);
			if (item2 != null)
				item2.setHighlight(visible, this);
		} else {
			item.setHighlight(visible, this);
		}
	} else {
		return false;
	}
	return true;
};

rnd.Render.prototype.itemGetPos = function (map, id)
{
	return this.ctab.molecule[map].get(id).pp;
};

rnd.Render.prototype.atomGetPos = function (id)
{
	rnd.logMethod('atomGetPos');
	return this.itemGetPos('atoms', id);
};

rnd.Render.prototype.rxnArrowGetPos = function (id)
{
	rnd.logMethod('rxnArrowGetPos');
	return this.itemGetPos('rxnArrows', id);
};

rnd.Render.prototype.rxnPlusGetPos = function (id)
{
	rnd.logMethod('rxnPlusGetPos');
	return this.itemGetPos('rxnPluses', id);
};

rnd.Render.prototype.getAdjacentBonds = function (atoms) {
	var aidSet = Set.fromList(atoms);
	var bidSetInner = Set.empty(), bidSetCross = Set.empty();
	for (var i = 0; i < atoms.length; ++i) {
		var aid = atoms[i];
		var atom = this.ctab.atoms.get(aid);
		for (var j = 0; j < atom.a.neighbors.length; ++j) {
			var hbid = atom.a.neighbors[j];
			var hb = this.ctab.molecule.halfBonds.get(hbid);
			var endId = hb.end;
			var set = Set.contains(aidSet, endId) ?
					bidSetInner : bidSetCross;
			Set.add(set, hb.bid);
		}
	}
	return {'inner': bidSetInner, 'cross': bidSetCross};
};

rnd.Render.prototype.bondGetAttr = function (bid, name)
{
	rnd.logMethod('bondGetAttr');
	return this.ctab.bonds.get(bid).b[name];
};

rnd.Render.prototype.setSelection = function (selection)
{
	rnd.logMethod('setSelection');
	for (var map in rnd.ReStruct.maps) {
		if (!rnd.ReStruct.maps[map].isSelectable())
			continue;
		var set = selection ? (selection[map] ? util.identityMap(selection[map]) : {}) : null;
		this.ctab[map].each(function (id, item){
			var selected = set ? set[id] === id : item.selected;
			item.selected = selected;
			this.ctab.showItemSelection(id, item, selected);
		}, this);
	}
};

rnd.Render.prototype.initStyles = function ()
{
	// TODO move fonts, dashed lines, etc. here
	var settings = this.settings;
	this.styles = {};
	this.styles.lineattr = {
		stroke: '#000',
		'stroke-width': settings.lineWidth,
		'stroke-linecap': 'round',
		'stroke-linejoin': 'round'
	};
	this.styles.selectionStyle = {
		'fill':'#7f7',
		'stroke':'none'
	};
	this.styles.selectionZoneStyle = {
		'fill':'#000',
		'stroke':'none',
		'opacity':0.0
	};
	this.styles.highlightStyle = {
		'stroke':'#0c0',
		'stroke-width':0.6 * settings.lineWidth
	};
	this.styles.sGroupHighlightStyle = {
		'stroke':'#9900ff',
		'stroke-width':0.6 * settings.lineWidth
	};
	this.styles.sgroupBracketStyle = {
		'stroke':'darkgray',
		'stroke-width':0.5 * settings.lineWidth
	};
	this.styles.atomSelectionPlateRadius = settings.labelFontSize * 1.2 ;
};

rnd.Render.prototype.initSettings = function ()
{
	var settings = this.settings = {};
	settings.delta = this.ctab.molecule.getCoordBoundingBox();
	settings.margin = 0.1;
	settings.scaleFactor = this.scale;
	settings.lineWidth = settings.scaleFactor / 20;
	settings.bondShift = settings.scaleFactor / 6;
	settings.bondSpace = settings.scaleFactor / 7;
	settings.labelFontSize = Math.ceil(1.9 * (settings.scaleFactor / 6)); // TODO: don't round?
	settings.subFontSize = Math.ceil(0.7 * settings.labelFontSize);
	// font size is not determined by the number in this string,
	//  but by the 'font-size' property
	settings.font = '30px "Arial"';
	settings.fontsz = this.settings.labelFontSize;
	settings.fontszsub = this.settings.subFontSize;
	settings.fontRLabel = this.settings.labelFontSize * 1.2;
	settings.fontRLogic = this.settings.labelFontSize * 0.7;
};

rnd.Render.prototype.getStructCenter = function (selection)
{
	var bb = this.ctab.getVBoxObj(selection);
	return Vec2.lc2(bb.p0, 0.5, bb.p1, 0.5);
};

rnd.Render.prototype.onResize = function ()
{
	this.setViewSize(new Vec2(this.clientArea['clientWidth'], this.clientArea['clientHeight']));
};

rnd.Render.prototype.setViewSize = function (viewSz)
{
	this.viewSz = new Vec2(viewSz);
};

rnd.Render.prototype._setPaperSize = function (sz)
{
	var z = this.zoom;
	this.paper.setSize(sz.x * z, sz.y * z);
	this.setViewBox(z);
};

rnd.Render.prototype.setPaperSize = function (sz)
{
	rnd.logMethod('setPaperSize');
	var oldSz = this.sz;
	this.sz = sz;
	this._setPaperSize(sz);
	if (this.onCanvasSizeChanged)
		this.onCanvasSizeChanged(sz, oldSz);
};

rnd.Render.prototype.setOffset = function (newoffset)
{
	rnd.logMethod('setOffset');
	if (this.onCanvasOffsetChanged) this.onCanvasOffsetChanged(newoffset, this.offset);
	this.offset = newoffset;
};

rnd.Render.prototype.getElementPos = function (obj)
{
	var curleft = 0, curtop = 0;

	if (obj.offsetParent) {
		do {
			curleft += obj.offsetLeft;
			curtop += obj.offsetTop;
		} while ((obj = obj.offsetParent));
	}
	return new Vec2(curleft,curtop);
};

rnd.Render.prototype.drawSelectionLine = function (p0, p1) {
	rnd.logMethod('drawSelectionLine');
	if (this.selectionRect) {
		this.selectionRect.remove();
		this.selectionRect = null;
	}
	if (p0 && p1) {
		p0 = this.obj2scaled(p0).add(this.offset);
		p1 = this.obj2scaled(p1).add(this.offset);
		this.selectionRect = this.paper.path(
		rnd.ReStruct.makeStroke(p0, p1)
		).attr({'stroke':'gray', 'stroke-width':'1px'});
	}
};

rnd.Render.prototype.drawSelectionRectangle = function (p0, p1) {
	rnd.logMethod('drawSelectionRectangle');
	if (this.selectionRect) {
		this.selectionRect.remove();
		this.selectionRect = null;
	}
	if (p0 && p1) {
		p0 = this.obj2scaled(p0).add(this.offset);
		p1 = this.obj2scaled(p1).add(this.offset);
		this.selectionRect = this.paper.rect(
		Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.abs(p1.x - p0.x), Math.abs(p1.y - p0.y)
		).attr({'stroke':'gray', 'stroke-width':'1px'});
	}
};

rnd.Render.prototype.getElementsInRectangle = function (p0,p1) {
	rnd.logMethod('getElementsInRectangle');
	var bondList = [];
	var atomList = [];

	var x0 = Math.min(p0.x, p1.x), x1 = Math.max(p0.x, p1.x), y0 = Math.min(p0.y, p1.y), y1 = Math.max(p0.y, p1.y);
	this.ctab.bonds.each(function (bid, bond){
		var centre = Vec2.lc2(this.ctab.atoms.get(bond.b.begin).a.pp, 0.5,
			this.ctab.atoms.get(bond.b.end).a.pp, 0.5);
		if (centre.x > x0 && centre.x < x1 && centre.y > y0 && centre.y < y1)
			bondList.push(bid);
	}, this);
	this.ctab.atoms.each(function (aid, atom) {
		if (atom.a.pp.x > x0 && atom.a.pp.x < x1 && atom.a.pp.y > y0 && atom.a.pp.y < y1)
			atomList.push(aid);
	}, this);
	var rxnArrowsList = [];
	var rxnPlusesList = [];
	this.ctab.rxnArrows.each(function (id, item){
		if (item.item.pp.x > x0 && item.item.pp.x < x1 && item.item.pp.y > y0 && item.item.pp.y < y1)
			rxnArrowsList.push(id);
	}, this);
	this.ctab.rxnPluses.each(function (id, item){
		if (item.item.pp.x > x0 && item.item.pp.x < x1 && item.item.pp.y > y0 && item.item.pp.y < y1)
			rxnPlusesList.push(id);
	}, this);
	var chiralFlagList = [];
	this.ctab.chiralFlags.each(function (id, item){
		if (item.pp.x > x0 && item.pp.x < x1 && item.pp.y > y0 && item.pp.y < y1)
			chiralFlagList.push(id);
	}, this);
	var sgroupDataList = [];
	this.ctab.sgroupData.each(function (id, item){
		if (item.sgroup.pp.x > x0 && item.sgroup.pp.x < x1 && item.sgroup.pp.y > y0 && item.sgroup.pp.y < y1)
			sgroupDataList.push(id);
	}, this);
	return {
		'atoms':atomList,
		'bonds':bondList,
		'rxnArrows':rxnArrowsList,
		'rxnPluses':rxnPlusesList,
		'chiralFlags':chiralFlagList,
		'sgroupData':sgroupDataList
	};
};

rnd.Render.prototype.drawSelectionPolygon = function (r) {
	rnd.logMethod('drawSelectionPolygon');
	if (this.selectionRect) {
		this.selectionRect.remove();
		this.selectionRect = null;
	}
	if (r && r.length > 1) {
		var v = this.obj2scaled(r[r.length - 1]).add(this.offset);
		var pstr = 'M' + tfx(v.x) + ',' + tfx(v.y);
		for (var i = 0; i < r.length; ++i) {
			v = this.obj2scaled(r[i]).add(this.offset);
			pstr += 'L' + tfx(v.x) + ',' + tfx(v.y);
		}
		this.selectionRect = this.paper.path(pstr).attr({'stroke':'gray', 'stroke-width':'1px'});
	}
};

rnd.Render.prototype.isPointInPolygon = function (r, p) {
	var d = new Vec2(0, 1);
	var n = d.rotate(Math.PI / 2);
	var v0 = Vec2.diff(r[r.length - 1], p);
	var n0 = Vec2.dot(n, v0);
	var d0 = Vec2.dot(d, v0);
	var w0 = null;
	var counter = 0;
	var eps = 1e-5;
	var flag1 = false, flag0 = false;

	for (var i = 0; i < r.length; ++i) {
		var v1 = Vec2.diff(r[i], p);
		var w1 = Vec2.diff(v1, v0);
		var n1 = Vec2.dot(n, v1);
		var d1 = Vec2.dot(d, v1);
		flag1 = false;
		if (n1 * n0 < 0)
		{
			if (d1 * d0 > -eps) {
				if (d0 > -eps)
					flag1 = true;
			} else if ((Math.abs(n0) * Math.abs(d1) - Math.abs(n1) * Math.abs(d0)) * d1 > 0) {
				flag1 = true;
			}
		}
		if (flag1 && flag0 && Vec2.dot(w1, n) * Vec2(w0, n) >= 0)
			flag1 = false;
		if (flag1)
			counter++;
		v0 = v1;
		n0 = n1;
		d0 = d1;
		w0 = w1;
		flag0 = flag1;
	}
	return (counter % 2) != 0;
};

rnd.Render.prototype.ps = function (pp) {
	return pp.scaled(this.settings.scaleFactor);
};

rnd.Render.prototype.getElementsInPolygon = function (rr) {
	rnd.logMethod('getElementsInPolygon');
	var bondList = [];
	var atomList = [];
	var r = [];
	for (var i = 0; i < rr.length; ++i) {
		r[i] = new Vec2(rr[i].x, rr[i].y);
	}
	this.ctab.bonds.each(function (bid, bond){
		var centre = Vec2.lc2(this.ctab.atoms.get(bond.b.begin).a.pp, 0.5,
			this.ctab.atoms.get(bond.b.end).a.pp, 0.5);
		if (this.isPointInPolygon(r, centre))
			bondList.push(bid);
	}, this);
	this.ctab.atoms.each(function (aid, atom){
		if (this.isPointInPolygon(r, atom.a.pp))
			atomList.push(aid);
	}, this);
	var rxnArrowsList = [];
	var rxnPlusesList = [];
	this.ctab.rxnArrows.each(function (id, item){
		if (this.isPointInPolygon(r, item.item.pp))
			rxnArrowsList.push(id);
	}, this);
	this.ctab.rxnPluses.each(function (id, item){
		if (this.isPointInPolygon(r, item.item.pp))
			rxnPlusesList.push(id);
	}, this);
	var chiralFlagList = [];
	this.ctab.chiralFlags.each(function (id, item){
		if (this.isPointInPolygon(r, item.pp))
			chiralFlagList.push(id);
	}, this);
	var sgroupDataList = [];
	this.ctab.sgroupData.each(function (id, item){
		if (this.isPointInPolygon(r, item.sgroup.pp))
			sgroupDataList.push(id);
	}, this);

	return {
		'atoms':atomList,
		'bonds':bondList,
		'rxnArrows':rxnArrowsList,
		'rxnPluses':rxnPlusesList,
		'chiralFlags':chiralFlagList,
		'sgroupData':sgroupDataList
	};
};

rnd.Render.prototype.testPolygon = function (rr) {
	rr = rr || [
	{
		x:50,
		y:10
	},

	{
		x:20,
		y:90
	},

	{
		x:90,
		y:30
	},

	{
		x:10,
		y:30
	},

	{
		x:90,
		y:80
	}
		];
	if (rr.length < 3)
		return;
	var min = rr[0], max = rr[0];
	for (var j = 1; j < rr.length; ++j) {
		min = Vec2.min(min, rr[j]);
		max = Vec2.max(max, rr[j]);
	}
	this.drawSelectionPolygon(rr);
	var zz = 10;
	for (var k = 0; k < 1000; ++k) {
		var p = new Vec2(Math.random() * zz, Math.random() * zz);
		var isin = this.isPointInPolygon(rr, p);
		var color = isin ? '#0f0' : '#f00';
		this.paper.circle(p.x, p.y, 2).attr({
			'fill':color,
			'stroke':'none'
		});
	}
	this.drawSelectionPolygon(rr);
};

rnd.Render.prototype.update = function (force)
{
	rnd.logMethod('update');

	if (!this.settings || this.dirty) {
		if (this.opt.autoScale) {
			var cbb = this.ctab.molecule.getCoordBoundingBox();
			// this is only an approximation to select some scale that's close enough to the target one
			var sy = cbb.max.y - cbb.min.y > 0 ? 0.8 * this.viewSz.y / (cbb.max.y - cbb.min.y) : 100;
			var sx = cbb.max.x - cbb.min.x > 0 ? 0.8 * this.viewSz.x / (cbb.max.x - cbb.min.x) : 100;
			this.scale = Math.min(sy, sx);
			if (this.opt.maxBondLength > 0 && this.scale > this.opt.maxBondLength)
				this.scale = this.opt.maxBondLength;
		}
		this.initSettings();
		this.initStyles();
		this.dirty = false;
		force = true;
	}

	var start = (new Date()).getTime();
	var changes = this.ctab.update(force);
	this.setSelection(null); // [MK] redraw the selection bits where necessary
	var time = (new Date()).getTime() - start;
	if (force && $('log'))
		$('log').innerHTML = time.toString() + '\n';
	if (changes) {
		var sf = this.settings.scaleFactor;
		var bb = this.ctab.getVBoxObj().transform(this.obj2scaled, this).translate(this.offset || new Vec2());

		if (!this.opt.autoScale) {
			var ext = Vec2.UNIT.scaled(sf);
			var eb = bb.sz().length() > 0 ? bb.extend(ext, ext) : bb;
			// The only reference to ui.zoom
			console.assert(ui.zoom == this.zoom);
			var vb = new Box2Abs(ui.scrollPos(), this.viewSz.scaled(1 / ui.zoom).sub(Vec2.UNIT.scaled(20)));
			var cb = Box2Abs.union(vb, eb);
			if (!this.oldCb)
				this.oldCb = new Box2Abs();

			var sz = cb.sz().floor();
			var delta = this.oldCb.p0.sub(cb.p0).ceil();
			this.oldBb = bb;
			if (!this.sz || sz.x != this.sz.x || sz.y != this.sz.y)
				this.setPaperSize(sz);

			this.offset = this.offset || new Vec2();
			if (delta.x != 0 || delta.y != 0) {
				this.setOffset(this.offset.add(delta));
				this.ctab.translate(delta);
			}
		} else {
			var sz1 = bb.sz();
			var marg = this.opt.autoScaleMargin;
			var mv = new Vec2(marg, marg);
			var csz = this.viewSz;
			if (csz.x < 2 * marg + 1 || csz.y < 2 * marg + 1)
				throw new Error('View box too small for the given margin');
			var rescale = Math.max(sz1.x / (csz.x - 2 * marg), sz1.y / (csz.y - 2 * marg));
			if (this.opt.maxBondLength / rescale > 1.0)
				rescale = 1.0;
			var sz2 = sz1.add(mv.scaled(2 * rescale));
			this.paper.setViewBox(bb.pos().x - marg * rescale - (csz.x * rescale - sz2.x) / 2, bb.pos().y - marg * rescale - (csz.y * rescale - sz2.y) / 2, csz.x * rescale, csz.y * rescale);
		}
	}
};

rnd.Render.prototype.checkBondExists = function (begin, end) {
	return this.ctab.molecule.checkBondExists(begin, end);
};

var findClosestChiralFlag = function (render, p) {
    var minDist;
    var ret;
    
    // there is only one chiral flag, but we treat it as a "map" for convenience
    render.ctab.chiralFlags.each(function (id, item) {
        var pos = item.pp;
        if (Math.abs(p.x - pos.x) < 1.0) {
            var dist = Math.abs(p.y - pos.y);
            if (dist < 0.3 && (!ret || dist < minDist)) {
                minDist = dist;
                ret = { 'id': id, 'dist': minDist };
            }
        }
    });
    return ret;
};

var findClosestSGroup = function (render, p) {
    var ret = null;
    var minDist = render.opt.selectionDistanceCoefficient;
    render.ctab.molecule.sgroups.each(function (sgid, sg) {
        var d = sg.bracketDir, n = d.rotateSC(1, 0);
        var pg = new Vec2(Vec2.dot(p, d), Vec2.dot(p, n));
        for (var i = 0; i < sg.areas.length; ++i) {
            var box = sg.areas[i];
            var inBox = box.p0.y < pg.y && box.p1.y > pg.y && box.p0.x < pg.x && box.p1.x > pg.x;
            var xDist = Math.min(Math.abs(box.p0.x - pg.x), Math.abs(box.p1.x - pg.x));
            if (inBox && (ret == null || xDist < minDist)) {
                ret = sgid;
                minDist = xDist;
            }
        }
    }, this);
    if (ret != null)
        return {
            'id': ret,
            'dist': minDist
        };
    return null;
};

var findClosestRxnArrow = function (render, p) {
    var minDist;
    var ret;
    
    render.ctab.rxnArrows.each(function (id, arrow) {
        var pos = arrow.item.pp;
        if (Math.abs(p.x - pos.x) < 1.0) {
            var dist = Math.abs(p.y - pos.y);
            if (dist < 0.3 && (!ret || dist < minDist)) {
                minDist = dist;
                ret = { 'id': id, 'dist': minDist };
            }
        }
    });
    return ret;
};

var findClosestSGroupData = function (render, p) {
    var minDist = null;
    var ret = null;
    
    render.ctab.sgroupData.each(function (id, item) {
        if (item.sgroup.type != 'DAT')
            throw new Error('Data group expected');
        var box = item.sgroup.dataArea;
        var inBox = box.p0.y < p.y && box.p1.y > p.y && box.p0.x < p.x && box.p1.x > p.x;
        var xDist = Math.min(Math.abs(box.p0.x - p.x), Math.abs(box.p1.x - p.x));
        if (inBox && (ret == null || xDist < minDist)) {
            ret = { 'id': id, 'dist': xDist };
            minDist = xDist;
        }
    });
    return ret;
};


var findClosestRxnPlus = function (render, p) {
    var minDist;
    var ret;
    
    render.ctab.rxnPluses.each(function (id, plus) {
        var pos = plus.item.pp;
        var dist = Math.max(Math.abs(p.x - pos.x), Math.abs(p.y - pos.y));
        if (dist < 0.5 && (!ret || dist < minDist)) {
            minDist = dist;
            ret = { 'id': id, 'dist': minDist };
        }
    });
    return ret;
};
var findClosestFrag = function (render, p, skip, minDist) {
    minDist = Math.min(minDist || render.opt.selectionDistanceCoefficient, render.opt.selectionDistanceCoefficient);
    var ret;
    render.ctab.frags.each(function (fid, frag) {
        if (fid != skip) {
            var bb = frag.calcBBox(render, fid); // TODO any faster way to obtain bb?
            if (bb.p0.y < p.y && bb.p1.y > p.y && bb.p0.x < p.x && bb.p1.x > p.x) {
                var xDist = Math.min(Math.abs(bb.p0.x - p.x), Math.abs(bb.p1.x - p.x));
                if (!ret || xDist < minDist) {
                    minDist = xDist;
                    ret = { 'id': fid, 'dist': minDist };
                }
            }
        }
    });
    return ret;
};

var findClosestRGroup = function (render, p, skip, minDist) {
    minDist = Math.min(minDist || render.opt.selectionDistanceCoefficient, render.opt.selectionDistanceCoefficient);
    var ret;
    render.ctab.rgroups.each(function (rgid, rgroup) {
        if (rgid != skip) {
            if (rgroup.labelBox) { // should be true at this stage, as the label is visible
                if (rgroup.labelBox.contains(p, 0.5)) { // inside the box or within 0.5 units from the edge
                    var dist = Vec2.dist(rgroup.labelBox.centre(), p);
                    if (!ret || dist < minDist) {
                        minDist = dist;
                        ret = { 'id': rgid, 'dist': minDist };
                    }
                }
            }
        }
    });
    return ret;
};

rnd.Render.prototype.findClosestAtom = function (pos, minDist, skip) { // TODO should be a member of ReAtom (see ReFrag)
	var closestAtom = null;
	var maxMinDist = this.opt.selectionDistanceCoefficient;
	minDist = minDist || maxMinDist;
	minDist	 = Math.min(minDist, maxMinDist);
	this.ctab.atoms.each(function (aid, atom){
		if (aid != skip) {
			var dist = Vec2.dist(pos, atom.a.pp);
			if (dist < minDist) {
				closestAtom = aid;
				minDist = dist;
			}
		}
	}, this);
	if (closestAtom != null)
		return {
			'id':closestAtom,
			'dist':minDist
		};
	return null;
};

var findClosestBond = function (render, pos, minDist) { // TODO should be a member of ReBond (see ReFrag)
	var closestBond = null;
	var closestBondCenter = null;
	var maxMinDist = render.opt.selectionDistanceCoefficient;
	minDist = minDist || maxMinDist;
	minDist = Math.min(minDist, maxMinDist);
	var minCDist = minDist;
    render.ctab.bonds.each(function (bid, bond){
		var p1 = render.ctab.atoms.get(bond.b.begin).a.pp,
		p2 = render.ctab.atoms.get(bond.b.end).a.pp;
		var mid = Vec2.lc2(p1, 0.5, p2, 0.5);
		var cdist = Vec2.dist(pos, mid);
		if (cdist < minCDist) {
			minCDist = cdist;
			closestBondCenter = bid;
		}
	}, render);
    render.ctab.bonds.each(function (bid, bond){
		var hb = render.ctab.molecule.halfBonds.get(bond.b.hb1);
		var d = hb.dir;
		var n = hb.norm;
		var p1 = render.ctab.atoms.get(bond.b.begin).a.pp,
		p2 = render.ctab.atoms.get(bond.b.end).a.pp;

		var inStripe = Vec2.dot(pos.sub(p1),d) * Vec2.dot(pos.sub(p2),d) < 0;
		if (inStripe) {
			var dist = Math.abs(Vec2.dot(pos.sub(p1),n));
			if (dist < minDist) {
				closestBond = bid;
				minDist = dist;
			}
		}
	}, render);
	if (closestBond !== null || closestBondCenter !== null)
		return {
			'id': closestBond,
			'dist': minDist,
			'cid': closestBondCenter,
			'cdist': minCDist
		};
	return null;
};

rnd.Render.prototype.findClosestItem = function (pos, maps, skip) {
	var ret = null;
	var updret = function (type, item, force) {
		if (item != null && (ret == null || ret.dist > item.dist || force)) {
			ret = {
				'type':type,
				'id':item.id,
				'dist':item.dist
			};
		}
	};

	// TODO make it "map-independent", each object should be able to "report" its distance to point (something like ReAtom.dist(point))
	if (!maps || maps.indexOf('atoms') >= 0) {
		var atom = this.findClosestAtom(
			pos, undefined, !Object.isUndefined(skip) && skip.map == 'atoms' ? skip.id : undefined
		);
		updret('Atom', atom);
	}
	if (!maps || maps.indexOf('bonds') >= 0) {
		var bond = findClosestBond(this, pos);
		if (bond) {
			if (bond.cid !== null)
				updret('Bond', {'id': bond.cid, 'dist': bond.cdist});
			if (ret == null || ret.dist > 0.4 * this.scale) // hack
				updret('Bond', bond);
		}
	}
	if (!maps || maps.indexOf('chiralFlags') >= 0) {
		var flag = findClosestChiralFlag(this, pos);
		updret('ChiralFlag', flag); // [MK] TODO: replace this with map name, 'ChiralFlag' -> 'chiralFlags', to avoid the extra mapping "if (ci.type == 'ChiralFlag') ci.map = 'chiralFlags';"
	}
	if (!maps || maps.indexOf('sgroupData') >= 0) {
		var sgd = findClosestSGroupData(this, pos);
		updret('DataSGroupData', sgd);
	}
	if (!maps || maps.indexOf('sgroups') >= 0) {
		var sg = findClosestSGroup(this, pos);
		updret('SGroup', sg);
	}
	if (!maps || maps.indexOf('rxnArrows') >= 0) {
		var arrow = findClosestRxnArrow(this, pos);
		updret('RxnArrow',arrow);
	}
	if (!maps || maps.indexOf('rxnPluses') >= 0) {
		var plus = findClosestRxnPlus(this, pos);
		updret('RxnPlus',plus);
	}
	if (!maps || maps.indexOf('frags') >= 0) {
		var frag = findClosestFrag(this, pos, skip && skip.map == 'atoms' ? skip.id : undefined);
		updret('Fragment', frag);
	}
	if (!maps || maps.indexOf('rgroups') >= 0) {
		var rgroup = findClosestRGroup(this, pos);
		updret('RGroup', rgroup);
	}

	ret = ret || {
		'type':'Canvas',
		'id':-1
		};
	return ret;
};

rnd.Render.prototype.setZoom = function (zoom) {
	this.zoom = zoom;
	this._setPaperSize(this.sz);
};

rnd.Render.prototype.extendCanvas = function (x0, y0, x1, y1) {
	var ex = 0, ey = 0, dx = 0, dy = 0;
	x0 = x0 - 0;
	x1 = x1 - 0;
	y0 = y0 - 0;
	y1 = y1 - 0;

	if (x0 < 0) {
		ex += -x0;
		dx += -x0;
	}
	if (y0 < 0) {
		ey += -y0;
		dy += -y0;
	}

	var szx = this.sz.x * this.zoom, szy = this.sz.y * this.zoom;
	if (szx < x1) {
		ex += x1 - szx;
	}
	if (szy < y1) {
		ey += y1 - szy;
	}

	var d = new Vec2(dx, dy).scaled(1 / this.zoom);
	if (ey > 0 || ex > 0) {
		var e = new Vec2(ex, ey).scaled(1 / this.zoom);
		var sz = this.sz.add(e);

		this.setPaperSize(sz);
		if (d.x > 0 || d.y > 0) {
			this.ctab.translate(d);
			this.setOffset(this.offset.add(d));
		}
	}
	return d;
};

rnd.Render.prototype.setScale = function (z) {
	if (this.offset)
		this.offset = this.offset.scaled(1 / z).scaled(this.zoom);
	this.scale = this.baseScale * this.zoom;
	this.settings = null;
	this.update(true);
};

rnd.Render.prototype.setViewBox = function (z) {
	if (!this.useOldZoom)
		this.paper.canvas.setAttribute('viewBox', '0 0 ' + this.sz.x + ' ' + this.sz.y);
	else
		this.setScale(z);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../chem/sgroup":15,"../chem/struct":18,"../raphael-ext.js":20,"../util":40,"../util/box2abs":39,"../util/set":43,"../util/vec2":44,"./restruct":24,"./restruct_rendering":25}],24:[function(require,module,exports){
(function (global){
// ReStruct is to store all the auxiliary information for
// Struct while rendering
var Box2Abs = require('../util/box2abs');
var Map = require('../util/map');
var Pool = require('../util/pool');
var Set = require('../util/set');
var Vec2 = require('../util/vec2');
var util = require('../util');

var element = require('../chem/element');
var Struct = require('../chem/struct');
var SGroup = require('../chem/sgroup');
var Bond = require('../chem/bond');

var Visel = require('./visel');

var rnd = global.rnd = global.rnd || {};
var tfx = util.tfx;

rnd.ReObject = function ()  // TODO ??? should it be in ReStruct namespace
{
	this.__ext = new Vec2(0.05 * 3, 0.05 * 3);
};

rnd.ReObject.prototype.init = function (viselType)
{
	this.visel = new Visel(viselType);

	this.highlight = false;
	this.highlighting = null;
	this.selected = false;
	this.selectionPlate = null;
};

// returns the bounding box of a ReObject in the object coordinates
rnd.ReObject.prototype.getVBoxObj = function (render) {
	var vbox = this.visel.boundingBox;
	if (util.isNull(vbox))
		return null;
	if (render.offset)
		vbox = vbox.translate(render.offset.negated());
	return vbox.transform(render.scaled2obj, render);
};

rnd.ReObject.prototype.drawHighlight = function (render) {
	console.log('ReObject.drawHighlight is not overridden');
};

rnd.ReObject.prototype.setHighlight = function (highLight, render) { // TODO render should be field
	if (highLight) {
		var noredraw = 'highlighting' in this && this.highlighting != null;// && !this.highlighting.removed;
		if (noredraw) {
			if (this.highlighting.type == 'set') {
				noredraw = !this.highlighting[0].removed;
			} else {
				noredraw = !this.highlighting.removed;
			}
		}
		// rbalabanov: here is temporary fix for "drag issue" on iPad
		//BEGIN
		noredraw = noredraw && (!('hiddenPaths' in rnd.ReStruct.prototype) || rnd.ReStruct.prototype.hiddenPaths.indexOf(this.highlighting) < 0);
		//END
		if (noredraw) {
			this.highlighting.show();
		}
		else {
			render.paper.setStart();
			this.drawHighlight(render);
			this.highlighting = render.paper.setFinish();
		}
	} else {
		if (this.highlighting) this.highlighting.hide();
	}
	this.highlight = highLight;
};

rnd.ReObject.prototype.makeSelectionPlate = function (render) {
	console.log('ReObject.makeSelectionPlate is not overridden');
};

var ReAtom = function (/*chem.Atom*/atom)
{
	this.init(Visel.TYPE.ATOM);

	this.a = atom; // TODO rename a to item
	this.showLabel = false;

	this.hydrogenOnTheLeft = false;

	this.component = -1;
};
ReAtom.prototype = new rnd.ReObject();
ReAtom.isSelectable = function () { return true; }

ReAtom.prototype.getVBoxObj = function (render) {
	if (this.visel.boundingBox)
		return rnd.ReObject.prototype.getVBoxObj.call(this, render);
	return new Box2Abs(this.a.pp, this.a.pp);
};

ReAtom.prototype.drawHighlight = function (render) {
	var ret = this.makeHighlightPlate(render);
	render.ctab.addReObjectPath('highlighting', this.visel, ret);
	return ret;
};

ReAtom.prototype.makeHighlightPlate = function (render) {
	var paper = render.paper;
	var styles = render.styles;
	var ps = render.ps(this.a.pp);
	return paper.circle(ps.x, ps.y, styles.atomSelectionPlateRadius)
	.attr(styles.highlightStyle);
};

ReAtom.prototype.makeSelectionPlate = function (restruct, paper, styles) {
	var ps = restruct.render.ps(this.a.pp);
	return paper.circle(ps.x, ps.y, styles.atomSelectionPlateRadius)
	.attr(styles.selectionStyle);
};

var ReBond = function (/*chem.Bond*/bond)
{
	this.init(Visel.TYPE.BOND);

	this.b = bond; // TODO rename b to item
	this.doubleBondShift = 0;
};
ReBond.prototype = new rnd.ReObject();
ReBond.isSelectable = function () { return true; }

ReBond.prototype.drawHighlight = function (render) {
	var ret = this.makeHighlightPlate(render);
	render.ctab.addReObjectPath('highlighting', this.visel, ret);
	return ret;
};

ReBond.prototype.makeHighlightPlate = function (render) {
	render.ctab.bondRecalc(render.settings, this);
	var c = render.ps(this.b.center);
	return render.paper.circle(c.x, c.y, 0.8 * render.styles.atomSelectionPlateRadius)
	.attr(render.styles.highlightStyle);
};

ReBond.prototype.makeSelectionPlate = function (restruct, paper, styles) {
	restruct.bondRecalc(restruct.render.settings, this);
	var c = restruct.render.ps(this.b.center);
	return paper.circle(c.x, c.y, 0.8 * styles.atomSelectionPlateRadius)
	.attr(styles.selectionStyle);
};

rnd.ReStruct = function (molecule, render, norescale)
{
	this.render = render;
	this.atoms = new Map();
	this.bonds = new Map();
	this.reloops = new Map();
	this.rxnPluses = new Map();
	this.rxnArrows = new Map();
	this.frags = new Map();
	this.rgroups = new Map();
	this.sgroups = new Map();
	this.sgroupData = new Map();
	this.chiralFlags = new Map();
	this.molecule = molecule || new Struct();
	this.initialized = false;
	this.layers = [];
	this.initLayers();

	this.connectedComponents = new Pool();
	this.ccFragmentType = new Map();

	for (var map in rnd.ReStruct.maps) {
		this[map + 'Changed'] = {};
	}
	this.structChanged = false;

	molecule.atoms.each(function (aid, atom){
		this.atoms.set(aid, new ReAtom(atom));
	}, this);

	molecule.bonds.each(function (bid, bond){
		this.bonds.set(bid, new ReBond(bond));
	}, this);

	molecule.loops.each(function (lid, loop){
		this.reloops.set(lid, new rnd.ReLoop(loop));
	}, this);

	molecule.rxnPluses.each(function (id, item){
		this.rxnPluses.set(id, new rnd.ReRxnPlus(item));
	}, this);

	molecule.rxnArrows.each(function (id, item){
		this.rxnArrows.set(id, new rnd.ReRxnArrow(item));
	}, this);

	molecule.frags.each(function (id, item) {
		this.frags.set(id, new rnd.ReFrag(item));
	}, this);

	molecule.rgroups.each(function (id, item) {
		this.rgroups.set(id, new rnd.ReRGroup(item));
	}, this);

	molecule.sgroups.each(function (id, item) {
		this.sgroups.set(id, new rnd.ReSGroup(item));
		if (item.type == 'DAT' && !item.data.attached) {
			this.sgroupData.set(id, new rnd.ReDataSGroupData(item)); // [MK] sort of a hack, we use the SGroup id for the data field id
		}
	}, this);

	if (molecule.isChiral && !this.render.opt.hideChiralFlag) {
		var bb = molecule.getCoordBoundingBox();
		this.chiralFlags.set(0,new rnd.ReChiralFlag(new Vec2(bb.max.x, bb.min.y - 1)));
	}

	this.coordProcess(norescale);
};

rnd.ReStruct.prototype.connectedComponentRemoveAtom = function (aid, atom) {
	atom = atom || this.atoms.get(aid);
	if (atom.component < 0)
		return;
	var cc = this.connectedComponents.get(atom.component);
	Set.remove(cc, aid);
	if (Set.size(cc) < 1)
		this.connectedComponents.remove(atom.component);

	atom.component = -1;
};

rnd.ReStruct.prototype.printConnectedComponents = function () {
	var strs = [];
	this.connectedComponents.each(function (ccid, cc){
		strs.push(' ' + ccid + ':[' + Set.list(cc).toString() + '].' + Set.size(cc).toString());
	}, this);
	console.log(strs.toString());
};

rnd.ReStruct.prototype.clearConnectedComponents = function () {
	this.connectedComponents.clear();
	this.atoms.each(function (aid, atom) {
		atom.component = -1;
	});
};

rnd.ReStruct.prototype.getConnectedComponent = function (aid, adjacentComponents) {
	var list = (typeof(aid['length']) == 'number') ? util.array(aid) : [aid];
	var ids = Set.empty();

	while (list.length > 0) {
		(function () {
			var aid = list.pop();
			Set.add(ids, aid);
			var atom = this.atoms.get(aid);
			if (atom.component >= 0) {
				Set.add(adjacentComponents, atom.component);
			}
			for (var i = 0; i < atom.a.neighbors.length; ++i) {
				var neiId = this.molecule.halfBonds.get(atom.a.neighbors[i]).end;
				if (!Set.contains(ids, neiId))
					list.push(neiId);
			}
		}).apply(this);
	}

	return ids;
};

rnd.ReStruct.prototype.addConnectedComponent = function (ids) {
	var compId = this.connectedComponents.add(ids);
	var adjacentComponents = Set.empty();
	var atomIds = this.getConnectedComponent(Set.list(ids), adjacentComponents);
	Set.remove(adjacentComponents, compId);
	var type = -1;
	Set.each(atomIds, function (aid) {
		var atom = this.atoms.get(aid);
		atom.component = compId;
		if (atom.a.rxnFragmentType != -1) {
			if (type != -1 && atom.a.rxnFragmentType != type)
				throw new Error('reaction fragment type mismatch');
			type = atom.a.rxnFragmentType;
		}
	}, this);

	this.ccFragmentType.set(compId, type);
	return compId;
};

rnd.ReStruct.prototype.removeConnectedComponent = function (ccid) {
	Set.each(this.connectedComponents.get(ccid), function (aid) {
		this.atoms.get(aid).component = -1;
	}, this);
	return this.connectedComponents.remove(ccid);
};

rnd.ReStruct.prototype.connectedComponentMergeIn = function (ccid, set) {
	Set.each(set, function (aid) {
		this.atoms.get(aid).component = ccid;
	}, this);
	Set.mergeIn(this.connectedComponents.get(ccid), set);
};

rnd.ReStruct.prototype.assignConnectedComponents = function () {
	this.atoms.each(function (aid,atom){
		if (atom.component >= 0)
			return;
		var adjacentComponents = Set.empty();
		var ids = this.getConnectedComponent(aid, adjacentComponents);
		Set.each(adjacentComponents, function (ccid){
			this.removeConnectedComponent(ccid);
		}, this);
		this.addConnectedComponent(ids);
	}, this);
};

rnd.ReStruct.prototype.connectedComponentGetBoundingBox = function (ccid, cc, bb) {
	cc = cc || this.connectedComponents.get(ccid);
	bb = bb || {'min':null, 'max':null};
	Set.each(cc, function (aid) {
		var ps = this.render.ps(this.atoms.get(aid).a.pp);
		if (bb.min == null) {
			bb.min = bb.max = ps;
		} else {
			bb.min = bb.min.min(ps);
			bb.max = bb.max.max(ps);
		}
	}, this);
	return bb;
};

rnd.ReStruct.prototype.initLayers = function () {
	for (var group in rnd.ReStruct.layerMap)
		this.layers[rnd.ReStruct.layerMap[group]] =
		this.render.paper.rect(0, 0, 10, 10)
		.attr({
			'fill':'#000',
			'opacity':'0.0'
		}).toFront();
};

rnd.ReStruct.prototype.insertInLayer = function (lid, path) {
	path.insertBefore(this.layers[lid]);
};

rnd.ReStruct.prototype.clearMarks = function () {
	for (var map in rnd.ReStruct.maps) {
		this[map + 'Changed'] = {};
	}
	this.structChanged = false;
};

rnd.ReStruct.prototype.markItemRemoved = function () {
	this.structChanged = true;
};

rnd.ReStruct.prototype.markBond = function (bid, mark) {
	this.markItem('bonds', bid, mark);
};

rnd.ReStruct.prototype.markAtom = function (aid, mark) {
	this.markItem('atoms', aid, mark);
};

rnd.ReStruct.prototype.markItem = function (map, id, mark) {
	var mapChanged = this[map + 'Changed'];
	mapChanged[id] = (typeof(mapChanged[id]) != 'undefined') ?
		Math.max(mark, mapChanged[id]) : mark;
	if (this[map].has(id))
		this.clearVisel(this[map].get(id).visel);
};

rnd.ReStruct.prototype.eachVisel = function (func, context) {
	for (var map in rnd.ReStruct.maps) {
		this[map].each(function (id, item) {
			func.call(context, item.visel);
		}, this);
	}
};

rnd.ReStruct.prototype.getVBoxObj = function (selection)
{
	selection = selection || {};
	if (this.selectionIsEmpty(selection)) {
		for (var map in rnd.ReStruct.maps) {
			selection[map] = this[map].keys();
		}
	}
	var vbox = null;
	for (var map in rnd.ReStruct.maps) {
		if (selection[map]) {
			util.each(selection[map], function (id) {
				var box = this[map].get(id).getVBoxObj(this.render);
				if (box)
					vbox = vbox ? Box2Abs.union(vbox, box) : box.clone();
			}, this);
		}
	}
	vbox = vbox || new Box2Abs(0, 0, 0, 0);
	return vbox;
};

rnd.ReStruct.prototype.selectionIsEmpty = function (selection) {
	util.assert(!util.isUndefined(selection), '\'selection\' is not defined');
	if (util.isNull(selection))
		return true;
	for (var map in rnd.ReStruct.maps)
		if (selection[map] && selection[map].length > 0)
			return false;
	return true;
}

rnd.ReStruct.prototype.translate = function (d) {
	this.eachVisel(function (visel){
		visel.translate(d);
	}, this);
};

rnd.ReStruct.prototype.scale = function (s) {
	// NOTE: bounding boxes are not valid after scaling
	this.eachVisel(function (visel){
		this.scaleVisel(visel, s);
	}, this);
};

rnd.ReStruct.prototype.scaleRPath = function (path, s) {
	if (path.type == 'set') { // TODO: rework scaling
		for (var i = 0; i < path.length; ++i)
			this.scaleRPath(path[i], s);
	} else {
		if (!Object.isUndefined(path.attrs)) {
			if ('font-size' in path.attrs)
				path.attr('font-size', path.attrs['font-size'] * s);
			else if ('stroke-width' in path.attrs)
				path.attr('stroke-width', path.attrs['stroke-width'] * s);
		}
		path.scale(s, s, 0, 0);
	}
};

rnd.ReStruct.prototype.scaleVisel = function (visel, s) {
	for (var i = 0; i < visel.paths.length; ++i)
		this.scaleRPath(visel.paths[i], s);
};

rnd.ReStruct.prototype.clearVisels = function () {
	this.eachVisel(function (visel){
		this.clearVisel(visel);
	}, this);
};

rnd.ReStruct.prototype.findIncomingStereoUpBond = function (atom, bid0, includeBoldStereoBond) {
	return util.findIndex(atom.neighbors, function (hbid) {
		var hb = this.molecule.halfBonds.get(hbid);
		var bid = hb.bid;
		if (bid === bid0)
			return false;
		var neibond = this.bonds.get(bid);
		if (neibond.b.type === Bond.PATTERN.TYPE.SINGLE && neibond.b.stereo === Bond.PATTERN.STEREO.UP)
			return neibond.b.end === hb.begin || (neibond.boldStereo && includeBoldStereoBond);
		if (neibond.b.type === Bond.PATTERN.TYPE.DOUBLE && neibond.b.stereo === Bond.PATTERN.STEREO.NONE && includeBoldStereoBond && neibond.boldStereo)
			return true;
		return false;
	}, this);
}

rnd.ReStruct.prototype.checkStereoBold = function (bid0, bond) {
	var halfbonds = util.map([bond.b.begin, bond.b.end], function (aid) {
		var atom = this.molecule.atoms.get(aid);
		var pos =  this.findIncomingStereoUpBond(atom, bid0, false);
		return pos < 0 ? -1 : atom.neighbors[pos];
	}, this);
	util.assert(halfbonds.length === 2);
	bond.boldStereo = halfbonds[0] >= 0 && halfbonds[1] >= 0;
};

rnd.ReStruct.prototype.findIncomingUpBonds = function (bid0, bond) {
	var halfbonds = util.map([bond.b.begin, bond.b.end], function (aid) {
		var atom = this.molecule.atoms.get(aid);
		var pos =  this.findIncomingStereoUpBond(atom, bid0, true);
		return pos < 0 ? -1 : atom.neighbors[pos];
	}, this);
	util.assert(halfbonds.length === 2);
	bond.neihbid1 = this.atoms.get(bond.b.begin).showLabel ? -1 : halfbonds[0];
	bond.neihbid2 = this.atoms.get(bond.b.end).showLabel ? -1 : halfbonds[1];
};

rnd.ReStruct.prototype.checkStereoBoldBonds = function () {
	this.bonds.each(this.checkStereoBold, this);
};

rnd.ReStruct.prototype.update = function (force)
{
	force = force || !this.initialized;

	// check items to update
	var id;
	if (force) {
		(function (){
			for (var map in rnd.ReStruct.maps) {
				var mapChanged = this[map + 'Changed'];
				this[map].each(function (id){
					mapChanged[id] = 1;
				}, this);
			}
		}).call(this);
	} else {
		// check if some of the items marked are already gone
		(function (){
			for (var map in rnd.ReStruct.maps) {
				var mapChanged = this[map + 'Changed'];
				for (id in mapChanged)
					if (!this[map].has(id))
						delete mapChanged[id];
			}
		}).call(this);
	}
	for (id in this.atomsChanged)
		this.connectedComponentRemoveAtom(id);

	// clean up empty fragments
	// TODO: fragment removal should be triggered by the action responsible for the fragment contents removal and form an operation of its own
	var emptyFrags = this.frags.findAll(function (fid, frag) {
		return !frag.calcBBox(this.render, fid);
	}, this);
	for (var j = 0; j < emptyFrags.length; ++j) {
		var fid = emptyFrags[j];
		this.clearVisel(this.frags.get(fid).visel);
		this.frags.unset(fid);
		this.molecule.frags.remove(fid);
	}

	(function (){
		for (var map in rnd.ReStruct.maps) {
			var mapChanged = this[map + 'Changed'];
			for (id in mapChanged) {
				this.clearVisel(this[map].get(id).visel);
				this.structChanged |= mapChanged[id] > 0;
			}
		}
	}).call(this);
	if (this.structChanged)
		util.each(this.render.structChangeHandlers, function (handler){handler.call();});

	// TODO: when to update sgroup?
	this.sgroups.each(function (sid, sgroup){
		this.clearVisel(sgroup.visel);
		sgroup.highlighting = null;
		sgroup.selectionPlate = null;
	}, this);

	// TODO [RB] need to implement update-on-demand for fragments and r-groups
	this.frags.each(function (frid, frag) {
		this.clearVisel(frag.visel);
	}, this);
	this.rgroups.each(function (rgid, rgroup) {
		this.clearVisel(rgroup.visel);
	}, this);

	if (force) { // clear and recreate all half-bonds
		this.clearConnectedComponents();
		this.molecule.initHalfBonds();
		this.molecule.initNeighbors();
	}

	// only update half-bonds adjacent to atoms that have moved
	this.molecule.updateHalfBonds(new Map(this.atomsChanged).findAll(function (aid, status){ return status >= 0; }, this));
	this.molecule.sortNeighbors(new Map(this.atomsChanged).findAll(function (aid, status){ return status >= 1; }, this));
	this.assignConnectedComponents();
	this.setImplicitHydrogen();
	this.setHydrogenPos();
	this.initialized = true;

	this.verifyLoops();
	var updLoops = force || this.structChanged;
	if (updLoops)
		this.updateLoops();
	this.setDoubleBondShift();
	this.checkLabelsToShow();
	this.checkStereoBoldBonds();
	this.showLabels();
	this.showBonds();
	if (updLoops)
		this.renderLoops();
	this.drawReactionSymbols();
	this.drawSGroups();
	this.drawFragments();
	this.drawRGroups();
	this.chiralFlags.each(function (id, item) {
		if (this.chiralFlagsChanged[id] > 0)
			item.draw(this.render);
	}, this);
	this.clearMarks();
	return true;
};

rnd.ReStruct.prototype.drawReactionSymbols = function ()
{
	var item;
	var id;
	for (id in this.rxnArrowsChanged) {
		item = this.rxnArrows.get(id);
		this.drawReactionArrow(id, item);
	}
	for (id in this.rxnPlusesChanged) {
		item = this.rxnPluses.get(id);
		this.drawReactionPlus(id, item);
	}
};

rnd.ReStruct.prototype.drawReactionArrow = function (id, item)
{
	var centre = this.render.ps(item.item.pp);
	var path = this.drawArrow(new Vec2(centre.x - this.render.scale, centre.y), new Vec2(centre.x + this.render.scale, centre.y));
	item.visel.add(path, Box2Abs.fromRelBox(util.relBox(path.getBBox())));
	var offset = this.render.offset;
	if (offset != null)
		path.translateAbs(offset.x, offset.y);
};

rnd.ReStruct.prototype.drawReactionPlus = function (id, item)
{
	var centre = this.render.ps(item.item.pp);
	var path = this.drawPlus(centre);
	item.visel.add(path, Box2Abs.fromRelBox(util.relBox(path.getBBox())));
	var offset = this.render.offset;
	if (offset != null)
		path.translateAbs(offset.x, offset.y);
};

rnd.ReStruct.prototype.drawSGroups = function ()
{
	util.each(this.molecule.sGroupForest.getSGroupsBFS().reverse(), function (id) {
		var sgroup = this.sgroups.get(id);
		var path = sgroup.draw(this.render);
		this.addReObjectPath('data', sgroup.visel, path, null, true);
		sgroup.setHighlight(sgroup.highlight, this.render); // TODO: fix this
	}, this);
};

rnd.ReStruct.prototype.drawFragments = function () {
	this.frags.each(function (id, frag) {
		var path = frag.draw(this.render, id);
		if (path) this.addReObjectPath('data', frag.visel, path, null, true);
		// TODO fragment selection & highlighting
	}, this);
};

rnd.ReStruct.prototype.drawRGroups = function () {
	this.rgroups.each(function (id, rgroup) {
		var drawing = rgroup.draw(this.render);
		for (var group in drawing) {
			while (drawing[group].length > 0) {
				this.addReObjectPath(group, rgroup.visel, drawing[group].shift(), null, true);
			}
		}
		// TODO rgroup selection & highlighting
	}, this);
};

rnd.ReStruct.prototype.eachCC = function (func, type, context) {
	this.connectedComponents.each(function (ccid, cc) {
		if (!type || this.ccFragmentType.get(ccid) == type)
			func.call(context || this, ccid, cc);
	}, this);
};

rnd.ReStruct.prototype.getGroupBB = function (type)
{
	var bb = {'min':null, 'max':null};

	this.eachCC(function (ccid, cc) {
		bb = this.connectedComponentGetBoundingBox(ccid, cc, bb);
	}, type, this);

	return bb;
};

rnd.ReStruct.prototype.setHydrogenPos = function () {
	// check where should the hydrogen be put on the left of the label
	for (var aid in this.atomsChanged) {
		var atom = this.atoms.get(aid);

		if (atom.a.neighbors.length == 0) {
			var elem = element.getElementByLabel(atom.a.label);
			if (elem != null) {
				atom.hydrogenOnTheLeft = element.get(elem).putHydrogenOnTheLeft;
			}
			continue;
		}
		var yl = 1, yr = 1, nl = 0, nr = 0;
		for (var i = 0; i < atom.a.neighbors.length; ++i) {
			var d = this.molecule.halfBonds.get(atom.a.neighbors[i]).dir;
			if (d.x <= 0) {
				yl = Math.min(yl, Math.abs(d.y));
				nl++;
			} else {
				yr = Math.min(yr, Math.abs(d.y));
				nr++;
			}
		}
		if (yl < 0.51 || yr < 0.51)
			atom.hydrogenOnTheLeft = yr < yl;
		else
			atom.hydrogenOnTheLeft = nr > nl;
	}
};

rnd.ReStruct.prototype.setImplicitHydrogen = function () {
	// calculate implicit hydrogens for atoms that have been modified
	this.molecule.setImplicitHydrogen(util.idList(this.atomsChanged));
};

rnd.ReLoop = function (loop)
{
	this.loop = loop;
	this.visel = new Visel(Visel.TYPE.LOOP);
	this.centre = new Vec2();
	this.radius = new Vec2();
};
rnd.ReLoop.prototype = new rnd.ReObject();
rnd.ReLoop.isSelectable = function () { return false; }

rnd.ReStruct.prototype.coordProcess = function (norescale)
{
	if (!norescale) {
		this.molecule.rescale();
	}
};

rnd.ReStruct.prototype.notifyAtomAdded = function (aid) {
	var atomData = new ReAtom(this.molecule.atoms.get(aid));
	atomData.component = this.connectedComponents.add(Set.single(aid));
	this.atoms.set(aid, atomData);
	this.markAtom(aid, 1);
};

rnd.ReStruct.prototype.notifyRxnPlusAdded = function (plid) {
	this.rxnPluses.set(plid, new rnd.ReRxnPlus(this.molecule.rxnPluses.get(plid)));
};

rnd.ReStruct.prototype.notifyRxnArrowAdded = function (arid) {
	this.rxnArrows.set(arid, new rnd.ReRxnArrow(this.molecule.rxnArrows.get(arid)));
};

rnd.ReStruct.prototype.notifyRxnArrowRemoved = function (arid) {
	this.markItemRemoved();
	this.clearVisel(this.rxnArrows.get(arid).visel);
	this.rxnArrows.unset(arid);
};

rnd.ReStruct.prototype.notifyRxnPlusRemoved = function (plid) {
	this.markItemRemoved();
	this.clearVisel(this.rxnPluses.get(plid).visel);
	this.rxnPluses.unset(plid);
};

rnd.ReStruct.prototype.notifyBondAdded = function (bid) {
	this.bonds.set(bid, new ReBond(this.molecule.bonds.get(bid)));
	this.markBond(bid, 1);
};

rnd.ReStruct.prototype.notifyAtomRemoved = function (aid) {
	var atom = this.atoms.get(aid);
	var set = this.connectedComponents.get(atom.component);
	Set.remove(set, aid);
	if (Set.size(set) == 0) {
		this.connectedComponents.remove(atom.component);
	}
	this.clearVisel(atom.visel);
	this.atoms.unset(aid);
	this.markItemRemoved();
};

rnd.ReStruct.prototype.notifyBondRemoved = function (bid) {
	var bond = this.bonds.get(bid);
	[bond.b.hb1, bond.b.hb2].each(function (hbid) {
		var hb = this.molecule.halfBonds.get(hbid);
		if (hb.loop >= 0)
			this.loopRemove(hb.loop);
	}, this);
	this.clearVisel(bond.visel);
	this.bonds.unset(bid);
	this.markItemRemoved();
};

rnd.ReStruct.prototype.loopRemove = function (loopId)
{
	if (!this.reloops.has(loopId))
		return;
	var reloop = this.reloops.get(loopId);
	this.clearVisel(reloop.visel);
	var bondlist = [];
	for (var i = 0; i < reloop.loop.hbs.length; ++i) {
		var hbid = reloop.loop.hbs[i];
		if (!this.molecule.halfBonds.has(hbid))
			continue;
		var hb = this.molecule.halfBonds.get(hbid);
		hb.loop = -1;
		this.markBond(hb.bid, 1);
		this.markAtom(hb.begin, 1);
		bondlist.push(hb.bid);
	}
	this.reloops.unset(loopId);
	this.molecule.loops.remove(loopId);
};

rnd.ReStruct.prototype.loopIsValid = function (rlid, reloop) {
	var halfBonds = this.molecule.halfBonds;
	var loop = reloop.loop;
	var bad = false;
	loop.hbs.each(function (hbid){
		if (!halfBonds.has(hbid) || halfBonds.get(hbid).loop !== rlid) {
			bad = true;
		}
	}, this);
	return !bad;
};

rnd.ReStruct.prototype.verifyLoops = function ()
{
	var toRemove = [];
	this.reloops.each(function (rlid, reloop){
		if (!this.loopIsValid(rlid, reloop)) {
			toRemove.push(rlid);
		}
	}, this);
	for (var i = 0; i < toRemove.length; ++i) {
		this.loopRemove(toRemove[i]);
	}
};

rnd.ReStruct.prototype.BFS = function (onAtom, orig, context) {
	orig = orig - 0;
	var queue = new Array();
	var mask = {};
	queue.push(orig);
	mask[orig] = 1;
	while (queue.length > 0) {
		var aid = queue.shift();
		onAtom.call(context, aid);
		var atom = this.atoms.get(aid);
		for (var i = 0; i < atom.a.neighbors.length; ++i) {
			var nei = atom.a.neighbors[i];
			var hb = this.molecule.halfBonds.get(nei);
			if (!mask[hb.end]) {
				mask[hb.end] = 1;
				queue.push(hb.end);
			}
		}
	}
};

rnd.ReRxnPlus = function (/*chem.RxnPlus*/plus)
{
	this.init(Visel.TYPE.PLUS);

	this.item = plus;
};
rnd.ReRxnPlus.prototype = new rnd.ReObject();
rnd.ReRxnPlus.isSelectable = function () { return true; }

rnd.ReRxnPlus.prototype.highlightPath = function (render) {
	var p = render.ps(this.item.pp);
	var s = render.settings.scaleFactor;
	return render.paper.rect(p.x - s / 4, p.y - s / 4, s / 2, s / 2, s / 8);
};

rnd.ReRxnPlus.prototype.drawHighlight = function (render) {
	var ret = this.highlightPath(render).attr(render.styles.highlightStyle);
	render.ctab.addReObjectPath('highlighting', this.visel, ret);
	return ret;
};

rnd.ReRxnPlus.prototype.makeSelectionPlate = function (restruct, paper, styles) { // TODO [MK] review parameters
	return this.highlightPath(restruct.render).attr(styles.selectionStyle);
};

rnd.ReRxnArrow = function (/*chem.RxnArrow*/arrow)
{
	this.init(Visel.TYPE.ARROW);

	this.item = arrow;
};
rnd.ReRxnArrow.prototype = new rnd.ReObject();
rnd.ReRxnArrow.isSelectable = function () { return true; }

rnd.ReRxnArrow.prototype.highlightPath = function (render) {
	var p = render.ps(this.item.pp);
	var s = render.settings.scaleFactor;
	return render.paper.rect(p.x - s, p.y - s / 4, 2 * s, s / 2, s / 8);
};

rnd.ReRxnArrow.prototype.drawHighlight = function (render) {
	var ret = this.highlightPath(render).attr(render.styles.highlightStyle);
	render.ctab.addReObjectPath('highlighting', this.visel, ret);
	return ret;
};

rnd.ReRxnArrow.prototype.makeSelectionPlate = function (restruct, paper, styles) {
	return this.highlightPath(restruct.render).attr(styles.selectionStyle);
};

rnd.ReFrag = function (/*Struct.Fragment*/frag) {
	this.init(Visel.TYPE.FRAGMENT);

	this.item = frag;
};
rnd.ReFrag.prototype = new rnd.ReObject();
rnd.ReFrag.isSelectable = function () { return false; };


rnd.ReFrag.prototype.fragGetAtoms = function (render, fid) {
	var ret = [];
	render.ctab.atoms.each(function (aid, atom) {
		if (atom.a.fragment == fid) {
			ret.push(aid);
		}
	}, this);
	return ret;
};

rnd.ReFrag.prototype.fragGetBonds = function (render, fid) {
	var ret = [];
	render.ctab.bonds.each(function (bid, bond) {
		if (render.ctab.atoms.get(bond.b.begin).a.fragment == fid &&
		render.ctab.atoms.get(bond.b.end).a.fragment == fid) {
			ret.push(bid);
		}
	}, this);
	return ret;
};

rnd.ReFrag.prototype.calcBBox = function (render, fid) { // TODO need to review parameter list
	var ret;
	render.ctab.atoms.each(function (aid, atom) {
		if (atom.a.fragment == fid) {
			// TODO ReObject.calcBBox to be used instead
			var bba = atom.visel.boundingBox;
			if (!bba) {
				bba = new Box2Abs(atom.a.pp, atom.a.pp);
				var ext = new Vec2(0.05 * 3, 0.05 * 3);
				bba = bba.extend(ext, ext);
			} else {
				bba = bba.translate((render.offset || new Vec2()).negated()).transform(render.scaled2obj, render);
			}
			ret = (ret ? Box2Abs.union(ret, bba) : bba);
		}
	}, this);
	return ret;
};

rnd.ReFrag.prototype._draw = function (render, fid, attrs) { // TODO need to review parameter list
	var bb = this.calcBBox(render, fid);
	if (bb) {
		var p0 = render.obj2scaled(new Vec2(bb.p0.x, bb.p0.y));
		var p1 = render.obj2scaled(new Vec2(bb.p1.x, bb.p1.y));
		return render.paper.rect(p0.x, p0.y, p1.x - p0.x, p1.y - p0.y, 0).attr(attrs);
	} else {
		// TODO abnormal situation, empty fragments must be destroyed by tools
	}
};

rnd.ReFrag.prototype.draw = function (render) {
	return null;//this._draw(render, fid, { 'stroke' : 'lightgray' }); // [RB] for debugging only
};

rnd.ReFrag.prototype.drawHighlight = function (render) {
	// Do nothing. This method shouldn't actually be called.
}

rnd.ReFrag.prototype.setHighlight = function (highLight, render) {
	var fid = render.ctab.frags.keyOf(this);
	if (!Object.isUndefined(fid)) {
		render.ctab.atoms.each(function (aid, atom) {
			if (atom.a.fragment == fid) {
				atom.setHighlight(highLight, render);
			}
		}, this);
		render.ctab.bonds.each(function (bid, bond) {
			if (render.ctab.atoms.get(bond.b.begin).a.fragment == fid)
				bond.setHighlight(highLight, render);
		}, this);
	} else {
		// TODO abnormal situation, fragment does not belong to the render
	}
};

rnd.ReRGroup = function (/*Struct.RGroup*/rgroup) {
	this.init(Visel.TYPE.RGROUP);

	this.labelBox = null;
	this.item = rgroup;
};
rnd.ReRGroup.prototype = new rnd.ReObject();
rnd.ReRGroup.isSelectable = function () { return false; }

rnd.ReRGroup.prototype.getAtoms = function (render) {
	var ret = [];
	this.item.frags.each(function (fnum, fid) {
		ret = ret.concat(render.ctab.frags.get(fid).fragGetAtoms(render, fid));
	});
	return ret;
};

rnd.ReRGroup.prototype.getBonds = function (render) {
	var ret = [];
	this.item.frags.each(function (fnum, fid) {
		ret = ret.concat(render.ctab.frags.get(fid).fragGetBonds(render, fid));
	});
	return ret;
};

rnd.ReRGroup.prototype.calcBBox = function (render) {
	var ret;
	this.item.frags.each(function (fnum, fid) {
		var bbf = render.ctab.frags.get(fid).calcBBox(render, fid);
		if (bbf) {
			ret = (ret ? Box2Abs.union(ret, bbf) : bbf);
		}
	});
	ret = ret.extend(this.__ext, this.__ext);
	return ret;
};

rnd.ReRGroup.drawBrackets = function (set, render, bb, d, n) {
	d = d || new Vec2(1, 0);
	var bracketWidth = Math.min(0.25, bb.sz().x * 0.3);
	var height = bb.p1.y - bb.p0.y;
	var cy = 0.5 * (bb.p1.y + bb.p0.y);
	var leftBracket = SGroup.drawBracket(render, render.paper, render.styles, d.negated(), d.negated().rotateSC(1, 0), new Vec2(bb.p0.x, cy), bracketWidth, height);
	var rightBracket = SGroup.drawBracket(render, render.paper, render.styles, d, d.rotateSC(1, 0), new Vec2(bb.p1.x, cy), bracketWidth, height);
	set.push(leftBracket, rightBracket);
};

rnd.ReRGroup.prototype.draw = function (render) { // TODO need to review parameter list
	var bb = this.calcBBox(render);
	var settings = render.settings;
	if (bb) {
		var ret = { 'data': [] };
		var p0 = render.obj2scaled(bb.p0);
		var p1 = render.obj2scaled(bb.p1);
		var brackets = render.paper.set();
		rnd.ReRGroup.drawBrackets(brackets, render, bb);
		ret.data.push(brackets);
		var key = render.ctab.rgroups.keyOf(this);
		var labelSet = render.paper.set();
		var label = render.paper.text(p0.x, (p0.y + p1.y) / 2, 'R' + key + '=')
		.attr({
			'font': settings.font,
			'font-size': settings.fontRLabel,
			'fill': 'black'
		});
		var labelBox = util.relBox(label.getBBox());
		label.translateAbs(-labelBox.width / 2 - settings.lineWidth, 0);
		labelSet.push(label);
		var logicStyle = {
			'font': settings.font,
			'font-size': settings.fontRLogic,
			'fill': 'black'
		};

		var logic = [];
		// TODO [RB] temporary solution, need to review
		//BEGIN
		/*
         if (this.item.range.length > 0)
         logic.push(this.item.range);
         if (this.item.resth)
         logic.push("RestH");
         if (this.item.ifthen > 0)
         logic.push("IF R" + key.toString() + " THEN R" + this.item.ifthen.toString());
         */
		logic.push(
			(this.item.ifthen > 0 ? 'IF ' : '')
			 + 'R' + key.toString()
			 + (this.item.range.length > 0
			 ? this.item.range.startsWith('>') || this.item.range.startsWith('<') || this.item.range.startsWith('=')
				 ? this.item.range
				 : '=' + this.item.range
			 : '>0')
			 + (this.item.resth ? ' (RestH)' : '')
			 + (this.item.ifthen > 0 ? '\nTHEN R' + this.item.ifthen.toString() : '')
		);
		//END
		var shift = labelBox.height / 2 + settings.lineWidth / 2;
		for (var i = 0; i < logic.length; ++i) {
			var logicPath = render.paper.text(p0.x, (p0.y + p1.y) / 2, logic[i]).attr(logicStyle);
			var logicBox = util.relBox(logicPath.getBBox());
			shift += logicBox.height / 2;
			logicPath.translateAbs(-logicBox.width / 2 - 6 * settings.lineWidth, shift);
			shift += logicBox.height / 2 + settings.lineWidth / 2;
			ret.data.push(logicPath);
			labelSet.push(logicPath);
		}
		ret.data.push(label);
		this.labelBox = Box2Abs.fromRelBox(labelSet.getBBox()).transform(render.scaled2obj, render);
		return ret;
	} else {
		// TODO abnormal situation, empty fragments must be destroyed by tools
		return {};
	}
};

rnd.ReRGroup.prototype._draw = function (render, rgid, attrs) { // TODO need to review parameter list
	var bb = this.getVBoxObj(render).extend(this.__ext, this.__ext);
	if (bb) {
		var p0 = render.obj2scaled(bb.p0);
		var p1 = render.obj2scaled(bb.p1);
		return render.paper.rect(p0.x, p0.y, p1.x - p0.x, p1.y - p0.y, 0).attr(attrs);
	}
};

rnd.ReRGroup.prototype.drawHighlight = function (render) {
	var rgid = render.ctab.rgroups.keyOf(this);
	if (!Object.isUndefined(rgid)) {
		var ret = this._draw(render, rgid, render.styles.highlightStyle/*{ 'fill' : 'red' }*/);
		render.ctab.addReObjectPath('highlighting', this.visel, ret);
		/*
         this.getAtoms(render).each(function(aid) {
         render.ctab.atoms.get(aid).drawHighlight(render);
         }, this);
         */
		this.item.frags.each(function (fnum, fid) {
			render.ctab.frags.get(fid).drawHighlight(render);
		}, this);
		return ret;
	} else {
		// TODO abnormal situation, fragment does not belong to the render
	}
};

rnd.ReSGroup = function (sgroup) {
	this.init(Visel.TYPE.SGROUP);

	this.item = sgroup;
};
rnd.ReSGroup.prototype = new rnd.ReObject();
rnd.ReSGroup.isSelectable = function () { return false; }

rnd.ReSGroup.prototype.draw = function (render) { // TODO need to review parameter list
	return this.item.draw(render.ctab);
};

rnd.ReSGroup.prototype.drawHighlight = function (render) {
	var styles = render.styles;
	var settings = render.settings;
	var paper = render.paper;
	var sg = this.item;
	var bb = sg.bracketBox.transform(render.obj2scaled, render);
	var lw = settings.lineWidth;
	var vext = new Vec2(lw * 4, lw * 6);
	bb = bb.extend(vext, vext);
	var d = sg.bracketDir, n = d.rotateSC(1,0);
	var a0 = Vec2.lc2(d, bb.p0.x, n, bb.p0.y);
	var a1 = Vec2.lc2(d, bb.p0.x, n, bb.p1.y);
	var b0 = Vec2.lc2(d, bb.p1.x, n, bb.p0.y);
	var b1 = Vec2.lc2(d, bb.p1.x, n, bb.p1.y);

	var set = paper.set();
	sg.highlighting = paper
	.path('M{0},{1}L{2},{3}L{4},{5}L{6},{7}L{0},{1}', tfx(a0.x), tfx(a0.y), tfx(a1.x), tfx(a1.y), tfx(b1.x), tfx(b1.y), tfx(b0.x), tfx(b0.y))
	.attr(styles.highlightStyle);
	set.push(sg.highlighting);

	SGroup.getAtoms(render.ctab.molecule, sg).each(function (aid) {
		set.push(render.ctab.atoms.get(aid).makeHighlightPlate(render));
	}, this);
	SGroup.getBonds(render.ctab.molecule, sg).each(function (bid) {
		set.push(render.ctab.bonds.get(bid).makeHighlightPlate(render));
	}, this);
	render.ctab.addReObjectPath('highlighting', this.visel, set);
};

rnd.ReDataSGroupData = function (sgroup)
{
	this.init(Visel.TYPE.SGROUP_DATA);

	this.sgroup = sgroup;
};

rnd.ReDataSGroupData.prototype = new rnd.ReObject();
rnd.ReDataSGroupData.isSelectable = function () { return true; }

rnd.ReDataSGroupData.prototype.highlightPath = function (render) {
	var box = this.sgroup.dataArea;
	var p0 = render.obj2scaled(box.p0);
	var sz = render.obj2scaled(box.p1).sub(p0);
	return render.paper.rect(p0.x, p0.y, sz.x, sz.y);
};

rnd.ReDataSGroupData.prototype.drawHighlight = function (render) {
	var ret = this.highlightPath(render).attr(render.styles.highlightStyle);
	render.ctab.addReObjectPath('highlighting', this.visel, ret);
	return ret;
};

rnd.ReDataSGroupData.prototype.makeSelectionPlate = function (restruct, paper, styles) { // TODO [MK] review parameters
	return this.highlightPath(restruct.render).attr(styles.selectionStyle);
};

rnd.ReChiralFlag = function (pos)
{
	this.init(Visel.TYPE.CHIRAL_FLAG);

	this.pp = pos;
};
rnd.ReChiralFlag.prototype = new rnd.ReObject();
rnd.ReChiralFlag.isSelectable = function () { return true; }

rnd.ReChiralFlag.prototype.highlightPath = function (render) {
	var box = Box2Abs.fromRelBox(this.path.getBBox());
	var sz = box.p1.sub(box.p0);
	var p0 = box.p0.sub(render.offset);
	return render.paper.rect(p0.x, p0.y, sz.x, sz.y);
};

rnd.ReChiralFlag.prototype.drawHighlight = function (render) {
	var ret = this.highlightPath(render).attr(render.styles.highlightStyle);
	render.ctab.addReObjectPath('highlighting', this.visel, ret);
	return ret;
};

rnd.ReChiralFlag.prototype.makeSelectionPlate = function (restruct, paper, styles) {
	return this.highlightPath(restruct.render).attr(styles.selectionStyle);
};

rnd.ReChiralFlag.prototype.draw = function (render) {
	var paper = render.paper;
	var settings = render.settings;
	var ps = render.ps(this.pp);
	this.path = paper.text(ps.x, ps.y, 'Chiral')
	.attr({
		'font': settings.font,
		'font-size': settings.fontsz,
		'fill': '#000'
	});
	render.ctab.addReObjectPath('data', this.visel, this.path, null, true);
};

rnd.ReStruct.maps = {
	'atoms':       ReAtom,
	'bonds':       ReBond,
	'rxnPluses':   rnd.ReRxnPlus,
	'rxnArrows':   rnd.ReRxnArrow,
	'frags':       rnd.ReFrag,
	'rgroups':     rnd.ReRGroup,
	'sgroupData':  rnd.ReDataSGroupData,
	'chiralFlags': rnd.ReChiralFlag,
	'sgroups':     rnd.ReSGroup,
	'reloops':     rnd.ReLoop
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../chem/bond":9,"../chem/element":12,"../chem/sgroup":15,"../chem/struct":18,"../util":40,"../util/box2abs":39,"../util/map":41,"../util/pool":42,"../util/set":43,"../util/vec2":44,"./visel":26}],25:[function(require,module,exports){
(function (global){
var Box2Abs = require('../util/box2abs');
var Vec2 = require('../util/vec2');
var util = require('../util');
var element = require('../chem/element');
var Bond = require('../chem/bond');

require('./restruct');
var rnd = global.rnd = global.rnd || {}; // jshint ignore:line
var tfx = util.tfx;

rnd.ReStruct.prototype.drawArrow = function (a, b)
{
	var width = 5, length = 7;
	var paper = this.render.paper;
	var styles = this.render.styles;
	return paper.path('M{0},{1}L{2},{3}L{4},{5}M{2},{3}L{4},{6}', tfx(a.x), tfx(a.y), tfx(b.x), tfx(b.y), tfx(b.x - length), tfx(b.y - width), tfx(b.y + width))
	.attr(styles.lineattr);
};

rnd.ReStruct.prototype.drawPlus = function (c)
{
	var s = this.render.scale / 5;
	var paper = this.render.paper;
	var styles = this.render.styles;
	return paper.path('M{0},{4}L{0},{5}M{2},{1}L{3},{1}', tfx(c.x), tfx(c.y), tfx(c.x - s), tfx(c.x + s), tfx(c.y - s), tfx(c.y + s))
	.attr(styles.lineattr);
};

rnd.ReStruct.prototype.drawBondSingle = function (hb1, hb2)
{
	var a = hb1.p, b = hb2.p;
	var paper = this.render.paper;
	var styles = this.render.styles;
	return paper.path(rnd.ReStruct.makeStroke(a, b))
	.attr(styles.lineattr);
};

rnd.ReStruct.prototype.drawBondSingleUp = function (hb1, hb2, bond)
{
	var a = hb1.p, b = hb2.p, n = hb1.norm;
	var settings = this.render.settings;
	var paper = this.render.paper;
	var styles = this.render.styles;
	var bsp = 0.7 * settings.bondSpace;
	var b2 = b.addScaled(n, bsp);
	var b3 = b.addScaled(n, -bsp);
	if (bond.neihbid2 >= 0) { // if the end is shared with another up-bond heading this way
		var coords = this.stereoUpBondGetCoordinates(hb2, bond.neihbid2);
		b2 = coords[0];
		b3 = coords[1];
	}
	return paper.path('M{0},{1}L{2},{3}L{4},{5}Z',
	tfx(a.x), tfx(a.y), tfx(b2.x), tfx(b2.y), tfx(b3.x), tfx(b3.y))
	.attr(styles.lineattr).attr({
		'fill':'#000'
	});
};

rnd.ReStruct.prototype.drawVec = function (a, dir, color, len) {
	var settings = this.render.settings;
	var paper = this.render.paper;
	var styles = this.render.styles;
	var bsp = settings.bondSpace;
	var b = a.addScaled(dir, len || 3 * bsp);
	return paper.path('M{0},{1}L{2},{3}',
	tfx(a.x), tfx(a.y), tfx(b.x), tfx(b.y))
	.attr(styles.lineattr).attr({
		'stroke':(color || '#0F0')
	});
};

rnd.ReStruct.prototype.stereoUpBondGetCoordinates = function (hb, neihbid)
{
	var bsp = this.render.settings.bondSpace;
	var neihb = this.molecule.halfBonds.get(neihbid);
	var cos = Vec2.dot(hb.dir, neihb.dir);
	var sin = Vec2.cross(hb.dir, neihb.dir);
	var cosHalf = Math.sqrt(0.5 * (1 - cos));
	var biss = neihb.dir.rotateSC((sin >= 0 ? -1 : 1) * cosHalf, Math.sqrt(0.5 * (1 + cos)));

	var denom_add = 0.3;
	var scale = 0.7;
	var a1 = hb.p.addScaled(biss, scale * bsp / (cosHalf + denom_add));
	var a2 = hb.p.addScaled(biss.negated(), scale * bsp / (cosHalf + denom_add));
	return sin > 0 ? [a1, a2] : [a2, a1];
};

rnd.ReStruct.prototype.drawBondSingleStereoBold = function (hb1, hb2, bond, isDouble)
{
	var paper = this.render.paper;
	var settings = this.render.settings;
	var styles = this.render.styles;
	var coords1 = this.stereoUpBondGetCoordinates(hb1, bond.neihbid1);
	var coords2 = this.stereoUpBondGetCoordinates(hb2, bond.neihbid2);
	var a1 = coords1[0];
	var a2 = coords1[1];
	var a3 = coords2[0];
	var a4 = coords2[1];
	var pathMain = paper.path('M{0},{1}L{2},{3}L{4},{5}L{6},{7}Z',
	tfx(a1.x), tfx(a1.y), tfx(a2.x), tfx(a2.y), tfx(a3.x), tfx(a3.y), tfx(a4.x), tfx(a4.y))
	.attr(styles.lineattr).attr({
		'stroke': '#000',
		'fill': '#000'
	});
	if (isDouble) {
		var a = hb1.p, b = hb2.p, n = hb1.norm, shift = bond.doubleBondShift;
		var bsp = 1.5 * settings.bondSpace;
		var b1 = a.addScaled(n, bsp * shift);
		var b2 = b.addScaled(n, bsp * shift);
		var shiftA = !this.atoms.get(hb1.begin).showLabel;
		var shiftB = !this.atoms.get(hb2.begin).showLabel;
		if (shift > 0) {
			if (shiftA)
				b1 = b1.addScaled(hb1.dir, bsp * this.getBondLineShift(hb1.rightCos, hb1.rightSin));
			if (shiftB)
				b2 = b2.addScaled(hb1.dir, -bsp * this.getBondLineShift(hb2.leftCos, hb2.leftSin));
		} else if (shift < 0) {
			if (shiftA)
				b1 = b1.addScaled(hb1.dir, bsp * this.getBondLineShift(hb1.leftCos, hb1.leftSin));
			if (shiftB)
				b2 = b2.addScaled(hb1.dir, -bsp * this.getBondLineShift(hb2.rightCos, hb2.rightSin));
		}

		return paper.set([pathMain, paper.path(
				'M{0},{1}L{2},{3}', tfx(b1.x), tfx(b1.y), tfx(b2.x), tfx(b2.y))
			.attr(styles.lineattr)]);
	}
	return pathMain;
};

rnd.ReStruct.prototype.drawBondSingleDown = function (hb1, hb2)
{
	var a = hb1.p, b = hb2.p, n = hb1.norm;
	var settings = this.render.settings;
	var paper = this.render.paper;
	var styles = this.render.styles;
	var bsp = 0.7 * settings.bondSpace;
	var d = b.sub(a);
	var len = d.length() + 0.2;
	d = d.normalized();
	var interval = 1.2 * settings.lineWidth;
	var nlines = Math.max(Math.floor((len - settings.lineWidth) /
	(settings.lineWidth + interval)),0) + 2;
	var step = len / (nlines - 1);

	var path = '', p, q, r = a;
	for (var i = 0; i < nlines; ++i) {
		r = a.addScaled(d, step * i);
		p = r.addScaled(n, bsp * (i + 0.5) / (nlines - 0.5));
		q = r.addScaled(n, -bsp * (i + 0.5) / (nlines - 0.5));
		path += rnd.ReStruct.makeStroke(p, q);
	}
	return paper.path(path)
	.attr(styles.lineattr);
};

rnd.ReStruct.prototype.drawBondSingleEither = function (hb1, hb2)
{
	var a = hb1.p, b = hb2.p, n = hb1.norm;
	var settings = this.render.settings;
	var paper = this.render.paper;
	var styles = this.render.styles;
	var bsp = 0.7 * settings.bondSpace;
	var d = b.sub(a);
	var len = d.length();
	d = d.normalized();
	var interval = 0.6 * settings.lineWidth;
	var nlines = Math.max(Math.floor((len - settings.lineWidth) /
	(settings.lineWidth + interval)),0) + 2;
	var step = len / (nlines - 0.5);

	var path = 'M' + tfx(a.x) + ',' + tfx(a.y), r = a;
	for (var i = 0; i < nlines; ++i) {
		r = a.addScaled(d, step * (i + 0.5)).addScaled(n,
			((i & 1) ? -1 : +1) * bsp * (i + 0.5) / (nlines - 0.5));
		path += 'L' + tfx(r.x) + ',' + tfx(r.y);
	}
	return paper.path(path)
	.attr(styles.lineattr);
};

rnd.ReStruct.prototype.getBondLineShift = function (cos, sin)
{
	if (sin < 0 || Math.abs(cos) > 0.9)
		return 0;
	return sin / (1 - cos);
};

rnd.ReStruct.prototype.drawBondDouble = function (hb1, hb2, bond, cis_trans)
{
	var a = hb1.p, b = hb2.p, n = hb1.norm, shift = cis_trans ? 0 : bond.doubleBondShift;
	var settings = this.render.settings;
	var paper = this.render.paper;
	var styles = this.render.styles;
	var bsp = settings.bondSpace / 2;
	var s1 = bsp, s2 = -bsp;
	s1 += shift * bsp;
	s2 += shift * bsp;
	var a2 = a.addScaled(n, s1);
	var b2 = b.addScaled(n, s1);
	var a3 = a.addScaled(n, s2);
	var b3 = b.addScaled(n, s2);

	var shiftA = !this.atoms.get(hb1.begin).showLabel;
	var shiftB = !this.atoms.get(hb2.begin).showLabel;
	if (shift > 0) {
		if (shiftA)
			a2 = a2.addScaled(hb1.dir, settings.bondSpace *
			this.getBondLineShift(hb1.rightCos, hb1.rightSin));
		if (shiftB)
			b2 = b2.addScaled(hb1.dir, -settings.bondSpace *
			this.getBondLineShift(hb2.leftCos, hb2.leftSin));
	} else if (shift < 0) {
		if (shiftA)
			a3 = a3.addScaled(hb1.dir, settings.bondSpace *
			this.getBondLineShift(hb1.leftCos, hb1.leftSin));
		if (shiftB)
			b3 = b3.addScaled(hb1.dir, -settings.bondSpace *
			this.getBondLineShift(hb2.rightCos, hb2.rightSin));
	}

	return paper.path(cis_trans ?
			'M{0},{1}L{6},{7}M{4},{5}L{2},{3}' :
			'M{0},{1}L{2},{3}M{4},{5}L{6},{7}',
	tfx(a2.x), tfx(a2.y), tfx(b2.x), tfx(b2.y), tfx(a3.x), tfx(a3.y), tfx(b3.x), tfx(b3.y))
	.attr(styles.lineattr);
};

rnd.ReStruct.makeStroke = function (a, b) {
	return 'M' + tfx(a.x) + ',' + tfx(a.y) +
		'L' + tfx(b.x) + ',' + tfx(b.y) + '	';
};

rnd.ReStruct.prototype.drawBondSingleOrDouble = function (hb1, hb2)
{
	var a = hb1.p, b = hb2.p, n = hb1.norm;
	var render = this.render;
	var settings = render.settings;
	var paper = render.paper;
	var styles = render.styles;
	var bsp = settings.bondSpace / 2;

	var nSect = (Vec2.dist(a, b) / (settings.bondSpace + settings.lineWidth)).toFixed() - 0;
	if (!(nSect & 1))
		nSect += 1;
	var path = '', pp = a;

	for (var i = 1; i <= nSect; ++i) {
		var pi = Vec2.lc2(a, (nSect - i) / nSect, b, i / nSect);
		if (i & 1) {
			path += rnd.ReStruct.makeStroke(pp, pi);
		} else {
			path += rnd.ReStruct.makeStroke(pp.addScaled(n, bsp), pi.addScaled(n, bsp));
			path += rnd.ReStruct.makeStroke(pp.addScaled(n, -bsp), pi.addScaled(n, -bsp));
		}
		pp = pi;
	}

	return paper.path(path)
	.attr(styles.lineattr);
};

rnd.ReStruct.prototype.drawBondTriple = function (hb1, hb2)
{
	var a = hb1.p, b = hb2.p, n = hb1.norm;
	var render = this.render;
	var settings = render.settings;
	var paper = render.paper;
	var styles = render.styles;
	var a2 = a.addScaled(n, settings.bondSpace);
	var b2 = b.addScaled(n, settings.bondSpace);
	var a3 = a.addScaled(n, -settings.bondSpace);
	var b3 = b.addScaled(n, -settings.bondSpace);
	return paper.path(rnd.ReStruct.makeStroke(a,b) + rnd.ReStruct.makeStroke(a2,b2) + rnd.ReStruct.makeStroke(a3,b3))
	.attr(styles.lineattr);
};

rnd.dashedPath = function (p0, p1, dash) {
	var t0 = 0;
	var t1 = Vec2.dist(p0, p1);
	var d = Vec2.diff(p1, p0).normalized();
	var black = true;
	var path = '';
	var i = 0;

	while (t0 < t1) {
		var len = dash[i % dash.length];
		var t2 = t0 + Math.min(len, t1 - t0);
		if (black)
			path += 'M ' + p0.addScaled(d, t0).coordStr() + ' L ' + p0.addScaled(d, t2).coordStr();
		t0 += len;
		black = !black;
		i++;
	}
	return path;
}

rnd.ReStruct.prototype.drawBondAromatic = function (hb1, hb2, bond, drawDashLine)
{
	if (!drawDashLine) {
		return this.drawBondSingle(hb1, hb2);
	}
	var shift = bond.doubleBondShift;
	var paper = this.render.paper;
	var paths = this.preparePathsForAromaticBond(hb1, hb2, shift);
	var l1 = paths[0], l2 = paths[1];
	(shift > 0 ? l1 : l2).attr({
		'stroke-dasharray':'- '
	});
	return paper.set([l1,l2]);
};

rnd.dashdotPattern = [0.125,0.125,0.005,0.125];

rnd.ReStruct.prototype.drawBondSingleOrAromatic = function (hb1, hb2, bond)
{
	var shift = bond.doubleBondShift;
	var paper = this.render.paper;
	var scale = this.render.settings.scaleFactor;
	var dash = util.map(rnd.dashdotPattern, function (v){ return v * scale; });
	var paths = this.preparePathsForAromaticBond(hb1, hb2, shift, shift > 0 ? 1 : 2, dash);
	var l1 = paths[0], l2 = paths[1];
// dotted line doesn't work in Chrome, render manually instead (see rnd.dashedPath)
//	(shift > 0 ? l1 : l2).attr({
//		'stroke-dasharray':'-.'
//	});
	return paper.set([l1,l2]);
};

rnd.ReStruct.prototype.preparePathsForAromaticBond = function (hb1, hb2, shift, mask, dash)
{
	var settings = this.render.settings;
	var paper = this.render.paper;
	var styles = this.render.styles;
	var a = hb1.p, b = hb2.p, n = hb1.norm;
	var bsp = settings.bondSpace / 2;
	var s1 = bsp, s2 = -bsp;
	s1 += shift * bsp;
	s2 += shift * bsp;
	var a2 = a.addScaled(n, s1);
	var b2 = b.addScaled(n, s1);
	var a3 = a.addScaled(n, s2);
	var b3 = b.addScaled(n, s2);
	var shiftA = !this.atoms.get(hb1.begin).showLabel;
	var shiftB = !this.atoms.get(hb2.begin).showLabel;
	if (shift > 0) {
		if (shiftA)
			a2 = a2.addScaled(hb1.dir, settings.bondSpace *
			this.getBondLineShift(hb1.rightCos, hb1.rightSin));
		if (shiftB)
			b2 = b2.addScaled(hb1.dir, -settings.bondSpace *
			this.getBondLineShift(hb2.leftCos, hb2.leftSin));
	} else if (shift < 0) {
		if (shiftA)
			a3 = a3.addScaled(hb1.dir, settings.bondSpace *
			this.getBondLineShift(hb1.leftCos, hb1.leftSin));
		if (shiftB)
			b3 = b3.addScaled(hb1.dir, -settings.bondSpace *
			this.getBondLineShift(hb2.rightCos, hb2.rightSin));
	}
	var l1 = paper.path(dash && (mask & 1) ? rnd.dashedPath(a2, b2, dash) : rnd.ReStruct.makeStroke(a2, b2)).attr(styles.lineattr);
	var l2 = paper.path(dash && (mask & 2) ? rnd.dashedPath(a3, b3, dash) : rnd.ReStruct.makeStroke(a3, b3)).attr(styles.lineattr);
	return [l1, l2];
};


rnd.ReStruct.prototype.drawBondDoubleOrAromatic = function (hb1, hb2, bond)
{
	var shift = bond.doubleBondShift;
	var paper = this.render.paper;
	var scale = this.render.settings.scaleFactor;
	var dash = util.map(rnd.dashdotPattern, function (v){ return v * scale; });
	var paths = this.preparePathsForAromaticBond(hb1, hb2, shift, 3, dash);
	var l1 = paths[0], l2 = paths[1];
// dotted line doesn't work in Chrome, render manually instead (see rnd.dashedPath)
//	l1.attr({'stroke-dasharray':'-.'});
//	l2.attr({'stroke-dasharray':'-.'});
	return paper.set([l1,l2]);
};

rnd.ReStruct.prototype.drawBondAny = function (hb1, hb2)
{
	var a = hb1.p, b = hb2.p;
	var paper = this.render.paper;
	var styles = this.render.styles;
	return paper.path(rnd.ReStruct.makeStroke(a,b))
	.attr(styles.lineattr).attr({
		'stroke-dasharray':'- '
	});
};

rnd.ReStruct.prototype.drawReactingCenter = function (bond, hb1, hb2)
{
	var a = hb1.p, b = hb2.p;
	var c = b.add(a).scaled(0.5);
	var d = b.sub(a).normalized();
	var n = d.rotateSC(1, 0);

	var paper = this.render.paper;
	var styles = this.render.styles;
	var settings = this.render.settings;

	var p = [];

	var lw = settings.lineWidth, bs = settings.bondSpace / 2;
	var alongIntRc = lw, // half interval along for CENTER
	alongIntMadeBroken = 2 * lw, // half interval between along for MADE_OR_BROKEN
	alongSz = 1.5 * bs, // half size along for CENTER
	acrossInt = 1.5 * bs, // half interval across for CENTER
	acrossSz = 3.0 * bs, // half size across for all
	tiltTan = 0.2; // tangent of the tilt angle

	switch (bond.b.reactingCenterStatus)
		{
		case Bond.PATTERN.REACTING_CENTER.NOT_CENTER: // X
			p.push(c.addScaled(n, acrossSz).addScaled(d, tiltTan * acrossSz));
			p.push(c.addScaled(n, -acrossSz).addScaled(d, -tiltTan * acrossSz));
			p.push(c.addScaled(n, acrossSz).addScaled(d, -tiltTan * acrossSz));
			p.push(c.addScaled(n, -acrossSz).addScaled(d, tiltTan * acrossSz));
			break;
		case Bond.PATTERN.REACTING_CENTER.CENTER:  // #
			p.push(c.addScaled(n, acrossSz).addScaled(d, tiltTan * acrossSz).addScaled(d, alongIntRc));
			p.push(c.addScaled(n, -acrossSz).addScaled(d, -tiltTan * acrossSz).addScaled(d, alongIntRc));
			p.push(c.addScaled(n, acrossSz).addScaled(d, tiltTan * acrossSz).addScaled(d, -alongIntRc));
			p.push(c.addScaled(n, -acrossSz).addScaled(d, -tiltTan * acrossSz).addScaled(d, -alongIntRc));
			p.push(c.addScaled(d, alongSz).addScaled(n, acrossInt));
			p.push(c.addScaled(d, -alongSz).addScaled(n, acrossInt));
			p.push(c.addScaled(d, alongSz).addScaled(n, -acrossInt));
			p.push(c.addScaled(d, -alongSz).addScaled(n, -acrossInt));
			break;
//	case Bond.PATTERN.REACTING_CENTER.UNCHANGED:  // o
//		//draw a circle
//		break;
		case Bond.PATTERN.REACTING_CENTER.MADE_OR_BROKEN:
			p.push(c.addScaled(n, acrossSz).addScaled(d, alongIntMadeBroken));
			p.push(c.addScaled(n, -acrossSz).addScaled(d, alongIntMadeBroken));
			p.push(c.addScaled(n, acrossSz).addScaled(d, -alongIntMadeBroken));
			p.push(c.addScaled(n, -acrossSz).addScaled(d, -alongIntMadeBroken));
			break;
		case Bond.PATTERN.REACTING_CENTER.ORDER_CHANGED:
			p.push(c.addScaled(n, acrossSz));
			p.push(c.addScaled(n, -acrossSz));
			break;
		case Bond.PATTERN.REACTING_CENTER.MADE_OR_BROKEN_AND_CHANGED:
			p.push(c.addScaled(n, acrossSz).addScaled(d, alongIntMadeBroken));
			p.push(c.addScaled(n, -acrossSz).addScaled(d, alongIntMadeBroken));
			p.push(c.addScaled(n, acrossSz).addScaled(d, -alongIntMadeBroken));
			p.push(c.addScaled(n, -acrossSz).addScaled(d, -alongIntMadeBroken));
			p.push(c.addScaled(n, acrossSz));
			p.push(c.addScaled(n, -acrossSz));
			break;
		default:
			return null;
	}

	var pathdesc = '';
	for (var i = 0; i < p.length / 2; ++i)
		pathdesc += rnd.ReStruct.makeStroke(p[2 * i], p[2 * i + 1]);
	return paper.path(pathdesc).attr(styles.lineattr);
};

rnd.ReStruct.prototype.drawTopologyMark = function (bond, hb1, hb2)
{
	var topologyMark = null;

	if (bond.b.topology == Bond.PATTERN.TOPOLOGY.RING)
		topologyMark = 'rng';
	else if (bond.b.topology == Bond.PATTERN.TOPOLOGY.CHAIN)
		topologyMark = 'chn';
	else
		return null;

	var paper = this.render.paper;
	var settings = this.render.settings;

	var a = hb1.p, b = hb2.p;
	var c = b.add(a).scaled(0.5);
	var d = b.sub(a).normalized();
	var n = d.rotateSC(1, 0);
	var fixed = settings.lineWidth;
	if (bond.doubleBondShift > 0)
		n = n.scaled(-bond.doubleBondShift);
	else if (bond.doubleBondShift == 0)
		fixed += settings.bondSpace / 2;

	var s = new Vec2(2, 1).scaled(settings.bondSpace);
	if (bond.b.type == Bond.PATTERN.TYPE.TRIPLE)
		fixed += settings.bondSpace;
	var p = c.add(new Vec2(n.x * (s.x + fixed), n.y * (s.y + fixed)));
	var path = paper.text(p.x, p.y, topologyMark)
	.attr({
		'font': settings.font,
		'font-size': settings.fontszsub,
		'fill': '#000'
	});
	var rbb = util.relBox(path.getBBox());
	this.centerText(path, rbb);
	return path;
};

rnd.ReStruct.prototype.drawBond = function (bond, hb1, hb2)
{
	var path = null;
	var molecule = this.molecule;
	switch (bond.b.type)
		{
		case Bond.PATTERN.TYPE.SINGLE:
			switch (bond.b.stereo) {
				case Bond.PATTERN.STEREO.UP:
					this.findIncomingUpBonds(hb1.bid, bond);
					if (bond.boldStereo && bond.neihbid1 >= 0 && bond.neihbid2 >= 0)
						path = this.drawBondSingleStereoBold(hb1, hb2, bond);
					else
						path = this.drawBondSingleUp(hb1, hb2, bond);
					break;
				case Bond.PATTERN.STEREO.DOWN:
					path = this.drawBondSingleDown(hb1, hb2, bond);
					break;
				case Bond.PATTERN.STEREO.EITHER:
					path = this.drawBondSingleEither(hb1, hb2, bond);
					break;
				default:
					path = this.drawBondSingle(hb1, hb2);
					break;
			}
			break;
		case Bond.PATTERN.TYPE.DOUBLE:
			this.findIncomingUpBonds(hb1.bid, bond);
			if (bond.b.stereo === Bond.PATTERN.STEREO.NONE && bond.boldStereo
				 && bond.neihbid1 >= 0 && bond.neihbid2 >= 0)
				path = this.drawBondSingleStereoBold(hb1, hb2, bond, true);
			else
				path = this.drawBondDouble(hb1, hb2, bond,
				bond.b.stereo === Bond.PATTERN.STEREO.CIS_TRANS);
			break;
		case Bond.PATTERN.TYPE.TRIPLE:
			path = this.drawBondTriple(hb1, hb2, bond);
			break;
		case Bond.PATTERN.TYPE.AROMATIC:
			var inAromaticLoop = (hb1.loop >= 0 && molecule.loops.get(hb1.loop).aromatic) ||
			(hb2.loop >= 0 && molecule.loops.get(hb2.loop).aromatic);
			path = this.drawBondAromatic(hb1, hb2, bond, !inAromaticLoop);
			break;
		case Bond.PATTERN.TYPE.SINGLE_OR_DOUBLE:
			path = this.drawBondSingleOrDouble(hb1, hb2, bond);
			break;
		case Bond.PATTERN.TYPE.SINGLE_OR_AROMATIC:
			path = this.drawBondSingleOrAromatic(hb1, hb2, bond);
			break;
		case Bond.PATTERN.TYPE.DOUBLE_OR_AROMATIC:
			path = this.drawBondDoubleOrAromatic(hb1, hb2, bond);
			break;
		case Bond.PATTERN.TYPE.ANY:
			path = this.drawBondAny(hb1, hb2, bond);
			break;
		default:
			throw new Error('Bond type ' + bond.b.type + ' not supported');
	}
	return path;
};

rnd.ReStruct.prototype.radicalCap = function (p)
{
	var settings = this.render.settings;
	var paper = this.render.paper;
	var s = settings.lineWidth * 0.9;
	var dw = s, dh = 2 * s;
	return paper.path('M{0},{1}L{2},{3}L{4},{5}',
	tfx(p.x - dw), tfx(p.y + dh), tfx(p.x), tfx(p.y), tfx(p.x + dw), tfx(p.y + dh))
	.attr({
		'stroke': '#000',
		'stroke-width': settings.lineWidth * 0.7,
		'stroke-linecap': 'square',
		'stroke-linejoin': 'miter'
	});
};

rnd.ReStruct.prototype.radicalBullet = function (p)
{
	var settings = this.render.settings;
	var paper = this.render.paper;
	return paper.circle(p.x, p.y, settings.lineWidth)
	.attr({
		stroke: null,
		fill: '#000'
	});
};

rnd.ReStruct.prototype.centerText = function (path, rbb)
{
	// TODO: find a better way
	if (this.render.paper.raphael.vml) {
		this.pathAndRBoxTranslate(path, rbb, 0, rbb.height * 0.16); // dirty hack
	}
};

rnd.ReStruct.prototype.showItemSelection = function (id, item, visible)
{
	var exists = (item.selectionPlate != null) && !item.selectionPlate.removed;
	// rbalabanov: here is temporary fix for "drag issue" on iPad
	//BEGIN
	exists = exists && (!('hiddenPaths' in rnd.ReStruct.prototype) || rnd.ReStruct.prototype.hiddenPaths.indexOf(item.selectionPlate) < 0);
	//END
	if (visible) {
		if (!exists) {
			var render = this.render;
			var styles = render.styles;
			var paper = render.paper;
			item.selectionPlate = item.makeSelectionPlate(this, paper, styles);
			this.addReObjectPath('selection-plate', item.visel, item.selectionPlate);
		}
		if (item.selectionPlate) item.selectionPlate.show(); // TODO [RB] review
	} else {
		if (exists)
		if (item.selectionPlate) item.selectionPlate.hide(); // TODO [RB] review
	}
};

rnd.ReStruct.prototype.pathAndRBoxTranslate = function (path, rbb, x, y)
{
	path.translateAbs(x, y);
	rbb.x += x;
	rbb.y += y;
};

var markerColors = ['black', 'cyan', 'magenta', 'red', 'green', 'blue', 'green'];

rnd.ReStruct.prototype.showLabels = function ()
{
	var render = this.render;
	var settings = render.settings;
	var styles = render.styles;
	var opt = render.opt;
	var paper = render.paper;
	var delta = 0.5 * settings.lineWidth;
	for (var aid in this.atomsChanged) {
		var atom = this.atoms.get(aid);

		var ps = render.ps(atom.a.pp);
		var index = null;
		if (opt.showAtomIds) {
			index = {};
			index.text = aid.toString();
			index.path = paper.text(ps.x, ps.y, index.text)
			.attr({
				'font': settings.font,
				'font-size': settings.fontszsub,
				'fill': '#070'
			});
			index.rbb = util.relBox(index.path.getBBox());
			this.centerText(index.path, index.rbb);
			this.addReObjectPath('indices', atom.visel, index.path, ps);
		}
		atom.setHighlight(atom.highlight, render);

		var color = '#000000';
		if (atom.showLabel)
		{
			var rightMargin = 0, leftMargin = 0;
			// label
			var label = {};
			if (atom.a.atomList != null) {
				label.text = atom.a.atomList.label();
			} else if (atom.a.label == 'R#' && atom.a.rglabel != null) {
				label.text = '';
				for (var rgi = 0; rgi < 32; rgi++) {
					if (atom.a.rglabel & (1 << rgi)) label.text += ('R' + (rgi + 1).toString());
				}
				if (label.text == '') label = 'R#'; // for structures that missed 'M  RGP' tag in molfile
			} else {
				label.text = atom.a.label;
				if (opt.atomColoring) {
					var elem = element.getElementByLabel(label.text);
					if (elem)
						color = element.get(elem).color;
				}
			}
			label.path = paper.text(ps.x, ps.y, label.text)
			.attr({
				'font': settings.font,
				'font-size': settings.fontsz,
				'fill': color
			});
			label.rbb = util.relBox(label.path.getBBox());
			this.centerText(label.path, label.rbb);
			if (atom.a.atomList != null)
				this.pathAndRBoxTranslate(label.path, label.rbb, (atom.hydrogenOnTheLeft ? -1 : 1) * (label.rbb.width - label.rbb.height) / 2, 0);
			this.addReObjectPath('data', atom.visel, label.path, ps, true);
			rightMargin = label.rbb.width / 2;
			leftMargin = -label.rbb.width / 2;
			var implh = Math.floor(atom.a.implicitH);
			var isHydrogen = label.text == 'H';
			var hydrogen = {}, hydroIndex = null;
			var hydrogenLeft = atom.hydrogenOnTheLeft;
			if (isHydrogen && implh > 0) {
				hydroIndex = {};
				hydroIndex.text = (implh + 1).toString();
				hydroIndex.path =
				paper.text(ps.x, ps.y, hydroIndex.text)
				.attr({
					'font': settings.font,
					'font-size': settings.fontszsub,
					'fill': color
				});
				hydroIndex.rbb = util.relBox(hydroIndex.path.getBBox());
				this.centerText(hydroIndex.path, hydroIndex.rbb);
				this.pathAndRBoxTranslate(hydroIndex.path, hydroIndex.rbb,
					rightMargin + 0.5 * hydroIndex.rbb.width + delta,
					0.2 * label.rbb.height);
				rightMargin += hydroIndex.rbb.width + delta;
				this.addReObjectPath('data',atom.visel, hydroIndex.path, ps, true);
			}

			var radical = {};
			if (atom.a.radical != 0)
			{
				var hshift;
				switch (atom.a.radical)
					{
					case 1:
						radical.path = paper.set();
						hshift = 1.6 * settings.lineWidth;
						radical.path.push(
						this.radicalBullet(ps.add(new Vec2(-hshift, 0))),
						this.radicalBullet(ps.add(new Vec2(hshift, 0))));
						radical.path.attr('fill', color);
						break;
					case 2:
						radical.path = this.radicalBullet(ps)
						.attr('fill', color);
						break;
					case 3:
						radical.path = paper.set();
						hshift = 1.6 * settings.lineWidth;
						radical.path.push(
						this.radicalCap(ps.add(new Vec2(-hshift, 0))),
						this.radicalCap(ps.add(new Vec2(hshift, 0))));
						radical.path.attr('stroke', color);
						break;
				}
				radical.rbb = util.relBox(radical.path.getBBox());
				var vshift = -0.5 * (label.rbb.height + radical.rbb.height);
				if (atom.a.radical == 3)
					vshift -= settings.lineWidth / 2;
				this.pathAndRBoxTranslate(radical.path, radical.rbb,
					0, vshift);
				this.addReObjectPath('data', atom.visel, radical.path, ps, true);
			}

			var isotope = {};
			if (atom.a.isotope != 0)
			{
				isotope.text = atom.a.isotope.toString();
				isotope.path = paper.text(ps.x, ps.y, isotope.text)
				.attr({
					'font': settings.font,
					'font-size': settings.fontszsub,
					'fill': color
				});
				isotope.rbb = util.relBox(isotope.path.getBBox());
				this.centerText(isotope.path, isotope.rbb);
				this.pathAndRBoxTranslate(isotope.path, isotope.rbb,
					leftMargin - 0.5 * isotope.rbb.width - delta,
					-0.3 * label.rbb.height);
				leftMargin -= isotope.rbb.width + delta;
				this.addReObjectPath('data', atom.visel, isotope.path, ps, true);
			}
			if (!isHydrogen && implh > 0 && !render.opt.hideImplicitHydrogen)
			{
				hydrogen.text = 'H';
				hydrogen.path = paper.text(ps.x, ps.y, hydrogen.text)
				.attr({
					'font': settings.font,
					'font-size': settings.fontsz,
					'fill': color
				});
				hydrogen.rbb = util.relBox(hydrogen.path.getBBox());
				this.centerText(hydrogen.path, hydrogen.rbb);
				if (!hydrogenLeft) {
					this.pathAndRBoxTranslate(hydrogen.path, hydrogen.rbb,
						rightMargin + 0.5 * hydrogen.rbb.width + delta, 0);
					rightMargin += hydrogen.rbb.width + delta;
				}
				if (implh > 1) {
					hydroIndex = {};
					hydroIndex.text = implh.toString();
					hydroIndex.path =
					paper.text(ps.x, ps.y, hydroIndex.text)
					.attr({
						'font': settings.font,
						'font-size': settings.fontszsub,
						'fill': color
					});
					hydroIndex.rbb = util.relBox(hydroIndex.path.getBBox());
					this.centerText(hydroIndex.path, hydroIndex.rbb);
					if (!hydrogenLeft) {
						this.pathAndRBoxTranslate(hydroIndex.path, hydroIndex.rbb,
							rightMargin + 0.5 * hydroIndex.rbb.width + delta,
							0.2 * label.rbb.height);
						rightMargin += hydroIndex.rbb.width + delta;
					}
				}
				if (hydrogenLeft) {
					if (hydroIndex != null) {
						this.pathAndRBoxTranslate(hydroIndex.path, hydroIndex.rbb,
							leftMargin - 0.5 * hydroIndex.rbb.width - delta,
							0.2 * label.rbb.height);
						leftMargin -= hydroIndex.rbb.width + delta;
					}
					this.pathAndRBoxTranslate(hydrogen.path, hydrogen.rbb,
						leftMargin - 0.5 * hydrogen.rbb.width - delta, 0);
					leftMargin -= hydrogen.rbb.width + delta;
				}
				this.addReObjectPath('data', atom.visel, hydrogen.path, ps, true);
				if (hydroIndex != null)
					this.addReObjectPath('data', atom.visel, hydroIndex.path, ps, true);
			}

			var charge = {};
			if (atom.a.charge != 0)
			{
				charge.text = '';
				var absCharge = Math.abs(atom.a.charge);
				if (absCharge != 1)
					charge.text = absCharge.toString();
				if (atom.a.charge < 0)
					charge.text += '\u2013';
				else
					charge.text += '+';

				charge.path = paper.text(ps.x, ps.y, charge.text)
				.attr({
					'font': settings.font,
					'font-size': settings.fontszsub,
					'fill': color
				});
				charge.rbb = util.relBox(charge.path.getBBox());
				this.centerText(charge.path, charge.rbb);
				this.pathAndRBoxTranslate(charge.path, charge.rbb,
					rightMargin + 0.5 * charge.rbb.width + delta,
					-0.3 * label.rbb.height);
				rightMargin += charge.rbb.width + delta;
				this.addReObjectPath('data', atom.visel, charge.path, ps, true);
			}

			var valence = {};
			var mapValence = {
				0: '0',
				1: 'I',
				2: 'II',
				3: 'III',
				4: 'IV',
				5: 'V',
				6: 'VI',
				7: 'VII',
				8: 'VIII',
				9: 'IX',
				10: 'X',
				11: 'XI',
				12: 'XII',
				13: 'XIII',
				14: 'XIV'
			};
			if (atom.a.explicitValence >= 0)
			{
				valence.text = mapValence[atom.a.explicitValence];
				if (!valence.text)
					throw new Error('invalid valence ' + atom.a.explicitValence.toString());
				valence.text = '(' + valence.text + ')';
				valence.path = paper.text(ps.x, ps.y, valence.text)
				.attr({
					'font': settings.font,
					'font-size': settings.fontszsub,
					'fill': color
				});
				valence.rbb = util.relBox(valence.path.getBBox());
				this.centerText(valence.path, valence.rbb);
				this.pathAndRBoxTranslate(valence.path, valence.rbb,
					rightMargin + 0.5 * valence.rbb.width + delta,
					-0.3 * label.rbb.height);
				rightMargin += valence.rbb.width + delta;
				this.addReObjectPath('data', atom.visel, valence.path, ps, true);
			}

			if (atom.a.badConn && opt.showValenceWarnings) {
				var warning = {};
				var y = ps.y + label.rbb.height / 2 + delta;
				warning.path = paper.path('M{0},{1}L{2},{3}',
				tfx(ps.x + leftMargin), tfx(y), tfx(ps.x + rightMargin), tfx(y))
				.attr(this.render.styles.lineattr)
				.attr({
					'stroke':'#F00'
				});
				warning.rbb = util.relBox(warning.path.getBBox());
				this.addReObjectPath('warnings', atom.visel, warning.path, ps, true);
			}
			if (index)
				this.pathAndRBoxTranslate(index.path, index.rbb,
					-0.5 * label.rbb.width - 0.5 * index.rbb.width - delta,
					0.3 * label.rbb.height);
		}

		var lsb = this.bisectLargestSector(atom);

		var asterisk = Prototype.Browser.IE ? '*' : '∗';
		if (atom.a.attpnt) {
			var i, c, j;
			for (i = 0, c = 0; i < 4; ++i) {
				var attpntText = '';
				if (atom.a.attpnt & (1 << i)) {
					if (attpntText.length > 0)
						attpntText += ' ';
					attpntText += asterisk;
					for (j = 0; j < (i == 0 ? 0 : (i + 1)); ++j) {
						attpntText += '\'';
					}
					var pos0 = new Vec2(ps);
					var pos1 = ps.addScaled(lsb, 0.7 * settings.scaleFactor);

					var attpntPath1 = paper.text(pos1.x, pos1.y, attpntText)
					.attr({
						'font': settings.font,
						'font-size': settings.fontsz,
						'fill': color
					});
					var attpntRbb = util.relBox(attpntPath1.getBBox());
					this.centerText(attpntPath1, attpntRbb);

					var lsbn = lsb.negated();
					pos1 = pos1.addScaled(lsbn, Vec2.shiftRayBox(pos1, lsbn, Box2Abs.fromRelBox(attpntRbb)) + settings.lineWidth / 2);
					pos0 = this.shiftBondEnd(atom, pos0, lsb, settings.lineWidth);
					var n = lsb.rotateSC(1, 0);
					var arrowLeft = pos1.addScaled(n, 0.05 * settings.scaleFactor).addScaled(lsbn, 0.09 * settings.scaleFactor);
					var arrowRight = pos1.addScaled(n, -0.05 * settings.scaleFactor).addScaled(lsbn, 0.09 * settings.scaleFactor);
					var attpntPath = paper.set();
					attpntPath.push(
						attpntPath1,
					paper.path('M{0},{1}L{2},{3}M{4},{5}L{2},{3}L{6},{7}', tfx(pos0.x), tfx(pos0.y), tfx(pos1.x), tfx(pos1.y), tfx(arrowLeft.x), tfx(arrowLeft.y), tfx(arrowRight.x), tfx(arrowRight.y))
					.attr(styles.lineattr).attr({'stroke-width': settings.lineWidth / 2})
					);
					this.addReObjectPath('indices', atom.visel, attpntPath, ps);
					lsb = lsb.rotate(Math.PI / 6);
				}
			}
		}

		var aamText = '';
		if (atom.a.aam > 0) {
			aamText += atom.a.aam;
		}
		if (atom.a.invRet > 0) {
			if (aamText.length > 0)
				aamText += ',';
			if (atom.a.invRet == 1)
				aamText += 'Inv';
			else if (atom.a.invRet == 2)
				aamText += 'Ret';
			else
				throw new Error('Invalid value for the invert/retain flag');
		}

		var queryAttrsText = '';
		if (atom.a.ringBondCount != 0) {
			if (atom.a.ringBondCount > 0)
				queryAttrsText += 'rb' + atom.a.ringBondCount.toString();
			else if (atom.a.ringBondCount == -1)
				queryAttrsText += 'rb0';
			else if (atom.a.ringBondCount == -2)
				queryAttrsText += 'rb*';
			else
				throw new Error('Ring bond count invalid');
		}
		if (atom.a.substitutionCount != 0) {
			if (queryAttrsText.length > 0)
				queryAttrsText += ',';

			if (atom.a.substitutionCount > 0)
				queryAttrsText += 's' + atom.a.substitutionCount.toString();
			else if (atom.a.substitutionCount == -1)
				queryAttrsText += 's0';
			else if (atom.a.substitutionCount == -2)
				queryAttrsText += 's*';
			else
				throw new Error('Substitution count invalid');
		}
		if (atom.a.unsaturatedAtom > 0) {
			if (queryAttrsText.length > 0)
				queryAttrsText += ',';

			if (atom.a.unsaturatedAtom == 1)
				queryAttrsText += 'u';
			else
				throw new Error('Unsaturated atom invalid value');
		}
		if (atom.a.hCount > 0) {
			if (queryAttrsText.length > 0)
				queryAttrsText += ',';

			queryAttrsText += 'H' + (atom.a.hCount - 1).toString();
		}


		if (atom.a.exactChangeFlag > 0) {
			if (aamText.length > 0)
				aamText += ',';
			if (atom.a.exactChangeFlag == 1)
				aamText += 'ext';
			else
				throw new Error('Invalid value for the exact change flag');
		}

		// this includes both aam flags, if any, and query features, if any
		// we render them together to avoid possible collisions
		aamText = (queryAttrsText.length > 0 ? queryAttrsText + '\n' : '') + (aamText.length > 0 ? '.' + aamText + '.' : '');
		if (aamText.length > 0) {
			var aamPath = paper.text(ps.x, ps.y, aamText)
			.attr({
				'font': settings.font,
				'font-size': settings.fontszsub,
				'fill': color
			});
			var aamBox = util.relBox(aamPath.getBBox());
			this.centerText(aamPath, aamBox);
			var dir = this.bisectLargestSector(atom);
			var visel = atom.visel;
			var t = 3;
			// estimate the shift to clear the atom label
			for (i = 0; i < visel.exts.length; ++i)
				t = Math.max(t, Vec2.shiftRayBox(ps, dir, visel.exts[i].translate(ps)));
			// estimate the shift backwards to account for the size of the aam/query text box itself
			t += Vec2.shiftRayBox(ps, dir.negated(), Box2Abs.fromRelBox(aamBox))
			dir = dir.scaled(8 + t);
			this.pathAndRBoxTranslate(aamPath, aamBox, dir.x, dir.y);
			this.addReObjectPath('data', atom.visel, aamPath, ps, true);
		}
	}
};

rnd.ReStruct.prototype.shiftBondEnd = function (atom, pos0, dir, margin){
	var t = 0;
	var visel = atom.visel;
	for (var k = 0; k < visel.exts.length; ++k) {
		var box = visel.exts[k].translate(pos0);
		t = Math.max(t, Vec2.shiftRayBox(pos0, dir, box));
	}
	if (t > 0)
		pos0 = pos0.addScaled(dir, t + margin);
	return pos0;
};

rnd.ReStruct.prototype.bisectLargestSector = function (atom)
{
	var angles = [];
	atom.a.neighbors.each( function (hbid) {
		var hb = this.molecule.halfBonds.get(hbid);
		angles.push(hb.ang);
	}, this);
	angles = angles.sort(function (a,b){return a - b;});
	var da = [];
	for (var i = 0; i < angles.length - 1; ++i) {
		da.push(angles[(i + 1) % angles.length] - angles[i]);
	}
	da.push(angles[0] - angles[angles.length - 1] + 2 * Math.PI);
	var daMax = 0;
	var ang = -Math.PI / 2;
	for (i = 0; i < angles.length; ++i) {
		if (da[i] > daMax) {
			daMax = da[i];
			ang = angles[i] + da[i] / 2;
		}
	}
	return new Vec2(Math.cos(ang), Math.sin(ang));
};

rnd.ReStruct.prototype.bondRecalc = function (settings, bond) {

	var render = this.render;
	var atom1 = this.atoms.get(bond.b.begin);
	var atom2 = this.atoms.get(bond.b.end);
	var p1 = render.ps(atom1.a.pp);
	var p2 = render.ps(atom2.a.pp);
	var hb1 = this.molecule.halfBonds.get(bond.b.hb1);
	var hb2 = this.molecule.halfBonds.get(bond.b.hb2);
	hb1.p = this.shiftBondEnd(atom1, p1, hb1.dir, 2 * settings.lineWidth);
	hb2.p = this.shiftBondEnd(atom2, p2, hb2.dir, 2 * settings.lineWidth);
	bond.b.center = Vec2.lc2(atom1.a.pp, 0.5, atom2.a.pp, 0.5);
	bond.b.len = Vec2.dist(p1, p2);
	bond.b.sb = settings.lineWidth * 5;
	bond.b.sa = Math.max(bond.b.sb,  bond.b.len / 2 - settings.lineWidth * 2);
	bond.b.angle = Math.atan2(hb1.dir.y, hb1.dir.x) * 180 / Math.PI;
};

rnd.ReStruct.prototype.showBonds = function ()
{
	var render = this.render;
	var settings = render.settings;
	var paper = render.paper;
	var opt = render.opt;
	for (var bid in this.bondsChanged) {
		var bond = this.bonds.get(bid);
		var hb1 = this.molecule.halfBonds.get(bond.b.hb1),
		hb2 = this.molecule.halfBonds.get(bond.b.hb2);
		this.bondRecalc(settings, bond);
		bond.path = this.drawBond(bond, hb1, hb2);
		bond.rbb = util.relBox(bond.path.getBBox());
		this.addReObjectPath('data', bond.visel, bond.path, null, true);
		var reactingCenter = {};
		reactingCenter.path = this.drawReactingCenter(bond, hb1, hb2);
		if (reactingCenter.path) {
			reactingCenter.rbb = util.relBox(reactingCenter.path.getBBox());
			this.addReObjectPath('data', bond.visel, reactingCenter.path, null, true);
		}
		var topology = {};
		topology.path = this.drawTopologyMark(bond, hb1, hb2);
		if (topology.path) {
			topology.rbb = util.relBox(topology.path.getBBox());
			this.addReObjectPath('data', bond.visel, topology.path, null, true);
		}
		bond.setHighlight(bond.highlight, render);
		var bondIdxOff = settings.subFontSize * 0.6;
		var ipath = null, irbb = null;
		if (opt.showBondIds) {
			var pb = Vec2.lc(hb1.p, 0.5, hb2.p, 0.5, hb1.norm, bondIdxOff);
			ipath = paper.text(pb.x, pb.y, bid.toString());
			irbb = util.relBox(ipath.getBBox());
			this.centerText(ipath, irbb);
			this.addReObjectPath('indices', bond.visel, ipath);
		}
		if (opt.showHalfBondIds) {
			var phb1 = Vec2.lc(hb1.p, 0.8, hb2.p, 0.2, hb1.norm, bondIdxOff);
			ipath = paper.text(phb1.x, phb1.y, bond.b.hb1.toString());
			irbb = util.relBox(ipath.getBBox());
			this.centerText(ipath, irbb);
			this.addReObjectPath('indices', bond.visel, ipath);
			var phb2 = Vec2.lc(hb1.p, 0.2, hb2.p, 0.8, hb2.norm, bondIdxOff);
			ipath = paper.text(phb2.x, phb2.y, bond.b.hb2.toString());
			irbb = util.relBox(ipath.getBBox());
			this.centerText(ipath, irbb);
			this.addReObjectPath('indices', bond.visel, ipath);
		}
		if (opt.showLoopIds && !opt.showBondIds) {
			var pl1 = Vec2.lc(hb1.p, 0.5, hb2.p, 0.5, hb2.norm, bondIdxOff);
			ipath = paper.text(pl1.x, pl1.y, hb1.loop.toString());
			irbb = util.relBox(ipath.getBBox());
			this.centerText(ipath, irbb);
			this.addReObjectPath('indices', bond.visel, ipath);
			var pl2 = Vec2.lc(hb1.p, 0.5, hb2.p, 0.5, hb1.norm, bondIdxOff);
			ipath = paper.text(pl2.x, pl2.y, hb2.loop.toString());
			irbb = util.relBox(ipath.getBBox());
			this.centerText(ipath, irbb);
			this.addReObjectPath('indices', bond.visel, ipath);
		}
	}
};

rnd.ReStruct.prototype.labelIsVisible = function (aid, atom)
{
	if (atom.a.neighbors.length == 0 ||
		(atom.a.neighbors.length < 2 && !this.render.opt.hideTerminalLabels) ||
	atom.a.label.toLowerCase() != 'c' ||
		(atom.a.badConn && this.render.opt.showValenceWarnings) ||
	atom.a.isotope != 0 ||
	atom.a.radical != 0 ||
	atom.a.charge != 0 ||
	atom.a.explicitValence >= 0 ||
	atom.a.atomList != null ||
	atom.a.rglabel != null)
		return true;
	if (atom.a.neighbors.length == 2) {
		var n1 = atom.a.neighbors[0];
		var n2 = atom.a.neighbors[1];
		var hb1 = this.molecule.halfBonds.get(n1);
		var hb2 = this.molecule.halfBonds.get(n2);
		var b1 = this.bonds.get(hb1.bid);
		var b2 = this.bonds.get(hb2.bid);
		if (b1.b.type == b2.b.type && b1.b.stereo == Bond.PATTERN.STEREO.NONE && b2.b.stereo == Bond.PATTERN.STEREO.NONE)
		if (Math.abs(Vec2.cross(hb1.dir, hb2.dir)) < 0.2)
			return true;
	}
	return false;
};

rnd.ReStruct.prototype.checkLabelsToShow = function ()
{
	for (var aid in this.atomsChanged) {
		var atom = this.atoms.get(aid);
		atom.showLabel = this.labelIsVisible(aid, atom);
	}
};

rnd.ReStruct.layerMap = {
	'background': 0,
	'selection-plate': 1,
	'highlighting': 2,
	'warnings': 3,
	'data': 4,
	'indices': 5
};

rnd.ReStruct.prototype.addReObjectPath = function (group, visel, path, pos, visible) {
	if (!path)
		return;
	var offset = this.render.offset;
	var bb = visible ? Box2Abs.fromRelBox(util.relBox(path.getBBox())) : null;
	var ext = pos && bb ? bb.translate(pos.negated()) : null;
	if (offset !== null) {
		path.translateAbs(offset.x, offset.y);
		bb = bb ? bb.translate(offset) : null;
	}
	visel.add(path, bb, ext);
	this.insertInLayer(rnd.ReStruct.layerMap[group], path);
};

rnd.ReStruct.prototype.clearVisel = function (visel)
{
	for (var i = 0; i < visel.paths.length; ++i)
		visel.paths[i].remove();
	visel.clear();
};

rnd.ReStruct.prototype.selectDoubleBondShift = function (n1, n2, d1, d2) {
	if (n1 == 6 && n2 != 6 && (d1 > 1 || d2 == 1))
		return -1;
	if (n2 == 6 && n1 != 6 && (d2 > 1 || d1 == 1))
		return 1;
	if (n2 * d1 > n1 * d2)
		return -1;
	if (n2 * d1 < n1 * d2)
		return 1;
	if (n2 > n1)
		return -1;
	return 1;
};

rnd.ReStruct.prototype.selectDoubleBondShift_Chain = function (bond) {
	var struct = this.molecule;
	var hb1 = struct.halfBonds.get(bond.b.hb1);
	var hb2 = struct.halfBonds.get(bond.b.hb2);
	var nLeft = (hb1.leftSin > 0.3 ? 1 : 0) + (hb2.rightSin > 0.3 ? 1 : 0);
	var nRight = (hb2.leftSin > 0.3 ? 1 : 0) + (hb1.rightSin > 0.3 ? 1 : 0);
	if (nLeft > nRight)
		return -1;
	if (nLeft < nRight)
		return 1;
	if ((hb1.leftSin > 0.3 ? 1 : 0) + (hb1.rightSin > 0.3 ? 1 : 0) == 1)
		return 1;
	return 0;
};

rnd.ReStruct.prototype.setDoubleBondShift = function ()
{
	var struct = this.molecule;
	// double bonds in loops
	for (var bid in this.bondsChanged) {
		var bond = this.bonds.get(bid);
		var loop1, loop2;
		loop1 = struct.halfBonds.get(bond.b.hb1).loop;
		loop2 = struct.halfBonds.get(bond.b.hb2).loop;
		if (loop1 >= 0 && loop2 >= 0) {
			var d1 = struct.loops.get(loop1).dblBonds;
			var d2 = struct.loops.get(loop2).dblBonds;
			var n1 = struct.loops.get(loop1).hbs.length;
			var n2 = struct.loops.get(loop2).hbs.length;
			bond.doubleBondShift = this.selectDoubleBondShift(n1, n2, d1, d2);
		} else if (loop1 >= 0) {
			bond.doubleBondShift = -1;
		} else if (loop2 >= 0) {
			bond.doubleBondShift = 1;
		} else {
			bond.doubleBondShift = this.selectDoubleBondShift_Chain(bond);
		}
	}
};

rnd.ReStruct.prototype.updateLoops = function ()
{
	this.reloops.each(function (rlid, reloop){
		this.clearVisel(reloop.visel);
	}, this);
	var ret = this.molecule.findLoops();
	util.each(ret.bondsToMark, function (bid) {
		this.markBond(bid, 1);
	}, this);
	util.each(ret.newLoops, function (loopId) {
		this.reloops.set(loopId, new rnd.ReLoop(this.molecule.loops.get(loopId)));
	}, this);
};

rnd.ReStruct.prototype.renderLoops = function ()
{
	var render = this.render;
	var settings = render.settings;
	var paper = render.paper;
	var molecule = this.molecule;
	this.reloops.each(function (rlid, reloop){
		var loop = reloop.loop;
		reloop.centre = new Vec2();
		loop.hbs.each(function (hbid){
			var hb = molecule.halfBonds.get(hbid);
			var bond = this.bonds.get(hb.bid);
			var apos = render.ps(this.atoms.get(hb.begin).a.pp);
			if (bond.b.type != Bond.PATTERN.TYPE.AROMATIC)
				loop.aromatic = false;
			reloop.centre.add_(apos);
		}, this);
		loop.convex = true;
		for (var k = 0; k < reloop.loop.hbs.length; ++k)
		{
			var hba = molecule.halfBonds.get(loop.hbs[k]);
			var hbb = molecule.halfBonds.get(loop.hbs[(k + 1) % loop.hbs.length]);
			var angle = Math.atan2(
			Vec2.cross(hba.dir, hbb.dir),
			Vec2.dot(hba.dir, hbb.dir));
			if (angle > 0)
				loop.convex = false;
		}

		reloop.centre = reloop.centre.scaled(1.0 / loop.hbs.length);
		reloop.radius = -1;
		loop.hbs.each(function (hbid){
			var hb = molecule.halfBonds.get(hbid);
			var apos = render.ps(this.atoms.get(hb.begin).a.pp);
			var bpos = render.ps(this.atoms.get(hb.end).a.pp);
			var n = Vec2.diff(bpos, apos).rotateSC(1, 0).normalized();
			var dist = Vec2.dot(Vec2.diff(apos, reloop.centre), n);
			if (reloop.radius < 0) {
				reloop.radius = dist;
			} else {
				reloop.radius = Math.min(reloop.radius, dist);
			}
		}, this);
		reloop.radius *= 0.7;
		if (!loop.aromatic)
			return;
		var path = null;
		if (loop.convex) {
			path = paper.circle(reloop.centre.x, reloop.centre.y, reloop.radius)
			.attr({
				'stroke': '#000',
				'stroke-width': settings.lineWidth
			});
		} else {
			var pathStr = '';
			for (k = 0; k < loop.hbs.length; ++k)
			{
				hba = molecule.halfBonds.get(loop.hbs[k]);
				hbb = molecule.halfBonds.get(loop.hbs[(k + 1) % loop.hbs.length]);
				angle = Math.atan2(
				Vec2.cross(hba.dir, hbb.dir),
				Vec2.dot(hba.dir, hbb.dir));
				var halfAngle = (Math.PI - angle) / 2;
				var dir = hbb.dir.rotate(halfAngle);
				var pi = render.ps(this.atoms.get(hbb.begin).a.pp);
				var sin = Math.sin(halfAngle);
				var minSin = 0.1;
				if (Math.abs(sin) < minSin)
					sin = sin * minSin / Math.abs(sin);
				var offset = settings.bondSpace / sin;
				var qi = pi.addScaled(dir, -offset);
				pathStr += (k == 0 ? 'M' : 'L');
				pathStr += tfx(qi.x) + ',' + tfx(qi.y);
			}
			pathStr += 'Z';
			path = paper.path(pathStr)
			.attr({
				'stroke': '#000',
				'stroke-width': settings.lineWidth,
				'stroke-dasharray':'- '
			});
		}
		this.addReObjectPath('data', reloop.visel, path, null, true);
	}, this);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../chem/bond":9,"../chem/element":12,"../util":40,"../util/box2abs":39,"../util/vec2":44,"./restruct":24}],26:[function(require,module,exports){
// Visel is a shorthand for VISual ELement
// It corresponds to a visualization (i.e. set of paths) of an atom or a bond.

var Box2Abs = require('../util/box2abs');
var Vec2 = require('../util/vec2');

var Visel = function (type) {
	this.type = type;
	this.paths = [];
	this.boxes = [];
	this.boundingBox = null;
};

Visel.TYPE = {
	'ATOM': 1,
	'BOND': 2,
	'LOOP': 3,
	'ARROW': 4,
	'PLUS': 5,
	'SGROUP': 6,
	'TMP': 7, // [MK] TODO: do we still need it?
	'FRAGMENT': 8,
	'RGROUP': 9,
	'CHIRAL_FLAG': 10
};

Visel.prototype.add = function (path, bb, ext) {
	this.paths.push(path);
	if (bb) {
		this.boxes.push(bb);
		this.boundingBox = this.boundingBox == null ? bb : Box2Abs.union(this.boundingBox, bb);
	}
	if (ext) {
		this.exts.push(ext);
	}
};

Visel.prototype.clear = function () {
	this.paths = [];
	this.boxes = [];
	this.exts = [];
	this.boundingBox = null;
};

Visel.prototype.translate = function (x, y) {
	if (arguments.length > 2) {    // TODO: replace to debug time assert
		throw new Error('One vector or two scalar arguments expected');
	}
	if (y === undefined) {
		this.translate(x.x, x.y);
	} else {
		var delta = new Vec2(x, y);
		for (var i = 0; i < this.paths.length; ++i) {
			this.paths[i].translateAbs(x, y);
		}
		for (var j = 0; j < this.boxes.length; ++j) {
			this.boxes[j] = this.boxes[j].translate(delta);
		}
		if (this.boundingBox !== null) {
			this.boundingBox = this.boundingBox.translate(delta);
		}
	}
};

module.exports = Visel;
},{"../util/box2abs":39,"../util/vec2":44}],27:[function(require,module,exports){
(function (global){
var Set = require('../util/set');
var Vec2 = require('../util/vec2');
var util = require('../util');
var op = require('./op');

var Struct = require('../chem/struct');
var Atom = require('../chem/atom');
var Bond = require('../chem/bond');
var SGroup = require('../chem/sgroup');

var ui = global.ui;

//
// Undo/redo actions
//
function Action ()
{
	this.operations = [];
};

Action.prototype.addOp = function (operation) {
	if (!operation.isDummy(ui.editor))
		this.operations.push(operation);
	return operation;
};

Action.prototype.mergeWith = function (action)
{
	this.operations = this.operations.concat(action.operations);
	return this;
};

// Perform action and return inverted one
Action.prototype.perform = function ()
{
	var action = new Action();
	var idx = 0;

	this.operations.each(function (operation) {
		action.addOp(operation.perform(ui.editor));
		idx++;
	}, this);

	action.operations.reverse();
	return action;
};

Action.prototype.isDummy = function ()
{
	return this.operations.detect(function (operation) {
		return !operation.isDummy(ui.editor); // TODO [RB] the condition is always true for op.* operations
	}, this) == null;
};

// Add action operation to remove atom from s-group if needed
Action.prototype.removeAtomFromSgroupIfNeeded = function (id)
{
	var sgroups = ui.render.atomGetSGroups(id);

	if (sgroups.length > 0)
	{
		sgroups.each(function (sid)
		{
			this.addOp(new op.SGroupAtomRemove(sid, id));
		}, this);

		return true;
	}

	return false;
};

// Add action operations to remove whole s-group if needed
Action.prototype.removeSgroupIfNeeded = function (atoms)
{
	var R = ui.render;
	var RS = R.ctab;
	var DS = RS.molecule;
	var sg_counts = new Hash();

	atoms.each(function (id)
	{
		var sgroups = ui.render.atomGetSGroups(id);

		sgroups.each(function (sid)
		{
			var n = sg_counts.get(sid);
			if (Object.isUndefined(n))
				n = 1;
			else
				n++;
			sg_counts.set(sid, n);
		}, this);
	}, this);

	sg_counts.each(function (sg)
	{
		var sid = parseInt(sg.key);
		var sg_atoms = ui.render.sGroupGetAtoms(sid);

		if (sg_atoms.length == sg.value)
		{ // delete whole s-group
			var sgroup = DS.sgroups.get(sid);
			this.mergeWith(sGroupAttributeAction(sid, sgroup.getAttrs()));
			this.addOp(new op.SGroupRemoveFromHierarchy(sid));
			this.addOp(new op.SGroupDelete(sid));
		}
	}, this);
};

function fromMultipleMove (lists, d)
{
	d = new Vec2(d);

	var action = new Action();
	var i;

	var R = ui.render;
	var RS = R.ctab;
	var DS = RS.molecule;
	var bondlist = [];
	var loops = Set.empty();
	var atomsToInvalidate = Set.empty();

	if (lists.atoms) {
		var atomSet = Set.fromList(lists.atoms);
		RS.bonds.each(function (bid, bond){

			if (Set.contains(atomSet, bond.b.begin) && Set.contains(atomSet, bond.b.end)) {
				bondlist.push(bid);
				// add all adjacent loops
				// those that are not completely inside the structure will get redrawn anyway
				util.each(['hb1','hb2'], function (hb){
					var loop = DS.halfBonds.get(bond.b[hb]).loop;
					if (loop >= 0)
						Set.add(loops, loop);
				}, this);
			}
			else if (Set.contains(atomSet, bond.b.begin))
				Set.add(atomsToInvalidate, bond.b.begin);
			else if (Set.contains(atomSet, bond.b.end))
				Set.add(atomsToInvalidate, bond.b.end);
		}, this);
		for (i = 0; i < bondlist.length; ++i) {
			action.addOp(new op.BondMove(bondlist[i], d));
		}
		Set.each(loops, function (loopId){
			if (RS.reloops.get(loopId) && RS.reloops.get(loopId).visel) // hack
				action.addOp(new op.LoopMove(loopId, d));
		}, this);
		for (i = 0; i < lists.atoms.length; ++i) {
			var aid = lists.atoms[i];
			action.addOp(new op.AtomMove(aid, d, !Set.contains(atomsToInvalidate, aid)));
		}
	}

	if (lists.rxnArrows)
		for (i = 0; i < lists.rxnArrows.length; ++i)
			action.addOp(new op.RxnArrowMove(lists.rxnArrows[i], d, true));

	if (lists.rxnPluses)
		for (i = 0; i < lists.rxnPluses.length; ++i)
			action.addOp(new op.RxnPlusMove(lists.rxnPluses[i], d, true));

	if (lists.sgroupData)
		for (i = 0; i < lists.sgroupData.length; ++i)
			action.addOp(new op.SGroupDataMove(lists.sgroupData[i], d));

	if (lists.chiralFlags)
		for (i = 0; i < lists.chiralFlags.length; ++i)
			action.addOp(new op.ChiralFlagMove(d));

	return action.perform();
};

function fromAtomsAttrs (ids, attrs, reset)
{
	var action = new Action();
	(typeof(ids) == 'number' ? [ids] : ids).each(function (id) {
		for (var key in Atom.attrlist) {
			var value;
			if (key in attrs)
				value = attrs[key];
			else if (reset)
				value = Atom.attrGetDefault(key);
			else
				continue;
			action.addOp(new op.AtomAttr(id, key, value));
		}
		if (!reset && 'label' in attrs && attrs.label != null && attrs.label != 'L#' && !attrs['atomList']) {
			action.addOp(new op.AtomAttr(id, 'atomList', null));
		}
	}, this);
	return action.perform();
};

function fromBondAttrs (id, attrs, flip, reset)
{
	var action = new Action();

	for (var key in Bond.PATTERN.attrlist) {
		var value;
		if (key in attrs)
			value = attrs[key];
		else if (reset)
			value = Bond.PATTERN.attrGetDefault(key);
		else
			continue;
		action.addOp(new op.BondAttr(id, key, value));
	}
	if (flip)
		action.mergeWith(toBondFlipping(id));
	return action.perform();
};

function fromSelectedBondsAttrs (attrs, flips)
{
	var action = new Action();

	attrs = new Hash(attrs);

	ui.editor.getSelection().bonds.each(function (id) {
		attrs.each(function (attr) {
			action.addOp(new op.BondAttr(id, attr.key, attr.value));
		}, this);
	}, this);
	if (flips)
		flips.each(function (id) {
			action.mergeWith(toBondFlipping(id));
		}, this);
	return action.perform();
};

function fromAtomAddition (pos, atom)
{
	atom = Object.clone(atom);
	var action = new Action();
	atom.fragment = action.addOp(new op.FragmentAdd().perform(ui.editor)).frid;
	action.addOp(new op.AtomAdd(atom, pos).perform(ui.editor));
	return action;
};

function mergeFragments (action, frid, frid2) {
	if (frid2 != frid && Object.isNumber(frid2)) {
		var rgid = Struct.RGroup.findRGroupByFragment(ui.render.ctab.molecule.rgroups, frid2);
		if (!Object.isUndefined(rgid)) {
			action.mergeWith(fromRGroupFragment(null, frid2));
		}
		ui.render.ctab.molecule.atoms.each(function (aid, atom) {
			if (atom.fragment == frid2) {
				action.addOp(new op.AtomAttr(aid, 'fragment', frid).perform(ui.editor));
			}
		});
		action.addOp(new op.FragmentDelete(frid2).perform(ui.editor));
	}
};

// Get new atom id/label and pos for bond being added to existing atom
function atomForNewBond (id)
{
	var neighbours = [];
	var pos = ui.render.atomGetPos(id);

	ui.render.atomGetNeighbors(id).each(function (nei)
	{
		var nei_pos = ui.render.atomGetPos(nei.aid);

		if (Vec2.dist(pos, nei_pos) < 0.1)
			return;

		neighbours.push({id: nei.aid, v: Vec2.diff(nei_pos, pos)});
	});

	neighbours.sort(function (nei1, nei2)
	{
		return Math.atan2(nei1.v.y, nei1.v.x) - Math.atan2(nei2.v.y, nei2.v.x);
	});

	var i, max_i = 0;
	var angle, max_angle = 0;

	// TODO: impove layout: tree, ...

	for (i = 0; i < neighbours.length; i++) {
		angle = Vec2.angle(neighbours[i].v, neighbours[(i + 1) % neighbours.length].v);

		if (angle < 0)
			angle += 2 * Math.PI;

		if (angle > max_angle)
			max_i = i, max_angle = angle;
	}

	var v = new Vec2(1, 0);

	if (neighbours.length > 0) {
		if (neighbours.length == 1) {
			max_angle = -(4 * Math.PI / 3);

			// zig-zag
			var nei = ui.render.atomGetNeighbors(id)[0];
			if (ui.render.atomGetDegree(nei.aid) > 1) {
				var nei_neighbours = [];
				var nei_pos = ui.render.atomGetPos(nei.aid);
				var nei_v = Vec2.diff(pos, nei_pos);
				var nei_angle = Math.atan2(nei_v.y, nei_v.x);

				ui.render.atomGetNeighbors(nei.aid).each(function (nei_nei) {
					var nei_nei_pos = ui.render.atomGetPos(nei_nei.aid);

					if (nei_nei.bid == nei.bid || Vec2.dist(nei_pos, nei_nei_pos) < 0.1)
						return;

					var v_diff = Vec2.diff(nei_nei_pos, nei_pos);
					var ang = Math.atan2(v_diff.y, v_diff.x) - nei_angle;

					if (ang < 0)
						ang += 2 * Math.PI;

					nei_neighbours.push(ang);
				});
				nei_neighbours.sort(function (nei1, nei2) {
					return nei1 - nei2;
				});

				if (nei_neighbours[0] <= Math.PI * 1.01 && nei_neighbours[nei_neighbours.length - 1] <= 1.01 * Math.PI)
					max_angle *= -1;

			}
		}

		angle = (max_angle / 2) + Math.atan2(neighbours[max_i].v.y, neighbours[max_i].v.x);

		v = v.rotate(angle);
	}

	v.add_(pos);

	var a = ui.render.findClosestAtom(v, 0.1);

	if (a == null)
		a = {label: 'C'};
	else
		a = a.id;

	return {atom: a, pos: v};
};

function fromBondAddition (bond, begin, end, pos, pos2)
{
	if (end === undefined) {
		var atom = atomForNewBond(begin);
		end = atom.atom;
		pos = atom.pos;
	}
	var action = new Action();

	var frid = null;
	if (!Object.isNumber(begin)) {
		if (Object.isNumber(end)) {
			frid = ui.render.atomGetAttr(end, 'fragment');
		}
	}
	else {
		frid = ui.render.atomGetAttr(begin, 'fragment');
		if (Object.isNumber(end)) {
			var frid2 = ui.render.atomGetAttr(end, 'fragment');
			mergeFragments(action, frid, frid2);
		}
	}
	if (frid == null) {
		frid = action.addOp(new op.FragmentAdd().perform(ui.editor)).frid;
	}

	if (!Object.isNumber(begin)) {
		begin.fragment = frid;
		begin = action.addOp(new op.AtomAdd(begin, pos).perform(ui.editor)).data.aid;

		pos = pos2;
	}
	else {
		if (ui.render.atomGetAttr(begin, 'label') == '*') {
			action.addOp(new op.AtomAttr(begin, 'label', 'C').perform(ui.editor));
		}
	}


	if (!Object.isNumber(end)) {
		end.fragment = frid;
		// TODO: <op>.data.aid here is a hack, need a better way to access the id of a newly created atom
		end = action.addOp(new op.AtomAdd(end, pos).perform(ui.editor)).data.aid;
		if (Object.isNumber(begin)) {
			ui.render.atomGetSGroups(begin).each(function (sid) {
				action.addOp(new op.SGroupAtomAdd(sid, end).perform(ui.editor));
			}, this);
		}
	}
	else {
		if (ui.render.atomGetAttr(end, 'label') == '*') {
			action.addOp(new op.AtomAttr(end, 'label', 'C').perform(ui.editor));
		}
	}

	var bid = action.addOp(new op.BondAdd(begin, end, bond).perform(ui.editor)).data.bid;

	action.operations.reverse();

	return [action, begin, end, bid];
};

function fromArrowAddition (pos)
{
	var action = new Action();
	if (ui.ctab.rxnArrows.count() < 1) {
		action.addOp(new op.RxnArrowAdd(pos).perform(ui.editor));
	}
	return action;
};

function fromArrowDeletion (id)
{
	var action = new Action();
	action.addOp(new op.RxnArrowDelete(id));
	return action.perform();
};

function fromChiralFlagAddition (pos)
{
	var action = new Action();
	if (ui.render.ctab.chiralFlags.count() < 1) {
		action.addOp(new op.ChiralFlagAdd(pos).perform(ui.editor));
	}
	return action;
};

function fromChiralFlagDeletion ()
{
	var action = new Action();
	action.addOp(new op.ChiralFlagDelete());
	return action.perform();
};

function fromPlusAddition (pos)
{
	var action = new Action();
	action.addOp(new op.RxnPlusAdd(pos).perform(ui.editor));
	return action;
};

function fromPlusDeletion (id)
{
	var action = new Action();
	action.addOp(new op.RxnPlusDelete(id));
	return action.perform();
};

function fromAtomDeletion (id)
{
	var action = new Action();
	var atoms_to_remove = new Array();

	var frid = ui.ctab.atoms.get(id).fragment;

	ui.render.atomGetNeighbors(id).each(function (nei)
	{
		action.addOp(new op.BondDelete(nei.bid));// [RB] !!
		if (ui.render.atomGetDegree(nei.aid) == 1)
		{
			if (action.removeAtomFromSgroupIfNeeded(nei.aid))
				atoms_to_remove.push(nei.aid);

			action.addOp(new op.AtomDelete(nei.aid));
		}
	}, this);

	if (action.removeAtomFromSgroupIfNeeded(id))
		atoms_to_remove.push(id);

	action.addOp(new op.AtomDelete(id));

	action.removeSgroupIfNeeded(atoms_to_remove);

	action = action.perform();

	action.mergeWith(fromFragmentSplit(frid));

	return action;
};

function fromBondDeletion (id)
{
	var action = new Action();
	var bond = ui.ctab.bonds.get(id);
	var frid = ui.ctab.atoms.get(bond.begin).fragment;
	var atoms_to_remove = new Array();

	action.addOp(new op.BondDelete(id));

	if (ui.render.atomGetDegree(bond.begin) == 1)
	{
		if (action.removeAtomFromSgroupIfNeeded(bond.begin))
			atoms_to_remove.push(bond.begin);

		action.addOp(new op.AtomDelete(bond.begin));
	}

	if (ui.render.atomGetDegree(bond.end) == 1)
	{
		if (action.removeAtomFromSgroupIfNeeded(bond.end))
			atoms_to_remove.push(bond.end);

		action.addOp(new op.AtomDelete(bond.end));
	}

	action.removeSgroupIfNeeded(atoms_to_remove);

	action = action.perform();

	action.mergeWith(fromFragmentSplit(frid));

	return action;
};

function fromFragmentSplit (frid) { // TODO [RB] the thing is too tricky :) need something else in future
	var action = new Action();
	var rgid = Struct.RGroup.findRGroupByFragment(ui.ctab.rgroups, frid);
	ui.ctab.atoms.each(function (aid, atom) {
		if (atom.fragment == frid) {
			var newfrid = action.addOp(new op.FragmentAdd().perform(ui.editor)).frid;
			var processAtom = function (aid1) {
				action.addOp(new op.AtomAttr(aid1, 'fragment', newfrid).perform(ui.editor));
				ui.render.atomGetNeighbors(aid1).each(function (nei) {
					if (ui.ctab.atoms.get(nei.aid).fragment == frid) {
						processAtom(nei.aid);
					}
				});
			};
			processAtom(aid);
			if (rgid) {
				action.mergeWith(fromRGroupFragment(rgid, newfrid));
			}
		}
	});
	if (frid != -1) {
		action.mergeWith(fromRGroupFragment(0, frid));
		action.addOp(new op.FragmentDelete(frid).perform(ui.editor));
	}
	return action;
};

function fromFragmentAddition (atoms, bonds, sgroups, rxnArrows, rxnPluses)
{
	var action = new Action();

	/*
     atoms.each(function (aid)
     {
     ui.render.atomGetNeighbors(aid).each(function (nei)
     {
     if (ui.selection.bonds.indexOf(nei.bid) == -1)
     ui.selection.bonds = ui.selection.bonds.concat([nei.bid]);
     }, this);
     }, this);
     */

	// TODO: merge close atoms and bonds

	sgroups.each(function (sid)
	{
		action.addOp(new op.SGroupRemoveFromHierarchy(sid));
		action.addOp(new op.SGroupDelete(sid));
	}, this);


	bonds.each(function (bid) {
		action.addOp(new op.BondDelete(bid));
	}, this);


	atoms.each(function (aid) {
		action.addOp(new op.AtomDelete(aid));
	}, this);

	rxnArrows.each(function (id) {
		action.addOp(new op.RxnArrowDelete(id));
	}, this);

	rxnPluses.each(function (id) {
		action.addOp(new op.RxnPlusDelete(id));
	}, this);

	action.mergeWith(new fromFragmentSplit(-1));

	return action;
};

function fromFragmentDeletion (selection)
{
	selection = selection || ui.editor.getSelection();

	var action = new Action();
	var atoms_to_remove = new Array();

	var frids = [];

	var actionRemoveDataSGroups = new Action();
	if (selection.sgroupData) {
		selection.sgroupData.each(function (id) {
			actionRemoveDataSGroups.mergeWith(fromSgroupDeletion(id));
		}, this);
	}

	selection.atoms.each(function (aid)
	{
		ui.render.atomGetNeighbors(aid).each(function (nei)
		{
			if (selection.bonds.indexOf(nei.bid) == -1)
				selection.bonds = selection.bonds.concat([nei.bid]);
		}, this);
	}, this);

	selection.bonds.each(function (bid)
	{
		action.addOp(new op.BondDelete(bid));

		var bond = ui.ctab.bonds.get(bid);

		if (selection.atoms.indexOf(bond.begin) == -1 && ui.render.atomGetDegree(bond.begin) == 1)
		{
			var frid1 = ui.ctab.atoms.get(bond.begin).fragment;
			if (frids.indexOf(frid1) < 0)
				frids.push(frid1);

			if (action.removeAtomFromSgroupIfNeeded(bond.begin))
				atoms_to_remove.push(bond.begin);

			action.addOp(new op.AtomDelete(bond.begin));
		}
		if (selection.atoms.indexOf(bond.end) == -1 && ui.render.atomGetDegree(bond.end) == 1)
		{
			var frid2 = ui.ctab.atoms.get(bond.end).fragment;
			if (frids.indexOf(frid2) < 0)
				frids.push(frid2);

			if (action.removeAtomFromSgroupIfNeeded(bond.end))
				atoms_to_remove.push(bond.end);

			action.addOp(new op.AtomDelete(bond.end));
		}
	}, this);


	selection.atoms.each(function (aid)
	{
		var frid3 = ui.ctab.atoms.get(aid).fragment;
		if (frids.indexOf(frid3) < 0)
			frids.push(frid3);

		if (action.removeAtomFromSgroupIfNeeded(aid))
			atoms_to_remove.push(aid);

		action.addOp(new op.AtomDelete(aid));
	}, this);

	action.removeSgroupIfNeeded(atoms_to_remove);

	selection.rxnArrows.each(function (id) {
		action.addOp(new op.RxnArrowDelete(id));
	}, this);

	selection.rxnPluses.each(function (id) {
		action.addOp(new op.RxnPlusDelete(id));
	}, this);

	selection.chiralFlags.each(function (id) {
		action.addOp(new op.ChiralFlagDelete(id));
	}, this);

	action = action.perform();

	while (frids.length > 0) action.mergeWith(new fromFragmentSplit(frids.pop()));

	action.mergeWith(actionRemoveDataSGroups);

	return action;
};

function fromAtomMerge (src_id, dst_id)
{
	var fragAction = new Action();
	var src_frid = ui.render.atomGetAttr(src_id, 'fragment'), dst_frid = ui.render.atomGetAttr(dst_id, 'fragment');
	if (src_frid != dst_frid) {
		mergeFragments(fragAction, src_frid, dst_frid);
	}

	var action = new Action();

	ui.render.atomGetNeighbors(src_id).each(function (nei)
	{
		var bond = ui.ctab.bonds.get(nei.bid);
		var begin, end;

		if (bond.begin == nei.aid) {
			begin = nei.aid;
			end = dst_id;
		} else {
			begin = dst_id;
			end = nei.aid;
		}
		if (dst_id != bond.begin && dst_id != bond.end && ui.ctab.findBondId(begin, end) == -1) // TODO: improve this
		{
			action.addOp(new op.BondAdd(begin, end, bond));
		}
		action.addOp(new op.BondDelete(nei.bid));
	}, this);

	var attrs = Atom.getAttrHash(ui.ctab.atoms.get(src_id));

	if (ui.render.atomGetDegree(src_id) == 1 && attrs.get('label') == '*')
		attrs.set('label', 'C');

	attrs.each(function (attr) {
		action.addOp(new op.AtomAttr(dst_id, attr.key, attr.value));
	}, this);

	var sg_changed = action.removeAtomFromSgroupIfNeeded(src_id);

	action.addOp(new op.AtomDelete(src_id));

	if (sg_changed)
		action.removeSgroupIfNeeded([src_id]);

	return action.perform().mergeWith(fragAction);
};

function toBondFlipping (id)
{
	var bond = ui.ctab.bonds.get(id);

	var action = new Action();
	action.addOp(new op.BondDelete(id));
	action.addOp(new op.BondAdd(bond.end, bond.begin, bond)).data.bid = id;
	return action;
};

function fromBondFlipping (bid) {
	return toBondFlipping(bid).perform();
};

function fromTemplateOnCanvas (pos, angle, template)
{
	var action = new Action();
	var frag = template.molecule;

	var fragAction = new op.FragmentAdd().perform(ui.editor);

	var map = {};

	// Only template atom label matters for now
	frag.atoms.each(function (aid, atom) {
		var operation;
		var attrs = Atom.getAttrHash(atom).toObject();
		attrs.fragment = fragAction.frid;

		action.addOp(
			operation = new op.AtomAdd(
				attrs,
			Vec2.diff(atom.pp, template.xy0).rotate(angle).add(pos)
			).perform(ui.editor)
		);

		map[aid] = operation.data.aid;
	});

	frag.bonds.each(function (bid, bond) {
		action.addOp(
		new op.BondAdd(
			map[bond.begin],
			map[bond.end],
			bond
		).perform(ui.editor)
		);
	});

	action.operations.reverse();
	action.addOp(fragAction);

	return action;
};

function atomAddToSGroups (sgroups, aid) {
	var action = new Action();
	util.each(sgroups, function (sid){
		action.addOp(new op.SGroupAtomAdd(sid, aid).perform(ui.editor));
	}, this);
	return action;
}

function fromTemplateOnAtom (aid, angle, extra_bond, template, calcAngle)
{
	var action = new Action();
	var frag = template.molecule;
	var R = ui.render;
	var RS = R.ctab;
	var molecule = RS.molecule;
	var atom = molecule.atoms.get(aid);
	var aid0 = aid; // the atom that was clicked on
	var aid1 = null; // the atom on the other end of the extra bond, if any
	var sgroups = ui.render.atomGetSGroups(aid);

	var frid = R.atomGetAttr(aid, 'fragment');

	var map = {};
	var xy0 = frag.atoms.get(template.aid).pp;

	if (extra_bond) {
		// create extra bond after click on atom
		if (angle == null)
		{
			var middle_atom = atomForNewBond(aid);
			var action_res = fromBondAddition({type: 1}, aid, middle_atom.atom, middle_atom.pos);
			action = action_res[0];
			action.operations.reverse();
			aid1 = aid = action_res[2];
		} else {
			var operation;

			action.addOp(
				operation = new op.AtomAdd(
				{ label: 'C', fragment: frid },
				(new Vec2(1, 0)).rotate(angle).add(atom.pp)
				).perform(ui.editor)
			);

			action.addOp(
			new op.BondAdd(
				aid,
				operation.data.aid,
			{ type: 1 }
			).perform(ui.editor)
			);

			aid1 = aid = operation.data.aid;
			action.mergeWith(atomAddToSGroups(sgroups, aid));
		}

		var atom0 = atom;
		atom = molecule.atoms.get(aid);
		var delta = calcAngle(atom0.pp, atom.pp) - template.angle0;
	} else {
		if (angle == null) {
			middle_atom = atomForNewBond(aid);
			angle = calcAngle(atom.pp, middle_atom.pos);
		}
		delta = angle - template.angle0;
	}

	frag.atoms.each(function (id, a) {
		var attrs = Atom.getAttrHash(a).toObject();
		attrs.fragment = frid;
		if (id == template.aid) {
			action.mergeWith(fromAtomsAttrs(aid, attrs, true));
			map[id] = aid;
		} else {
			var v;

			v = Vec2.diff(a.pp, xy0).rotate(delta).add(atom.pp);

			action.addOp(
				operation = new op.AtomAdd(
					attrs,
					v
				).perform(ui.editor)
			);
			map[id] = operation.data.aid;
		}
		if (map[id] - 0 !== aid0 - 0 && map[id] - 0 !== aid1 - 0)
			action.mergeWith(atomAddToSGroups(sgroups, map[id]));
	});

	frag.bonds.each(function (bid, bond) {
		action.addOp(
		new op.BondAdd(
			map[bond.begin],
			map[bond.end],
			bond
		).perform(ui.editor)
		);
	});

	action.operations.reverse();

	return action;
};

function fromTemplateOnBond (bid, template, calcAngle, flip)
{
	var action = new Action();
	var frag = template.molecule;
	var R = ui.render;
	var RS = R.ctab;
	var molecule = RS.molecule;

	var bond = molecule.bonds.get(bid);
	var begin = molecule.atoms.get(bond.begin);
	var end = molecule.atoms.get(bond.end);
	var sgroups = Set.list(Set.intersection(
	Set.fromList(ui.render.atomGetSGroups(bond.begin)),
	Set.fromList(ui.render.atomGetSGroups(bond.end))));

	var fr_bond = frag.bonds.get(template.bid);
	var fr_begin;
	var fr_end;

	var frid = R.atomGetAttr(bond.begin, 'fragment');

	var map = {};

	if (flip) {
		fr_begin = frag.atoms.get(fr_bond.end);
		fr_end = frag.atoms.get(fr_bond.begin);
		map[fr_bond.end] = bond.begin;
		map[fr_bond.begin] = bond.end;
	} else {
		fr_begin = frag.atoms.get(fr_bond.begin);
		fr_end = frag.atoms.get(fr_bond.end);
		map[fr_bond.begin] = bond.begin;
		map[fr_bond.end] = bond.end;
	}

	// calc angle
	var angle = calcAngle(begin.pp, end.pp) - calcAngle(fr_begin.pp, fr_end.pp);
	var scale = Vec2.dist(begin.pp, end.pp) / Vec2.dist(fr_begin.pp, fr_end.pp);

	var xy0 = fr_begin.pp;

	frag.atoms.each(function (id, a) {
		var attrs = Atom.getAttrHash(a).toObject();
		attrs.fragment = frid;
		if (id == fr_bond.begin || id == fr_bond.end) {
			action.mergeWith(fromAtomsAttrs(map[id], attrs, true));
			return;
		}

		var v;

		v = Vec2.diff(a.pp, fr_begin.pp).rotate(angle).scaled(scale).add(begin.pp);

		var merge_a = R.findClosestAtom(v, 0.1);

		if (merge_a == null) {
			var operation;
			action.addOp(
				operation = new op.AtomAdd(
					attrs,
					v
				).perform(ui.editor)
			);

			map[id] = operation.data.aid;
			action.mergeWith(atomAddToSGroups(sgroups, map[id]));
		} else {
			map[id] = merge_a.id;
			action.mergeWith(fromAtomsAttrs(map[id], attrs, true));
			// TODO [RB] need to merge fragments?
		}
	});

	frag.bonds.each(function (id, bond) {
		var exist_id = molecule.findBondId(map[bond.begin], map[bond.end]);
		if (exist_id == -1) {
			action.addOp(
			new op.BondAdd(
				map[bond.begin],
				map[bond.end],
				bond
			).perform(ui.editor));
		} else {
			action.mergeWith(fromBondAttrs(exist_id, fr_bond, false, true));
		}
	});

	action.operations.reverse();

	return action;
}

function fromChain (p0, v, nSect, atom_id)
{
	var angle = Math.PI / 6;
	var dx = Math.cos(angle), dy = Math.sin(angle);

	var action = new Action();

	var frid;
	if (atom_id != null) {
		frid = ui.render.atomGetAttr(atom_id, 'fragment');
	} else {
		frid = action.addOp(new op.FragmentAdd().perform(ui.editor)).frid;
	}

	var id0 = -1;
	if (atom_id != null) {
		id0 = atom_id;
	} else {
		id0 = action.addOp(new op.AtomAdd({label: 'C', fragment: frid}, p0).perform(ui.editor)).data.aid;
	}

	action.operations.reverse();

	nSect.times(function (i) {
		var pos = new Vec2(dx * (i + 1), i & 1 ? 0 : dy).rotate(v).add(p0);

		var a = ui.render.findClosestAtom(pos, 0.1);

		var ret = fromBondAddition({}, id0, a ? a.id : {}, pos);
		action = ret[0].mergeWith(action);
		id0 = ret[2];
	}, this);

	return action;
};

function fromNewCanvas (ctab)
{
	var action = new Action();

	action.addOp(new op.CanvasLoad(ctab));
	return action.perform();
};

function fromSgroupType (id, type)
{
	var R = ui.render;
	var cur_type = R.sGroupGetType(id);
	if (type && type != cur_type) {
		var atoms = util.array(R.sGroupGetAtoms(id));
		var attrs = R.sGroupGetAttrs(id);
		var actionDeletion = fromSgroupDeletion(id); // [MK] order of execution is important, first delete then recreate
		var actionAddition = fromSgroupAddition(type, atoms, attrs, id);
		return actionAddition.mergeWith(actionDeletion); // the actions are already performed and reversed, so we merge them backwards
	}
	return new Action();
};

function fromSgroupAttrs (id, attrs)
{
	var action = new Action();
	var R = ui.render;
	var RS = R.ctab;
	var sg = RS.sgroups.get(id).item;

	new Hash(attrs).each(function (attr) {
		action.addOp(new op.SGroupAttr(id, attr.key, attr.value));
	}, this);

	return action.perform();
};

function sGroupAttributeAction (id, attrs)
{
	var action = new Action();

	new Hash(attrs).each(function (attr) { // store the attribute assignment
		action.addOp(new op.SGroupAttr(id, attr.key, attr.value));
	}, this);

	return action;
};

function fromSgroupDeletion (id)
{
	var action = new Action();
	var R = ui.render;
	var RS = R.ctab;
	var DS = RS.molecule;

	if (ui.render.sGroupGetType(id) == 'SRU') {
		ui.render.sGroupsFindCrossBonds();
		var nei_atoms = ui.render.sGroupGetNeighborAtoms(id);

		nei_atoms.each(function (aid) {
			if (ui.render.atomGetAttr(aid, 'label') == '*') {
				action.addOp(new op.AtomAttr(aid, 'label', 'C'));
			}
		}, this);
	}

	var sg = DS.sgroups.get(id);
	var atoms = SGroup.getAtoms(DS, sg);
	var attrs = sg.getAttrs();
	action.addOp(new op.SGroupRemoveFromHierarchy(id));
	for (var i = 0; i < atoms.length; ++i) {
		action.addOp(new op.SGroupAtomRemove(id, atoms[i]));
	}
	action.addOp(new op.SGroupDelete(id));

	action = action.perform();

	action.mergeWith(sGroupAttributeAction(id, attrs));

	return action;
};

function fromSgroupAddition (type, atoms, attrs, sgid, pp)
{
	var action = new Action();
	var i;

	// TODO: shoud the id be generated when OpSGroupCreate is executed?
	//      if yes, how to pass it to the following operations?
	sgid = sgid - 0 === sgid ? sgid : ui.render.ctab.molecule.sgroups.newId();

	action.addOp(new op.SGroupCreate(sgid, type, pp));
	for (i = 0; i < atoms.length; i++)
		action.addOp(new op.SGroupAtomAdd(sgid, atoms[i]));
	action.addOp(new op.SGroupAddToHierarchy(sgid));

	action = action.perform();

	if (type == 'SRU') {
		ui.render.sGroupsFindCrossBonds();
		var asterisk_action = new Action();
		ui.render.sGroupGetNeighborAtoms(sgid).each(function (aid) {
			if (ui.render.atomGetDegree(aid) == 1 && ui.render.atomIsPlainCarbon(aid)) {
				asterisk_action.addOp(new op.AtomAttr(aid, 'label', '*'));
			}
		}, this);

		asterisk_action = asterisk_action.perform();
		asterisk_action.mergeWith(action);
		action = asterisk_action;
	}

	return fromSgroupAttrs(sgid, attrs).mergeWith(action);
};

function fromRGroupAttrs (id, attrs) {
	var action = new Action();
	new Hash(attrs).each(function (attr) {
		action.addOp(new op.RGroupAttr(id, attr.key, attr.value));
	}, this);
	return action.perform();
};

function fromRGroupFragment (rgidNew, frid) {
	var action = new Action();
	action.addOp(new op.RGroupFragment(rgidNew, frid));
	return action.perform();
};

// Should it be named structCenter?
function getAnchorPosition(clipboard) {
	if (clipboard.atoms.length) {
		var xmin = 1e50, ymin = xmin, xmax = -xmin, ymax = -ymin;
		for (var i = 0; i < clipboard.atoms.length; i++) {
			xmin = Math.min(xmin, clipboard.atoms[i].pp.x);
			ymin = Math.min(ymin, clipboard.atoms[i].pp.y);
			xmax = Math.max(xmax, clipboard.atoms[i].pp.x);
			ymax = Math.max(ymax, clipboard.atoms[i].pp.y);
		}
		return new Vec2((xmin + xmax) / 2, (ymin + ymax) / 2); // TODO: check
	} else if (clipboard.rxnArrows.length) {
		return clipboard.rxnArrows[0].pp;
	} else if (clipboard.rxnPluses.length) {
		return clipboard.rxnPluses[0].pp;
	} else if (clipboard.chiralFlags.length) {
		return clipboard.chiralFlags[0].pp;
	} else {
		return null;
	}
}

// TODO: merge to bellow
function struct2Clipboard(struct) {
	console.assert(!struct.isBlank(), 'Empty struct');

	var selection = {
		atoms: struct.atoms.keys(),
		bonds: struct.bonds.keys(),
		rxnArrows: struct.rxnArrows.keys(),
		rxnPluses: struct.rxnPluses.keys()
	};

	var clipboard = {
		atoms: [],
		bonds: [],
		sgroups: [],
		rxnArrows: [],
		rxnPluses: [],
		chiralFlags: [],
		rgmap: {},
		rgroups: {}
	};

	var mapping = {};
	selection.atoms.each(function (id)
	{
		var new_atom = new Atom(struct.atoms.get(id));
		new_atom.pos = new_atom.pp;
		mapping[id] = clipboard.atoms.push(new Atom(new_atom)) - 1;
	});

	selection.bonds.each(function (id)
	{
		var new_bond = new Bond(struct.bonds.get(id));
		new_bond.begin = mapping[new_bond.begin];
		new_bond.end = mapping[new_bond.end];
		clipboard.bonds.push(new Bond(new_bond));
	});

	var sgroup_list = struct.getSGroupsInAtomSet(selection.atoms);

	util.each(sgroup_list, function (sid){
		var sgroup = struct.sgroups.get(sid);
		var sgAtoms = SGroup.getAtoms(struct, sgroup);
		var sgroup_info = {
			type: sgroup.type,
			attrs: sgroup.getAttrs(),
			atoms: util.array(sgAtoms),
			pp: sgroup.pp
		};

		for (var i = 0; i < sgroup_info.atoms.length; i++)
			sgroup_info.atoms[i] = mapping[sgroup_info.atoms[i]];

		clipboard.sgroups.push(sgroup_info);
	}, this);

	selection.rxnArrows.each(function (id)
	{
		var arrow = new Struct.RxnArrow(struct.rxnArrows.get(id));
		arrow.pos = arrow.pp;
		clipboard.rxnArrows.push(arrow);
	});

	selection.rxnPluses.each(function (id)
	{
		var plus = new Struct.RxnPlus(struct.rxnPluses.get(id));
		plus.pos = plus.pp;
		clipboard.rxnPluses.push(plus);
	});

	// r-groups
	var atomFragments = {};
	var fragments = Set.empty();
	selection.atoms.each(function (id) {
		var atom = struct.atoms.get(id);
		var frag = atom.fragment;
		atomFragments[id] = frag;
		Set.add(fragments, frag);
	});

	var rgids = Set.empty();
	Set.each(fragments, function (frid){
		var atoms = Struct.Fragment.getAtoms(struct, frid);
		for (var i = 0; i < atoms.length; ++i)
			if (!Set.contains(atomFragments, atoms[i]))
				return;
		var rgid = Struct.RGroup.findRGroupByFragment(struct.rgroups, frid);
		clipboard.rgmap[frid] = rgid;
		Set.add(rgids, rgid);
	}, this);

	Set.each(rgids, function (id){
		clipboard.rgroups[id] = struct.rgroups.get(id).getAttrs();
	}, this);

	return clipboard;
}

function fromPaste (struct, point) {
	var clipboard = struct2Clipboard(struct);
	var offset = point ? Vec2.diff(point, getAnchorPosition(clipboard)) : new Vec2();
	var action = new Action(), amap = {}, fmap = {};
	// atoms
	for (var aid = 0; aid < clipboard.atoms.length; aid++) {
		var atom = Object.clone(clipboard.atoms[aid]);
		if (!(atom.fragment in fmap)) {
			fmap[atom.fragment] = action.addOp(new op.FragmentAdd().perform(ui.editor)).frid;
		}
		atom.fragment = fmap[atom.fragment];
		amap[aid] = action.addOp(new op.AtomAdd(atom, atom.pp.add(offset)).perform(ui.editor)).data.aid;
	}

	var rgnew = [];
	for (var rgid in clipboard.rgroups) {
		if (!ui.ctab.rgroups.has(rgid)) {
			rgnew.push(rgid);
		}
	}

	// assign fragments to r-groups
	for (var frid in clipboard.rgmap) {
		action.addOp(new op.RGroupFragment(clipboard.rgmap[frid], fmap[frid]).perform(ui.editor));
	}

	for (var i = 0; i < rgnew.length; ++i) {
		action.mergeWith(fromRGroupAttrs(rgnew[i], clipboard.rgroups[rgnew[i]]));
	}

	//bonds
	for (var bid = 0; bid < clipboard.bonds.length; bid++) {
		var bond = Object.clone(clipboard.bonds[bid]);
		action.addOp(new op.BondAdd(amap[bond.begin], amap[bond.end], bond).perform(ui.editor));
	}
	//sgroups
	for (var sgid = 0; sgid < clipboard.sgroups.length; sgid++) {
		var sgroup_info = clipboard.sgroups[sgid];
		var atoms = sgroup_info.atoms;
		var sgatoms = [];
		for (var sgaid = 0; sgaid < atoms.length; sgaid++) {
			sgatoms.push(amap[atoms[sgaid]]);
		}
		var newsgid = ui.render.ctab.molecule.sgroups.newId();
		var sgaction = fromSgroupAddition(sgroup_info.type, sgatoms, sgroup_info.attrs, newsgid, sgroup_info.pp ? sgroup_info.pp.add(offset) : null);
		for (var iop = sgaction.operations.length - 1; iop >= 0; iop--) {
			action.addOp(sgaction.operations[iop]);
		}
	}
	//reaction arrows
	if (ui.editor.render.ctab.rxnArrows.count() < 1) {
		for (var raid = 0; raid < clipboard.rxnArrows.length; raid++) {
			action.addOp(new op.RxnArrowAdd(clipboard.rxnArrows[raid].pp.add(offset)).perform(ui.editor));
		}
	}
	//reaction pluses
	for (var rpid = 0; rpid < clipboard.rxnPluses.length; rpid++) {
		action.addOp(new op.RxnPlusAdd(clipboard.rxnPluses[rpid].pp.add(offset)).perform(ui.editor));
	}
	//thats all
	action.operations.reverse();
	return action;
};

function fromFlip (objects, flip) {
	var render = ui.render;
	var ctab = render.ctab;
	var molecule = ctab.molecule;

	var action = new Action();
	var i;
	var fids = {};

	if (objects.atoms) {
		for (i = 0; i < objects.atoms.length; i++) {
			var aid = objects.atoms[i];
			var atom = molecule.atoms.get(aid);
			if (!(atom.fragment in fids)) {
				fids[atom.fragment] = [aid];
			} else {
				fids[atom.fragment].push(aid);
			}
		}

		fids = new Hash(fids);

		if (fids.detect(function (frag) {
			return !Set.eq(molecule.getFragmentIds(frag[0]), Set.fromList(frag[1]));
		})) {
			return action; // empty action
		}

		fids.each(function (frag) {
			var fragment = Set.fromList(frag[1]);
			//var x1 = 100500, x2 = -100500, y1 = 100500, y2 = -100500;
			var bbox = molecule.getCoordBoundingBox(fragment);

			Set.each(fragment, function (aid) {
				var atom = molecule.atoms.get(aid);
				var d = new Vec2();

				if (flip == 'horizontal') {
					d.x = bbox.min.x + bbox.max.x - 2 * atom.pp.x;
				} else { // 'vertical'
					d.y = bbox.min.y + bbox.max.y - 2 * atom.pp.y;
				}

				action.addOp(new op.AtomMove(aid, d));
			});
		});

		if (objects.bonds) {
			for (i = 0; i < objects.bonds.length; i++) {
				var bid = objects.bonds[i];
				var bond = molecule.bonds.get(bid);

				if (bond.type == Bond.PATTERN.TYPE.SINGLE) {
					if (bond.stereo == Bond.PATTERN.STEREO.UP) {
						action.addOp(new op.BondAttr(bid, 'stereo', Bond.PATTERN.STEREO.DOWN));
					} else if (bond.stereo == Bond.PATTERN.STEREO.DOWN) {
						action.addOp(new op.BondAttr(bid, 'stereo', Bond.PATTERN.STEREO.UP));
					}
				}
			}
		}
	}

	return action.perform();
};

function fromRotate (objects, pos, angle) {
	var render = ui.render;
	var ctab = render.ctab;
	var molecule = ctab.molecule;

	var action = new Action();
	var i;
	var fids = {};

	function rotateDelta(v)
	{
		var v1 = v.sub(pos);
		v1 = v1.rotate(angle);
		v1.add_(pos);
		return v1.sub(v);
	}

	if (objects.atoms) {
		objects.atoms.each(function (aid) {
			var atom = molecule.atoms.get(aid);
			action.addOp(new op.AtomMove(aid, rotateDelta(atom.pp)));
		});
	}

	if (objects.rxnArrows) {
		objects.rxnArrows.each(function (aid) {
			var arrow = molecule.rxnArrows.get(aid);
			action.addOp(new op.RxnArrowMove(aid, rotateDelta(arrow.pp)));
		});
	}

	if (objects.rxnPluses) {
		objects.rxnPluses.each(function (pid) {
			var plus = molecule.rxnPluses.get(pid);
			action.addOp(new op.RxnPlusMove(pid, rotateDelta(plus.pp)));
		});
	}

	if (objects.sgroupData) {
		objects.sgroupData.each(function (did) {
			var data = molecule.sgroups.get(did);
			action.addOp(new op.SGroupDataMove(did, rotateDelta(data.pp)));
		});
	}

	if (objects.chiralFlags) {
		objects.chiralFlags.each(function (fid) {
			var flag = molecule.chiralFlags.get(fid);
			action.addOp(new op.ChiralFlagMove(fid, rotateDelta(flag.pp)));
		});
	}

	return action.perform();
};

module.exports = util.extend(Action, {
	fromMultipleMove: fromMultipleMove,
	fromAtomAddition: fromAtomAddition,
	fromArrowAddition: fromArrowAddition,
	fromArrowDeletion: fromArrowDeletion,
	fromChiralFlagDeletion: fromChiralFlagDeletion,
	fromPlusAddition: fromPlusAddition,
	fromPlusDeletion: fromPlusDeletion,
	fromAtomDeletion: fromAtomDeletion,
	fromBondDeletion: fromBondDeletion,
	fromFragmentDeletion: fromFragmentDeletion,
	fromAtomMerge: fromAtomMerge,
	fromBondFlipping: fromBondFlipping,
	fromTemplateOnCanvas: fromTemplateOnCanvas,
	fromTemplateOnAtom: fromTemplateOnAtom,
	fromTemplateOnBond: fromTemplateOnBond,
	fromAtomsAttrs: fromAtomsAttrs,
	fromBondAttrs: fromBondAttrs,
	fromChain: fromChain,
	fromBondAddition: fromBondAddition,
	fromNewCanvas: fromNewCanvas,
	fromSgroupType: fromSgroupType,
	fromSgroupDeletion: fromSgroupDeletion,
	fromSgroupAttrs: fromSgroupAttrs,
	fromRGroupFragment: fromRGroupFragment,
	fromPaste: fromPaste,
	fromRGroupAttrs: fromRGroupAttrs,
	fromSgroupAddition: fromSgroupAddition,
	fromFlip: fromFlip,
	fromRotate: fromRotate
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../chem/atom":8,"../chem/bond":9,"../chem/sgroup":15,"../chem/struct":18,"../util":40,"../util/set":43,"../util/vec2":44,"./op":36}],28:[function(require,module,exports){
(function (global){
var keymage = require('keymage');
var element = require('../../chem/element');
var util = require('../../util');
var Action = require('../action');

var ui = global.ui;

function initDialogs () {
	// Label input events
	$('input_label').observe('blur', function () {
		keymage.setScope('editor');
		this.hide();
	});
	$('input_label').observe('keypress', onKeyPress_InputLabel);
	$('input_label').observe('keyup', onKeyUp_InputLabel);

	// Atom properties dialog events
	$('atom_label').observe('change', onChange_AtomLabel);
	$('atom_charge').observe('change', onChange_AtomCharge);
	$('atom_isotope').observe('change', onChange_AtomIsotope);
	$('atom_valence').observe('change', onChange_AtomValence);
	$('atom_prop_cancel').observe('click', function () {
		ui.hideDialog('atom_properties');
	});
	$('atom_prop_ok').observe('click', function () {
		applyAtomProperties();
	});
	$('bond_prop_cancel').observe('click', function () {
		ui.hideDialog('bond_properties');
	});
	$('bond_prop_ok').observe('click', function () {
		applyBondProperties();
	});
};

//
// Atom attachment points dialog
//
function showAtomAttachmentPoints (params) {
	$('atom_ap1').checked = ((params.selection || 0) & 1) > 0;
	$('atom_ap2').checked = ((params.selection || 0) & 2) > 0;
	ui.showDialog('atom_attpoints');
	var _onOk = new Event.Handler('atom_attpoints_ok', 'click', undefined, function () {
		_onOk.stop();
		_onCancel.stop();
		ui.hideDialog('atom_attpoints');
		if ('onOk' in params) {
			params.onOk(($('atom_ap1').checked ? 1 : 0) + ($('atom_ap2').checked ? 2 : 0));
		}
	}).start();
	var _onCancel = new Event.Handler('atom_attpoints_cancel', 'click', undefined, function () {
		_onOk.stop();
		_onCancel.stop();
		ui.hideDialog('atom_attpoints');
		if ('onCancel' in params) {
			params.onCancel();
		}
	}).start();
	$('atom_attpoints_ok').focus();
};

//
// Atom properties dialog
//
function showAtomProperties (id) {
	$('atom_properties').atom_id = id;
	$('atom_label').value = ui.render.atomGetAttr(id, 'label');
	onChange_AtomLabel.call($('atom_label'));
	var value = ui.render.atomGetAttr(id, 'charge') - 0;
	$('atom_charge').value = (value == 0 ? '' : value);
	value = ui.render.atomGetAttr(id, 'isotope') - 0;
	$('atom_isotope').value = (value == 0 ? '' : value);
	value = ui.render.atomGetAttr(id, 'explicitValence') - 0;
	$('atom_valence').value = value < 0 ? '' : value;
	$('atom_radical').value = ui.render.atomGetAttr(id, 'radical');

	$('atom_inversion').value = ui.render.atomGetAttr(id, 'invRet');
	$('atom_exactchange').value = ui.render.atomGetAttr(id, 'exactChangeFlag') ? 1 : 0;
	$('atom_ringcount').value = ui.render.atomGetAttr(id, 'ringBondCount');
	$('atom_substitution').value = ui.render.atomGetAttr(id, 'substitutionCount');
	$('atom_unsaturation').value = ui.render.atomGetAttr(id, 'unsaturatedAtom');
	$('atom_hcount').value = ui.render.atomGetAttr(id, 'hCount');

	ui.showDialog('atom_properties');
	$('atom_label').activate();
};

function applyAtomProperties () {
	ui.hideDialog('atom_properties');

	var id = $('atom_properties').atom_id;

	ui.addUndoAction(Action.fromAtomsAttrs(id,
	{
		label: $('atom_label').value,
		charge: $('atom_charge').value == '' ? 0 : parseInt($('atom_charge').value, 10),
		isotope: $('atom_isotope').value == '' ? 0 : parseInt($('atom_isotope').value, 10),
		explicitValence: $('atom_valence').value == '' ? -1 : parseInt($('atom_valence').value, 10),
		radical: parseInt($('atom_radical').value, 10),
		// reaction flags
		invRet: parseInt($('atom_inversion').value, 10),
		exactChangeFlag: parseInt($('atom_exactchange').value, 10) ? true : false,
		// query flags
		ringBondCount: parseInt($('atom_ringcount').value, 10),
		substitutionCount: parseInt($('atom_substitution').value, 10),
		unsaturatedAtom: parseInt($('atom_unsaturation').value, 10),
		hCount: parseInt($('atom_hcount').value, 10)
	}), true);

	ui.render.update();
};

function onChange_AtomLabel () {
	this.value = this.value.strip().capitalize();

	var elem = element.getElementByLabel(this.value);

	if (
		elem == null && this.value !== 'A' &&
	this.value !== '*' && this.value !== 'Q' && this.value !== 'X' &&
	this.value !== 'R'
	) {
		this.value = ui.render.atomGetAttr($('atom_properties').atom_id, 'label');

		if (this.value !== 'A' && this.value !== '*') {
			elem = element.getElementByLabel(this.value);
		}
	}

	if (this.value == 'A' || this.value == '*') {
		$('atom_number').value = 'any';
	} else if (!elem) {
		$('atom_number').value = '';
	} else {
		$('atom_number').value = elem.toString();
	}
};

function onChange_AtomCharge () {
	if (this.value.strip() === '' || this.value == '0') {
		this.value = '';
	} else if (this.value.match(/^[1-9][0-9]{0,1}[-+]$/)) {
		this.value = (this.value.endsWith('-') ? '-' : '') + this.value.substr(0, this.value.length - 1);
	} else if (!this.value.match(/^[+-]?[1-9][0-9]{0,1}$/)) {
		this.value = ui.render.atomGetAttr($('atom_properties').atom_id, 'charge');
	}
};

function onChange_AtomIsotope () {
	if (this.value == util.getElementTextContent($('atom_number')) || this.value.strip() == '' || this.value == '0') {
		this.value = '';
	} else if (!this.value.match(/^[1-9][0-9]{0,2}$/)) {
		this.value = ui.render.atomGetAttr($('atom_properties').atom_id, 'isotope');
	}
};

function onChange_AtomValence () {
	/*
     if (this.value.strip() == '')
     this.value = '';
     else if (!this.value.match(/^[0-9]$/))
     this.value = ui.render.atomGetAttr($('atom_properties').atom_id, 'valence');
     */
};

//
// Bond properties dialog
//
function showBondProperties (id) {
	var bond;
	$('bond_properties').bond_id = id;

	var type = ui.render.bondGetAttr(id, 'type');
	var stereo = ui.render.bondGetAttr(id, 'stereo');

	for (bond in ui.bondTypeMap) {
		if (ui.bondTypeMap[bond].type == type && ui.bondTypeMap[bond].stereo == stereo) {
			break;
		}
	}

	$('bond_type').value = bond;
	$('bond_topology').value = ui.render.bondGetAttr(id, 'topology') || 0;
	$('bond_center').value = ui.render.bondGetAttr(id, 'reactingCenterStatus') || 0;

	ui.showDialog('bond_properties');
	$('bond_type').activate();
};

function applyBondProperties () {
	ui.hideDialog('bond_properties');

	var id = $('bond_properties').bond_id;
	var bond = Object.clone(ui.bondTypeMap[$('bond_type').value]);

	bond.topology = parseInt($('bond_topology').value, 10);
	bond.reactingCenterStatus = parseInt($('bond_center').value, 10);

	ui.addUndoAction(Action.fromBondAttrs(id, bond), true);

	ui.render.update();
};

//
// Reaction auto-mapping
//

function showAutomapProperties (params) {
	ui.showDialog('automap_properties');
	var _onOk;
	var _onCancel;

	_onOk = new Event.Handler('automap_ok', 'click', undefined, function () {
		_onOk.stop();
		_onCancel.stop();
		if (params && 'onOk' in params) params['onOk']($('automap_mode').value);
		ui.hideDialog('automap_properties');
	}).start();

	_onCancel = new Event.Handler('automap_cancel', 'click', undefined, function () {
		_onOk.stop();
		_onCancel.stop();
		ui.hideDialog('automap_properties');
		if (params && 'onCancel' in params) params['onCancel']();
	}).start();

	$('automap_mode').activate();
};

function showRLogicTable (args) {
	var params = args || {};
	params.rlogic = params.rlogic || {};
	$('rlogic_occurrence').value = params.rlogic.occurrence || '>0';
	$('rlogic_resth').value = params.rlogic.resth ? '1' : '0';
	var ifOptHtml = '<option value="0">Always</option>';
	for (var r = 1; r <= 32; r++) {
		if (r != params.rgid && (params.rgmask & (1 << (r - 1))) != 0) {
			ifOptHtml += '<option value="' + r + '">IF R' + params.rgid + ' THEN R' + r + '</option>';
		}
	}
	$('rlogic_if').outerHTML = '<select id="rlogic_if">' + ifOptHtml + '</select>'; // [RB] thats tricky because IE8 fails to set innerHTML
	$('rlogic_if').value = params.rlogic.ifthen;
	ui.showDialog('rlogic_table');

	var _onOk = new Event.Handler('rlogic_ok', 'click', undefined, function () {
		var result = {
			'occurrence': $('rlogic_occurrence').value
			.replace(/\s*/g, '').replace(/,+/g, ',').replace(/^,/, '').replace(/,$/, ''),
			'resth': $('rlogic_resth').value == '1',
			'ifthen': parseInt($('rlogic_if').value, 10)
		};
		if (!params || !('onOk' in params) || params.onOk(result)) {
			_onOk.stop();
			_onCancel.stop();
			ui.hideDialog('rlogic_table');
		}
	}).start();
	var _onCancel = new Event.Handler('rlogic_cancel', 'click', undefined, function () {
		_onOk.stop();
		_onCancel.stop();
		ui.hideDialog('rlogic_table');
		if (params && 'onCancel' in params) params['onCancel']();
	}).start();

	$('rlogic_occurrence').activate();
};

function onKeyPress_Dialog (event)
{
	util.stopEventPropagation(event);
	if (event.keyCode === 27) {
		ui.hideDialog(this.id);
		return util.preventDefault(event);
	}
};

function onKeyPress_InputLabel (event)
{
	util.stopEventPropagation(event);
	if (event.keyCode == 13) {
		keymage.setScope('editor');
		this.hide();

		var label = '';
		var charge = 0;
		var value_arr = this.value.toArray();

		if (this.value == '*') {
			label = 'A';
		}
		else if (this.value.match(/^[*][1-9]?[+-]$/i)) {
			label = 'A';

			if (this.value.length == 2)
				charge = 1;
			else
				charge = parseInt(value_arr[1]);

			if (value_arr[2] == '-')
				charge *= -1;
		}
		else if (this.value.match(/^[A-Z]{1,2}$/i)) {
			label = this.value.capitalize();
		}
		else if (this.value.match(/^[A-Z]{1,2}[0][+-]?$/i)) {
			if (this.value.match(/^[A-Z]{2}/i))
				label = this.value.substr(0, 2).capitalize();
			else
				label = value_arr[0].capitalize();
		}
		else if (this.value.match(/^[A-Z]{1,2}[1-9]?[+-]$/i)) {
			if (this.value.match(/^[A-Z]{2}/i))
				label = this.value.substr(0, 2).capitalize();
			else
				label = value_arr[0].capitalize();

			var match = this.value.match(/[0-9]/i);

			if (match != null)
				charge = parseInt(match[0]);
			else
				charge = 1;

			if (value_arr[this.value.length - 1] == '-')
				charge *= -1;
		}

		if (label == 'A' || label == 'Q' || label == 'X' || label == 'R' || element.getElementByLabel(label) != null) {
			ui.addUndoAction(Action.fromAtomsAttrs(this.atom_id, {label: label, charge: charge}), true);
			ui.render.update();
		}
		return util.preventDefault(event);
	}
	if (event.keyCode == 27) {
		this.hide();
		keymage.setScope('editor');
		return util.preventDefault(event);
	}
};

function onKeyUp_InputLabel (event)
{
	util.stopEventPropagation(event);
	if (event.keyCode == 27) {
		this.hide();
		keymage.setScope('editor');
		return util.preventDefault(event);
	}
};

function showLabelEditor (aid)
{
	// TODO: RB: to be refactored later, need to attach/detach listeners here as anon-functions, not on global scope (onKeyPress_InputLabel, onBlur, etc)
	var input_el = $('input_label');
	keymage.setScope('label');

	var offset = Math.min(7 * ui.render.zoom, 16);

	input_el.atom_id = aid;
	input_el.value = ui.render.atomGetAttr(aid, 'label');
	input_el.style.fontSize = offset * 2 + 'px';

	input_el.show();

	var atom_pos = ui.render.obj2view(ui.render.atomGetPos(aid));
	// TODO: some other way to handle pos
	//var offset_client = ui.client_area.cumulativeOffset();
	var offset_client = {left: 0, top: 0};
	var offset_parent = Element.cumulativeOffset(input_el.offsetParent);
	var d = 0; // TODO: fix/Math.ceil(4 * ui.abl() / 100);
	input_el.style.left = (atom_pos.x + offset_client.left - offset_parent.left - offset - d) + 'px';
	input_el.style.top = (atom_pos.y + offset_client.top - offset_parent.top - offset - d) + 'px';

	input_el.activate();
};

module.exports = {
	initDialogs: initDialogs,
	showAtomAttachmentPoints: showAtomAttachmentPoints,
	showAtomProperties: showAtomProperties,
	showBondProperties: showBondProperties,
	showAutomapProperties: showAutomapProperties,
	showRLogicTable: showRLogicTable,
	showLabelEditor: showLabelEditor
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../chem/element":12,"../../util":40,"../action":27,"keymage":2}],29:[function(require,module,exports){
(function (global){
var Promise = require('promise-polyfill');
// var base64 = require('base64-js');

var ui = global.ui;

function dialog (params) {
	var dlg = ui.showDialog('open-file');
	var okButton = dlg.select('input[value=OK]')[0];
	var textInput = dlg.select('textarea')[0];
	var fileInput = dlg.select('input[type=file]')[0];
	var fragmentInput = dlg.select('input[name=fragment]')[0];
	var readFile;
	var handlers = [];

	handlers[0] = dlg.on('click', 'input[type=button]', function (_, button) {
		handlers.forEach(function (h) { h.stop(); });
		ui.hideDialog('open-file');

		var key = 'on' + button.value.capitalize();
		if (params && key in params) {
			// TODO: generalize to form serialization
			params[key]({
				fragment: fragmentInput.checked,
				value: textInput.value
			});
		}
	});

	handlers[1] = fileInput.on('change', function (_, input) {
		console.assert(readFile, 'No valid file opener');
		if (input.files.length) {
			dlg.select('input').each(function (el) {
				el.disabled = true;
			});
			readFile(input.files[0]).then(function (content) {
				textInput.value = content;
				dlg.select('input').each(function (el) {
					el.disabled = false;
				});
			}, ui.echo);
		}
	});

	handlers[2] = textInput.on('input', function (_, input) {
		var text = textInput.value.trim();
		okButton.disabled = !text;
	});

	textInput.value = '';
	fragmentInput.checked = false;
	okButton.disabled = true;

	fileInput.disabled = true;
	fileInput.parentNode.addClassName('disabled');
	fileOpener().then(function (f) {
		readFile = f;
		fileInput.disabled = false;
		fileInput.parentNode.removeClassName('disabled');
	});
};

function fileOpener () {
	function throughFileReader(file) {
		return new Promise(function (resolve, reject) {
			var rd = new FileReader();
			rd.onload = function (event) {
				resolve(event.target.result);
			};
			rd.onerror = function (event) {
				reject(event);
			};
			rd.readAsText(file, 'UTF-8');
		});
	}
	function throughFileSystemObject(fso, file) {
		// IE9 and below
		var fd =  fso.OpenTextFile(file.name, 1),
		content = fd.ReadAll();
		fd.Close();
		return content;
	}
	function throughForm2IframePosting(file) {
	}
	return new Promise(function (resolve, reject) {
		// TODO: refactor return
		if (global.FileReader)
			return resolve(throughFileReader);

		if (global.ActiveXObject) {
			try {
				var fso = new global.ActiveXObject('Scripting.FileSystemObject');
				return resolve(function (file) {
					return Promise.resolve(throughFileSystemObject(fso, file));
				});
			} catch (e) {
				}
		}

		if (ui.standalone)
			return reject('Standalone mode!');
		return resolve(throughForm2IframePosting);
	});
}

function loadHook() {
	// Called from iframe's 'onload'
}

// basicaly hack to export just the dialog func
dialog.loadHook = loadHook;
module.exports = dialog;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"promise-polyfill":3}],30:[function(require,module,exports){
(function (global){
var Promise = require('promise-polyfill');
var fs = require('filesaver.js');

var molfile = require('../../chem/molfile');
var smiles = require('../../chem/smiles');

var ui = global.ui;

function saveDialog (params, server) {
	var dlg = ui.showDialog('save-file'),
	output = dlg.select('textarea')[0],
	formatInput = dlg.select('select')[0],
	saveButton = dlg.select('.save')[0],
	saveFile,
	handlers = [];

	function outputMolecule(text, format) {
		format = format || 'mol';
		output.value = text;
		output.className = format;
		output.activate();
	}

	handlers[0] = dlg.on('click', 'input[type=button]', function (_, button) {
		handlers.forEach(function (h) { h.stop(); });
		ui.hideDialog('save-file');

		var key = 'on' + button.value.capitalize();
		if (params && key in params) {
			params[key]({});
		}
	});

	handlers[1] = formatInput.on('change', function (_, input) {
		var format = formatInput.value;
		convertMolecule(server, params.molecule, format).then(function (res) {
			outputMolecule(res, format);
		}, ui.echo);
	});

	handlers[2] = saveButton.on('click', function (event) {
		if (saveFile) {
			saveFile(output.value, formatInput.value);
			dlg.select('input[type=button]')[0].click();
		}
		event.preventDefault();
	});

	outputMolecule(molfile.stringify(params.molecule));
	saveButton.addClassName('disabled');
	fileSaver(server).then(function (f) {
		saveFile = f;
		saveButton.removeClassName('disabled');
	});
	formatInput.select('[value=inchi]')[0].disabled = ui.standalone;
};

function fileSaver (server) {
	var mimemap = {
		'smi': 'chemical/x-daylight-smiles',
		'mol': 'chemical/x-mdl-molfile',
		'rxn': 'chemical/x-mdl-rxnfile',
		'inchi': 'chemical/x-inchi'
	};
	return new Promise(function (resolve, reject) {
		if (global.Blob && fs.saveAs)
			resolve(function (data, type) {
				if (type == 'mol' && data.indexOf('$RXN') == 0)
					type = 'rxn';
				console.assert(mimemap[type], 'Unknown chemical file type');
				var blob = new Blob([data], {type: mimemap[type] });
				fs.saveAs(blob, 'ketcher.' + type);
			});
		else if (ui.standalone)
			reject('Standalone mode!');
		else
			resolve(function (data, type) {
				server.save({filedata: [type, data].join('\n')});
			});
	});
};

function convertMolecule (server, molecule, format) {
	return new Promise(function (resolve, reject) {
		var moldata = molfile.stringify(molecule);
		if (format == 'mol') {
			resolve(moldata);
		}
		else if (format == 'smi') {
			resolve(smiles.stringify(molecule));
		}
		else if (format == 'inchi') {
			if (ui.standalone)
				throw Error('InChI is not supported in the standalone mode');

			if (molecule.rgroups.count() !== 0)
				ui.echo('R-group fragments are not supported and will be discarded');
			molecule = molecule.getScaffold();
			if (molecule.atoms.count() === 0)
				resolve('');
			else {
				molecule = molecule.clone();
				molecule.sgroups.each(function (sgid, sg) {
					// ? Not sure we should check it client side
					if (sg.type != 'MUL' && !/^INDIGO_.+_DESC$/i.test(sg.data.fieldName))
						throw Error('InChi data format doesn\'t support s-groups');
				});

				resolve(server.inchi({ moldata: moldata }));
			}
		}
	});
}

module.exports = saveDialog;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../chem/molfile":13,"../../chem/smiles":16,"filesaver.js":1,"promise-polyfill":3}],31:[function(require,module,exports){
(function (global){
var ui = global.ui;

function dialog (name, params) {
	var dlg = ui.showDialog(name);
	var okButton = dlg.select('input[value=OK]')[0];
	var mode = params.mode || 'single';
	var handlers = [];

	function setSelected(values) {
		dlg.select('.selected').each(function (button) {
			button.removeClassName('selected');
		});
		if (values) {
			dlg.select('button').each(function (button) {
				var value = button.value || button.textContent || button.innerText;
				if (values.indexOf(value) >= 0) {
					button.addClassName('selected');
				}
			});
		} else if (params.required) {
			okButton.disabled = true;
		}
	}

	function getSelected() {
		var values = [];
		dlg.select('.selected').each(function (button) {
			var value = button.value || button.textContent || button.innerText;
			values.push(value);
		});
		return values;
	}

	handlers[0] = dlg.on('click', 'input[type=button]', function (_, button) {
		handlers.forEach(function (h) { h.stop(); });
		ui.hideDialog(name);

		var key = 'on' + button.value.capitalize();

		console.assert(key != 'onOk' || !params.required ||
		               getSelected().length != 0,
		               'No elements selected');
		if (params && key in params) {
			params[key]({
				mode: mode,
				values: getSelected()
			});
		}
	});

	handlers[1] = dlg.on('click', 'button', function (event, button) {
		if (mode === 'single') {
			if (!button.hasClassName('selected')) {
				setSelected(null);
			} else if (params.required) {
				okButton.click();
			}
		}

		button.toggleClassName('selected');
		if (params.required) {
			okButton.disabled = dlg.select('.selected').length === 0;
		}
		event.stop();
	});

	handlers[2] = dlg.on('click', 'input[name=mode]', function (_, radio) {
		if (radio.value != mode) {
			if (radio.value == 'single') {
				setSelected(null);
			}
			mode = radio.value;
		}
	});

	setSelected(params.values);
	dlg.select('input[name=mode]').each(function (radio) {
		if (radio.value == mode) {
			radio.checked = true;
		}
	});
}

module.exports = dialog;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],32:[function(require,module,exports){
(function (global){
var util = require('../../util');

var ui = global.ui;

function dialog (params) {
	var dlg = ui.showDialog('sgroup_special');
	var cache = {};
	var handlers = [];

	console.assert(!params.type || params.type == 'DAT');
	console.assert(!params.type || params.attrs.fieldName);

	var context = params.type && matchContext(params.attrs.fieldName, params.attrs.fieldValue) ||
		          params.context || 'Fragment';
	setContext(context, cache, true);
	if (params.attrs.fieldName)
		setField(params.attrs.fieldName, cache, true);

	$('sgroup_special_value').value = params.attrs.fieldValue;
	if (params.attrs.attached)
		$('sgroup_special_attached').checked = true;
	else if (params.attrs.absolute)
		$('sgroup_special_absolute').checked = true;
	else
		$('sgroup_special_relative').checked = true;

	handlers[0] = dlg.on('click', 'input[type=button]', function (_, button) {
		var key = 'on' + button.value.capitalize();
		var res = key != 'onOk' || getValidateAttrs();
		if (res) {
			handlers.forEach(function (h) { h.stop(); });
			ui.hideDialog('sgroup_special');
			if (key in params && res)
				params[key](res);
		}
	});

	handlers[1] = dlg.on('change', 'select', function (_, select) {
		if (select.id == 'sgroup_context')
			setContext($('sgroup_context').value, cache);
		if (select.id == 'sgroup_special_name')
			setField($('sgroup_special_name').value, cache);
	});
};

function getValidateAttrs() {
	var attrs = {
		mul: null,
		connectivity: '',
		name: '',
		subscript: ''
	};

	attrs.fieldName = $('sgroup_special_name').value.strip();
	attrs.fieldValue = $('sgroup_special_value').value.strip();
	attrs.absolute = $('sgroup_special_absolute').checked;
	attrs.attached = $('sgroup_special_attached').checked;

	if (attrs.fieldValue == '') {
		alert('Please, specify data field value.');
		return null;
	}

	return { type: 'DAT',
	         attrs: attrs };
};

function setContext(context, cache, force) {
	console.info('set context:', context, cache);
	console.assert(cache.context || force, 'Field setup should be forced');
	if (force || context != cache.context.name) {
		cache.context = util.find(special_choices, function (opt) {
			return opt.name == context;
		});
		console.assert(cache.context, 'Can\'t find such context');
		var str = cache.context.value.reduce(function (res, opt) {
			return res + '<option value="' + opt.name + '">' + opt.name + "</option>";
		}, '');
		$('sgroup_special_name').update(str);
		setField(cache.context.value[0].name, cache, true);
		if (force)
			$('sgroup_context').value = context;
	}
}

function setField(field, cache, force) {
	console.info('set field:', field, cache);
	console.assert(cache.field || force, 'Field setup should be forced');
	if (field || field != cache.field.name) {
		cache.field = util.find(cache.context.value, function (opt) {
			return opt.name == field;
		});
		console.assert(cache.field, 'Can\'t find such field');
		if (!cache.field.value)
			$('sgroup_special_value').outerHTML = '<textarea id="sgroup_special_value"></textarea>';
		else {
			var str = cache.field.value.reduce(function (res, opt) {
				return res + '<option value="' + opt + '">' + opt + "</option>";
			}, '');
			$('sgroup_special_value').outerHTML = '<select size="10" id="sgroup_special_value">' + str + '</select>';
		}
		$('sgroup_special_name').value = field;
	}
}

function matchContext(field, value) {
	console.info('search:', util.unicodeLiteral(field), util.unicodeLiteral(value));
	var c = util.find(special_choices, function(c) {
		var f = util.find(c.value, function(f) {
			return f.name == field;
		});
		if (!f)
			return false;
		return !value || !f.value || !!util.find(f.value, function(v) {
			return v == value;
		});
	});
	return c && c.name;
}

var special_choices = [
	{ name: 'Fragment',
	  value: [
		  { name: 'MDLBG_FRAGMENT_STEREO',
		    value: [
			'abs',
			'(+)-enantiomer',
			'(-)-enantiomer',
			'steric',
			'rel',
			'R(a)',
			'S(a)',
			'R(p)',
			'S(p)'
		    ]},
		  { name: 'MDLBG_FRAGMENT_COEFFICIENT',
		    value: null},
		  { name: 'MDLBG_FRAGMENT_CHARGE',
		    value: null },
		  { name: 'MDLBG_FRAGMENT_RADICALS',
		    value: null },
	]},
	{ name: 'Single Bond',
	  value: [
		  { name: 'MDLBG_STEREO_KEY',
		    value: [
			'erythro',
			'threo',
			'alpha',
			'beta',
			'endo',
			'exo',
			'anti',
			'syn',
			'ECL',
			'STG'
		    ]},
		  { name: 'MDLBG_BOND_KEY',
		    value: [
			    'Value=4'
		    ]},
	]},
	{ name: 'Atom',
	  value: [
		  { name: 'MDLBG_STEREO_KEY',
		    value: [
			'RS',
			'SR',
			'P-3',
			'P-3-PI',
			'SP-4',
			'SP-4-PI',
			'T-4',
			'T-4-PI',
			'SP-5',
			'SP-5-PI',
			'TB-5',
			'TB-5-PI',
			'OC-6',
			'TB-5-PI',
			'TP-6',
			'PB-7',
			'CU-8',
			'SA-8',
			'DD-8',
			'HB-9',
			'TPS-9',
			'HB-9'
		]}
	]},
	{ name: 'Group',
	  value: [
		  { name: 'MDLBG_STEREO_KEY',
		    value: [
			'cis',
			'trans'
		    ]}
	  ]}
];

dialog.match = function (params) {
	return !params.type ||
		params.type == 'DAT' && !!matchContext(params.attrs.fieldName, params.attrs.fieldValue);
};

module.exports = dialog;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../util":40}],33:[function(require,module,exports){
(function (global){
// TODO: exclude from no-groups build
var ui = global.ui;

function dialog (params) {
	var dlg = ui.showDialog('sgroup_properties');
	var type = params.type || 'GEN';

	$('sgroup_type').value = type;
	$('sgroup_type').activate();
	onChange_SGroupType.call($('sgroup_type'));

	switch (type) {
	case 'SRU':
		$('sgroup_connection').value = params.attrs.connectivity;
		$('sgroup_label').value = params.attrs.subscript;
		break;
	case 'MUL':
		$('sgroup_label').value = params.attrs.mul;
		break;
	case 'SUP':
		$('sgroup_label').value = params.attrs.name;
		break;
	case 'DAT':
		$('sgroup_field_name').value = params.attrs.fieldName;
		$('sgroup_field_value').value = params.attrs.fieldValue;
		if (params.attrs.attached)
			$('sgroup_pos_attached').checked = true;
		else if (params.attrs.absolute)
			$('sgroup_pos_absolute').checked = true;
		else
			$('sgroup_pos_relative').checked = true;
			break;
		default:
			break;
	}

	if (type != 'DAT') {
		$('sgroup_field_name').value = '';
		$('sgroup_field_value').value = '';
	}

	var handlers = [];
	handlers[0] = dlg.on('click', 'input[type=button]', function (_, button) {
		var key = 'on' + button.value.capitalize();
		var res = key != 'onOk' || getValidateAttrs();
		if (res) {
			handlers.forEach(function (h) { h.stop(); });
			ui.hideDialog('sgroup_properties');
			if (key in params && res)
				params[key](res);
		}
	});

	handlers[1] = $('sgroup_type').on('change', onChange_SGroupType);
	handlers[2] = $('sgroup_label').on('change', onChange_SGroupLabel);
};

function getValidateAttrs() {
	var type = $('sgroup_type').value;
	var attrs = {
		mul: null,
		connectivity: '',
		name: '',
		subscript: '',
		fieldName: '',
		fieldValue: '',
		attached: false,
		absolute: false
	};

	switch (type) {
	case 'SRU':
		attrs.connectivity = $('sgroup_connection').value.strip();
		attrs.subscript = $('sgroup_label').value.strip();
		if (attrs.subscript.length != 1 || !attrs.subscript.match(/^[a-zA-Z]$/)) {
			alert(attrs.subscript.length ? 'SRU subscript should consist of a single letter.' : 'Please provide an SRU subscript.');
			return null;
		}
		break;
	case 'MUL':
		attrs.mul = parseInt($('sgroup_label').value);
		break;
	case 'SUP':
		attrs.name = $('sgroup_label').value.strip();
		if (!attrs.name) {
			alert('Please provide a name for the superatom.');
			return null;
		}
		break;
	case 'DAT':
		attrs.fieldName = $('sgroup_field_name').value.strip();
		attrs.fieldValue = $('sgroup_field_value').value.strip();
		attrs.absolute = $('sgroup_pos_absolute').checked;
		attrs.attached = $('sgroup_pos_attached').checked;

		if (attrs.fieldName == '' || attrs.fieldValue == '') {
			alert('Please, specify data field name and value.');
			return null;
		}
		break;
	}
	return { type: type,
	         attrs: attrs };
};

function onChange_SGroupLabel ()
{
	if ($('sgroup_type').value == 'MUL' && !this.value.match(/^[1-9][0-9]{0,2}$/))
		this.value = '1';
};

function onChange_SGroupType ()
{
	var type = $('sgroup_type').value;
	if (type == 'DAT') {
		$$('#sgroup_properties .base')[0].hide();
		$$('#sgroup_properties .data')[0].show();
		return;
	}
	$$('#sgroup_properties .base')[0].show();
	$$('#sgroup_properties .data')[0].hide();

	$('sgroup_label').disabled = (type != 'SRU') && (type != 'MUL') && (type != 'SUP');
	$('sgroup_connection').disabled = (type != 'SRU');

	if (type == 'MUL' && !$('sgroup_label').value.match(/^[1-9][0-9]{0,2}$/))
		$('sgroup_label').value = '1';
	else if (type == 'SRU')
		$('sgroup_label').value = 'n';
	else if (type == 'GEN' || type == 'SUP')
		$('sgroup_label').value = '';
}

module.exports = dialog;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],34:[function(require,module,exports){
(function (global){
var Promise = require('promise-polyfill');
require('../../rnd');

var ajax = require('../../util/ajax.js');
var molfile = require('../../chem/molfile');

var ui = global.ui;
var rnd = global.rnd;

// TODO: move to Molfile
function parseSdf (sdf) {
	var items = sdf.split(/^[$][$][$][$]$/m);
	var parsed = [];

	items.each(function (item) {
		item = item.replace(/\r/g, '');
		item = item.strip();
		var end_idx = item.indexOf('M  END');

		if (end_idx == -1) {
			return;
		}

		var iparsed = {};

		iparsed.molfile = item.substring(0, end_idx + 6);
		iparsed.name = item.substring(0, item.indexOf('\n')).strip();
		item = item.substr(end_idx + 7).strip();

		var entries = item.split(/^$/m);

		entries.each(function (entry) {
			entry = entry.strip();
			if (!entry.startsWith('> <')) {
				return;
			}
			var lines = entry.split('\n');
			var field = lines[0].strip().substring(3, lines[0].lastIndexOf('>')).strip();

			iparsed[field] = parseInt(lines[1].strip()) || lines[1].strip();
		});
		parsed.push(iparsed);
	});

	return parsed;
}

function fetchTemplateCustom (base_url) {
	return ajax(base_url + 'templates.sdf').then(function (xhr) {
		//headers: {Accept: 'application/octet-stream'}
		var items = parseSdf(xhr.responseText);

		var templates = [];
		var i = 0;
		items.each(function (item) {
			templates.push({
				name: (item.name || ('customtemplate ' + (++i))).capitalize(),
				molfile: item.molfile,
				aid: (item.atomid || 1) - 1,
				bid: (item.bondid || 1) - 1
			});
		});

		return templates;
	});
};

var custom_templates;
function initTemplateCustom (el, base_url) {
	return fetchTemplateCustom(base_url).then(function (templates) {
		custom_templates = templates;
		return eachAsync(templates, function (tmpl, _) {
			var li =  new Element('li');
			li.title = tmpl.name;
			el.insert({ bottom: li });
			var mol = molfile.parse(tmpl.molfile),
			render = new rnd.Render(li, 0, {
				'autoScale': true,
				'autoScaleMargin': 0,
				//'debug': true,
				'ignoreMouseEvents': true,
				'hideChiralFlag': true,
				'maxBondLength': 30
			});
			render.setMolecule(mol);
			render.update();
		}, 50);
	});
}

function eachAsync(list, process, timeGap, startTimeGap) {
	return new Promise(function (resolve) {
		var i = 0;
		var n = list.length;
		function iterate() {
			if (i < n) {
				process(list[i], i++);
				setTimeout(iterate, timeGap);
			} else {
				resolve();
			}
		}
		setTimeout(iterate, startTimeGap || timeGap);
	});
};

function dialog (base_url, params) {
	var dlg = ui.showDialog('custom_templates'),
	selectedLi = dlg.select('.selected')[0],
	okButton = dlg.select('[value=OK]')[0],
	ul = dlg.select('ul')[0];

	if (ul.children.length === 0) { // first time
		$('loading').style.display = '';
		dlg.addClassName('loading');
		var loading = initTemplateCustom(ul, base_url).then(function () {
			$('loading').style.display = 'none';
			dlg.removeClassName('loading');
		});

		loading.then(function () {
			okButton.disabled = true;
			dlg.on('click', 'li', function (_, li) {
				if (selectedLi == li)
					okButton.click();
				else {
					if (selectedLi)
						selectedLi.removeClassName('selected');
					else
						okButton.disabled = false;
					li.addClassName('selected');
					selectedLi = li;
				}
			});
			dlg.on('click', 'input', function (_, input) {
				var mode = input.value,
				key = 'on' + input.value.capitalize(),
				res;
				if (mode == 'OK') {
					console.assert(selectedLi, 'No element selected');
					var ind = selectedLi.previousSiblings().size();
					res = custom_templates[ind];
				}
				ui.hideDialog('custom_templates');
				if (params && key in params)
					params[key](res);
			});
		});
	}
};

module.exports = dialog;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../chem/molfile":13,"../../rnd":22,"../../util/ajax.js":38,"promise-polyfill":3}],35:[function(require,module,exports){
(function (global){
var ui = global.ui = {};

require('../rnd');

var rnd = global.rnd;

var Promise = require('promise-polyfill');
var keymage = require('keymage');

var Set = require('../util/set');
var Vec2 = require('../util/vec2');
var util = require('../util');
var Action = require('./action.js');

var templates = require('./templates');

var element = require('../chem/element');
var Struct = require('../chem/struct');
var Atom = require('../chem/atom');
var Bond = require('../chem/bond');
var molfile = require('../chem/molfile');
var smiles = require('../chem/smiles');
var SGroup = require('../chem/sgroup');

var Editor = require('../rnd/editor');

var openDialog = require('./dialog/open.js');
var saveDialog = require('./dialog/save.js');
var selectDialog = require('./dialog/select');
var templatesDialog = require('./dialog/templates');
var sgroupDialog = require('./dialog/sgroup');
var sgroupSpecialDialog = require('./dialog/sgroup-special');
var obsolete = require('./dialog/obsolete');

var SCALE = 40;  // const
var HISTORY_LENGTH = 32;

var undoStack = [];
var redoStack = [];

var ketcherWindow;
var toolbar;
var lastSelected;
var clientArea = null;
var dropdownOpened;
var zspObj;
var server;

var serverActions = ['cleanup', 'arom', 'dearom', 'calc-cip',
                     'reaction-automap', 'template-custom'];
var clipActions = ['cut', 'copy', 'paste'];

function init (options, apiServer) {
	ketcherWindow = $$('[role=application]')[0] || $$('body')[0];
	toolbar = ketcherWindow.select('[role=toolbar]')[0];
	clientArea = $('canvas');
	server = apiServer;

	updateServerButtons();
	if (server) { // && ['http:', 'https:'].indexOf(window.location.protocol) >= 0) {
		// don't try to knock if the file is opened locally ("file:" protocol)
		// TODO: check when this is nesessary
		server.knocknock().then(function (res) {
			ui.standalone = false;
			updateServerButtons();
		}, function (val) {
			document.title += ' (standalone)';
			// TODO: echo instead
		}).then(function () {
			// TODO: move it out there as server incapsulates
			// standalone
			if (options.mol) {
				loadMolecule(options.mol);
			}
		});
	}

	obsolete.initDialogs();

	// Button events
	var keyMap = {};
	toolbar.select('button').each(function (el) {
		// window.status onhover?
		var caption =  el.textContent || el.innerText;
		var kd = el.dataset ? el.dataset.keys : el.getAttribute('data-keys');
		if (!kd)
			el.title = el.title || caption;
		else {
			var keys = kd.split(',').map(function (s) { return s.strip(); });
			var mk = shortcutStr(keys[0]);
			var action = el.parentNode.id;
			el.title = (el.title || caption) + ' (' + mk + ')';
			el.innerHTML += ' <kbd>' + mk + '</kbd>';

			keys.forEach(function (kb) {
				var nk = kb.toLowerCase();
				if (Array.isArray(keyMap[nk]))
				    keyMap[nk].push(action);
				else
					keyMap[nk] = [action];
			});
		}
	});
	keyMap = util.extend(keyMap, {
		'a': ['atom-any'],
		'defmod-a': ['select-all'],
		'defmod-shift-a': ['deselect-all'],
		'ctrl-alt-r': ['force-update']
	});

	Object.keys(keyMap).forEach(function (key) {
		keymage('editor', key, keyMap[key].length == 1 ? function (event) {
			// TODO: handle disabled
			var action = keyMap[key][0];
			if (clipActions.indexOf(action) == -1) {
				// else delegate to cliparea
				selectAction(keyMap[key][0]);
				event.preventDefault();
			}
		} : function () {
			console.info('actions', keyMap[key]);
		});
	});
	keymage.setScope('editor');

	toolbar.select('li').each(function (el) {
		el.on('click', function (event) {
			if (event.target.tagName == 'BUTTON' &&
			    event.target.parentNode == this) {
				if (!this.hasClassName('selected')) {
					event.stop();
				}
				selectAction(this.id);
			}

			if (hideBlurredControls()) {
				event.stop();
			}
			else if (this.getStyle('overflow') == 'hidden') {
				this.addClassName('opened');
				dropdownOpened = this;
				event.stop();
			}
		});
	});

	initCliparea(ketcherWindow);
	initZoom();
	updateHistoryButtons();

	clientArea.on('scroll', onScroll_ClientArea);
	clientArea.on('mousedown', function () {
		keymage.setScope('editor');
	});

	// Init renderer
	var opts = new rnd.RenderOptions(options);
	opts.atomColoring = true;
	ui.render =  new rnd.Render(clientArea, SCALE, opts);
	ui.editor = new Editor(ui.render);

	ui.render.onCanvasOffsetChanged = onOffsetChanged;

	selectAction('select-lasso');
	setScrollOffset(0, 0);

	ui.render.setMolecule(ui.ctab);
	ui.render.update();
};

function shortcutStr(key) {
	var isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
	return key.replace(/Defmod/g, isMac ? '⌘' : 'Ctrl')
		      .replace(/-(?!$)/g, '+');
}

function subEl (id) {
	return $(id).children[0];
};

function hideBlurredControls () {
	if (!dropdownOpened) {
		return false;
	}

	dropdownOpened.removeClassName('opened');
	var sel = dropdownOpened.select('.selected');
	if (sel.length == 1) {
		//var index = sel[0].previousSiblings().size();
		var menu = subEl(dropdownOpened);
		menu.style.marginTop = (-sel[0].offsetTop + menu.offsetTop) + 'px';
	}

	// FIX: Quick fix of Chrome (Webkit probably) box-shadow
	// repaint bug: http://bit.ly/1iiSMgy
	// needs investigation, performance
	clientArea.style.visibility = 'hidden';
	setTimeout(function () {
		clientArea.style.visibility = 'visible';
	}, 0);
	// ?? ui.render.update(true);
	// END
	dropdownOpened = null;
	return true;
};

function selectAction (action) {
	// TODO: lastSelected -> prevtool_id
	action = action || lastSelected;
	var el = $(action);
	var args = [].slice.call(arguments, 1);
	console.assert(action.startsWith, 'id is not a string', action);

	if (clipActions.indexOf(action) != -1 && args.length == 0)
		return delegateCliparea(action);

	// TODO: refactor !el - case when there are no such id
	if (!el || !subEl(el).disabled) {
		args.unshift(action);
		var tool = mapTool.apply(null, args);
		if (tool instanceof Editor.EditorTool) {
			var oldel = toolbar.select('.selected')[0];
			//console.assert(!lastSelected || oldel,
			//               "No last mode selected!");

			if (el != oldel || !el) { // tool canceling needed when dialog opens
				// if el.selected not changed
				if (ui.render.current_tool) {
					ui.render.current_tool.OnCancel();
				}
				ui.render.current_tool = tool;

				if (action.startsWith('select-')) {
					lastSelected = action;
				}
				if (el) {
					el.addClassName('selected');
				}
				if (oldel) {
					oldel.removeClassName('selected');
				}
			}
		}
		return tool;
	}
	return null;
};

function delegateCliparea(action) {
	var enabled = document.queryCommandSupported(action);
	if (enabled) try {
		document.execCommand(action);
	} catch (ex) {
		// FF < 41
		enabled = false;
	}
	if (!enabled) {
		var el = subEl(action);
		var key = el.dataset ? el.dataset.keys : el.getAttribute('data-keys');
		echo('These action is unavailble via menu.\n' +
		     'Instead, use ' + shortcutStr(key) + ' to ' + action + '.');
	}
	return null;
}

function initCliparea(parent) {
	var cliparea = new Element('input', { type: 'text', 'class': 'cliparea', autofocus: true});
	var ieCb = window.clipboardData;
	var pasteFormats = [
		'chemical/x-mdl-molfile',
		'chemical/x-mdl-rxnfile',
		'chemical/x-cml',
		'text/plain',
		'chemical/x-daylight-smiles',
		'chemical/x-inchi'
	];
	var autofocus = function() {
		if (keymage.getScope() == 'editor') {
			cliparea.value = ' ';
			cliparea.focus();
			cliparea.select();
			return true;
		}
		return false;
	};
	var copyCut = function (struct, cb) {
		var moldata = molfile.stringify(struct);
		if (!cb && ieCb) {
			ieCb.setData('text', moldata);
		} else {
			cb.setData('text/plain', moldata);
			try {
				cb.setData(!struct.isReaction ?
				           'chemical/x-mdl-molfile': 'chemical/x-mdl-rxnfile',
				           moldata);
				cb.setData('chemical/x-daylight-smiles',
				           smiles.stringify(struct));
			} catch (ex) {
				console.info('Could not write exact type', ex);
			}
		}
	};
	var paste = function (cb) {
		var data = '';
		if (!cb && ieCb) {
			data = ieCb.getData('text');
		} else {
			for (var i = 0; i < pasteFormats.length; i++) {
				data = cb.getData(pasteFormats[i]);
				if (data)
					break;
			}
		}
		console.info('paste', i >= 0 && pasteFormats[i], data.slice(0, 50), '..');
		return data;
	};

	parent.insert(cliparea);
	parent.on('mouseup', autofocus);

	// ? events should be attached to document
	['copy', 'cut'].forEach(function (action) {
		parent.on(action, function (event) {
			if (autofocus()) {
				var struct = selectAction(action, true);
				if (struct)
					copyCut(struct, event.clipboardData);
				event.preventDefault();
			}
		});
	});
	parent.on('paste', function (event) {
		if (autofocus()) {
			var data = paste(event.clipboardData);
			if (data)
				loadFragment(data);
			event.preventDefault();
		}
	});
}

function updateClipboardButtons () {
	subEl('copy').disabled = subEl('cut').disabled = !ui.editor.hasSelection(true);
};

function updateHistoryButtons () {
	subEl('undo').disabled = (undoStack.length == 0);
	subEl('redo').disabled = (redoStack.length == 0);
};

function updateServerButtons () {
	serverActions.forEach(function (action) {
		subEl(action).disabled = ui.standalone;
	});
};

function transitionEndEvent () {
	var el = document.createElement('transitionTest'),
	transEndEventNames = {
		'WebkitTransition': 'webkitTransitionEnd',
		'MozTransition': 'transitionend',
		'OTransition': 'oTransitionEnd otransitionend',
		'transition': 'transitionend'
	},
	name;
	for (name in transEndEventNames) {
		if (el.style[name] !== undefined)
			return transEndEventNames[name];
	}
	return false;
};

function animateToggle (el, callback) {
	ketcherWindow.addClassName('animate');
	var transitionEnd = transitionEndEvent(),
	animateStop = function (cb) {
		setTimeout(function () {
			cb && cb();
			ketcherWindow.removeClassName('animate');
		}, 0);
	};

	if (!callback || !transitionEnd) {
		animateStop(callback);
			callback || el();
	}
	else {
		var fireOne = function () {
			animateStop(callback);
			el.removeEventListener(transitionEnd, fireOne, false);
		};
		el.addEventListener(transitionEnd, fireOne, false);
	}
};

function showDialog (name) {
	var dialog = $(name);
	keymage.setScope('dialog');
	animateToggle(function () {
		$$('.overlay')[0].show();
		// dialog.show();
		dialog.style.display = '';
	});
	return dialog;
};

function hideDialog (name) {
	var cover = $$('.overlay')[0];
	animateToggle(cover, function () {
		// $(name).hide();
		$(name).style.display = 'none';
		cover.hide();
		keymage.setScope('editor');
	});
};

function showElemTable (params) {
	params.required = true;
	selectDialog('elem-table', params);
};

function showRGroupTable (params) {
	selectDialog('rgroup-table', params);
};

function showReaGenericsTable (params) {
	params.required = true;
	selectDialog('generics-table', params);
};

function echo (message) {
	// TODO: make special area for messages
	alert(message);
};

//
// Main section
//
function updateMolecule (mol) {
	if (typeof(mol) == 'undefined' || mol == null)
		return;

	ui.editor.deselectAll();
	addUndoAction(Action.fromNewCanvas(mol));
	showDialog('loading');
	// setTimeout(function ()
	// {
	try {
		ui.render.onResize(); // TODO: this methods should be called in the resize-event handler
		ui.render.update();
		setZoomCentered(null, ui.render.getStructCenter());
	}
	catch (er) {
		alert(er.message);
	}
	finally {
		hideDialog('loading');
	}
//    }, 50);
};


function addUndoAction (action, check_dummy)
{
	if (action == null)
		return;

	if (check_dummy != true || !action.isDummy())
	{
		undoStack.push(action);
		redoStack.clear();
		if (undoStack.length > HISTORY_LENGTH)
			undoStack.splice(0, 1);
		updateHistoryButtons();
	}
};

//
// New document
//
function onClick_NewFile ()
{
	selectAction(null);

	if (!ui.ctab.isBlank()) {
		addUndoAction(Action.fromNewCanvas(new Struct()));
		ui.render.update();
	}
}

function onClick_OpenFile ()
{
	openDialog({
		onOk: function (res) {
			if (res.fragment)
				loadFragment(res.value, true);
			else
				loadMolecule(res.value, true);
		}
	});
}

function onClick_SaveFile ()
{
	saveDialog({molecule: ui.ctab}, server);
}

function aromatize(mol, arom)
{
	mol = mol.clone();
	var implicitReaction = mol.addRxnArrowIfNecessary();
	var mol_string = molfile.stringify(mol);

	if (!ui.standalone) {
		var method = arom ? 'aromatize' : 'dearomatize',
		request = server[method]({moldata: mol_string});
		request.then(function (data) {
			var resmol = parseMayBeCorruptedCTFile(data);
			if (implicitReaction)
				resmol.rxnArrows.clear();
			updateMolecule(resmol);
		}, echo);
	} else {
		throw new Error('Aromatization and dearomatization are not supported in the standalone mode.');
	}
};

// TODO: merge with arom/dearom + spinner
function calculateCip() {
	util.assert(!ui.standalone, 'Can\'t calculate in standalone mode!'); // it's assert error now
	var mol = ui.ctab.clone();
	var implicitReaction = mol.addRxnArrowIfNecessary();
	var mol_string = molfile.stringify(mol);

	var request = server.calculateCip({moldata: mol_string});
	request.then(function (data) {
		var resmol = parseMayBeCorruptedCTFile(data);
		if (implicitReaction)
			resmol.rxnArrows.clear();
		updateMolecule(resmol);
	}).then(null, echo);
};

//
// Zoom section
//
function initZoom() {
	var zoomSelect = subEl('zoom-list');
	zoomSelect.on('focus', function () {
		keymage.pushScope('zoom');
	});
	zoomSelect.on('blur', function () {
		keymage.popScope('zoom');
	});
	zoomSelect.on('change', updateZoom);
	updateZoom(true);
}

function onClick_ZoomIn () {
	subEl('zoom-list').selectedIndex++;
	updateZoom();
};

function onClick_ZoomOut () {
	subEl('zoom-list').selectedIndex--;
	updateZoom();
};

function updateZoom (noRefresh) {
	var zoomSelect = subEl('zoom-list');
	var i = zoomSelect.selectedIndex,
	    len = zoomSelect.length;
	console.assert(0 <= i && i < len, 'Zoom out of range');

	subEl('zoom-in').disabled = (i == len - 1);
	subEl('zoom-out').disabled = (i == 0);

	var value = parseFloat(zoomSelect.options[i].innerHTML) / 100;
	// TODO: remove this shit (used in rnd.Render guts
	// only in dialog/crap and render one time
	ui.zoom = value;
	if (!noRefresh) {
		setZoomCentered(value,
		                ui.render.getStructCenter(ui.editor.getSelection()));
		ui.render.update();
	}
};

function setZoomRegular (zoom) {
	//mr: prevdent unbounded zooming
	//begin
	if (zoom < 0.1 || zoom > 10)
		return;
	//end
	ui.zoom = zoom;
	ui.render.setZoom(ui.zoom);
	// when scaling the canvas down it may happen that the scaled canvas is smaller than the view window
	// don't forget to call setScrollOffset after zooming (or use extendCanvas directly)
};

// get the size of the view window in pixels
function getViewSz () {
	return new Vec2(ui.render.viewSz);
};

// c is a point in scaled coordinates, which will be positioned in the center of the view area after zooming
function setZoomCentered (zoom, c) {
	if (!c)
		throw new Error('Center point not specified');
	if (zoom) {
		setZoomRegular(zoom);
	}
	setScrollOffset(0, 0);
	var sp = ui.render.obj2view(c).sub(ui.render.viewSz.scaled(0.5));
	setScrollOffset(sp.x, sp.y);
};

// set the reference point for the "static point" zoom (in object coordinates)
function setZoomStaticPointInit (s) {
	zspObj = new Vec2(s);
};

// vp is the point where the reference point should now be (in view coordinates)
function setZoomStaticPoint (zoom, vp) {
	setZoomRegular(zoom);
	setScrollOffset(0, 0);
	var avp = ui.render.obj2view(zspObj);
	var so = avp.sub(vp);
	setScrollOffset(so.x, so.y);
};

function setScrollOffset (x, y) {
	var cx = clientArea.clientWidth;
	var cy = clientArea.clientHeight;
	ui.render.extendCanvas(x, y, cx + x, cy + y);
	clientArea.scrollLeft = x;
	clientArea.scrollTop = y;
	scrollLeft = clientArea.scrollLeft; // TODO: store drag position in scaled systems
	scrollTop = clientArea.scrollTop;
};

function setScrollOffsetRel (dx, dy) {
	setScrollOffset(clientArea.scrollLeft + dx, clientArea.scrollTop + dy);
};

//
// Automatic layout
//
function onClick_CleanUp ()
{
	var atoms = util.array(ui.editor.getSelection(true).atoms);
	var selective = atoms.length > 0;
	if (selective) {
		var atomSet = Set.fromList(atoms);
		var atomSetExtended = Set.empty();
		ui.ctab.loops.each(function (lid, loop) {
			// if selection contains any of the atoms in this loop, add all the atoms in the loop to selection
			if (util.findIndex(loop.hbs, function (hbid) {
				return Set.contains(atomSet, ui.ctab.halfBonds.get(hbid).begin);
			}) >= 0)
				util.each(loop.hbs, function (hbid) {
					Set.add(atomSetExtended, ui.ctab.halfBonds.get(hbid).begin);
				}, this);
		}, this);
		Set.mergeIn(atomSetExtended, atomSet);
		atoms = Set.list(atomSetExtended);
	}
	ui.editor.deselectAll();
	try {
		var aidMap = {};
		var mol = ui.ctab.clone(null, null, false, aidMap);
		if (selective) {
			util.each(atoms, function (aid){
				aid = aidMap[aid];
				var dsg = new SGroup('DAT');
				var dsgid = mol.sgroups.add(dsg);
				dsg.id = dsgid;
				dsg.pp = new Vec2();
				dsg.data.fieldName = '_ketcher_selective_layout';
				dsg.data.fieldValue = '1';
				mol.atomAddToSGroup(dsgid, aid);
			}, this);
		}
		var implicitReaction = mol.addRxnArrowIfNecessary();
		var req = server.layout({
			moldata: molfile.stringify(mol)
		}, selective ? {'selective': 1} : null);
		req.then(function (res) {
			var struct = parseMayBeCorruptedCTFile(res);
			if (implicitReaction)
				struct.rxnArrows.clear();
			updateMolecule(struct);
		});
	} catch (er) {
			alert('ERROR: ' + er.message); // TODO [RB] ??? global re-factoring needed on error-reporting
		}
};

function onClick_Aromatize ()
{
	try {
		aromatize(ui.ctab, true);
	} catch (er) {
		alert('Molfile: ' + er.message);
	}
};

function onClick_Dearomatize ()
{
	try {
		aromatize(ui.ctab, false);
	} catch (er) {
		alert('Molfile: ' + er.message);
	}
};

function onClick_Automap () {
	obsolete.showAutomapProperties({
		onOk: function (mode) {
			var mol = ui.ctab;
			var implicitReaction = mol.addRxnArrowIfNecessary();
			if (mol.rxnArrows.count() == 0) {
				echo('Auto-Mapping can only be applied to reactions');
				return;
			}
			var moldata = molfile.stringify(mol, { ignoreErrors: true }),
			request = server.automap({
				moldata: moldata,
				mode: mode
			});

			request.then(function (res) {
				var mol = parseMayBeCorruptedCTFile(res);
				if (implicitReaction) {
					mol.rxnArrows.clear();
				}
				/*
                 var aam = parseCTFile(res.responseText);
                 var action = new Action();
                 for (var aid = aam.atoms.count() - 1; aid >= 0; aid--) {
                 action.mergeWith(Action.fromAtomAttrs(aid, { aam : aam.atoms.get(aid).aam }));
                 }
                 addUndoAction(action, true);
                 */
				updateMolecule(mol);
				/*
                 ui.render.update();
                 */

			}, echo);
		}
	});
};

function loadMolecule (mol, checkEmptyLine) {
	return getStruct(mol,
	                 checkEmptyLine).then(updateMolecule, function (err) {
		                 console.error('To DS:', err);
	                 });
}

function loadFragment (mol, checkEmptyLine) {
	return getStruct(mol, checkEmptyLine).then(function (struct) {
		struct.rescale();
		selectAction('paste', struct);
	});
}

function guessType(mol, strict) {
	// Mimic Indigo/molecule_auto_loader.cpp as much as possible
	var molStr = mol.trim();
	var molMatch = molStr.match(/^(M  END|\$END MOL)$/m);
	if (molMatch) {
		var end = molMatch.index + molMatch[0].length;
		if (end == molStr.length ||
		    molStr.slice(end, end + 20).search(/^\$(MOL|END CTAB)$/m) != -1)
			return 'mol';
	}
	if (molStr[0] == '<' && molStr.indexOf('<molecule') != -1)
		return 'cml';
	if (molStr.slice(0, 5) == 'InChI')
		return 'inchi';
	if (molStr.indexOf('\n') == -1)
		return 'smiles';
	// Molfile by default as Indigo does
	return strict ? null : 'mol';
}

function getStruct(mol, checkEmptyLine) {
	return new Promise(function (resolve, reject) {
		var type = guessType(mol);
		if (type == 'mol') {
			var struct = parseMayBeCorruptedCTFile(mol,
			                                       checkEmptyLine);
			resolve(struct);
		} else if (ui.standalone)
			throw type ? type.toUpperCase() : 'Format' +
			      ' is not supported in a standalone mode.';
		else {
			var req = (type == 'smiles') ?
			    server.layout_smiles(null, {smiles: mol.trim()}) :
			    server.molfile({moldata: mol});
			resolve(req.then(function (res) {
				return parseMayBeCorruptedCTFile(res);
			}));
		}
	});
};

function page2canvas2 (pos)
{
	var offset = clientArea.cumulativeOffset();
	return new Vec2(pos.pageX - offset.left, pos.pageY - offset.top);
};

function page2obj (pagePos)
{
	return ui.render.view2obj(page2canvas2(pagePos));
};

function scrollPos ()
{
	return new Vec2(clientArea.scrollLeft, clientArea.scrollTop);
};

//
// Scrolling
//
var scrollLeft = null;
var scrollTop = null;

function onScroll_ClientArea (event)
{
	// ! DIALOG ME
	// if ($('input_label').visible())
	//      $('input_label').hide();

	scrollLeft = clientArea.scrollLeft;
	scrollTop = clientArea.scrollTop;

	util.stopEventPropagation(event);
};

//
// Canvas size
//
function onOffsetChanged (newOffset, oldOffset)
{
	if (oldOffset == null)
		return;

	var delta = new Vec2(newOffset.x - oldOffset.x, newOffset.y - oldOffset.y);

	clientArea.scrollLeft += delta.x;
	clientArea.scrollTop += delta.y;
};

function removeSelected ()
{
	addUndoAction(Action.fromFragmentDeletion());
	ui.editor.deselectAll();
	ui.render.update();
};

function undo ()
{
	if (ui.render.current_tool)
		ui.render.current_tool.OnCancel();

	ui.editor.deselectAll();
	redoStack.push(undoStack.pop().perform());
	ui.render.update();
	updateHistoryButtons();
};

function redo ()
{
	if (ui.render.current_tool)
		ui.render.current_tool.OnCancel();

	ui.editor.deselectAll();
	undoStack.push(redoStack.pop().perform());
	ui.render.update();
	updateHistoryButtons();
};

var current_elemtable_props = null;
function onClick_ElemTableButton ()
{
	showElemTable({
		onOk: function (res) {
			var props;
			if (res.mode == 'single')
				props = {
					label: element.get(res.values[0]).label
				};
			else
				props = {
					label: 'L#',
					atomList: new Atom.List({
						notList: res.mode == 'not-list',
						ids: res.values
					})
				};
			current_elemtable_props = props;
			selectAction('atom-table');
			return true;
		},
		onCancel: function () {
			//ui.elem_table_obj.restore();
		}
	});
};

var current_reagenerics = null;
function onClick_ReaGenericsTableButton ()
{
	showReaGenericsTable({
		onOk: function (res) {
			current_reagenerics = {label: res.values[0]};
			selectAction('atom-reagenerics');
			return true;
		}
	});
};

// TODO: remove this crap (quick hack to pass parametr to selectAction)
var current_template_custom = null;
function onClick_TemplateCustom () {
	templatesDialog('', {
		onOk: function (tmpl) {
			current_template_custom = tmpl;
			selectAction('template-custom-select');
			return true;
		}
	});
};

function showSgroupDialog(params) {
	if (false && sgroupSpecialDialog.match(params))
		return sgroupSpecialDialog(params);
	return sgroupDialog(params);
};

// try to reconstruct molfile string instead parsing multiple times
// TODO: move this logic to Molfile
function parseMayBeCorruptedCTFile (mol, checkEmptyLine) {
	var lines = util.splitNewlines(mol);
	try {
		return molfile.parse(lines);
	} catch (ex) {
		if (checkEmptyLine) {
			try {
				// check whether there's an extra empty line on top
				// this often happens when molfile text is pasted into the dialog window
				return molfile.parse(lines.slice(1));
			} catch (ex1) {
			}
			try {
				// check for a missing first line
				// this sometimes happens when pasting
				return molfile.parse([''].concat(lines));
			} catch (ex2) {
			}
		}
		throw ex;
	}
};

var actionMap = {
	'new': onClick_NewFile,
	'open': onClick_OpenFile,
	'save': onClick_SaveFile,
	'undo': undo,
	'redo': redo,
	'zoom-in': onClick_ZoomIn,
	'zoom-out': onClick_ZoomOut,
	'cleanup': onClick_CleanUp,
	'arom': onClick_Aromatize,
	'dearom': onClick_Dearomatize,
	'period-table': onClick_ElemTableButton,
	'generic-groups': onClick_ReaGenericsTableButton,
	'template-custom': onClick_TemplateCustom,
	'cut': function () {
		var struct = ui.editor.getSelectionStruct();
		removeSelected();
		return struct.isBlank() ? null : struct;
	},
	'copy': function () {
		var struct = ui.editor.getSelectionStruct();
		ui.editor.deselectAll();
		return struct.isBlank() ? null : struct;
	},
	'paste': function (struct) {
		if (struct.isBlank())
			throw 'Not a valid structure to paste';
		ui.editor.deselectAll();
		return new Editor.PasteTool(ui.editor, struct);
	},
	'info': function (el) {
		showDialog('about_dialog');
	},
	'select-all': function () {
		ui.editor.selectAll();
	},
	'deselect-all': function () {
		ui.editor.deselectAll();
	},
	'force-update': function () {
		// original: for dev purposes
		ui.render.update(true);
	},
	'reaction-automap': onClick_Automap,
	'calc-cip': calculateCip
};

// TODO: rewrite declaratively, merge to actionMap
function mapTool (id) {

	console.assert(id, 'The null tool');

	var args = [].slice.call(arguments, 1);
	if (actionMap[id])
		return actionMap[id].apply(null, args);
	// special cases
	if (ui.editor.hasSelection()) {
		if (id == 'erase') {
			removeSelected();
			return null;
		}
		// BK: TODO: add this ability to mass-change atom labels to the keyboard handler
		if (id.startsWith('atom-')) {
			addUndoAction(Action.fromAtomsAttrs(ui.editor.getSelection().atoms, atomLabel(id)), true);
			ui.render.update();
			return null;
		}

		if (id.startsWith('transform-flip')) {
			addUndoAction(Action.fromFlip(ui.editor.getSelection(),
				id.endsWith('h') ? 'horizontal' :
					'vertical'),
				true);
			ui.render.update();
			return null;
		}

		/* BK: TODO: add this ability to change the bond under cursor to the editor tool
         else if (mode.startsWith('bond_')) {
         var cBond = ui.render.findClosestBond(page2obj(ui.cursorPos));
         if (cBond) {
         addUndoAction(Action.fromBondAttrs(cBond.id, { type: bondType(mode).type, stereo: Bond.PATTERN.STEREO.NONE }), true);
         ui.render.update();
         return;
         }
         } */
	}

	if (id != 'transform-rotate')
		ui.editor.deselectAll();

	if (id == 'select-lasso') {
		return new Editor.LassoTool(ui.editor, 0);
	} else if (id == 'select-rectangle') {
		return new Editor.LassoTool(ui.editor, 1);
	} else if (id == 'select-fragment') {
		return new Editor.LassoTool(ui.editor, 1, true);
	} else if (id == 'erase') {
		return new Editor.EraserTool(ui.editor, 1); // TODO last selector mode is better
	} else if (id.startsWith('atom-')) {
		return new Editor.AtomTool(ui.editor, atomLabel(id));
	} else if (id.startsWith('bond-')) {
		return new Editor.BondTool(ui.editor, bondType(id));
	} else if (id == 'chain') {
		return new Editor.ChainTool(ui.editor);
	} else if (id.startsWith('template-custom')) {
		return new Editor.TemplateTool(ui.editor, current_template_custom);
	} else if (id.startsWith('template')) {
		return new Editor.TemplateTool(ui.editor, templates[parseInt(id.split('-')[1])]);
	} else if (id == 'charge-plus') {
		return new Editor.ChargeTool(ui.editor, 1);
	} else if (id == 'charge-minus') {
		return new Editor.ChargeTool(ui.editor, -1);
	} else if (id == 'sgroup') {
		return new Editor.SGroupTool(ui.editor);
	} else if (id == 'reaction-arrow') {
		return new Editor.ReactionArrowTool(ui.editor);
	} else if (id == 'reaction-plus') {
		return new Editor.ReactionPlusTool(ui.editor);
	} else if (id == 'reaction-map') {
		return new Editor.ReactionMapTool(ui.editor);
	} else if (id == 'reaction-unmap') {
		return new Editor.ReactionUnmapTool(ui.editor);
	} else if (id == 'rgroup-label') {
		return new Editor.RGroupAtomTool(ui.editor);
	} else if (id == 'rgroup-fragment') {
		return new Editor.RGroupFragmentTool(ui.editor);
	} else if (id == 'rgroup-attpoints') {
		return new Editor.APointTool(ui.editor);
	} else if (id.startsWith('transform-rotate')) {
		return new Editor.RotateTool(ui.editor);
	}
	return null;
};

// TODO: remove. only in obsolete dialogs
var bondTypeMap = {
	'single': {type: 1, stereo: Bond.PATTERN.STEREO.NONE},
	'up': {type: 1, stereo: Bond.PATTERN.STEREO.UP},
	'down': {type: 1, stereo: Bond.PATTERN.STEREO.DOWN},
	'updown': {type: 1, stereo: Bond.PATTERN.STEREO.EITHER},
	'double': {type: 2, stereo: Bond.PATTERN.STEREO.NONE},
	'crossed': {type: 2, stereo: Bond.PATTERN.STEREO.CIS_TRANS},
	'triple': {type: 3, stereo: Bond.PATTERN.STEREO.NONE},
	'aromatic': {type: 4, stereo: Bond.PATTERN.STEREO.NONE},
	'singledouble': {type: 5, stereo: Bond.PATTERN.STEREO.NONE},
	'singlearomatic': {type: 6, stereo: Bond.PATTERN.STEREO.NONE},
	'doublearomatic': {type: 7, stereo: Bond.PATTERN.STEREO.NONE},
	'any':  {type: 8, stereo: Bond.PATTERN.STEREO.NONE}
};

function bondType (mode)
{
	var type_str = mode.substr(5);
	return bondTypeMap[type_str];
};

function atomLabel (mode) {
	var label = mode.substr(5);
	switch (label) {
	case 'table':
		return current_elemtable_props;
	case 'reagenerics':
		return current_reagenerics;
	case 'any':
		return {label:'A'};
	default:
		label = label.capitalize();
		console.assert(element.getElementByLabel(label),
		              "No such atom exist");
		return {label: label};
	}
};

function clean () {
	// latter if (initialized)
	Action.fromNewCanvas(new Struct());
	ui.render.update();
	undoStack.clear();
	redoStack.clear();
	updateHistoryButtons();
	selectAction(null);
}

// The expose guts two way
module.exports = {
	init: init,
	clean: clean,
	loadMolecule: loadMolecule,
	loadFragment: loadFragment
};

util.extend(ui, module.exports);

util.extend(ui, {
	standalone: true,
	ctab: new Struct(),
	render: null,
	editor: null,

	hideBlurredControls: hideBlurredControls,
	updateClipboardButtons: updateClipboardButtons,
	selectAction: selectAction,
	addUndoAction: addUndoAction,

	// TODO: remove me as we get better server API
	loadMoleculeFromFile: openDialog.loadHook,

	echo: echo,
	showDialog: showDialog,
	hideDialog: hideDialog,
	bondTypeMap: bondTypeMap,

	// TODO: move schrool/zoom machinery to render
	zoom: 1.0,
	setZoomStaticPointInit: setZoomStaticPointInit,
	setZoomStaticPoint: setZoomStaticPoint,
	page2canvas2: page2canvas2,
	scrollPos: scrollPos,
	page2obj: page2obj,

	// TODO: search a way to pass dialogs to editor
	showSGroupProperties: showSgroupDialog,
	showRGroupTable: showRGroupTable,
	showElemTable: showElemTable,
	showReaGenericsTable: showReaGenericsTable,
	showAtomAttachmentPoints: obsolete.showAtomAttachmentPoints,
	showAtomProperties: obsolete.showAtomProperties,
	showBondProperties: obsolete.showBondProperties,
	showRLogicTable: obsolete.showRLogicTable,
	showLabelEditor: obsolete.showLabelEditor
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../chem/atom":8,"../chem/bond":9,"../chem/element":12,"../chem/molfile":13,"../chem/sgroup":15,"../chem/smiles":16,"../chem/struct":18,"../rnd":22,"../rnd/editor":21,"../util":40,"../util/set":43,"../util/vec2":44,"./action.js":27,"./dialog/obsolete":28,"./dialog/open.js":29,"./dialog/save.js":30,"./dialog/select":31,"./dialog/sgroup":33,"./dialog/sgroup-special":32,"./dialog/templates":34,"./templates":37,"keymage":2,"promise-polyfill":3}],36:[function(require,module,exports){
(function (global){
var Vec2 = require('../util/vec2');
var Set = require('../util/set');

var Struct = require('../chem/struct');
var Atom = require('../chem/atom');
var Bond = require('../chem/bond');
var SGroup = require('../chem/sgroup');

require('../rnd');

var ui = global.ui;
var rnd = global.rnd;

function Base () {
	this.type = 'OpBase';

	// assert here?
	this._execute = function () {
		throw new Error('Operation._execute() is not implemented');
	};
	this._invert = function () {
		throw new Error('Operation._invert() is not implemented');
	};

	this.perform = function (editor) {
		this._execute(editor);
		if (!this.__inverted) {
			this.__inverted = this._invert();
			this.__inverted.__inverted = this;
		}
		return this.__inverted;
	};
	this.isDummy = function (editor) {
		return this._isDummy ? this._isDummy(editor) : false;
	};
}

function AtomAdd (atom, pos) {
	this.data = { aid: null, atom: atom, pos: pos };
	this._execute = function (editor) {
		var R = editor.render, RS = R.ctab, DS = RS.molecule;
		var pp = {};
		if (this.data.atom)
			for (var p in this.data.atom)
				pp[p] = this.data.atom[p];
		pp.label = pp.label || 'C';
		if (!Object.isNumber(this.data.aid)) {
			this.data.aid = DS.atoms.add(new Atom(pp));
		} else {
			DS.atoms.set(this.data.aid, new Atom(pp));
		}
		RS.notifyAtomAdded(this.data.aid);
		DS._atomSetPos(this.data.aid, new Vec2(this.data.pos));
	};
	this._invert = function () {
		var ret = new AtomDelete();
		ret.data = this.data;
		return ret;
	};
};
AtomAdd.prototype = new Base();

function AtomDelete (aid) {
	this.data = { aid: aid, atom: null, pos: null };
	this._execute = function (editor) {
		var R = editor.render, RS = R.ctab, DS = RS.molecule;
		if (!this.data.atom) {
			this.data.atom = DS.atoms.get(this.data.aid);
			this.data.pos = R.atomGetPos(this.data.aid);
		}
		RS.notifyAtomRemoved(this.data.aid);
		DS.atoms.remove(this.data.aid);
	};
	this._invert = function () {
		var ret = new AtomAdd();
		ret.data = this.data;
		return ret;
	};
};
AtomDelete.prototype = new Base();

function AtomAttr (aid, attribute, value) {
	this.data = { aid: aid, attribute: attribute, value: value };
	this.data2 = null;
	this._execute = function (editor) {
		var atom = editor.render.ctab.molecule.atoms.get(this.data.aid);
		if (!this.data2) {
			this.data2 = { aid: this.data.aid, attribute: this.data.attribute, value: atom[this.data.attribute] };
		}
		atom[this.data.attribute] = this.data.value;
		editor.render.invalidateAtom(this.data.aid);
	};
	this._isDummy = function (editor) {
		return editor.render.ctab.molecule.atoms.get(this.data.aid)[this.data.attribute] == this.data.value;
	};
	this._invert = function () {
		var ret = new AtomAttr();
		ret.data = this.data2;
		ret.data2 = this.data;return ret;
	};
};
AtomAttr.prototype = new Base();

function AtomMove (aid, d, noinvalidate) {
	this.data = {aid: aid, d: d, noinvalidate: noinvalidate};
	this._execute = function (editor) {
		var R = editor.render;
		var RS = R.ctab;
		var DS = RS.molecule;
		var aid = this.data.aid;
		var d = this.data.d;
		DS.atoms.get(aid).pp.add_(d);
		RS.atoms.get(aid).visel.translate(R.ps(d));
		this.data.d = d.negated();
		if (!this.data.noinvalidate)
			R.invalidateAtom(aid, 1);
	};
	this._isDummy = function (editor) {
		return this.data.d.x == 0 && this.data.d.y == 0;
	};
	this._invert = function () {
		var ret = new AtomMove();
		ret.data = this.data;
		return ret;
	};
};
AtomMove.prototype = new Base();

function BondMove (bid, d) {
	this.data = {bid: bid, d: d};
	this._execute = function (editor) {
		var R = editor.render;
		var RS = R.ctab;
		RS.bonds.get(this.data.bid).visel.translate(R.ps(this.data.d));
		this.data.d = this.data.d.negated();
	};
	this._invert = function () {
		var ret = new BondMove();
		ret.data = this.data;
		return ret;
	};
};
BondMove.prototype = new Base();

function LoopMove (id, d) {
	this.data = {id: id, d: d};
	this._execute = function (editor) {
		var R = editor.render;
		var RS = R.ctab;
		// not sure if there should be an action to move a loop in the first place
		// but we have to somehow move the aromatic ring, which is associated with the loop, rather than with any of the bonds
		if (RS.reloops.get(this.data.id) && RS.reloops.get(this.data.id).visel)
			RS.reloops.get(this.data.id).visel.translate(R.ps(this.data.d));
		this.data.d = this.data.d.negated();
	};
	this._invert = function () {
		var ret = new LoopMove();
		ret.data = this.data;
		return ret;
	};
};
LoopMove.prototype = new Base();

function SGroupAtomAdd (sgid, aid) {
	this.type = 'OpSGroupAtomAdd';
	this.data = {'aid': aid, 'sgid': sgid};
	this._execute = function (editor) {
		var R = editor.render, RS = R.ctab, DS = RS.molecule;
		var aid = this.data.aid;
		var sgid = this.data.sgid;
		var atom = DS.atoms.get(aid);
		var sg = DS.sgroups.get(sgid);
		if (sg.atoms.indexOf(aid) >= 0)
			throw new Error('The same atom cannot be added to an S-group more than once');
		if (!atom)
			throw new Error('OpSGroupAtomAdd: Atom ' + aid + ' not found');
		DS.atomAddToSGroup(sgid, aid);
		R.invalidateAtom(aid);
	};
	this._invert = function () {
		var ret = new SGroupAtomRemove();
		ret.data = this.data;
		return ret;
	};
};
SGroupAtomAdd.prototype = new Base();

function SGroupAtomRemove (sgid, aid) {
	this.type = 'OpSGroupAtomRemove';
	this.data = {'aid': aid, 'sgid': sgid};
	this._execute = function (editor) {
		var aid = this.data.aid;
		var sgid = this.data.sgid;
		var R = editor.render, RS = R.ctab, DS = RS.molecule;
		var atom = DS.atoms.get(aid);
		var sg = DS.sgroups.get(sgid);
		SGroup.removeAtom(sg, aid);
		Set.remove(atom.sgs, sgid);
		R.invalidateAtom(aid);
	};
	this._invert = function () {
		var ret = new SGroupAtomAdd();
		ret.data = this.data;
		return ret;
	};
};
SGroupAtomRemove.prototype = new Base();

function SGroupAttr (sgid, attr, value) {
	this.type = 'OpSGroupAttr';
	this.data = {sgid: sgid, attr: attr, value: value};
	this._execute = function (editor) {
		var R = editor.render, RS = R.ctab, DS = RS.molecule;
		var sgid = this.data.sgid;
		var sg = DS.sgroups.get(sgid);
		if (sg.type == 'DAT' && RS.sgroupData.has(sgid)) { // clean the stuff here, else it might be left behind if the sgroups is set to "attached"
			RS.clearVisel(RS.sgroupData.get(sgid).visel);
			RS.sgroupData.unset(sgid);
		}

		this.data.value = sg.setAttr(this.data.attr, this.data.value);
	};
	this._invert = function () {
		var ret = new SGroupAttr();
		ret.data = this.data;
		return ret;
	};
};
SGroupAttr.prototype = new Base();

function SGroupCreate (sgid, type, pp) {
	this.type = 'OpSGroupCreate';
	this.data = {'sgid': sgid, 'type': type, 'pp': pp};
	this._execute = function (editor) {
		var R = editor.render, RS = R.ctab, DS = RS.molecule;
		var sg = new SGroup(this.data.type);
		var sgid = this.data.sgid;
		sg.id = sgid;
		DS.sgroups.set(sgid, sg);
		if (this.data.pp) {
			DS.sgroups.get(sgid).pp = new Vec2(this.data.pp);
		}
		RS.sgroups.set(sgid, new rnd.ReSGroup(DS.sgroups.get(sgid)));
		this.data.sgid = sgid;
	};
	this._invert = function () {
		var ret = new SGroupDelete();
		ret.data = this.data;
		return ret;
	};
};
SGroupCreate.prototype = new Base();

function SGroupDelete (sgid) {
	this.type = 'OpSGroupDelete';
	this.data = {'sgid': sgid};
	this._execute = function (editor) {
		var R = editor.render, RS = R.ctab, DS = RS.molecule;
		var sgid = this.data.sgid;
		var sg = RS.sgroups.get(sgid);
		this.data.type = sg.item.type;
		this.data.pp = sg.item.pp;
		if (sg.item.type == 'DAT' && RS.sgroupData.has(sgid)) {
			RS.clearVisel(RS.sgroupData.get(sgid).visel);
			RS.sgroupData.unset(sgid);
		}

		RS.clearVisel(sg.visel);
		if (sg.item.atoms.length != 0)
			throw new Error('S-Group not empty!');
		RS.sgroups.unset(sgid);
		DS.sgroups.remove(sgid);
	};
	this._invert = function () {
		var ret = new SGroupCreate();
		ret.data = this.data;
		return ret;
	};
};
SGroupDelete.prototype = new Base();

function SGroupAddToHierarchy (sgid) {
	this.type = 'OpSGroupAddToHierarchy';
	this.data = {'sgid': sgid};
	this._execute = function (editor) {
		var R = editor.render, RS = R.ctab, DS = RS.molecule;
		var sgid = this.data.sgid;
		var relations = DS.sGroupForest.insert(sgid, this.data.parent, this.data.children);
		this.data.parent = relations.parent;
		this.data.children = relations.children;
	};
	this._invert = function () {
		var ret = new SGroupRemoveFromHierarchy();
		ret.data = this.data;
		return ret;
	};
};
SGroupAddToHierarchy.prototype = new Base();

function SGroupRemoveFromHierarchy (sgid) {
	this.type = 'OpSGroupRemoveFromHierarchy';
	this.data = {'sgid': sgid};
	this._execute = function (editor) {
		var R = editor.render, RS = R.ctab, DS = RS.molecule;
		var sgid = this.data.sgid;
		this.data.parent = DS.sGroupForest.parent.get(sgid);
		this.data.children = DS.sGroupForest.children.get(sgid);
		DS.sGroupForest.remove(sgid);
	};
	this._invert = function () {
		var ret = new SGroupAddToHierarchy();
		ret.data = this.data;
		return ret;
	};
};
SGroupRemoveFromHierarchy.prototype = new Base();

function BondAdd (begin, end, bond) {
	this.data = { bid: null, bond: bond, begin: begin, end: end };
	this._execute = function (editor) {
		var R = editor.render, RS = R.ctab, DS = RS.molecule;
		if (this.data.begin == this.data.end)
			throw new Error('Distinct atoms expected');
		if (rnd.DEBUG && this.molecule.checkBondExists(this.data.begin, this.data.end))
			throw new Error('Bond already exists');

		R.invalidateAtom(this.data.begin, 1);
		R.invalidateAtom(this.data.end, 1);

		var pp = {};
		if (this.data.bond)
			for (var p in this.data.bond)
				pp[p] = this.data.bond[p];
		pp.type = pp.type || Bond.PATTERN.TYPE.SINGLE;
		pp.begin = this.data.begin;
		pp.end = this.data.end;

		if (!Object.isNumber(this.data.bid)) {
			this.data.bid = DS.bonds.add(new Bond(pp));
		} else {
			DS.bonds.set(this.data.bid, new Bond(pp));
		}
		DS.bondInitHalfBonds(this.data.bid);
		DS.atomAddNeighbor(DS.bonds.get(this.data.bid).hb1);
		DS.atomAddNeighbor(DS.bonds.get(this.data.bid).hb2);

		RS.notifyBondAdded(this.data.bid);
	};
	this._invert = function () {
		var ret = new BondDelete();
		ret.data = this.data;
		return ret;
	};
};
BondAdd.prototype = new Base();

function BondDelete (bid) {
	this.data = { bid: bid, bond: null, begin: null, end: null };
	this._execute = function (editor) {
		var R = editor.render, RS = R.ctab, DS = RS.molecule;
		if (!this.data.bond) {
			this.data.bond = DS.bonds.get(this.data.bid);
			this.data.begin = this.data.bond.begin;
			this.data.end = this.data.bond.end;
		}

		R.invalidateBond(this.data.bid);

		RS.notifyBondRemoved(this.data.bid);

		var bond = DS.bonds.get(this.data.bid);
		[bond.hb1, bond.hb2].each(function (hbid) {
			var hb = DS.halfBonds.get(hbid);
			var atom = DS.atoms.get(hb.begin);
			var pos = atom.neighbors.indexOf(hbid);
			var prev = (pos + atom.neighbors.length - 1) % atom.neighbors.length;
			var next = (pos + 1) % atom.neighbors.length;
			DS.setHbNext(atom.neighbors[prev], atom.neighbors[next]);
			atom.neighbors.splice(pos, 1);
		}, this);
		DS.halfBonds.unset(bond.hb1);
		DS.halfBonds.unset(bond.hb2);

		DS.bonds.remove(this.data.bid);
	};
	this._invert = function () {
		var ret = new BondAdd();
		ret.data = this.data;
		return ret;
	};
};
BondDelete.prototype = new Base();

function BondAttr (bid, attribute, value) {
	this.data = { bid: bid, attribute: attribute, value: value };
	this.data2 = null;
	this._execute = function (editor) {
		var bond = editor.render.ctab.molecule.bonds.get(this.data.bid);
		if (!this.data2) {
			this.data2 = { bid: this.data.bid, attribute: this.data.attribute, value: bond[this.data.attribute] };
		}

		bond[this.data.attribute] = this.data.value;

		editor.render.invalidateBond(this.data.bid);
		if (this.data.attribute == 'type')
			editor.render.invalidateLoop(this.data.bid);
	};
	this._isDummy = function (editor) {
		return editor.render.ctab.molecule.bonds.get(this.data.bid)[this.data.attribute] == this.data.value;
	};
	this._invert = function () {
		var ret = new BondAttr();
		ret.data = this.data2;
		ret.data2 = this.data;
		return ret;
	};
};
BondAttr.prototype = new Base();

function FragmentAdd (frid) {
	this.frid = Object.isUndefined(frid) ? null : frid;
	this._execute = function (editor) {
		var RS = editor.render.ctab, DS = RS.molecule;
		var frag = new Struct.Fragment();
		if (this.frid == null) {
			this.frid = DS.frags.add(frag);
		} else {
			DS.frags.set(this.frid, frag);
		}
		RS.frags.set(this.frid, new rnd.ReFrag(frag)); // TODO add ReStruct.notifyFragmentAdded
	};
	this._invert = function () {
		return new FragmentDelete(this.frid);
	};
};
FragmentAdd.prototype = new Base();

function FragmentDelete (frid) {
	this.frid = frid;
	this._execute = function (editor) {
		var R = editor.render, RS = R.ctab, DS = RS.molecule;
		R.invalidateItem('frags', this.frid, 1);
		RS.frags.unset(this.frid);
		DS.frags.remove(this.frid); // TODO add ReStruct.notifyFragmentRemoved
	};
	this._invert = function () {
		return new FragmentAdd(this.frid);
	};
};
FragmentDelete.prototype = new Base();

function RGroupAttr (rgid, attribute, value) {
	this.data = { rgid: rgid, attribute: attribute, value: value };
	this.data2 = null;
	this._execute = function (editor) {
		var rgp = editor.render.ctab.molecule.rgroups.get(this.data.rgid);
		if (!this.data2) {
			this.data2 = { rgid: this.data.rgid, attribute: this.data.attribute, value: rgp[this.data.attribute] };
		}

		rgp[this.data.attribute] = this.data.value;

		editor.render.invalidateItem('rgroups', this.data.rgid);
	};
	this._isDummy = function (editor) {
		return editor.render.ctab.molecule.rgroups.get(this.data.rgid)[this.data.attribute] == this.data.value;
	};
	this._invert = function () {
		var ret = new RGroupAttr();
		ret.data = this.data2;
		ret.data2 = this.data;
		return ret;
	};
};
RGroupAttr.prototype = new Base();

function RGroupFragment (rgid, frid, rg) {
	this.rgid_new = rgid;
	this.rg_new = rg;
	this.rgid_old = null;
	this.rg_old = null;
	this.frid = frid;
	this._execute = function (editor) {
		var RS = editor.render.ctab, DS = RS.molecule;
		this.rgid_old = this.rgid_old || Struct.RGroup.findRGroupByFragment(DS.rgroups, this.frid);
		this.rg_old = (this.rgid_old ? DS.rgroups.get(this.rgid_old) : null);
		if (this.rg_old) {
			this.rg_old.frags.remove(this.rg_old.frags.keyOf(this.frid));
			RS.clearVisel(RS.rgroups.get(this.rgid_old).visel);
			if (this.rg_old.frags.count() == 0) {
				RS.rgroups.unset(this.rgid_old);
				DS.rgroups.unset(this.rgid_old);
				RS.markItemRemoved();
			} else {
				RS.markItem('rgroups', this.rgid_old, 1);
			}
		}
		if (this.rgid_new) {
			var rgNew = DS.rgroups.get(this.rgid_new);
			if (!rgNew) {
				rgNew = this.rg_new || new Struct.RGroup();
				DS.rgroups.set(this.rgid_new, rgNew);
				RS.rgroups.set(this.rgid_new, new rnd.ReRGroup(rgNew));
			} else {
				RS.markItem('rgroups', this.rgid_new, 1);
			}
			rgNew.frags.add(this.frid);
		}
	};
	this._invert = function () {
		return new RGroupFragment(this.rgid_old, this.frid, this.rg_old);
	};
};
RGroupFragment.prototype = new Base();

function RxnArrowAdd (pos) {
	this.data = { arid: null, pos: pos };
	this._execute = function (editor) {
		var R = editor.render, RS = R.ctab, DS = RS.molecule;
		if (!Object.isNumber(this.data.arid)) {
			this.data.arid = DS.rxnArrows.add(new Struct.RxnArrow());
		} else {
			DS.rxnArrows.set(this.data.arid, new Struct.RxnArrow());
		}
		RS.notifyRxnArrowAdded(this.data.arid);
		DS._rxnArrowSetPos(this.data.arid, new Vec2(this.data.pos));

		R.invalidateItem('rxnArrows', this.data.arid, 1);
	};
	this._invert = function () {
		var ret = new RxnArrowDelete();
		ret.data = this.data;
		return ret;
	};
};
RxnArrowAdd.prototype = new Base();

function RxnArrowDelete (arid) {
	this.data = { arid: arid, pos: null };
	this._execute = function (editor) {
		var R = editor.render, RS = R.ctab, DS = RS.molecule;
		if (!this.data.pos) {
			this.data.pos = R.rxnArrowGetPos(this.data.arid);
		}
		RS.notifyRxnArrowRemoved(this.data.arid);
		DS.rxnArrows.remove(this.data.arid);
	};
	this._invert = function () {
		var ret = new RxnArrowAdd();
		ret.data = this.data;
		return ret;
	};
};
RxnArrowDelete.prototype = new Base();

function RxnArrowMove (id, d, noinvalidate) {
	this.data = {id: id, d: d, noinvalidate: noinvalidate};
	this._execute = function (editor) {
		var R = editor.render;
		var RS = R.ctab;
		var DS = RS.molecule;
		var id = this.data.id;
		var d = this.data.d;
		DS.rxnArrows.get(id).pp.add_(d);
		RS.rxnArrows.get(id).visel.translate(R.ps(d));
		this.data.d = d.negated();
		if (!this.data.noinvalidate)
			editor.render.invalidateItem('rxnArrows', id, 1);
	};
	this._invert = function () {
		var ret = new RxnArrowMove();
		ret.data = this.data;
		return ret;
	};
};
RxnArrowMove.prototype = new Base();

function RxnPlusAdd (pos) {
	this.data = { plid: null, pos: pos };
	this._execute = function (editor) {
		var R = editor.render, RS = R.ctab, DS = RS.molecule;
		if (!Object.isNumber(this.data.plid)) {
			this.data.plid = DS.rxnPluses.add(new Struct.RxnPlus());
		} else {
			DS.rxnPluses.set(this.data.plid, new Struct.RxnPlus());
		}
		RS.notifyRxnPlusAdded(this.data.plid);
		DS._rxnPlusSetPos(this.data.plid, new Vec2(this.data.pos));

		R.invalidateItem('rxnPluses', this.data.plid, 1);
	};
	this._invert = function () {
		var ret = new RxnPlusDelete();
		ret.data = this.data;
		return ret;
	};
};
RxnPlusAdd.prototype = new Base();

function RxnPlusDelete (plid) {
	this.data = { plid: plid, pos: null };
	this._execute = function (editor) {
		var R = editor.render, RS = R.ctab, DS = RS.molecule;
		if (!this.data.pos) {
			this.data.pos = R.rxnPlusGetPos(this.data.plid);
		}
		RS.notifyRxnPlusRemoved(this.data.plid);
		DS.rxnPluses.remove(this.data.plid);
	};
	this._invert = function () {
		var ret = new RxnPlusAdd();
		ret.data = this.data;
		return ret;
	};
};
RxnPlusDelete.prototype = new Base();

function RxnPlusMove (id, d, noinvalidate) {
	this.data = {id: id, d: d, noinvalidate: noinvalidate};
	this._execute = function (editor) {
		var R = editor.render;
		var RS = R.ctab;
		var DS = RS.molecule;
		var id = this.data.id;
		var d = this.data.d;
		DS.rxnPluses.get(id).pp.add_(d);
		RS.rxnPluses.get(id).visel.translate(R.ps(d));
		this.data.d = d.negated();
		if (!this.data.noinvalidate)
			editor.render.invalidateItem('rxnPluses', id, 1);
	};
	this._invert = function () {
		var ret = new RxnPlusMove();
		ret.data = this.data;
		return ret;
	};
};
RxnPlusMove.prototype = new Base();

function SGroupDataMove (id, d) {
	this.data = {id: id, d: d};
	this._execute = function (editor) {
		ui.ctab.sgroups.get(this.data.id).pp.add_(this.data.d);
		this.data.d = this.data.d.negated();
		editor.render.invalidateItem('sgroupData', this.data.id, 1); // [MK] this currently does nothing since the DataSGroupData Visel only contains the highlighting/selection and SGroups are redrawn every time anyway
	};
	this._invert = function () {
		var ret = new SGroupDataMove();
		ret.data = this.data;
		return ret;
	};
};
SGroupDataMove.prototype = new Base();

function CanvasLoad (ctab) {
	this.data = {ctab: ctab, norescale: false};
	this._execute = function (editor) {
		var R = editor.render;

		R.ctab.clearVisels();
		var oldCtab = ui.ctab;
		ui.ctab = this.data.ctab;
		R.setMolecule(ui.ctab, this.data.norescale);
		this.data.ctab = oldCtab;
		this.data.norescale = true;
	};

	this._invert = function () {
		var ret = new CanvasLoad();
		ret.data = this.data;
		return ret;
	};
};
CanvasLoad.prototype = new Base();

function ChiralFlagAdd (pos) {
	this.data = {pos: pos};
	this._execute = function (editor) {
		var R = editor.render, RS = R.ctab, DS = RS.molecule;
		if (RS.chiralFlags.count() > 0)
			throw new Error('Cannot add more than one Chiral flag');
		RS.chiralFlags.set(0, new rnd.ReChiralFlag(pos));
		DS.isChiral = true;
		R.invalidateItem('chiralFlags', 0, 1);
	};
	this._invert = function () {
		var ret = new ChiralFlagDelete();
		ret.data = this.data;
		return ret;
	};
};
ChiralFlagAdd.prototype = new Base();

function ChiralFlagDelete () {
	this.data = {pos: null};
	this._execute = function (editor) {
		var R = editor.render, RS = R.ctab, DS = RS.molecule;
		if (RS.chiralFlags.count() < 1)
			throw new Error('Cannot remove chiral flag');
		RS.clearVisel(RS.chiralFlags.get(0).visel);
		this.data.pos = RS.chiralFlags.get(0).pp;
		RS.chiralFlags.unset(0);
		DS.isChiral = false;
	};
	this._invert = function () {
		var ret = new ChiralFlagAdd(this.data.pos);
		ret.data = this.data;
		return ret;
	};
};
ChiralFlagDelete.prototype = new Base();

function ChiralFlagMove (d) {
	this.data = {d: d};
	this._execute = function (editor) {
		var R = editor.render, RS = R.ctab;
		RS.chiralFlags.get(0).pp.add_(this.data.d);
		this.data.d = this.data.d.negated();
		R.invalidateItem('chiralFlags', 0, 1);
	};
	this._invert = function () {
		var ret = new ChiralFlagMove();
		ret.data = this.data;
		return ret;
	};
};
ChiralFlagMove.prototype = new Base();

module.exports = {
	AtomAdd: AtomAdd,
	AtomDelete: AtomDelete,
	AtomAttr: AtomAttr,
	AtomMove: AtomMove,
	BondMove: BondMove,
	LoopMove: LoopMove,
	SGroupAtomAdd: SGroupAtomAdd,
	SGroupAtomRemove: SGroupAtomRemove,
	SGroupAttr: SGroupAttr,
	SGroupCreate: SGroupCreate,
	SGroupDelete: SGroupDelete,
	SGroupAddToHierarchy: SGroupAddToHierarchy,
	SGroupRemoveFromHierarchy: SGroupRemoveFromHierarchy,
	BondAdd: BondAdd,
	BondDelete: BondDelete,
	BondAttr: BondAttr,
	FragmentAdd: FragmentAdd,
	FragmentDelete: FragmentDelete,
	RGroupAttr: RGroupAttr,
	RGroupFragment: RGroupFragment,
	RxnArrowAdd: RxnArrowAdd,
	RxnArrowDelete: RxnArrowDelete,
	RxnArrowMove: RxnArrowMove,
	RxnPlusAdd: RxnPlusAdd,
	RxnPlusDelete: RxnPlusDelete,
	RxnPlusMove: RxnPlusMove,
	SGroupDataMove: SGroupDataMove,
	CanvasLoad: CanvasLoad,
	ChiralFlagAdd: ChiralFlagAdd,
	ChiralFlagDelete: ChiralFlagDelete,
	ChiralFlagMove: ChiralFlagMove
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../chem/atom":8,"../chem/bond":9,"../chem/sgroup":15,"../chem/struct":18,"../rnd":22,"../util/set":43,"../util/vec2":44}],37:[function(require,module,exports){
module.exports = [
	{
		name: 'benzene',
		molfile:
		'\n' +
			'  Ketcher 11161218352D 1   1.00000     0.00000     0\n' +
			'\n' +
			'  6  6  0     0  0            999 V2000\n' +
			'    0.8660    2.0000    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'    1.7320    1.5000    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'    1.7320    0.5000    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'    0.8660    0.0000    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'    0.0000    0.5000    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'    0.0000    1.5000    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'  1  2  1  0     0  0\n' +
			'  2  3  2  0     0  0\n' +
			'  3  4  1  0     0  0\n' +
			'  4  5  2  0     0  0\n' +
			'  5  6  1  0     0  0\n' +
			'  6  1  2  0     0  0\n' +
			'M  END\n',
		bid: 0,
		aid: 0
	},
	{
		name: 'cyclopentadiene',
		molfile:
		'\n' +
			'  Ketcher 11161218352D 1   1.00000     0.00000     0\n' +
			'\n' +
			'  5  5  0     0  0            999 V2000\n' +
			'    0.0000    1.4257    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'    0.8090    0.8379    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'    0.5000   -0.1132    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'   -0.5000   -0.1132    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'   -0.8090    0.8379    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'  1  2  1  0     0  0\n' +
			'  2  3  2  0     0  0\n' +
			'  3  4  1  0     0  0\n' +
			'  4  5  2  0     0  0\n' +
			'  5  1  1  0     0  0\n' +
			'M  END\n',
		bid: 0,
		aid: 0
	},
	{
		name: 'cyclohexane',
		molfile:
		'\n' +
			'  Ketcher 11161218352D 1   1.00000     0.00000     0\n' +
			'\n' +
			'  6  6  0     0  0            999 V2000\n' +
			'    0.8660    2.0000    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'    1.7320    1.5000    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'    1.7320    0.5000    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'    0.8660    0.0000    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'    0.0000    0.5000    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'    0.0000    1.5000    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'  1  2  1  0     0  0\n' +
			'  2  3  1  0     0  0\n' +
			'  3  4  1  0     0  0\n' +
			'  4  5  1  0     0  0\n' +
			'  5  6  1  0     0  0\n' +
			'  6  1  1  0     0  0\n' +
			'M  END\n',
		bid: 0,
		aid: 0
	},
	{
		name: 'cyclopentane',
		molfile:
		'\n' +
			'  Ketcher 11161218352D 1   1.00000     0.00000     0\n' +
			'\n' +
			'  5  5  0     0  0            999 V2000\n' +
			'    0.8090    1.5389    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'    1.6180    0.9511    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'    1.3090    0.0000    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'    0.3090    0.0000    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'    0.0000    0.9511    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'  1  2  1  0     0  0\n' +
			'  2  3  1  0     0  0\n' +
			'  3  4  1  0     0  0\n' +
			'  4  5  1  0     0  0\n' +
			'  5  1  1  0     0  0\n' +
			'M  END\n',
		bid: 0,
		aid: 0
	},
	{
		name: 'cyclopropane',
		molfile:
		'\n' +
			'  Ketcher 11161218352D 1   1.00000     0.00000     0\n' +
			'\n' +
			'  3  3  0     0  0            999 V2000\n' +
			'   -3.2250   -0.2750    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'   -2.2250   -0.2750    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'   -2.7250    0.5910    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'  1  2  1  0     0  0\n' +
			'  2  3  1  0     0  0\n' +
			'  1  3  1  0     0  0\n' +
			'M  END\n',
		bid: 0,
		aid: 0
	},
	{
		name: 'cyclobutane',
		molfile:
		'\n' +
			'  Ketcher 11161218352D 1   1.00000     0.00000     0\n' +
			'\n' +
			'  4  4  0     0  0            999 V2000\n' +
			'   -3.8250    1.5500    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'   -3.8250    0.5500    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'   -2.8250    1.5500    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'   -2.8250    0.5500    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'  1  2  1  0     0  0\n' +
			'  1  3  1  0     0  0\n' +
			'  3  4  1  0     0  0\n' +
			'  4  2  1  0     0  0\n' +
			'M  END\n',
		bid: 0,
		aid: 0
	},
	{
		name: 'cycloheptane',
		molfile:
		'\n' +
			'  Ketcher 11161218352D 1   1.00000     0.00000     0\n' +
			'\n' +
			'  7  7  0     0  0            999 V2000\n' +
			'    0.0000    1.6293    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'    0.7835    2.2465    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'    1.7559    2.0242    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'    2.1897    1.1289    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'    0.0000    0.6228    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'    1.7566    0.2224    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'    0.7835    0.0000    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'  6  7  1  0     0  0\n' +
			'  5  7  1  0     0  0\n' +
			'  1  5  1  0     0  0\n' +
			'  4  6  1  0     0  0\n' +
			'  3  4  1  0     0  0\n' +
			'  2  3  1  0     0  0\n' +
			'  1  2  1  0     0  0\n' +
			'M  END\n',
		bid: 0,
		aid: 0
	},
	{
		name: 'cyclooctane',
		molfile:
		'\n' +
			'  Ketcher 11161218352D 1   1.00000     0.00000     0\n' +
			'\n' +
			'  8  8  0     0  0            999 V2000\n' +
			'    0.0000    0.7053    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'    0.0000    1.7078    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'    0.7053    2.4131    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'    0.7056    0.0000    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'    1.7079    0.0000    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'    2.4133    0.7053    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'    2.4133    1.7078    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'    1.7079    2.4131    0.0000 C   0  0  0  0  0  0        0  0  0\n' +
			'  8  3  1  0     0  0\n' +
			'  7  8  1  0     0  0\n' +
			'  6  7  1  0     0  0\n' +
			'  5  6  1  0     0  0\n' +
			'  4  5  1  0     0  0\n' +
			'  1  4  1  0     0  0\n' +
			'  2  3  1  0     0  0\n' +
			'  1  2  1  0     0  0\n' +
			'M  END\n',
		bid: 0,
		aid: 0
	}
];

},{}],38:[function(require,module,exports){
var getXHR = require('xhrpolyfill');
var Promise = require('promise-polyfill');
var util = require('./index.js');

function ajax(options, callback) {
	var xhr = getXHR();
	var headers = options.headers || {};

	xhr.open(options.method, options.url, !!callback, options.user, options.password);

	for (var k in headers) {
		if (headers.hasOwnProperty(k)) {
			xhr.setRequestHeader(k, headers[k]);
		}
	}
	if (typeof options.config === 'function') {
		var maybeXhr = options.config(xhr, options);
		if (maybeXhr !== undefined) {
			xhr = maybeXhr;
		}
	}
	if (options.timeout > 0) {
		setTimeout(function () {
			xhr.status = -1;
			xhr.abort();
		}, options.timeout);
	}
	if (callback) {
		xhr.onreadystatechange = function () {
			if (xhr.readyState === 4) {
				callback(xhr);
			}
		};
	}
	xhr.send(options.data);
	return xhr;
}

function successful(xhr) {
	return xhr.status >= 200 && xhr.status < 300;
}

function queryString(obj) {
	var str = [];
	for (var prop in obj) {
		if (obj.hasOwnProperty(prop)) { // don't handle nested objects
			str.push(encodeURIComponent(prop) + '=' +
			encodeURIComponent(obj[prop]));
		}
	}
	return str.join('&');
}

function request(opts) {
	var options = util.extend({
		method: 'GET',
		headers: {},
		timeout: 6000
	}, util.isObject(opts) ? opts : { url: opts });
	if (util.isObject(options.data)) {
		options.data = JSON.stringify(options.data);
		options.headers['Content-Type'] = 'application/json; charset=utf-8';
	}
	if (options.params) {
		options.url = options.url + (options.url.indexOf('?') < 0 ? '?' : '&') + queryString(options.params);
	}

	if (!options.sync) {
		return new Promise(function (resolve, reject) {
			ajax(options, function (xhr) {
				var complete = successful(xhr) ? resolve : reject;
				complete(xhr);
			});
		});
	}

	var xhr = ajax(options);
	if (!successful(xhr)) {
		throw xhr;
	}
	return xhr;
}

module.exports = request;

},{"./index.js":40,"promise-polyfill":3,"xhrpolyfill":6}],39:[function(require,module,exports){
var util = require('./index');
var Vec2 = require('./vec2');

var Box2Abs = function () {
	if (arguments.length == 1 && 'min' in arguments[0] && 'max' in arguments[0]) {
		this.p0 = arguments[0].min;
		this.p1 = arguments[0].max;
	}

	if (arguments.length == 2 && arguments[0] instanceof Vec2 && arguments[1] instanceof Vec2) {
		this.p0 = arguments[0];
		this.p1 = arguments[1];
	} else if (arguments.length == 4) {
		this.p0 = new Vec2(arguments[0], arguments[1]);
		this.p1 = new Vec2(arguments[2], arguments[3]);
	} else if (arguments.length == 0) {
		this.p0 = new Vec2();
		this.p1 = new Vec2();
	} else {
		new Error('Box2Abs constructor only accepts 4 numbers or 2 vectors or no arguments!');
	}
};

Box2Abs.prototype.toString = function () {
	return this.p0.toString() + ' ' + this.p1.toString();

};

Box2Abs.fromRelBox = function (relBox) {
	util.assertDefined(relBox);
	return new Box2Abs(relBox.x, relBox.y, relBox.x + relBox.width, relBox.y + relBox.height);
};

Box2Abs.prototype.clone = function () {
	return new Box2Abs(this.p0, this.p1);
};

Box2Abs.union = function (/*Box2Abs*/b1, /*Box2Abs*/b2) {
	util.assertDefined(b1);
	util.assertDefined(b2);
	return new Box2Abs(Vec2.min(b1.p0, b2.p0), Vec2.max(b1.p1, b2.p1));
};

Box2Abs.prototype.extend = function (/*Vec2*/lp, /*Vec2*/rb) {
	util.assertDefined(lp);
	rb = rb || lp;
	return new Box2Abs(this.p0.sub(lp), this.p1.add(rb));
};

Box2Abs.prototype.include = function (/*Vec2*/p) {
	util.assertDefined(p);
	return new Box2Abs(this.p0.min(p), this.p1.max(p));
};

Box2Abs.prototype.contains = function (/*Vec2*/p, /*float*/ext) {
	ext = (ext || 0) - 0;
	util.assertDefined(p);
	return p.x >= this.p0.x - ext && p.x <= this.p1.x + ext && p.y >= this.p0.y - ext && p.y <= this.p1.y + ext;
};

Box2Abs.prototype.translate = function (/*Vec2*/d) {
	util.assertDefined(d);
	return new Box2Abs(this.p0.add(d), this.p1.add(d));
};

Box2Abs.prototype.transform = function (/*function(Vec2):Vec2*/f, context) {
	util.assert(!util.isNullOrUndefined(f));
	return new Box2Abs(f.call(context, this.p0), f.call(context, this.p1));
};

Box2Abs.prototype.sz = function () {
	return this.p1.sub(this.p0);
};

Box2Abs.prototype.centre = function () {
	return Vec2.centre(this.p0, this.p1);
};

Box2Abs.prototype.pos = function () {
	return this.p0;
};

module.exports = Box2Abs;

},{"./index":40,"./vec2":44}],40:[function(require,module,exports){
Array.prototype.swap = function (i1, i2) { //eslint-disable-line
	var tmp = this[i1];
	this[i1] = this[i2];
	this[i2] = tmp;
};

var tfx = function (v) {
	return (v - 0).toFixed(8);
};

// "each" function for an array
var each = function (array, func, context) {
	assert(!isNullOrUndefined(array), 'array must be defined');
	for (var i = 0; i < array.length; ++i) {
		func.call(context, array[i], i);
	}
};

var map_each = function (map, func, context) {
	assert(!isNullOrUndefined(map), 'map must be defined');
	for (var key in map) {
		if (map.hasOwnProperty(key)) {
			func.call(context, key, map[key]);
		}
	}
};

function find(array, pred) {
	for (var i = 0; i < array.length; i++) {
		if (pred(array[i], i, array))
			return array[i];
	}
	return undefined;
}

function findIndex(array, func, context) {
	for (var i = 0; i < array.length; ++i) {
		if (func.call(context, array[i], i)) {
			return i;
		}
	}
	return -1;
};

var findAll = function (array, func, context) {
	var i;
	var ret = [];
	for (i = 0; i < array.length; ++i) {
		if (func.call(context, array[i], i)) {
			ret.push(array[i]);
		}
	}
	return ret;
};

var array = function (arrayLike) {
	var a = [];
	var i = arrayLike.length;
	while (--i >= 0) {
		a[i] = arrayLike[i];
	}
	return a;
};

var isEmpty = function (obj) {
	for (var v in obj) {
		if (obj.hasOwnProperty(v)) {
			return false;
		}
	}
	return true;
};

var stopEventPropagation = function (event) {
	if ('stopPropagation' in event) {// Mozilla, Opera, Safari
		event.stopPropagation();
	} else if ('cancelBubble' in event) {// IE
		event.cancelBubble = true;
	} else {
		throw Error('Browser unrecognized');
	}
};

var preventDefault = function (event) {
	if ('preventDefault' in event) {
		event.preventDefault();
	}
	if (Prototype.Browser.IE) {
		event.returnValue = false;
		event.keyCode = 0;
	}
	return false;
};

var setElementTextContent = function (element, text) {
	if ('textContent' in element) {// Mozilla, Opera, Safari
		element.textContent = text;
	} else if ('innerText' in element) {// IE and others (except Mozilla)
		element.innerText = text;
	} else {
		throw Error('Browser unrecognized');
	}
};

var getElementTextContent = function (element) {
	if ('textContent' in element) {// Mozilla, Opera, Safari
		return element.textContent;
	} else if ('innerText' in element) {// IE and others (except Mozilla)
		return element.innerText;
	}

	throw Error('Browser unrecognized');
};

var stringPadded = function (string, width, leftAligned) {
	var str = string + '';
	var space = '';
	while (str.length + space.length < width) {
		space += ' ';
	}

	return (leftAligned) ? string + space : space + string;
};


// According Unicode Consortium sould be
// nlRe = /\r\n|[\n\v\f\r\x85\u2028\u2029]/g;
// http://www.unicode.org/reports/tr18/#Line_Boundaries
var nlRe = /\r\n|[\n\r]/g;

function normalizeNewlines(str) {
	return str.replace(nlRe, '\n');
};
function splitNewlines(str) {
	return str.split(nlRe);
};

function unicodeLiteral(str){
	function fixedHex(number, length){
		var str = number.toString(16).toUpperCase();
		while(str.length < length)
			str = "0" + str;
		return str;
	}
	var i;
	var result = "";
	for( i = 0; i < str.length; ++i){
		if(str.charCodeAt(i) > 126 || str.charCodeAt(i) < 32)
			result += "\\u" + fixedHex(str.charCodeAt(i),4);
		else
			result += str[i];
	}
	return result;
}


var idList = function (object) {
	var list = [];
	for (var aid in object) {
		if (object.hasOwnProperty(aid)) {
			list.push(aid);
		}
	}
	return list;
};

var mapArray = function (src, map) {
	var dst = [];
	for (var i = 0; i < src.length; ++i) {
		dst.push(map[src[i]]);
	}
	return dst;
};

var arrayMax = function (array) {
	return Math.max.apply(Math, array);
};

var arrayMin = function (array) {
	return Math.min.apply(Math, array);
};

var map = function (src, func, context) {
	var dst = [];
	for (var i = 0; i < src.length; ++i) {
		dst.push(func.call(context, src[i]));
	}
	return dst;
};

var apply = function (array, func) {
	for (var i = 0; i < array.length; ++i) {
		array[i] = func(array[i]);
	}
};

var ifDef = function (dst, src, prop, def) {
	dst[prop] = !Object.isUndefined(src[prop]) ? src[prop] : def;
};

var ifDefList = function (dst, src, prop, def) {
	dst[prop] = !Object.isUndefined(src[prop]) && src[prop] !== null ? array(src[prop]) : def;
};

var identityMap = function (array) {
	var map = {};
	for (var i = 0; i < array.length; ++i) {
		map[array[i]] = array[i];
	}
	return map;
};

var strip = function (src) {
	return src.replace(/\s*$/, '').replace(/^\s*/, '');
};

var stripRight = function (src) {
	return src.replace(/\s*$/, '');
};

var stripQuotes = function (str) {
	if (str[0] === '"' && str[str.length - 1] === '"') {
		return str.substr(1, str.length - 2);
	}
	return str;
};

var paddedFloat = function (number, width, precision) {
	var numStr = number.toFixed(precision).replace(',', '.');
	if (numStr.length > width) {
		throw new Error('number does not fit');
	}
	return stringPadded(numStr, width);
};

var paddedInt = function (number, width) {
	var numStr = number.toFixed(0);
	if (numStr.length > width) {
		throw new Error('number does not fit');
	}
	return stringPadded(numStr, width);
};

var arrayAddIfMissing = function (array, item) {
	for (var i = 0; i < array.length; ++i) {
		if (array[i] === item) {
			return false;
		}
	}
	array.push(item);
	return true;
};

var assert = function (condition, comment) {
	if (!condition) {
		throw new Error(comment ? ('Assertion failed: ' + comment) : 'Assertion failed');
	}
};

var assertDefined = function(v) {
	assert(!isNullOrUndefined(v));
};

var isUndefined = function (variable) {
	return Object.isUndefined(variable); // use prototype.js method for now
};

var isNull = function (variable) {
	return variable === null;
};

var isNullOrUndefined = function (v) {
	return isUndefined(v) || isNull(v);
};

var arrayRemoveByValue = function (array, item) {
	assert(!isUndefined(array) && !isNull(array), 'array must be defined');
	var idx = array.indexOf(item);
	var cnt = 0;
	while (idx >= 0) {
		array.splice(idx, 1);
		cnt += 1;
		idx = array.indexOf(item);
	}
	return cnt;
};

var listNextRotate = function (list, value) {
	return list[(list.indexOf(value) + 1) % list.length];
};

// similar to Object.assign
// http://www.2ality.com/2014/01/object-assign.html
var extend = function (dest, src) {
	for (var prop in src) {
		if (src.hasOwnProperty(prop)) {
			dest[prop] = src[prop];
		}
	}
	return dest;
};

var isObject = function (obj) {
	return obj === Object(obj);
};

var relBox = function (box) {
    return {
        x: box.x,
        y: box.y,
        width: box.width,
        height: box.height
    };
};

module.exports = {
	tfx: tfx,
	each: each,
	find: find,
	findIndex: findIndex,
	findAll: findAll,
	array: array,
	isEmpty: isEmpty,
	stopEventPropagation: stopEventPropagation,
	preventDefault: preventDefault,
	setElementTextContent: setElementTextContent,
	getElementTextContent: getElementTextContent,
	stringPadded: stringPadded,
	normalizeNewlines: normalizeNewlines,
	splitNewlines: splitNewlines,
	unicodeLiteral: unicodeLiteral,
	idList: idList,
	mapArray: mapArray,
	arrayMax: arrayMax,
	arrayMin: arrayMin,
	map: map,
	apply: apply,
	ifDef: ifDef,
	ifDefList: ifDefList,
	identityMap: identityMap,
	strip: strip,
	stripRight: stripRight,
	stripQuotes: stripQuotes,
	paddedFloat: paddedFloat,
	paddedInt: paddedInt,
	arrayAddIfMissing: arrayAddIfMissing,
	assert: assert,
	assertDefined: assertDefined,
	isUndefined: isUndefined,
	isNull: isNull,
	isNullOrUndefined: isNullOrUndefined,
	arrayRemoveByValue: arrayRemoveByValue,
	listNextRotate: listNextRotate,
	extend: extend,
    isObject: isObject,
    relBox: relBox
};

},{}],41:[function(require,module,exports){
var util = require('./index');

var Map = function (obj) {
	if (typeof (obj) !== 'undefined' && obj.constructor !== Object) {
		throw Error('Passed object is not an instance of "Object"!');
	}
	this._obj = obj || {};
	this._count = 0;
};

Map.prototype.each = function (func, context) {
	var v;
	var value;
	var vInt;

	for (v in this._obj) {
		vInt = parseInt(v, 10);
		value = this._obj[v];

		if (!isNaN(vInt)) {
			v = vInt;
		}
		func.call(context, v, value);
	}
};

Map.prototype.map = function (func, context) {
	var ret = new Map();
	this.each(function (v, value) {
		ret.set(v, func.call(context, v, value));
	}, this);
	return ret;
};

Map.prototype.find = function (func, context) {
	var v;
	var vInt;
	var value;

	for (v in this._obj) {
		vInt = parseInt(v, 10);
		value = this._obj[v];

		if (!isNaN(vInt)) {
			v = vInt;
		}
		if (func.call(context, v, value)) {
			return v;
		}
	}
};

Map.prototype.findAll = function (func, context) {
	var v;
	var vInt;
	var value;
	var vv = [];

	for (v in this._obj) {
		vInt = parseInt(v, 10);
		value = this._obj[v];
		if (!isNaN(vInt)) {
			v = vInt;
		}
		if (func.call(context, v, value)) {
			vv.push(v);
		}
	}
	return vv;
};

Map.prototype.keys = function () {
	var keys = [];
	var v;
	for (v in this._obj) {
		keys.push(v);
	}
	return keys;
};

Map.prototype.ikeys = function () {
	var keys = [];
	for (var v in this._obj) {
		keys.push(v - 0);
	}
	return keys;
};

Map.prototype.set = function (key, value) {
	var val;
	this._count += (typeof value !== 'undefined' ? 1 : 0) - (typeof this._obj[key] !== 'undefined' ? 1 : 0);

	if (typeof value === 'undefined') {
		val = this._obj[key];
		delete this._obj[key];
		return val;
	}

	this._obj[key] = value;
	return value;
};

Map.prototype.get = function (key) {
	if (this._obj[key] !== Object.prototype[key]) {
		return this._obj[key];
	}
	return undefined;
};

Map.prototype.has = function (key) {
	return (this._obj[key] !== Object.prototype[key]);
};

Map.prototype.unset = function (key) {
	return this.set(key, undefined);
};

Map.prototype.update = function (object) {
	for (var v in object) {
		this.set(v, object[v]);
	}
};

Map.prototype.clear = function () {
	this._obj = {};
	this._count = 0;
};

Map.prototype.count = function () {
	return this._count;
};

Map.prototype.idList = function () {
	return util.idList(this._obj);
};

Map.prototype.keyOf = function (value) {
	for (var key in this._obj) {
		if (this._obj[key] === value) {
			return key;
		}
	}
};

module.exports = Map;

},{"./index":40}],42:[function(require,module,exports){
var Map = require('./map.js');

var Pool = function () {
	this._map = new Map();
	this._nextId = 0;
};

Pool.prototype.newId = function () {
	return this._nextId++;
};

Pool.prototype.add = function (obj) {
	var id = this._nextId++;
	this._map.set(id, obj);
	return id;
};

Pool.prototype.set = function (id, obj) {
	this._map.set(id, obj);
};

Pool.prototype.get = function (id) {
	return this._map.get(id);
};

Pool.prototype.has = function (id) {
	return this._map.has(id);
};

Pool.prototype.remove = function (id) {
	return this._map.unset(id);
};

Pool.prototype.clear = function () {
	this._map.clear();
};

Pool.prototype.keys = function () {
	return this._map.keys();
};

Pool.prototype.ikeys = function () {
	return this._map.ikeys();
};

Pool.prototype.each = function (func, context) {
	this._map.each(func, context);
};

Pool.prototype.map = function (func, context) {
	return this._map.map(func, context);
};

Pool.prototype.find = function (func, context) {
	return this._map.find(func, context);
};

Pool.prototype.count = function () {
	return this._map.count();
};

Pool.prototype.keyOf = function (value) {
	return this._map.keyOf(value);
};

module.exports = Pool;

},{"./map.js":41}],43:[function(require,module,exports){
var Set = {
	empty: function () {
		return {};
	},

	single: function (item) {
		var set = {};
		Set.add(set, item);
		return set;
	},

	size: function (set) {
		var cnt = 0;
		for (var id in set) {
			if (set[id] !== Object.prototype[id]) {
				cnt++;
			}
		}
		return cnt;
	},

	contains: function (set, v) {
		return typeof (set[v]) !== 'undefined' && set[v] !== Object.prototype[v];
	},

	subset: function (subset, superset) {
		for (var id in subset) {
			if (subset[id] !== Object.prototype[id]) {
				if (superset[id] !== subset[id]) {
					return false;
				}
			}
		}
		return true;
	},

	intersection: function (set1, set2) {
		var set = {};
		for (var id in set1) {
			if (set1[id] !== Object.prototype[id]) {
				if (set2[id] === set1[id]) {
					Set.add(set, id);
				}
			}
		}
		return set;
	},

	disjoint: function (set1, set2) {
		for (var id in set1) {
			if (set1[id] !== Object.prototype[id]) {
				if (set2[id] === set1[id]) {
					return false;
				}
			}
		}
		return true;
	},

	eq: function (set1, set2) {
		return Set.subset(set1, set2) && Set.subset(set2, set1);
	},

	each: function (set, func, context) {
		for (var v in set) {
			if (set[v] !== Object.prototype[v]) {
				func.call(context, set[v]);
			}
		}
	},

	filter: function (set, func, context) {
		var subset = {};
		for (var v in set) {
			if (set[v] !== Object.prototype[v]) {
				if (func.call(context, set[v])) {
					subset[set[v]] = set[v];
				}
			}
		}
		return subset;
	},

	pick: function (set) {
		for (var v in set) {
			if (set[v] !== Object.prototype[v]) {
				return set[v];
			}
		}
		return null;
	},

	list: function (set) {
		var list = [];
		for (var v in set) {
			if (set[v] !== Object.prototype[v]) {
				list.push(set[v]);
			}
		}
		return list;
	},

	add: function (set, item) {
		set[item] = item;
	},

	mergeIn: function (set, other) {
		Set.each(other, function (item) {
			Set.add(set, item);
		});
	},

	remove: function (set, item) {
		var v = set[item];
		delete set[item];
		return v;
	},

	clone: function (other) {
		var set = {};
		Set.mergeIn(set, other);
		return set;
	},

	fromList: function (list) {
		var set = {};
		if (list) {
			for (var i = 0; i < list.length; ++i) {
				set[list[i] - 0] = list[i] - 0;
			}
		}
		return set;
	},

	keySetInt: function (map) {
		var set = {};
		map.each(function (id) {
			set[id - 0] = id - 0;
		});
		return set;
	},

	find: function (set, func, context) {
		for (var v in set) {
			if (set[v] !== Object.prototype[v]) {
				if (func.call(context, set[v])) {
					return v;
				}
			}
		}
		return null;
	}
};

module.exports = Set;

},{}],44:[function(require,module,exports){
var util = require('./index');

var Vec2 = function (x, y)
{
	if (arguments.length == 0) {
		this.x = 0;
		this.y = 0;
	} else if (arguments.length == 1) {
		this.x = parseFloat(x.x);
		this.y = parseFloat(x.y);
	} else if (arguments.length == 2) {
		this.x = parseFloat(x);
		this.y = parseFloat(y);
	} else {
		throw new Error('Vec2(): invalid arguments');
	}
};

Vec2.ZERO = new Vec2(0, 0);
Vec2.UNIT = new Vec2(1, 1);

Vec2.segmentIntersection = function (a, b, c, d) {
	var dc = (a.x - c.x) * (b.y - c.y) - (a.y - c.y) * (b.x - c.x);
	var dd = (a.x - d.x) * (b.y - d.y) - (a.y - d.y) * (b.x - d.x);
	var da = (c.x - a.x) * (d.y - a.y) - (c.y - a.y) * (d.x - a.x);
	var db = (c.x - b.x) * (d.y - b.y) - (c.y - b.y) * (d.x - b.x);
	return dc * dd <= 0 && da * db <= 0;
};

Vec2.prototype.length = function () {
	return Math.sqrt(this.x * this.x + this.y * this.y);
};

Vec2.prototype.equals = function (v) {
	util.assertDefined(v);
	return this.x == v.x && this.y == v.y;
};

Vec2.prototype.add = function (v) {
	util.assertDefined(v);
	return new Vec2(this.x + v.x, this.y + v.y);
};

Vec2.prototype.add_ = function (v) {
	util.assertDefined(v);
	this.x += v.x;
	this.y += v.y;
};

Vec2.prototype.sub = function (v) {
	util.assertDefined(v);
	return new Vec2(this.x - v.x, this.y - v.y);
};

Vec2.prototype.scaled = function (s) {
	util.assertDefined(s);
	return new Vec2(this.x * s, this.y * s);
};

Vec2.prototype.negated = function () {
	return new Vec2(-this.x, -this.y);
};

Vec2.prototype.yComplement = function (y1) {
	y1 = y1 || 0;
	return new Vec2(this.x, y1 - this.y);
};

Vec2.prototype.addScaled = function (v, f) {
	util.assertDefined(v);
	util.assertDefined(f);
	return new Vec2(this.x + v.x * f, this.y + v.y * f);
};

Vec2.prototype.normalized = function () {
	return this.scaled(1 / this.length());
};

Vec2.prototype.normalize = function () {
	var l = this.length();

	if (l < 0.000001)
		return false;

	this.x /= l;
	this.y /= l;

	return true;
};

Vec2.prototype.turnLeft = function () {
	return new Vec2(-this.y, this.x);
};

Vec2.prototype.coordStr = function () {
	return this.x.toString() + ' , ' + this.y.toString();
};

Vec2.prototype.toString = function () {
	return '(' + this.x.toFixed(2) + ',' + this.y.toFixed(2) + ')';
};

Vec2.dist = function (a, b) {
	util.assertDefined(a);
	util.assertDefined(b);
	return Vec2.diff(a, b).length();
};

Vec2.max = function (v1, v2) {
	util.assertDefined(v1);
	util.assertDefined(v2);
	return new Vec2(Math.max(v1.x, v2.x), Math.max(v1.y, v2.y));
};

Vec2.min = function (v1, v2) {
	util.assertDefined(v1);
	util.assertDefined(v2);
	return new Vec2(Math.min(v1.x, v2.x), Math.min(v1.y, v2.y));
};

Vec2.prototype.max = function (v) {
	util.assertDefined(v);
	return new Vec2.max(this, v);
};

Vec2.prototype.min = function (v) {
	util.assertDefined(v);
	return new Vec2.min(this, v);
};

Vec2.prototype.ceil = function () {
	return new Vec2(Math.ceil(this.x), Math.ceil(this.y));
};

Vec2.prototype.floor = function () {
	return new Vec2(Math.floor(this.x), Math.floor(this.y));
};

Vec2.sum = function (v1, v2) {
	util.assertDefined(v1);
	util.assertDefined(v2);
	return new Vec2(v1.x + v2.x, v1.y + v2.y);
};

Vec2.dot = function (v1, v2) {
	util.assertDefined(v1);
	util.assertDefined(v2);
	return v1.x * v2.x + v1.y * v2.y;
};

Vec2.cross = function (v1, v2) {
	util.assertDefined(v1);
	util.assertDefined(v2);
	return v1.x * v2.y - v1.y * v2.x;
};

Vec2.prototype.rotate = function (angle) {
	util.assertDefined(angle);
	var si = Math.sin(angle);
	var co = Math.cos(angle);

	return this.rotateSC(si, co);
};

Vec2.prototype.rotateSC = function (si, co) {
	util.assertDefined(si);
	util.assertDefined(co);
	return new Vec2(this.x * co - this.y * si, this.x * si + this.y * co);
};

Vec2.angle = function (v1, v2) {
	util.assertDefined(v1);
	util.assertDefined(v2);
	return Math.atan2(Vec2.cross(v1, v2), Vec2.dot(v1, v2));
};

Vec2.prototype.oxAngle = function () {
	return Math.atan2(this.y, this.x);
};

Vec2.diff = function (v1, v2) {
	util.assertDefined(v1);
	util.assertDefined(v2);
	return new Vec2(v1.x - v2.x, v1.y - v2.y);
};

// assume arguments v1, f1, v2, f2, v3, f3, etc.
// where v[i] are vectors and f[i] are corresponding coefficients
Vec2.lc = function () {
	var v = new Vec2();
	for (var i = 0; i < arguments.length / 2; ++i)
		v = v.addScaled(arguments[2 * i], arguments[2 * i + 1]);
	return v;
};

Vec2.lc2 = function (v1, f1, v2, f2) {
	util.assertDefined(v1);
	util.assertDefined(v2);
	util.assertDefined(f1);
	util.assertDefined(f2);
	return new Vec2(v1.x * f1 + v2.x * f2, v1.y * f1 + v2.y * f2);
};

Vec2.centre = function (v1, v2) {
	return new Vec2.lc2(v1, 0.5, v2, 0.5);
};

// find intersection of a ray and a box and
//  return the shift magnitude to avoid it
Vec2.shiftRayBox = function (/*Vec2*/p, /*Vec2*/d, /*Box2Abs*/bb) {
	util.assertDefined(p);
	util.assertDefined(d);
	util.assertDefined(bb);
	// four corner points of the box
	var b = [bb.p0, new Vec2(bb.p1.x, bb.p0.y),
			bb.p1, new Vec2(bb.p0.x, bb.p1.y)];
	var r = b.map(function (v){return v.sub(p)}); // b relative to p
	d = d.normalized();
	var rc = r.map(function (v){return Vec2.cross(v, d)}); // cross prods
	var rd = r.map(function (v){return Vec2.dot(v, d)}); // dot prods

	// find foremost points on the right and on the left of the ray
	var pid = -1, nid = -1;
	for (var i = 0; i < 4; ++i)
		if (rc[i] > 0)  {if (pid < 0 || rd[pid] < rd[i]) pid = i;}
		else            {if (nid < 0 || rd[nid] < rd[i]) nid = i;}

	if (nid < 0 || pid < 0) // no intersection, no shift
		return 0;

	// check the order
	var id0, id1;
	if (rd[pid] > rd[nid])
		id0 = nid, id1 = pid;
	else
		id0 = pid, id1 = nid;

	// simple proportion to calculate the shift
	return rd[id0] + Math.abs(rc[id0]) * (rd[id1] - rd[id0])
		 / (Math.abs(rc[id0]) + Math.abs(rc[id1]));
};

module.exports = Vec2;

},{"./index":40}]},{},[19])(19)
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZmlsZXNhdmVyLmpzL0ZpbGVTYXZlci5qcyIsIm5vZGVfbW9kdWxlcy9rZXltYWdlL2tleW1hZ2UuanMiLCJub2RlX21vZHVsZXMvcHJvbWlzZS1wb2x5ZmlsbC9Qcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5LXN0cmluZy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeS1zdHJpbmcvbm9kZV9tb2R1bGVzL3N0cmljdC11cmktZW5jb2RlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3hocnBvbHlmaWxsL2luZGV4LmpzIiwic2NyaXB0L2FwaS5qcyIsInNjcmlwdC9jaGVtL2F0b20uanMiLCJzY3JpcHQvY2hlbS9ib25kLmpzIiwic2NyaXB0L2NoZW0vY2lzX3RyYW5zLmpzIiwic2NyaXB0L2NoZW0vZGZzLmpzIiwic2NyaXB0L2NoZW0vZWxlbWVudC5qcyIsInNjcmlwdC9jaGVtL21vbGZpbGUuanMiLCJzY3JpcHQvY2hlbS9zZ2ZvcmVzdC5qcyIsInNjcmlwdC9jaGVtL3Nncm91cC5qcyIsInNjcmlwdC9jaGVtL3NtaWxlcy5qcyIsInNjcmlwdC9jaGVtL3N0ZXJlb2NlbnRlcnMuanMiLCJzY3JpcHQvY2hlbS9zdHJ1Y3QuanMiLCJzY3JpcHQvaW5kZXguanMiLCJzY3JpcHQvcmFwaGFlbC1leHQuanMiLCJzY3JpcHQvcm5kL2VkaXRvci5qcyIsInNjcmlwdC9ybmQvaW5kZXguanMiLCJzY3JpcHQvcm5kL3JlbmRlci5qcyIsInNjcmlwdC9ybmQvcmVzdHJ1Y3QuanMiLCJzY3JpcHQvcm5kL3Jlc3RydWN0X3JlbmRlcmluZy5qcyIsInNjcmlwdC9ybmQvdmlzZWwuanMiLCJzY3JpcHQvdWkvYWN0aW9uLmpzIiwic2NyaXB0L3VpL2RpYWxvZy9vYnNvbGV0ZS5qcyIsInNjcmlwdC91aS9kaWFsb2cvb3Blbi5qcyIsInNjcmlwdC91aS9kaWFsb2cvc2F2ZS5qcyIsInNjcmlwdC91aS9kaWFsb2cvc2VsZWN0LmpzIiwic2NyaXB0L3VpL2RpYWxvZy9zZ3JvdXAtc3BlY2lhbC5qcyIsInNjcmlwdC91aS9kaWFsb2cvc2dyb3VwLmpzIiwic2NyaXB0L3VpL2RpYWxvZy90ZW1wbGF0ZXMuanMiLCJzY3JpcHQvdWkvaW5kZXguanMiLCJzY3JpcHQvdWkvb3AuanMiLCJzY3JpcHQvdWkvdGVtcGxhdGVzLmpzIiwic2NyaXB0L3V0aWwvYWpheC5qcyIsInNjcmlwdC91dGlsL2JveDJhYnMuanMiLCJzY3JpcHQvdXRpbC9pbmRleC5qcyIsInNjcmlwdC91dGlsL21hcC5qcyIsInNjcmlwdC91dGlsL3Bvb2wuanMiLCJzY3JpcHQvdXRpbC9zZXQuanMiLCJzY3JpcHQvdXRpbC92ZWMyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcHdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy8wQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3YzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzloQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDOXREQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcHVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3MUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDLzhDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2pZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3RJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDanJDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzF2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qIEZpbGVTYXZlci5qc1xuICogQSBzYXZlQXMoKSBGaWxlU2F2ZXIgaW1wbGVtZW50YXRpb24uXG4gKiAxLjEuMjAxNTA3MTZcbiAqXG4gKiBCeSBFbGkgR3JleSwgaHR0cDovL2VsaWdyZXkuY29tXG4gKiBMaWNlbnNlOiBYMTEvTUlUXG4gKiAgIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZWxpZ3JleS9GaWxlU2F2ZXIuanMvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZFxuICovXG5cbi8qZ2xvYmFsIHNlbGYgKi9cbi8qanNsaW50IGJpdHdpc2U6IHRydWUsIGluZGVudDogNCwgbGF4YnJlYWs6IHRydWUsIGxheGNvbW1hOiB0cnVlLCBzbWFydHRhYnM6IHRydWUsIHBsdXNwbHVzOiB0cnVlICovXG5cbi8qISBAc291cmNlIGh0dHA6Ly9wdXJsLmVsaWdyZXkuY29tL2dpdGh1Yi9GaWxlU2F2ZXIuanMvYmxvYi9tYXN0ZXIvRmlsZVNhdmVyLmpzICovXG5cbnZhciBzYXZlQXMgPSBzYXZlQXMgfHwgKGZ1bmN0aW9uKHZpZXcpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdC8vIElFIDwxMCBpcyBleHBsaWNpdGx5IHVuc3VwcG9ydGVkXG5cdGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIC9NU0lFIFsxLTldXFwuLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdHZhclxuXHRcdCAgZG9jID0gdmlldy5kb2N1bWVudFxuXHRcdCAgLy8gb25seSBnZXQgVVJMIHdoZW4gbmVjZXNzYXJ5IGluIGNhc2UgQmxvYi5qcyBoYXNuJ3Qgb3ZlcnJpZGRlbiBpdCB5ZXRcblx0XHQsIGdldF9VUkwgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB2aWV3LlVSTCB8fCB2aWV3LndlYmtpdFVSTCB8fCB2aWV3O1xuXHRcdH1cblx0XHQsIHNhdmVfbGluayA9IGRvYy5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIsIFwiYVwiKVxuXHRcdCwgY2FuX3VzZV9zYXZlX2xpbmsgPSBcImRvd25sb2FkXCIgaW4gc2F2ZV9saW5rXG5cdFx0LCBjbGljayA9IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHZhciBldmVudCA9IG5ldyBNb3VzZUV2ZW50KFwiY2xpY2tcIik7XG5cdFx0XHRub2RlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHRcdH1cblx0XHQsIHdlYmtpdF9yZXFfZnMgPSB2aWV3LndlYmtpdFJlcXVlc3RGaWxlU3lzdGVtXG5cdFx0LCByZXFfZnMgPSB2aWV3LnJlcXVlc3RGaWxlU3lzdGVtIHx8IHdlYmtpdF9yZXFfZnMgfHwgdmlldy5tb3pSZXF1ZXN0RmlsZVN5c3RlbVxuXHRcdCwgdGhyb3dfb3V0c2lkZSA9IGZ1bmN0aW9uKGV4KSB7XG5cdFx0XHQodmlldy5zZXRJbW1lZGlhdGUgfHwgdmlldy5zZXRUaW1lb3V0KShmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhyb3cgZXg7XG5cdFx0XHR9LCAwKTtcblx0XHR9XG5cdFx0LCBmb3JjZV9zYXZlYWJsZV90eXBlID0gXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIlxuXHRcdCwgZnNfbWluX3NpemUgPSAwXG5cdFx0Ly8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzUyOTcjYzcgYW5kXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2VsaWdyZXkvRmlsZVNhdmVyLmpzL2NvbW1pdC80ODU5MzBhI2NvbW1pdGNvbW1lbnQtODc2ODA0N1xuXHRcdC8vIGZvciB0aGUgcmVhc29uaW5nIGJlaGluZCB0aGUgdGltZW91dCBhbmQgcmV2b2NhdGlvbiBmbG93XG5cdFx0LCBhcmJpdHJhcnlfcmV2b2tlX3RpbWVvdXQgPSA1MDAgLy8gaW4gbXNcblx0XHQsIHJldm9rZSA9IGZ1bmN0aW9uKGZpbGUpIHtcblx0XHRcdHZhciByZXZva2VyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgZmlsZSA9PT0gXCJzdHJpbmdcIikgeyAvLyBmaWxlIGlzIGFuIG9iamVjdCBVUkxcblx0XHRcdFx0XHRnZXRfVVJMKCkucmV2b2tlT2JqZWN0VVJMKGZpbGUpO1xuXHRcdFx0XHR9IGVsc2UgeyAvLyBmaWxlIGlzIGEgRmlsZVxuXHRcdFx0XHRcdGZpbGUucmVtb3ZlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRpZiAodmlldy5jaHJvbWUpIHtcblx0XHRcdFx0cmV2b2tlcigpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2V0VGltZW91dChyZXZva2VyLCBhcmJpdHJhcnlfcmV2b2tlX3RpbWVvdXQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQsIGRpc3BhdGNoID0gZnVuY3Rpb24oZmlsZXNhdmVyLCBldmVudF90eXBlcywgZXZlbnQpIHtcblx0XHRcdGV2ZW50X3R5cGVzID0gW10uY29uY2F0KGV2ZW50X3R5cGVzKTtcblx0XHRcdHZhciBpID0gZXZlbnRfdHlwZXMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHR2YXIgbGlzdGVuZXIgPSBmaWxlc2F2ZXJbXCJvblwiICsgZXZlbnRfdHlwZXNbaV1dO1xuXHRcdFx0XHRpZiAodHlwZW9mIGxpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0bGlzdGVuZXIuY2FsbChmaWxlc2F2ZXIsIGV2ZW50IHx8IGZpbGVzYXZlcik7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZXgpIHtcblx0XHRcdFx0XHRcdHRocm93X291dHNpZGUoZXgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHQsIGF1dG9fYm9tID0gZnVuY3Rpb24oYmxvYikge1xuXHRcdFx0Ly8gcHJlcGVuZCBCT00gZm9yIFVURi04IFhNTCBhbmQgdGV4dC8qIHR5cGVzIChpbmNsdWRpbmcgSFRNTClcblx0XHRcdGlmICgvXlxccyooPzp0ZXh0XFwvXFxTKnxhcHBsaWNhdGlvblxcL3htbHxcXFMqXFwvXFxTKlxcK3htbClcXHMqOy4qY2hhcnNldFxccyo9XFxzKnV0Zi04L2kudGVzdChibG9iLnR5cGUpKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgQmxvYihbXCJcXHVmZWZmXCIsIGJsb2JdLCB7dHlwZTogYmxvYi50eXBlfSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYmxvYjtcblx0XHR9XG5cdFx0LCBGaWxlU2F2ZXIgPSBmdW5jdGlvbihibG9iLCBuYW1lLCBub19hdXRvX2JvbSkge1xuXHRcdFx0aWYgKCFub19hdXRvX2JvbSkge1xuXHRcdFx0XHRibG9iID0gYXV0b19ib20oYmxvYik7XG5cdFx0XHR9XG5cdFx0XHQvLyBGaXJzdCB0cnkgYS5kb3dubG9hZCwgdGhlbiB3ZWIgZmlsZXN5c3RlbSwgdGhlbiBvYmplY3QgVVJMc1xuXHRcdFx0dmFyXG5cdFx0XHRcdCAgZmlsZXNhdmVyID0gdGhpc1xuXHRcdFx0XHQsIHR5cGUgPSBibG9iLnR5cGVcblx0XHRcdFx0LCBibG9iX2NoYW5nZWQgPSBmYWxzZVxuXHRcdFx0XHQsIG9iamVjdF91cmxcblx0XHRcdFx0LCB0YXJnZXRfdmlld1xuXHRcdFx0XHQsIGRpc3BhdGNoX2FsbCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRpc3BhdGNoKGZpbGVzYXZlciwgXCJ3cml0ZXN0YXJ0IHByb2dyZXNzIHdyaXRlIHdyaXRlZW5kXCIuc3BsaXQoXCIgXCIpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBvbiBhbnkgZmlsZXN5cyBlcnJvcnMgcmV2ZXJ0IHRvIHNhdmluZyB3aXRoIG9iamVjdCBVUkxzXG5cdFx0XHRcdCwgZnNfZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQvLyBkb24ndCBjcmVhdGUgbW9yZSBvYmplY3QgVVJMcyB0aGFuIG5lZWRlZFxuXHRcdFx0XHRcdGlmIChibG9iX2NoYW5nZWQgfHwgIW9iamVjdF91cmwpIHtcblx0XHRcdFx0XHRcdG9iamVjdF91cmwgPSBnZXRfVVJMKCkuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodGFyZ2V0X3ZpZXcpIHtcblx0XHRcdFx0XHRcdHRhcmdldF92aWV3LmxvY2F0aW9uLmhyZWYgPSBvYmplY3RfdXJsO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR2YXIgbmV3X3RhYiA9IHZpZXcub3BlbihvYmplY3RfdXJsLCBcIl9ibGFua1wiKTtcblx0XHRcdFx0XHRcdGlmIChuZXdfdGFiID09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc2FmYXJpICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRcdFx0XHRcdC8vQXBwbGUgZG8gbm90IGFsbG93IHdpbmRvdy5vcGVuLCBzZWUgaHR0cDovL2JpdC5seS8xa1pmZlJJXG5cdFx0XHRcdFx0XHRcdHZpZXcubG9jYXRpb24uaHJlZiA9IG9iamVjdF91cmxcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZmlsZXNhdmVyLnJlYWR5U3RhdGUgPSBmaWxlc2F2ZXIuRE9ORTtcblx0XHRcdFx0XHRkaXNwYXRjaF9hbGwoKTtcblx0XHRcdFx0XHRyZXZva2Uob2JqZWN0X3VybCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0LCBhYm9ydGFibGUgPSBmdW5jdGlvbihmdW5jKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKGZpbGVzYXZlci5yZWFkeVN0YXRlICE9PSBmaWxlc2F2ZXIuRE9ORSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0LCBjcmVhdGVfaWZfbm90X2ZvdW5kID0ge2NyZWF0ZTogdHJ1ZSwgZXhjbHVzaXZlOiBmYWxzZX1cblx0XHRcdFx0LCBzbGljZVxuXHRcdFx0O1xuXHRcdFx0ZmlsZXNhdmVyLnJlYWR5U3RhdGUgPSBmaWxlc2F2ZXIuSU5JVDtcblx0XHRcdGlmICghbmFtZSkge1xuXHRcdFx0XHRuYW1lID0gXCJkb3dubG9hZFwiO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNhbl91c2Vfc2F2ZV9saW5rKSB7XG5cdFx0XHRcdG9iamVjdF91cmwgPSBnZXRfVVJMKCkuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXHRcdFx0XHRzYXZlX2xpbmsuaHJlZiA9IG9iamVjdF91cmw7XG5cdFx0XHRcdHNhdmVfbGluay5kb3dubG9hZCA9IG5hbWU7XG5cdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Y2xpY2soc2F2ZV9saW5rKTtcblx0XHRcdFx0XHRkaXNwYXRjaF9hbGwoKTtcblx0XHRcdFx0XHRyZXZva2Uob2JqZWN0X3VybCk7XG5cdFx0XHRcdFx0ZmlsZXNhdmVyLnJlYWR5U3RhdGUgPSBmaWxlc2F2ZXIuRE9ORTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIE9iamVjdCBhbmQgd2ViIGZpbGVzeXN0ZW0gVVJMcyBoYXZlIGEgcHJvYmxlbSBzYXZpbmcgaW4gR29vZ2xlIENocm9tZSB3aGVuXG5cdFx0XHQvLyB2aWV3ZWQgaW4gYSB0YWIsIHNvIEkgZm9yY2Ugc2F2ZSB3aXRoIGFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVxuXHRcdFx0Ly8gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9OTExNThcblx0XHRcdC8vIFVwZGF0ZTogR29vZ2xlIGVycmFudGx5IGNsb3NlZCA5MTE1OCwgSSBzdWJtaXR0ZWQgaXQgYWdhaW46XG5cdFx0XHQvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzg5NjQyXG5cdFx0XHRpZiAodmlldy5jaHJvbWUgJiYgdHlwZSAmJiB0eXBlICE9PSBmb3JjZV9zYXZlYWJsZV90eXBlKSB7XG5cdFx0XHRcdHNsaWNlID0gYmxvYi5zbGljZSB8fCBibG9iLndlYmtpdFNsaWNlO1xuXHRcdFx0XHRibG9iID0gc2xpY2UuY2FsbChibG9iLCAwLCBibG9iLnNpemUsIGZvcmNlX3NhdmVhYmxlX3R5cGUpO1xuXHRcdFx0XHRibG9iX2NoYW5nZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gU2luY2UgSSBjYW4ndCBiZSBzdXJlIHRoYXQgdGhlIGd1ZXNzZWQgbWVkaWEgdHlwZSB3aWxsIHRyaWdnZXIgYSBkb3dubG9hZFxuXHRcdFx0Ly8gaW4gV2ViS2l0LCBJIGFwcGVuZCAuZG93bmxvYWQgdG8gdGhlIGZpbGVuYW1lLlxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTY1NDQwXG5cdFx0XHRpZiAod2Via2l0X3JlcV9mcyAmJiBuYW1lICE9PSBcImRvd25sb2FkXCIpIHtcblx0XHRcdFx0bmFtZSArPSBcIi5kb3dubG9hZFwiO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGUgPT09IGZvcmNlX3NhdmVhYmxlX3R5cGUgfHwgd2Via2l0X3JlcV9mcykge1xuXHRcdFx0XHR0YXJnZXRfdmlldyA9IHZpZXc7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIXJlcV9mcykge1xuXHRcdFx0XHRmc19lcnJvcigpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRmc19taW5fc2l6ZSArPSBibG9iLnNpemU7XG5cdFx0XHRyZXFfZnModmlldy5URU1QT1JBUlksIGZzX21pbl9zaXplLCBhYm9ydGFibGUoZnVuY3Rpb24oZnMpIHtcblx0XHRcdFx0ZnMucm9vdC5nZXREaXJlY3RvcnkoXCJzYXZlZFwiLCBjcmVhdGVfaWZfbm90X2ZvdW5kLCBhYm9ydGFibGUoZnVuY3Rpb24oZGlyKSB7XG5cdFx0XHRcdFx0dmFyIHNhdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGRpci5nZXRGaWxlKG5hbWUsIGNyZWF0ZV9pZl9ub3RfZm91bmQsIGFib3J0YWJsZShmdW5jdGlvbihmaWxlKSB7XG5cdFx0XHRcdFx0XHRcdGZpbGUuY3JlYXRlV3JpdGVyKGFib3J0YWJsZShmdW5jdGlvbih3cml0ZXIpIHtcblx0XHRcdFx0XHRcdFx0XHR3cml0ZXIub253cml0ZWVuZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRfdmlldy5sb2NhdGlvbi5ocmVmID0gZmlsZS50b1VSTCgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZmlsZXNhdmVyLnJlYWR5U3RhdGUgPSBmaWxlc2F2ZXIuRE9ORTtcblx0XHRcdFx0XHRcdFx0XHRcdGRpc3BhdGNoKGZpbGVzYXZlciwgXCJ3cml0ZWVuZFwiLCBldmVudCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXZva2UoZmlsZSk7XG5cdFx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0XHR3cml0ZXIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGVycm9yID0gd3JpdGVyLmVycm9yO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGVycm9yLmNvZGUgIT09IGVycm9yLkFCT1JUX0VSUikge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRmc19lcnJvcigpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdFx0XCJ3cml0ZXN0YXJ0IHByb2dyZXNzIHdyaXRlIGFib3J0XCIuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHdyaXRlcltcIm9uXCIgKyBldmVudF0gPSBmaWxlc2F2ZXJbXCJvblwiICsgZXZlbnRdO1xuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdHdyaXRlci53cml0ZShibG9iKTtcblx0XHRcdFx0XHRcdFx0XHRmaWxlc2F2ZXIuYWJvcnQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHdyaXRlci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZmlsZXNhdmVyLnJlYWR5U3RhdGUgPSBmaWxlc2F2ZXIuRE9ORTtcblx0XHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRcdGZpbGVzYXZlci5yZWFkeVN0YXRlID0gZmlsZXNhdmVyLldSSVRJTkc7XG5cdFx0XHRcdFx0XHRcdH0pLCBmc19lcnJvcik7XG5cdFx0XHRcdFx0XHR9KSwgZnNfZXJyb3IpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0ZGlyLmdldEZpbGUobmFtZSwge2NyZWF0ZTogZmFsc2V9LCBhYm9ydGFibGUoZnVuY3Rpb24oZmlsZSkge1xuXHRcdFx0XHRcdFx0Ly8gZGVsZXRlIGZpbGUgaWYgaXQgYWxyZWFkeSBleGlzdHNcblx0XHRcdFx0XHRcdGZpbGUucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRzYXZlKCk7XG5cdFx0XHRcdFx0fSksIGFib3J0YWJsZShmdW5jdGlvbihleCkge1xuXHRcdFx0XHRcdFx0aWYgKGV4LmNvZGUgPT09IGV4Lk5PVF9GT1VORF9FUlIpIHtcblx0XHRcdFx0XHRcdFx0c2F2ZSgpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZnNfZXJyb3IoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSk7XG5cdFx0XHRcdH0pLCBmc19lcnJvcik7XG5cdFx0XHR9KSwgZnNfZXJyb3IpO1xuXHRcdH1cblx0XHQsIEZTX3Byb3RvID0gRmlsZVNhdmVyLnByb3RvdHlwZVxuXHRcdCwgc2F2ZUFzID0gZnVuY3Rpb24oYmxvYiwgbmFtZSwgbm9fYXV0b19ib20pIHtcblx0XHRcdHJldHVybiBuZXcgRmlsZVNhdmVyKGJsb2IsIG5hbWUsIG5vX2F1dG9fYm9tKTtcblx0XHR9XG5cdDtcblx0Ly8gSUUgMTArIChuYXRpdmUgc2F2ZUFzKVxuXHRpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYikge1xuXHRcdHJldHVybiBmdW5jdGlvbihibG9iLCBuYW1lLCBub19hdXRvX2JvbSkge1xuXHRcdFx0aWYgKCFub19hdXRvX2JvbSkge1xuXHRcdFx0XHRibG9iID0gYXV0b19ib20oYmxvYik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IoYmxvYiwgbmFtZSB8fCBcImRvd25sb2FkXCIpO1xuXHRcdH07XG5cdH1cblxuXHRGU19wcm90by5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBmaWxlc2F2ZXIgPSB0aGlzO1xuXHRcdGZpbGVzYXZlci5yZWFkeVN0YXRlID0gZmlsZXNhdmVyLkRPTkU7XG5cdFx0ZGlzcGF0Y2goZmlsZXNhdmVyLCBcImFib3J0XCIpO1xuXHR9O1xuXHRGU19wcm90by5yZWFkeVN0YXRlID0gRlNfcHJvdG8uSU5JVCA9IDA7XG5cdEZTX3Byb3RvLldSSVRJTkcgPSAxO1xuXHRGU19wcm90by5ET05FID0gMjtcblxuXHRGU19wcm90by5lcnJvciA9XG5cdEZTX3Byb3RvLm9ud3JpdGVzdGFydCA9XG5cdEZTX3Byb3RvLm9ucHJvZ3Jlc3MgPVxuXHRGU19wcm90by5vbndyaXRlID1cblx0RlNfcHJvdG8ub25hYm9ydCA9XG5cdEZTX3Byb3RvLm9uZXJyb3IgPVxuXHRGU19wcm90by5vbndyaXRlZW5kID1cblx0XHRudWxsO1xuXG5cdHJldHVybiBzYXZlQXM7XG59KFxuXHQgICB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmXG5cdHx8IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93XG5cdHx8IHRoaXMuY29udGVudFxuKSk7XG4vLyBgc2VsZmAgaXMgdW5kZWZpbmVkIGluIEZpcmVmb3ggZm9yIEFuZHJvaWQgY29udGVudCBzY3JpcHQgY29udGV4dFxuLy8gd2hpbGUgYHRoaXNgIGlzIG5zSUNvbnRlbnRGcmFtZU1lc3NhZ2VNYW5hZ2VyXG4vLyB3aXRoIGFuIGF0dHJpYnV0ZSBgY29udGVudGAgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgd2luZG93XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzLnNhdmVBcyA9IHNhdmVBcztcbn0gZWxzZSBpZiAoKHR5cGVvZiBkZWZpbmUgIT09IFwidW5kZWZpbmVkXCIgJiYgZGVmaW5lICE9PSBudWxsKSAmJiAoZGVmaW5lLmFtZCAhPSBudWxsKSkge1xuICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzYXZlQXM7XG4gIH0pO1xufVxuIiwiLy8ga2V5bWFnZS5qcyAtIEphdmFzY3JpcHQga2V5Ym9hcmQgZXZlbnQgaGFuZGxpbmdcbi8vIGh0dHA6Ly9naXRodWIuY29tL3BpcmFuaGEva2V5bWFnZVxuLy9cbi8vIChjKSAyMDEyIEFsZXhhbmRlciBTb2xvdnlvdlxuLy8gdW5kZXIgdGVybXMgb2YgSVNDIExpY2Vuc2VcblxuKGZ1bmN0aW9uKGRlZmluZSwgdW5kZWZpbmVkKSB7XG5kZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgdmFyIFZFUlNJT04gPSAnMS4xLjInO1xuICAgIHZhciBpc09zeCA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIH5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ01hYyBPUyBYJyk7XG5cbiAgICAvLyBEZWZpbmluZyBhbGwga2V5c1xuICAgIHZhciBNT0RQUk9QUyA9IFsnc2hpZnRLZXknLCAnY3RybEtleScsICdhbHRLZXknLCAnbWV0YUtleSddO1xuICAgIHZhciBNT0RTID0ge1xuICAgICAgICAnc2hpZnQnOiAnc2hpZnQnLFxuICAgICAgICAnY3RybCc6ICdjdHJsJywgJ2NvbnRyb2wnOiAnY3RybCcsXG4gICAgICAgICdhbHQnOiAnYWx0JywgJ29wdGlvbic6ICdhbHQnLFxuICAgICAgICAnd2luJzogJ21ldGEnLCAnY21kJzogJ21ldGEnLCAnc3VwZXInOiAnbWV0YScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdtZXRhJzogJ21ldGEnLFxuICAgICAgICAvLyBkZWZhdWx0IG1vZGlmaWVyIGZvciBvcyB4IGlzIGNtZCBhbmQgZm9yIG90aGVycyBpcyBjdHJsXG4gICAgICAgICdkZWZtb2QnOiAgaXNPc3ggPyAnbWV0YScgOiAnY3RybCdcbiAgICAgICAgfTtcbiAgICB2YXIgTU9ET1JERVIgPSBbJ3NoaWZ0JywgJ2N0cmwnLCAnYWx0JywgJ21ldGEnXTtcbiAgICB2YXIgTU9ETlVNUyA9IFsxNiwgMTcsIDE4LCA5MV07XG5cbiAgICB2YXIgS0VZUyA9IHtcbiAgICAgICAgJ2JhY2tzcGFjZSc6IDgsXG4gICAgICAgICd0YWInOiA5LFxuICAgICAgICAnZW50ZXInOiAxMywgJ3JldHVybic6IDEzLFxuICAgICAgICAncGF1c2UnOiAxOSxcbiAgICAgICAgJ2NhcHMnOiAyMCwgJ2NhcHNsb2NrJzogMjAsXG4gICAgICAgICdlc2NhcGUnOiAyNywgJ2VzYyc6IDI3LFxuICAgICAgICAnc3BhY2UnOiAzMixcbiAgICAgICAgJ3BndXAnOiAzMywgJ3BhZ2V1cCc6IDMzLFxuICAgICAgICAncGdkb3duJzogMzQsICdwYWdlZG93bic6IDM0LFxuICAgICAgICAnZW5kJzogMzUsXG4gICAgICAgICdob21lJzogMzYsXG4gICAgICAgICdpbnMnOiA0NSwgJ2luc2VydCc6IDQ1LFxuICAgICAgICAnZGVsJzogNDYsICdkZWxldGUnOiA0NixcblxuICAgICAgICAnbGVmdCc6IDM3LFxuICAgICAgICAndXAnOiAzOCxcbiAgICAgICAgJ3JpZ2h0JzogMzksXG4gICAgICAgICdkb3duJzogNDAsXG5cbiAgICAgICAgJyonOiAxMDYsXG4gICAgICAgICcrJzogMTA3LCAncGx1cyc6IDEwNyxcbiAgICAgICAgJ21pbnVzJzogMTA5LFxuICAgICAgICAnOyc6IDE4NixcbiAgICAgICAgJz0nOiAxODcsXG4gICAgICAgICcsJzogMTg4LFxuICAgICAgICAnLSc6IDE4OSxcbiAgICAgICAgJy4nOiAxOTAsXG4gICAgICAgICcvJzogMTkxLFxuICAgICAgICAnYCc6IDE5MixcbiAgICAgICAgJ1snOiAyMTksXG4gICAgICAgICdcXFxcJzogMjIwLFxuICAgICAgICAnXSc6IDIyMSxcbiAgICAgICAgXCInXCI6IDIyMlxuICAgIH07XG5cbiAgICB2YXIgaTtcbiAgICAvLyBudW1wYWRcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICBLRVlTWydudW0tJyArIGldID0gaSArIDk1O1xuICAgIH1cbiAgICAvLyB0b3Agcm93IDAtOVxuICAgIGZvciAoaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIEtFWVNbaS50b1N0cmluZygpXSA9IGkgKyA0ODtcbiAgICB9XG4gICAgLy8gZjEtZjI0XG4gICAgZm9yIChpID0gMTsgaSA8IDI1OyBpKyspIHtcbiAgICAgICAgS0VZU1snZicgKyBpXSA9IGkgKyAxMTE7XG4gICAgfVxuICAgIC8vIGFscGhhYmV0XG4gICAgZm9yIChpID0gNjU7IGkgPCA5MTsgaSsrKSB7XG4gICAgICAgIEtFWVNbU3RyaW5nLmZyb21DaGFyQ29kZShpKS50b0xvd2VyQ2FzZSgpXSA9IGk7XG4gICAgfVxuXG4gICAgLy8gUmV2ZXJzZSBrZXkgY29kZXNcbiAgICB2YXIgS0VZUkVWID0ge307XG4gICAgZm9yICh2YXIgayBpbiBLRVlTKSB7XG4gICAgICAgIHZhciB2YWwgPSBLRVlTW2tdO1xuICAgICAgICBpZiAoIUtFWVJFVlt2YWxdIHx8IEtFWVJFVlt2YWxdLmxlbmd0aCA8IGsubGVuZ3RoKSB7XG4gICAgICAgICAgICBLRVlSRVZbdmFsXSA9IGs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEFjdHVhbCB3b3JrIGlzIGRvbmUgaGVyZVxuXG4gICAgdmFyIGN1cnJlbnRTY29wZSA9ICcnO1xuICAgIHZhciBhbGxDaGFpbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlS2V5U3RyaW5nKGtleXN0cmluZykge1xuICAgICAgICB2YXIgYml0cyA9IGtleXN0cmluZy5zcGxpdCgvLSg/ISQpLyk7XG4gICAgICAgIHZhciBidXR0b24gPSBiaXRzW2JpdHMubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBrZXkgPSB7Y29kZTogS0VZU1tidXR0b25dfTtcblxuICAgICAgICBpZiAoIWtleS5jb2RlKSB7XG4gICAgICAgICAgICB0aHJvdyAnVW5rbm93biBrZXkgXCInICsgYnV0dG9uICsgJ1wiIGluIGtleXN0cmluZyBcIicgK1xuICAgICAgICAgICAgICAgIGtleXN0cmluZyArICdcIic7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbW9kO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJpdHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBidXR0b24gPSBiaXRzW2ldO1xuICAgICAgICAgICAgbW9kID0gTU9EU1tidXR0b25dO1xuICAgICAgICAgICAgaWYgKCFtb2QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ1Vua25vd24gbW9kaWZpZXIgXCInICsgYnV0dG9uICsgJ1wiIGluIGtleXN0cmluZyBcIicgK1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5c3RyaW5nICsgJ1wiJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtleVttb2RdID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RyaW5naWZ5S2V5KGtleSkge1xuICAgICAgICB2YXIgcyA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE1PRE9SREVSLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoa2V5W01PRE9SREVSW2ldXSkge1xuICAgICAgICAgICAgICAgIHMgKz0gTU9ET1JERVJbaV0gKyAnLSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcyArPSBLRVlSRVZba2V5LmNvZGVdO1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVLZXlDaGFpbihrZXljaGFpblN0cmluZykge1xuICAgICAgICB2YXIga2V5Y2hhaW4gPSBbXTtcbiAgICAgICAgdmFyIGtleXMgPSBrZXljaGFpblN0cmluZy5zcGxpdCgnICcpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IHBhcnNlS2V5U3RyaW5nKGtleXNbaV0pO1xuICAgICAgICAgICAga2V5ID0gc3RyaW5naWZ5S2V5KGtleSk7XG4gICAgICAgICAgICBrZXljaGFpbi5wdXNoKGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBrZXljaGFpbi5vcmlnaW5hbCA9IGtleWNoYWluU3RyaW5nO1xuICAgICAgICByZXR1cm4ga2V5Y2hhaW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXZlbnRLZXlTdHJpbmcoZSkge1xuICAgICAgICB2YXIga2V5ID0ge2NvZGU6IGUua2V5Q29kZX07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTU9EUFJPUFMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtb2QgPSBNT0RQUk9QU1tpXTtcbiAgICAgICAgICAgIGlmIChlW21vZF0pIHtcbiAgICAgICAgICAgICAgICBrZXlbbW9kLnNsaWNlKDAsIG1vZC5sZW5ndGggLSAzKV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlLZXkoa2V5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXROZXN0ZWRDaGFpbnMoY2hhaW5zLCBzY29wZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNjb3BlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYml0ID0gc2NvcGVbaV07XG5cbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgICBjaGFpbnMgPSBjaGFpbnNbYml0XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFjaGFpbnMpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhaW5zO1xuICAgIH1cblxuICAgIHZhciBzZXF1ZW5jZSA9IFtdO1xuICAgIGZ1bmN0aW9uIGRpc3BhdGNoKGUpIHtcbiAgICAgICAgLy8gU2tpcCBhbGwgbW9kaWZpZXJzXG4gICAgICAgIGlmICh+TU9ETlVNUy5pbmRleE9mKGUua2V5Q29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZXEgPSBzZXF1ZW5jZS5zbGljZSgpO1xuICAgICAgICBzZXEucHVzaChldmVudEtleVN0cmluZyhlKSk7XG4gICAgICAgIHZhciBzY29wZSA9IGN1cnJlbnRTY29wZS5zcGxpdCgnLicpO1xuICAgICAgICB2YXIgbWF0Y2hlZCwgY2hhaW5zLCBrZXk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IHNjb3BlLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNoYWlucyA9IGdldE5lc3RlZENoYWlucyhhbGxDaGFpbnMsIHNjb3BlLnNsaWNlKDAsIGkpKTtcbiAgICAgICAgICAgIGlmICghY2hhaW5zKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VxLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gc2VxW2pdO1xuICAgICAgICAgICAgICAgIGlmICghY2hhaW5zW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hhaW5zID0gY2hhaW5zW2tleV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVmaW5pdGlvblNjb3BlID0gc2NvcGUuc2xpY2UoMCwgaSkuam9pbignLicpO1xuICAgICAgICB2YXIgcHJldmVudERlZmF1bHQgPSBjaGFpbnMucHJldmVudERlZmF1bHQ7XG5cbiAgICAgICAgLy8gcGFydGlhbCBtYXRjaCwgc2F2ZSB0aGUgc2VxdWVuY2VcbiAgICAgICAgaWYgKG1hdGNoZWQgJiYgIWNoYWlucy5oYW5kbGVycykge1xuICAgICAgICAgICAgc2VxdWVuY2UgPSBzZXE7XG4gICAgICAgICAgICBpZiAocHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNoYWlucy5oYW5kbGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gY2hhaW5zLmhhbmRsZXJzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gaGFuZGxlci5fa2V5bWFnZTtcblxuICAgICAgICAgICAgICAgIHZhciByZXMgPSBoYW5kbGVyLmNhbGwob3B0aW9ucy5jb250ZXh0LCBlLCB7XG4gICAgICAgICAgICAgICAgICAgIHNob3J0Y3V0OiBvcHRpb25zLm9yaWdpbmFsLFxuICAgICAgICAgICAgICAgICAgICBzY29wZTogY3VycmVudFNjb3BlLFxuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uU2NvcGU6IGRlZmluaXRpb25TY29wZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlcyA9PT0gZmFsc2UgfHwgcHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVpdGhlciBtYXRjaGVkIG9yIG5vdCwgZHJvcCB0aGUgc2VxdWVuY2VcbiAgICAgICAgc2VxdWVuY2UgPSBbXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRIYW5kbGVycyhzY29wZSwga2V5Y2hhaW4sIGZuKSB7XG4gICAgICAgIHZhciBiaXRzID0gc2NvcGUuc3BsaXQoJy4nKTtcbiAgICAgICAgdmFyIGNoYWlucyA9IGFsbENoYWlucztcbiAgICAgICAgYml0cyA9IGJpdHMuY29uY2F0KGtleWNoYWluKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGJpdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYml0ID0gYml0c1tpXTtcbiAgICAgICAgICAgIGlmICghYml0KSBjb250aW51ZTtcblxuICAgICAgICAgICAgY2hhaW5zID0gY2hhaW5zW2JpdF0gfHwgKGNoYWluc1tiaXRdID0ge30pO1xuICAgICAgICAgICAgaWYgKGZuICYmIGZuLl9rZXltYWdlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgY2hhaW5zLnByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGkgPT09IGwgLSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXJzID0gY2hhaW5zLmhhbmRsZXJzIHx8IChjaGFpbnMuaGFuZGxlcnMgPSBbXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXNzaWduS2V5KHNjb3BlLCBrZXljaGFpbiwgZm4pIHtcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gZ2V0SGFuZGxlcnMoc2NvcGUsIGtleWNoYWluLCBmbik7XG4gICAgICAgIGhhbmRsZXJzLnB1c2goZm4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuYXNzaWduS2V5KHNjb3BlLCBrZXljaGFpbiwgZm4pIHtcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gZ2V0SGFuZGxlcnMoc2NvcGUsIGtleWNoYWluKTtcbiAgICAgICAgdmFyIGlkeCA9IGhhbmRsZXJzLmluZGV4T2YoZm4pO1xuICAgICAgICBpZiAofmlkeCkge1xuICAgICAgICAgICAgaGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZWQoc2NvcGUsIGtleWNoYWluLCBmbiwgb3B0aW9ucykge1xuICAgICAgICBpZiAoa2V5Y2hhaW4gPT09IHVuZGVmaW5lZCAmJiBmbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oa2V5Y2hhaW4sIGZuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleW1hZ2Uoc2NvcGUsIGtleWNoYWluLCBmbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXljaGFpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGZuO1xuICAgICAgICAgICAgZm4gPSBrZXljaGFpbjtcbiAgICAgICAgICAgIGtleWNoYWluID0gc2NvcGU7XG4gICAgICAgICAgICBzY29wZSA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVLZXlDaGFpbihrZXljaGFpbik7XG5cbiAgICAgICAgcmV0dXJuIFtzY29wZSwgbm9ybWFsaXplZCwgZm4sIG9wdGlvbnNdO1xuICAgIH1cblxuICAgIC8vIG9wdGlvbmFsIGFyZ3VtZW50czogc2NvcGUsIG9wdGlvbnMuXG4gICAgZnVuY3Rpb24ga2V5bWFnZShzY29wZSwga2V5Y2hhaW4sIGZuLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBhcmdzID0gcGFyc2VkKHNjb3BlLCBrZXljaGFpbiwgZm4sIG9wdGlvbnMpO1xuICAgICAgICBmbiA9IGFyZ3NbMl07XG4gICAgICAgIG9wdGlvbnMgPSBhcmdzWzNdO1xuICAgICAgICBmbi5fa2V5bWFnZSA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGZuLl9rZXltYWdlLm9yaWdpbmFsID0ga2V5Y2hhaW47XG4gICAgICAgIGFzc2lnbktleS5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG5cbiAgICBrZXltYWdlLnVuYmluZCA9IGZ1bmN0aW9uKHNjb3BlLCBrZXljaGFpbiwgZm4pIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBwYXJzZWQoc2NvcGUsIGtleWNoYWluLCBmbik7XG4gICAgICAgIHVuYXNzaWduS2V5LmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH07XG5cbiAgICBrZXltYWdlLnBhcnNlID0gcGFyc2VLZXlTdHJpbmc7XG4gICAga2V5bWFnZS5zdHJpbmdpZnkgPSBzdHJpbmdpZnlLZXk7XG5cbiAgICBrZXltYWdlLmJpbmRpbmdzID0gYWxsQ2hhaW5zO1xuXG4gICAga2V5bWFnZS5zZXRTY29wZSA9IGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgICAgIGN1cnJlbnRTY29wZSA9IHNjb3BlID8gc2NvcGUgOiAnJztcbiAgICB9O1xuXG4gICAga2V5bWFnZS5nZXRTY29wZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY3VycmVudFNjb3BlOyB9O1xuXG4gICAga2V5bWFnZS5wdXNoU2NvcGUgPSBmdW5jdGlvbihzY29wZSkge1xuICAgICAgICBjdXJyZW50U2NvcGUgPSAoY3VycmVudFNjb3BlID8gY3VycmVudFNjb3BlICsgJy4nIDogJycpICsgc2NvcGU7XG4gICAgICAgIHJldHVybiBjdXJyZW50U2NvcGU7XG4gICAgfTtcblxuICAgIGtleW1hZ2UucG9wU2NvcGUgPSBmdW5jdGlvbihzY29wZSkge1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICBpZiAoIXNjb3BlKSB7XG4gICAgICAgICAgICBpID0gY3VycmVudFNjb3BlLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgICAgICAgICBzY29wZSA9IGN1cnJlbnRTY29wZS5zbGljZShpICsgMSk7XG4gICAgICAgICAgICBjdXJyZW50U2NvcGUgPSBpID09IC0xID8gJycgOiBjdXJyZW50U2NvcGUuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICByZXR1cm4gc2NvcGU7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50U2NvcGUgPSBjdXJyZW50U2NvcGUucmVwbGFjZShcbiAgICAgICAgICAgIG5ldyBSZWdFeHAoJyhefFxcXFwuKScgKyBzY29wZSArICcoXFxcXC58JCkuKicpLCAnJyk7XG4gICAgICAgIHJldHVybiBzY29wZTtcbiAgICB9O1xuXG4gICAga2V5bWFnZS52ZXJzaW9uID0gVkVSU0lPTjtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZGlzcGF0Y2gsIGZhbHNlKTtcblxuICAgIHJldHVybiBrZXltYWdlO1xufSk7XG59KSh0eXBlb2YgZGVmaW5lICE9PSAndW5kZWZpbmVkJyA/IGRlZmluZSA6IGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LmtleW1hZ2UgPSBmYWN0b3J5KCk7XG4gICAgfVxufSk7XG4iLCIoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8vIFVzZSBwb2x5ZmlsbCBmb3Igc2V0SW1tZWRpYXRlIGZvciBwZXJmb3JtYW5jZSBnYWluc1xuXHR2YXIgYXNhcCA9ICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nICYmIHNldEltbWVkaWF0ZSkgfHxcblx0XHRmdW5jdGlvbihmbikgeyBzZXRUaW1lb3V0KGZuLCAxKTsgfTtcblxuXHQvLyBQb2x5ZmlsbCBmb3IgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcblx0ZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50cyk7XG5cdFx0fVxuXHR9XG5cblx0dmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBcIltvYmplY3QgQXJyYXldXCIgfTtcblxuXHRmdW5jdGlvbiBQcm9taXNlKGZuKSB7XG5cdFx0aWYgKHR5cGVvZiB0aGlzICE9PSAnb2JqZWN0JykgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJvbWlzZXMgbXVzdCBiZSBjb25zdHJ1Y3RlZCB2aWEgbmV3Jyk7XG5cdFx0aWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcignbm90IGEgZnVuY3Rpb24nKTtcblx0XHR0aGlzLl9zdGF0ZSA9IG51bGw7XG5cdFx0dGhpcy5fdmFsdWUgPSBudWxsO1xuXHRcdHRoaXMuX2RlZmVycmVkcyA9IFtdXG5cblx0XHRkb1Jlc29sdmUoZm4sIGJpbmQocmVzb2x2ZSwgdGhpcyksIGJpbmQocmVqZWN0LCB0aGlzKSlcblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZShkZWZlcnJlZCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0aWYgKHRoaXMuX3N0YXRlID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLl9kZWZlcnJlZHMucHVzaChkZWZlcnJlZCk7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0YXNhcChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjYiA9IG1lLl9zdGF0ZSA/IGRlZmVycmVkLm9uRnVsZmlsbGVkIDogZGVmZXJyZWQub25SZWplY3RlZFxuXHRcdFx0aWYgKGNiID09PSBudWxsKSB7XG5cdFx0XHRcdChtZS5fc3RhdGUgPyBkZWZlcnJlZC5yZXNvbHZlIDogZGVmZXJyZWQucmVqZWN0KShtZS5fdmFsdWUpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgcmV0O1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmV0ID0gY2IobWUuX3ZhbHVlKTtcblx0XHRcdH1cblx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlamVjdChlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0ZGVmZXJyZWQucmVzb2x2ZShyZXQpO1xuXHRcdH0pXG5cdH1cblxuXHRmdW5jdGlvbiByZXNvbHZlKG5ld1ZhbHVlKSB7XG5cdFx0dHJ5IHsgLy9Qcm9taXNlIFJlc29sdXRpb24gUHJvY2VkdXJlOiBodHRwczovL2dpdGh1Yi5jb20vcHJvbWlzZXMtYXBsdXMvcHJvbWlzZXMtc3BlYyN0aGUtcHJvbWlzZS1yZXNvbHV0aW9uLXByb2NlZHVyZVxuXHRcdFx0aWYgKG5ld1ZhbHVlID09PSB0aGlzKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIHByb21pc2UgY2Fubm90IGJlIHJlc29sdmVkIHdpdGggaXRzZWxmLicpO1xuXHRcdFx0aWYgKG5ld1ZhbHVlICYmICh0eXBlb2YgbmV3VmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBuZXdWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykpIHtcblx0XHRcdFx0dmFyIHRoZW4gPSBuZXdWYWx1ZS50aGVuO1xuXHRcdFx0XHRpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRkb1Jlc29sdmUoYmluZCh0aGVuLCBuZXdWYWx1ZSksIGJpbmQocmVzb2x2ZSwgdGhpcyksIGJpbmQocmVqZWN0LCB0aGlzKSk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9zdGF0ZSA9IHRydWU7XG5cdFx0XHR0aGlzLl92YWx1ZSA9IG5ld1ZhbHVlO1xuXHRcdFx0ZmluYWxlLmNhbGwodGhpcyk7XG5cdFx0fSBjYXRjaCAoZSkgeyByZWplY3QuY2FsbCh0aGlzLCBlKTsgfVxuXHR9XG5cblx0ZnVuY3Rpb24gcmVqZWN0KG5ld1ZhbHVlKSB7XG5cdFx0dGhpcy5fc3RhdGUgPSBmYWxzZTtcblx0XHR0aGlzLl92YWx1ZSA9IG5ld1ZhbHVlO1xuXHRcdGZpbmFsZS5jYWxsKHRoaXMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZmluYWxlKCkge1xuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9kZWZlcnJlZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGhhbmRsZS5jYWxsKHRoaXMsIHRoaXMuX2RlZmVycmVkc1tpXSk7XG5cdFx0fVxuXHRcdHRoaXMuX2RlZmVycmVkcyA9IG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiBIYW5kbGVyKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCByZXNvbHZlLCByZWplY3Qpe1xuXHRcdHRoaXMub25GdWxmaWxsZWQgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IG51bGw7XG5cdFx0dGhpcy5vblJlamVjdGVkID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT09ICdmdW5jdGlvbicgPyBvblJlamVjdGVkIDogbnVsbDtcblx0XHR0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuXHRcdHRoaXMucmVqZWN0ID0gcmVqZWN0O1xuXHR9XG5cblx0LyoqXG5cdCAqIFRha2UgYSBwb3RlbnRpYWxseSBtaXNiZWhhdmluZyByZXNvbHZlciBmdW5jdGlvbiBhbmQgbWFrZSBzdXJlXG5cdCAqIG9uRnVsZmlsbGVkIGFuZCBvblJlamVjdGVkIGFyZSBvbmx5IGNhbGxlZCBvbmNlLlxuXHQgKlxuXHQgKiBNYWtlcyBubyBndWFyYW50ZWVzIGFib3V0IGFzeW5jaHJvbnkuXG5cdCAqL1xuXHRmdW5jdGlvbiBkb1Jlc29sdmUoZm4sIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG5cdFx0dmFyIGRvbmUgPSBmYWxzZTtcblx0XHR0cnkge1xuXHRcdFx0Zm4oZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdGlmIChkb25lKSByZXR1cm47XG5cdFx0XHRcdGRvbmUgPSB0cnVlO1xuXHRcdFx0XHRvbkZ1bGZpbGxlZCh2YWx1ZSk7XG5cdFx0XHR9LCBmdW5jdGlvbiAocmVhc29uKSB7XG5cdFx0XHRcdGlmIChkb25lKSByZXR1cm47XG5cdFx0XHRcdGRvbmUgPSB0cnVlO1xuXHRcdFx0XHRvblJlamVjdGVkKHJlYXNvbik7XG5cdFx0XHR9KVxuXHRcdH0gY2F0Y2ggKGV4KSB7XG5cdFx0XHRpZiAoZG9uZSkgcmV0dXJuO1xuXHRcdFx0ZG9uZSA9IHRydWU7XG5cdFx0XHRvblJlamVjdGVkKGV4KTtcblx0XHR9XG5cdH1cblxuXHRQcm9taXNlLnByb3RvdHlwZVsnY2F0Y2gnXSA9IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG5cdFx0cmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGVkKTtcblx0fTtcblxuXHRQcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdGhhbmRsZS5jYWxsKG1lLCBuZXcgSGFuZGxlcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcmVzb2x2ZSwgcmVqZWN0KSk7XG5cdFx0fSlcblx0fTtcblxuXHRQcm9taXNlLmFsbCA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgaXNBcnJheShhcmd1bWVudHNbMF0pID8gYXJndW1lbnRzWzBdIDogYXJndW1lbnRzKTtcblxuXHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRpZiAoYXJncy5sZW5ndGggPT09IDApIHJldHVybiByZXNvbHZlKFtdKTtcblx0XHRcdHZhciByZW1haW5pbmcgPSBhcmdzLmxlbmd0aDtcblx0XHRcdGZ1bmN0aW9uIHJlcyhpLCB2YWwpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRpZiAodmFsICYmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSkge1xuXHRcdFx0XHRcdFx0dmFyIHRoZW4gPSB2YWwudGhlbjtcblx0XHRcdFx0XHRcdGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwodmFsLCBmdW5jdGlvbiAodmFsKSB7IHJlcyhpLCB2YWwpIH0sIHJlamVjdCk7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YXJnc1tpXSA9IHZhbDtcblx0XHRcdFx0XHRpZiAoLS1yZW1haW5pbmcgPT09IDApIHtcblx0XHRcdFx0XHRcdHJlc29sdmUoYXJncyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGNhdGNoIChleCkge1xuXHRcdFx0XHRcdHJlamVjdChleCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRyZXMoaSwgYXJnc1tpXSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH07XG5cblx0UHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IFByb21pc2UpIHtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcblx0XHRcdHJlc29sdmUodmFsdWUpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdFByb21pc2UucmVqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdHJlamVjdCh2YWx1ZSk7XG5cdFx0fSk7XG5cdH07XG5cblx0UHJvbWlzZS5yYWNlID0gZnVuY3Rpb24gKHZhbHVlcykge1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRmb3IodmFyIGkgPSAwLCBsZW4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0dmFsdWVzW2ldLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0IHRoZSBpbW1lZGlhdGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSBjYWxsYmFja3Ncblx0ICogQHBhcmFtIGZuIHtmdW5jdGlvbn0gRnVuY3Rpb24gdG8gZXhlY3V0ZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0UHJvbWlzZS5fc2V0SW1tZWRpYXRlRm4gPSBmdW5jdGlvbiBfc2V0SW1tZWRpYXRlRm4oZm4pIHtcblx0XHRhc2FwID0gZm47XG5cdH07XG5cblx0aWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuXHR9IGVsc2UgaWYgKCFyb290LlByb21pc2UpIHtcblx0XHRyb290LlByb21pc2UgPSBQcm9taXNlO1xuXHR9XG5cbn0pKHRoaXMpOyIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJpY3RVcmlFbmNvZGUgPSByZXF1aXJlKCdzdHJpY3QtdXJpLWVuY29kZScpO1xuXG5leHBvcnRzLmV4dHJhY3QgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHJldHVybiBzdHIuc3BsaXQoJz8nKVsxXSB8fCAnJztcbn07XG5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuXHRcdHJldHVybiB7fTtcblx0fVxuXG5cdHN0ciA9IHN0ci50cmltKCkucmVwbGFjZSgvXihcXD98I3wmKS8sICcnKTtcblxuXHRpZiAoIXN0cikge1xuXHRcdHJldHVybiB7fTtcblx0fVxuXG5cdHJldHVybiBzdHIuc3BsaXQoJyYnKS5yZWR1Y2UoZnVuY3Rpb24gKHJldCwgcGFyYW0pIHtcblx0XHR2YXIgcGFydHMgPSBwYXJhbS5yZXBsYWNlKC9cXCsvZywgJyAnKS5zcGxpdCgnPScpO1xuXHRcdC8vIEZpcmVmb3ggKHByZSA0MCkgZGVjb2RlcyBgJTNEYCB0byBgPWBcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3F1ZXJ5LXN0cmluZy9wdWxsLzM3XG5cdFx0dmFyIGtleSA9IHBhcnRzLnNoaWZ0KCk7XG5cdFx0dmFyIHZhbCA9IHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0cy5qb2luKCc9JykgOiB1bmRlZmluZWQ7XG5cblx0XHRrZXkgPSBkZWNvZGVVUklDb21wb25lbnQoa2V5KTtcblxuXHRcdC8vIG1pc3NpbmcgYD1gIHNob3VsZCBiZSBgbnVsbGA6XG5cdFx0Ly8gaHR0cDovL3czLm9yZy9UUi8yMDEyL1dELXVybC0yMDEyMDUyNC8jY29sbGVjdC11cmwtcGFyYW1ldGVyc1xuXHRcdHZhbCA9IHZhbCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlY29kZVVSSUNvbXBvbmVudCh2YWwpO1xuXG5cdFx0aWYgKCFyZXQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0cmV0W2tleV0gPSB2YWw7XG5cdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJldFtrZXldKSkge1xuXHRcdFx0cmV0W2tleV0ucHVzaCh2YWwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXRba2V5XSA9IFtyZXRba2V5XSwgdmFsXTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LCB7fSk7XG59O1xuXG5leHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChvYmopIHtcblx0cmV0dXJuIG9iaiA/IE9iamVjdC5rZXlzKG9iaikuc29ydCgpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dmFyIHZhbCA9IG9ialtrZXldO1xuXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuXHRcdFx0cmV0dXJuIHZhbC5zb3J0KCkubWFwKGZ1bmN0aW9uICh2YWwyKSB7XG5cdFx0XHRcdHJldHVybiBzdHJpY3RVcmlFbmNvZGUoa2V5KSArICc9JyArIHN0cmljdFVyaUVuY29kZSh2YWwyKTtcblx0XHRcdH0pLmpvaW4oJyYnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc3RyaWN0VXJpRW5jb2RlKGtleSkgKyAnPScgKyBzdHJpY3RVcmlFbmNvZGUodmFsKTtcblx0fSkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG5cdFx0cmV0dXJuIHgubGVuZ3RoID4gMDtcblx0fSkuam9pbignJicpIDogJyc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKC9bIScoKSpdL2csIGZ1bmN0aW9uIChjKSB7XG5cdFx0cmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNik7XG5cdH0pO1xufTtcbiIsInZhciB4aHJGYWN0b3J5ID0gKGZ1bmN0aW9uIGdldFhIUmZhY3RvcnkgKGZhY3Rvcmllcykge1xuICBmb3IgKHZhciBpPTAsIHhociwgWCwgbGVuPWZhY3Rvcmllcy5sZW5ndGg7IGk8bGVuOyBpKyspIHtcbiAgICB0cnkgeyBYID0gZmFjdG9yaWVzW2ldOyB4aHIgPSBYKCk7XG4gICAgICByZXR1cm4gd2luZG93LlhNTEh0dHBSZXF1ZXN0ID8gWCA6IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCA9IFg7XG4gICAgfSBjYXRjaCAoZSkgeyBjb250aW51ZTsgfVxuICB9XG59KShbXG4gIGZ1bmN0aW9uICgpIHtyZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7fSwvLyBJRTEwKyxGRixDaHJvbWUsT3BlcmEsU2FmYXJpXG4gIGZ1bmN0aW9uICgpIHtyZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoXCJNc3htbDMuXCIpO30sICAgICAgICAgICAgLy8gSUU5XG4gIGZ1bmN0aW9uICgpIHtyZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoXCJNc3htbDIuWE1MSFRUUC42LjBcIik7fSwgLy8gSUU4XG4gIGZ1bmN0aW9uICgpIHtyZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoXCJNc3htbDIuWE1MSFRUUC4zLjBcIik7fSwgLy8gSUU3XG4gIGZ1bmN0aW9uICgpIHtyZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoXCJNc3htbDIuWE1MSFRUUFwiKTt9LCAgICAgLy8gSUU2XG4gIGZ1bmN0aW9uICgpIHtyZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKTt9LCAgLy8gSUU1XG4gIGZ1bmN0aW9uICgpIHtyZXR1cm4gbnVsbDt9XG5dKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0WEhSKCkgeyByZXR1cm4geGhyRmFjdG9yeSgpOyB9XG4iLCJ2YXIgYWpheCA9IHJlcXVpcmUoJy4vdXRpbC9hamF4LmpzJyk7XHJcblxyXG4vLyBzdGVhbGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2lhbWJ1bWJsZWhlYWQvZm9ybS11cmxlbmNvZGVkL1xyXG5mdW5jdGlvbiBmb3JtRW5jb2RlU3RyaW5nKHN0cikge1xyXG5cdHJldHVybiBzdHIucmVwbGFjZSgvW14gIScoKX5cXCpdKi9nLCBlbmNvZGVVUklDb21wb25lbnQpXHJcblx0LnJlcGxhY2UoLyAvZywgJysnKVxyXG5cdC5yZXBsYWNlKC9bIScoKX5cXCpdL2csIGZ1bmN0aW9uIChjaCkge1xyXG5cdFx0cmV0dXJuICclJyArICgnMCcgKyBjaC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSlcclxuXHRcdC5zbGljZSgtMikudG9VcHBlckNhc2UoKTtcclxuXHR9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gZm9ybUVuY29kZShvYmopIHtcclxuXHR2YXIgc3RyID0gW107XHJcblx0Zm9yICh2YXIgcHJvcCBpbiBvYmopIHtcclxuXHRcdGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHsvLyBkb24ndCBoYW5kbGUgbmVzdGVkIG9iamVjdHNcclxuXHRcdFx0c3RyLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KHByb3ApICsgJz0nICtcclxuXHRcdFx0Zm9ybUVuY29kZVN0cmluZyhvYmpbcHJvcF0pKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIHN0ci5qb2luKCcmJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVud3JhcCh4aHIpIHtcclxuXHR2YXIgZGF0YSA9IHhoci5yZXNwb25zZVRleHQ7XHJcblx0dmFyIHZhbHVlID0gZGF0YS5zdWJzdHJpbmcoZGF0YS5pbmRleE9mKCdcXG4nKSArIDEpO1xyXG5cclxuXHRpZiAoZGF0YS5zdGFydHNXaXRoKCdPay4nKSkge1xyXG5cdFx0cmV0dXJuIHZhbHVlO1xyXG5cdH1cclxuXHR0aHJvdyBFcnJvcignVW5rbm93biBzZXJ2ZXIgZXJyb3I6ICcgKyBkYXRhKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXBpIChiYXNlX3VybCkge1xyXG5cdGZ1bmN0aW9uIHJlcXVlc3QgKG1ldGhvZCwgdXJsKSB7XHJcblx0XHRmdW5jdGlvbiBvcHRpb25zKGRhdGEsIHBhcmFtcywgc3luYykge1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdG1ldGhvZDogbWV0aG9kLFxyXG5cdFx0XHRcdHVybDogcmVzLnVybCxcclxuXHRcdFx0XHRzeW5jOiBzeW5jLFxyXG5cdFx0XHRcdHBhcmFtczogcGFyYW1zLFxyXG5cdFx0XHRcdGRhdGE6IGRhdGEgJiYgZm9ybUVuY29kZShkYXRhKSxcclxuXHRcdFx0XHRoZWFkZXJzOiBkYXRhICYmIHtcclxuXHRcdFx0XHRcdCdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHRcdHZhciByZXMgPSBmdW5jdGlvbiAoZGF0YSwgcGFyYW1zKSB7XHJcblx0XHRcdHJldHVybiBhamF4KG9wdGlvbnMoZGF0YSwgcGFyYW1zKSkudGhlbih1bndyYXApO1xyXG5cdFx0fTtcclxuXHRcdHJlcy5zeW5jID0gZnVuY3Rpb24gKGRhdGEsIHBhcmFtcykge1xyXG5cdFx0XHQvLyBUT0RPOiBoYW5kbGUgZXJyb3JzXHJcblx0XHRcdHJldHVybiB1bndyYXAoYWpheChvcHRpb25zKGRhdGEsIHBhcmFtcywgdHJ1ZSkpKTtcclxuXHRcdH07XHJcblx0XHRyZXMudXJsID0gYmFzZV91cmwgKyB1cmw7XHJcblx0XHRyZXR1cm4gcmVzO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdGluY2hpOiByZXF1ZXN0KCdQT1NUJywgJ2dldGluY2hpJyksXHJcblx0XHRtb2xmaWxlOiByZXF1ZXN0KCdQT1NUJywgJ2dldG1vbGZpbGUnKSxcclxuXHRcdGFyb21hdGl6ZTogcmVxdWVzdCgnUE9TVCcsICdhcm9tYXRpemUnKSxcclxuXHRcdGRlYXJvbWF0aXplOiByZXF1ZXN0KCdQT1NUJywgJ2RlYXJvbWF0aXplJyksXHJcblx0XHRjYWxjdWxhdGVDaXA6IHJlcXVlc3QoJ1BPU1QnLCAnY2FsY3VsYXRlX2NpcCcpLFxyXG5cdFx0YXV0b21hcDogcmVxdWVzdCgnUE9TVCcsICdhdXRvbWFwJyksXHJcblx0XHRsYXlvdXRfc21pbGVzOiByZXF1ZXN0KCdHRVQnLCAnbGF5b3V0JyksXHJcblx0XHRsYXlvdXQ6IHJlcXVlc3QoJ1BPU1QnLCAnbGF5b3V0JyksXHJcblx0XHRzbWlsZXM6IHJlcXVlc3QoJ1BPU1QnLCAnc21pbGVzJyksXHJcblx0XHRzYXZlOiByZXF1ZXN0KCdQT1NUJywgJ3NhdmUnKSxcclxuXHRcdGtub2Nrbm9jazogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRyZXR1cm4gYWpheChiYXNlX3VybCArICdrbm9ja25vY2snKS50aGVuKGZ1bmN0aW9uICh4aHIpIHtcclxuXHRcdFx0XHRpZiAoeGhyLnJlc3BvbnNlVGV4dCAhPT0gJ1lvdSBhcmUgd2VsY29tZSEnKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBFcnJvcignU2VydmVyIGlzIG5vdCBjb21wYXRpYmxlJyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGFwaTtcclxuIiwidmFyIFZlYzIgPSByZXF1aXJlKCcuLi91dGlsL3ZlYzInKTtcclxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XHJcbnZhciBlbGVtZW50ID0gcmVxdWlyZSgnLi9lbGVtZW50Jyk7XHJcblxyXG52YXIgQXRvbSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcclxuXHR2YXIgZGVmID0gQXRvbS5hdHRyR2V0RGVmYXVsdDtcclxuXHRpZiAoIXBhcmFtcyB8fCAhKCdsYWJlbCcgaW4gcGFyYW1zKSlcclxuXHRcdHRocm93IG5ldyBFcnJvcignbGFiZWwgbXVzdCBiZSBzcGVjaWZpZWQhJyk7XHJcblxyXG5cdHRoaXMubGFiZWwgPSBwYXJhbXMubGFiZWw7XHJcblx0dGhpcy5mcmFnbWVudCA9ICFPYmplY3QuaXNVbmRlZmluZWQocGFyYW1zLmZyYWdtZW50KSA/IHBhcmFtcy5mcmFnbWVudCA6IC0xO1xyXG5cclxuXHR1dGlsLmlmRGVmKHRoaXMsIHBhcmFtcywgJ2lzb3RvcGUnLCBkZWYoJ2lzb3RvcGUnKSk7XHJcblx0dXRpbC5pZkRlZih0aGlzLCBwYXJhbXMsICdyYWRpY2FsJywgZGVmKCdyYWRpY2FsJykpO1xyXG5cdHV0aWwuaWZEZWYodGhpcywgcGFyYW1zLCAnY2hhcmdlJywgZGVmKCdjaGFyZ2UnKSk7XHJcblx0dXRpbC5pZkRlZih0aGlzLCBwYXJhbXMsICdyZ2xhYmVsJywgZGVmKCdyZ2xhYmVsJykpOyAvLyByLWdyb3VwIGluZGV4IG1hc2ssIGktdGggYml0IHN0YW5kcyBmb3IgaS10aCByLXNpdGVcclxuXHR1dGlsLmlmRGVmKHRoaXMsIHBhcmFtcywgJ2F0dHBudCcsIGRlZignYXR0cG50JykpOyAvLyBhdHRhY2htZW50IHBvaW50XHJcblx0dXRpbC5pZkRlZih0aGlzLCBwYXJhbXMsICdleHBsaWNpdFZhbGVuY2UnLCBkZWYoJ2V4cGxpY2l0VmFsZW5jZScpKTtcclxuXHJcblx0dGhpcy52YWxlbmNlID0gMDtcclxuXHR0aGlzLmltcGxpY2l0SCA9IDA7IC8vIGltcGxpY2l0SCBpcyBub3QgYW4gYXR0cmlidXRlXHJcblx0aWYgKCFPYmplY3QuaXNVbmRlZmluZWQocGFyYW1zLnBwKSlcclxuXHRcdHRoaXMucHAgPSBuZXcgVmVjMihwYXJhbXMucHApO1xyXG5cdGVsc2VcclxuXHRcdHRoaXMucHAgPSBuZXcgVmVjMigpO1xyXG5cclxuXHQvLyBzZ3Mgc2hvdWxkIG9ubHkgYmUgc2V0IHdoZW4gYW4gYXRvbSBpcyBhZGRlZCB0byBhbiBzLWdyb3VwIGJ5IGFuIGFwcHJvcHJpYXRlIG1ldGhvZCxcclxuXHQvLyAgIG9yIGVsc2UgYSBjb3BpZWQgYXRvbSBtaWdodCB0aGluayBpdCBiZWxvbmdzIHRvIGEgZ3JvdXAsIGJ1dCB0aGUgZ3JvdXAgYmUgdW5hd2FyZSBvZiB0aGUgYXRvbVxyXG5cdC8vIFRPRE86IG1ha2UgYSBjb25zaXN0ZW5jeSBjaGVjayBvbiBhdG9tL3MtZ3JvdXAgYXNzaWdubWVudHNcclxuXHR0aGlzLnNncyA9IHt9O1xyXG5cclxuXHQvLyBxdWVyeVxyXG5cdHV0aWwuaWZEZWYodGhpcywgcGFyYW1zLCAncmluZ0JvbmRDb3VudCcsIGRlZigncmluZ0JvbmRDb3VudCcpKTtcclxuXHR1dGlsLmlmRGVmKHRoaXMsIHBhcmFtcywgJ3N1YnN0aXR1dGlvbkNvdW50JywgZGVmKCdzdWJzdGl0dXRpb25Db3VudCcpKTtcclxuXHR1dGlsLmlmRGVmKHRoaXMsIHBhcmFtcywgJ3Vuc2F0dXJhdGVkQXRvbScsIGRlZigndW5zYXR1cmF0ZWRBdG9tJykpO1xyXG5cdHV0aWwuaWZEZWYodGhpcywgcGFyYW1zLCAnaENvdW50JywgZGVmKCdoQ291bnQnKSk7XHJcblxyXG5cdC8vIHJlYWN0aW9uXHJcblx0dXRpbC5pZkRlZih0aGlzLCBwYXJhbXMsICdhYW0nLCBkZWYoJ2FhbScpKTtcclxuXHR1dGlsLmlmRGVmKHRoaXMsIHBhcmFtcywgJ2ludlJldCcsIGRlZignaW52UmV0JykpO1xyXG5cdHV0aWwuaWZEZWYodGhpcywgcGFyYW1zLCAnZXhhY3RDaGFuZ2VGbGFnJywgZGVmKCdleGFjdENoYW5nZUZsYWcnKSk7XHJcblx0dXRpbC5pZkRlZih0aGlzLCBwYXJhbXMsICdyeG5GcmFnbWVudFR5cGUnLCAtMSk7IC8vIHRoaXMgaXNuJ3QgcmVhbGx5IGFuIGF0dHJpYnV0ZVxyXG5cclxuXHR0aGlzLmF0b21MaXN0ID0gIU9iamVjdC5pc1VuZGVmaW5lZChwYXJhbXMuYXRvbUxpc3QpICYmIHBhcmFtcy5hdG9tTGlzdCAhPSBudWxsID8gQXRvbUxpc3QocGFyYW1zLmF0b21MaXN0KSA6IG51bGw7XHJcblx0dGhpcy5uZWlnaGJvcnMgPSBbXTsgLy8gc2V0IG9mIGhhbGYtYm9uZHMgaGF2aW5nIHRoaXMgYXRvbSBhcyB0aGVpciBvcmlnaW5cclxuXHR0aGlzLmJhZENvbm4gPSBmYWxzZTtcclxufTtcclxuXHJcbkF0b20uUEFUVEVSTiA9XHJcbiB7XHJcbiAgICBSQURJQ0FMOlxyXG4ge1xyXG4gICAgICAgIE5PTkU6IDAsXHJcbiAgICAgICAgU0lOR0xFVDogMSxcclxuICAgICAgICBET1VQTEVUOiAyLFxyXG4gICAgICAgIFRSSVBMRVQ6IDNcclxuICAgIH1cclxufTtcclxuXHJcbkF0b20uYXR0cmxpc3QgPSB7XHJcbiAgICAnbGFiZWwnOiAnQycsXHJcbiAgICAnaXNvdG9wZSc6IDAsXHJcbiAgICAncmFkaWNhbCc6IDAsXHJcbiAgICAnY2hhcmdlJzogMCxcclxuICAgICdleHBsaWNpdFZhbGVuY2UnOiAtMSxcclxuICAgICdyaW5nQm9uZENvdW50JzogMCxcclxuICAgICdzdWJzdGl0dXRpb25Db3VudCc6IDAsXHJcbiAgICAndW5zYXR1cmF0ZWRBdG9tJzogMCxcclxuICAgICdoQ291bnQnOiAwLFxyXG4gICAgJ2F0b21MaXN0JzogbnVsbCxcclxuICAgICdpbnZSZXQnOiAwLFxyXG4gICAgJ2V4YWN0Q2hhbmdlRmxhZyc6IDAsXHJcbiAgICAncmdsYWJlbCc6IG51bGwsXHJcbiAgICAnYXR0cG50JzogbnVsbCxcclxuICAgICdhYW0nOiAwXHJcbn07XHJcblxyXG5BdG9tLmdldEF0dHJIYXNoID0gZnVuY3Rpb24gKGF0b20pIHtcclxuXHR2YXIgYXR0cnMgPSBuZXcgSGFzaCgpO1xyXG5cdGZvciAodmFyIGF0dHIgaW4gQXRvbS5hdHRybGlzdCkge1xyXG5cdFx0aWYgKHR5cGVvZihhdG9tW2F0dHJdKSAhPSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHRhdHRycy5zZXQoYXR0ciwgYXRvbVthdHRyXSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBhdHRycztcclxufTtcclxuXHJcbkF0b20uYXR0ckdldERlZmF1bHQgPSBmdW5jdGlvbiAoYXR0cikge1xyXG5cdGlmIChhdHRyIGluIEF0b20uYXR0cmxpc3QpXHJcblx0XHRyZXR1cm4gQXRvbS5hdHRybGlzdFthdHRyXTtcclxuXHR0aHJvdyBuZXcgRXJyb3IoJ0F0dHJpYnV0ZSB1bmtub3duJyk7XHJcbn07XHJcblxyXG5cclxuQXRvbS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoZmlkTWFwKVxyXG57XHJcblx0dmFyIHJldCA9IG5ldyBBdG9tKHRoaXMpO1xyXG5cdGlmIChmaWRNYXAgJiYgdGhpcy5mcmFnbWVudCBpbiBmaWRNYXApIHtcclxuXHRcdHJldC5mcmFnbWVudCA9IGZpZE1hcFt0aGlzLmZyYWdtZW50XTtcclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufTtcclxuXHJcbkF0b20ucHJvdG90eXBlLmlzUXVlcnkgPSAgZnVuY3Rpb24gKClcclxue1xyXG5cdHJldHVybiB0aGlzLmF0b21MaXN0ICE9IG51bGwgfHwgdGhpcy5sYWJlbCA9PSAnQScgfHwgdGhpcy5hdHRwbnQgfHwgdGhpcy5oQ291bnQ7XHJcbn07XHJcblxyXG5BdG9tLnByb3RvdHlwZS5wdXJlSHlkcm9nZW4gPSAgZnVuY3Rpb24gKClcclxue1xyXG5cdHJldHVybiB0aGlzLmxhYmVsID09ICdIJyAmJiB0aGlzLmlzb3RvcGUgPT0gMDtcclxufTtcclxuXHJcbkF0b20ucHJvdG90eXBlLmlzUGxhaW5DYXJib24gPSAgZnVuY3Rpb24gKClcclxue1xyXG5cdHJldHVybiB0aGlzLmxhYmVsID09ICdDJyAmJiB0aGlzLmlzb3RvcGUgPT0gMCAmJiB0aGlzLnJhZGljYWwgPT0gMCAmJiB0aGlzLmNoYXJnZSA9PSAwXHJcblx0XHQgJiYgdGhpcy5leHBsaWNpdFZhbGVuY2UgPCAwICYmIHRoaXMucmluZ0JvbmRDb3VudCA9PSAwICYmIHRoaXMuc3Vic3RpdHV0aW9uQ291bnQgPT0gMFxyXG5cdFx0ICYmIHRoaXMudW5zYXR1cmF0ZWRBdG9tID09IDAgJiYgdGhpcy5oQ291bnQgPT0gMCAmJiAhdGhpcy5hdG9tTGlzdDtcclxufTtcclxuXHJcbkF0b20ucHJvdG90eXBlLmlzUHNldWRvID0gIGZ1bmN0aW9uICgpXHJcbntcclxuXHQvLyBUT0RPOiBoYW5kbGUgcmVheHlzIGdlbmVyaWNzIHNlcGFyYXRlbHlcclxuXHRyZXR1cm4gIXRoaXMuYXRvbUxpc3QgJiYgIXRoaXMucmdsYWJlbCAmJiAhZWxlbWVudC5nZXRFbGVtZW50QnlMYWJlbCh0aGlzLmxhYmVsKTtcclxufTtcclxuXHJcbkF0b20ucHJvdG90eXBlLmhhc1J4blByb3BzID0gIGZ1bmN0aW9uICgpXHJcbntcclxuXHRyZXR1cm4gISEodGhpcy5pbnZSZXQgfHwgdGhpcy5leGFjdENoYW5nZUZsYWcgfHwgIXV0aWwuaXNOdWxsKHRoaXMuYXR0cG50KSB8fCB0aGlzLmFhbSk7XHJcbn07XHJcblxyXG5cclxudmFyIHJhZGljYWxFbGVjdHJvbnMgPSBmdW5jdGlvbiAocmFkaWNhbCkge1xyXG4gICAgcmFkaWNhbCA9IHJhZGljYWwgLSAwO1xyXG4gICAgaWYgKHJhZGljYWwgPT0gQXRvbS5QQVRURVJOLlJBRElDQUwuTk9ORSlcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIGVsc2UgaWYgKHJhZGljYWwgPT0gQXRvbS5QQVRURVJOLlJBRElDQUwuRE9VUExFVClcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIGVsc2UgaWYgKHJhZGljYWwgPT0gQXRvbS5QQVRURVJOLlJBRElDQUwuU0lOR0xFVCB8fFxyXG4gICAgICAgIHJhZGljYWwgPT0gQXRvbS5QQVRURVJOLlJBRElDQUwuVFJJUExFVClcclxuICAgICAgICByZXR1cm4gMjtcclxuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biByYWRpY2FsIHZhbHVlJyk7XHJcbn07XHJcblxyXG5BdG9tLnByb3RvdHlwZS5jYWxjVmFsZW5jZSA9IGZ1bmN0aW9uIChjb25uKSB7XHJcbiAgICB2YXIgYXRvbSA9IHRoaXM7XHJcbiAgICB2YXIgY2hhcmdlID0gYXRvbS5jaGFyZ2U7XHJcbiAgICB2YXIgbGFiZWwgPSBhdG9tLmxhYmVsO1xyXG4gICAgaWYgKGF0b20uaXNRdWVyeSgpKSB7XHJcbiAgICAgICAgdGhpcy5pbXBsaWNpdEggPSAwO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgdmFyIGVsZW0gPSBlbGVtZW50LmdldEVsZW1lbnRCeUxhYmVsKGxhYmVsKTtcclxuICAgIGlmIChlbGVtID09IG51bGwpIHtcclxuICAgICAgICB0aGlzLmltcGxpY2l0SCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGdyb3Vwbm8gPSBlbGVtZW50LmdldChlbGVtKS5ncm91cDtcclxuICAgIHZhciByYWQgPSByYWRpY2FsRWxlY3Ryb25zKGF0b20ucmFkaWNhbCk7XHJcblxyXG4gICAgdmFyIHZhbGVuY2UgPSBjb25uO1xyXG4gICAgdmFyIGh5ZCA9IDA7XHJcbiAgICB2YXIgYWJzQ2hhcmdlID0gTWF0aC5hYnMoY2hhcmdlKTtcclxuXHJcbiAgICBzd2l0Y2ggKGdyb3Vwbm8pIHtcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgIGlmIChsYWJlbCA9PSAnSCcgfHxcclxuXHRcdFx0bGFiZWwgPT0gJ0xpJyB8fCBsYWJlbCA9PSAnTmEnIHx8IGxhYmVsID09ICdLJyB8fFxyXG5cdFx0XHRsYWJlbCA9PSAnUmInIHx8IGxhYmVsID09ICdDcycgfHwgbGFiZWwgPT0gJ0ZyJykge1xyXG4gICAgICAgICAgICAgICAgdmFsZW5jZSA9IDE7XHJcbiAgICAgICAgICAgICAgICBoeWQgPSAxIC0gcmFkIC0gY29ubiAtIGFic0NoYXJnZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgIGlmIChsYWJlbCA9PSAnQicgfHwgbGFiZWwgPT0gJ0FsJyB8fCBsYWJlbCA9PSAnR2EnIHx8IGxhYmVsID09ICdJbicpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFyZ2UgPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWxlbmNlID0gNDtcclxuICAgICAgICAgICAgICAgICAgICBoeWQgPSA0IC0gcmFkIC0gY29ubjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbGVuY2UgPSAzO1xyXG4gICAgICAgICAgICAgICAgICAgIGh5ZCA9IDMgLSByYWQgLSBjb25uIC0gYWJzQ2hhcmdlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsID09ICdUbCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcmdlID09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYWQgKyBjb25uIDw9IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGVuY2UgPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHlkID0gMiAtIHJhZCAtIGNvbm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxlbmNlID0gNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh5ZCA9IDQgLSByYWQgLSBjb25uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcmdlID09IC0yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmFkICsgY29ubiA8PSAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsZW5jZSA9IDM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHlkID0gMyAtIHJhZCAtIGNvbm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxlbmNlID0gNTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoeWQgPSA1IC0gcmFkIC0gY29ubjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYWQgKyBjb25uICsgYWJzQ2hhcmdlIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxlbmNlID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoeWQgPSAxIC0gcmFkIC0gY29ubiAtIGFic0NoYXJnZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGVuY2UgPSAzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh5ZCA9IDMgLSByYWQgLSBjb25uIC0gYWJzQ2hhcmdlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgaWYgKGxhYmVsID09ICdDJyB8fCBsYWJlbCA9PSAnU2knIHx8IGxhYmVsID09ICdHZScpIHtcclxuICAgICAgICAgICAgICAgIHZhbGVuY2UgPSA0O1xyXG4gICAgICAgICAgICAgICAgaHlkID0gNCAtIHJhZCAtIGNvbm4gLSBhYnNDaGFyZ2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFiZWwgPT0gJ1NuJyB8fCBsYWJlbCA9PSAnUGInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm4gKyByYWQgKyBhYnNDaGFyZ2UgPD0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxlbmNlID0gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHlkID0gMiAtIHJhZCAtIGNvbm4gLSBhYnNDaGFyZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxlbmNlID0gNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHlkID0gNCAtIHJhZCAtIGNvbm4gLSBhYnNDaGFyZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgaWYgKGxhYmVsID09ICdOJyB8fCBsYWJlbCA9PSAnUCcpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFyZ2UgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbGVuY2UgPSA0O1xyXG4gICAgICAgICAgICAgICAgICAgIGh5ZCA9IDQgLSByYWQgLSBjb25uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJnZSA9PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGVuY2UgPSAzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoeWQgPSAzIC0gcmFkIC0gY29ubjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbCA9PSAnTicgfHwgcmFkICsgY29ubiArIGFic0NoYXJnZSA8PSAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxlbmNlID0gMztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh5ZCA9IDMgLSByYWQgLSBjb25uIC0gYWJzQ2hhcmdlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgLy8gRUxFTV9QICYmIHJhZCArIGNvbm4gKyBhYnNDaGFyZ2UgPiAzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGVuY2UgPSA1O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHlkID0gNSAtIHJhZCAtIGNvbm4gLSBhYnNDaGFyZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFiZWwgPT0gJ0JpJyB8fCBsYWJlbCA9PSAnU2InIHx8IGxhYmVsID09ICdBcycpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcmdlID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhZCArIGNvbm4gPD0gMiAmJiBsYWJlbCAhPSAnQXMnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxlbmNlID0gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh5ZCA9IDIgLSByYWQgLSBjb25uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsZW5jZSA9IDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoeWQgPSA0IC0gcmFkIC0gY29ubjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJnZSA9PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxlbmNlID0gMztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh5ZCA9IDMgLSByYWQgLSBjb25uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhZCArIGNvbm4gPD0gMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGVuY2UgPSAzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh5ZCA9IDMgLSByYWQgLSBjb25uIC0gYWJzQ2hhcmdlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsZW5jZSA9IDU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHlkID0gNSAtIHJhZCAtIGNvbm4gLSBhYnNDaGFyZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICBpZiAobGFiZWwgPT0gJ08nKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcmdlID49IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWxlbmNlID0gMztcclxuICAgICAgICAgICAgICAgICAgICBoeWQgPSAzIC0gcmFkIC0gY29ubjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbGVuY2UgPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgIGh5ZCA9IDIgLSByYWQgLSBjb25uIC0gYWJzQ2hhcmdlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsID09ICdTJyB8fCBsYWJlbCA9PSAnU2UnIHx8IGxhYmVsID09ICdQbycpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcmdlID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm4gPD0gMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsZW5jZSA9IDM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoeWQgPSAzIC0gcmFkIC0gY29ubjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGVuY2UgPSA1O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHlkID0gNSAtIHJhZCAtIGNvbm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25uICsgcmFkICsgYWJzQ2hhcmdlIDw9IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGVuY2UgPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHlkID0gMiAtIHJhZCAtIGNvbm4gLSBhYnNDaGFyZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29ubiArIHJhZCArIGFic0NoYXJnZSA8PSA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VlIGV4YW1wbGVzIGluIFB1YkNoZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBbU10gOiBDSUQgMTY2ODQyMTZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBbU2VdOiBDSUQgNTI0MjI1MlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFtQb106IG5vIGV4YW1wbGUsIGp1c3QgZm9sbG93aW5nIElTSVMvRHJhdyBsb2dpYyBoZXJlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxlbmNlID0gNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoeWQgPSA0IC0gcmFkIC0gY29ubiAtIGFic0NoYXJnZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZSBleGFtcGxlcyBpbiBQdWJDaGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gW1NdIDogQ0lEIDQ2OTM3MDQ0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gW1NlXTogQ0lEIDU5Nzg2XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gW1BvXTogbm8gZXhhbXBsZSwganVzdCBmb2xsb3dpbmcgSVNJUy9EcmF3IGxvZ2ljIGhlcmUge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGVuY2UgPSA2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh5ZCA9IDYgLSByYWQgLSBjb25uIC0gYWJzQ2hhcmdlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsID09ICdUZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJnZSA9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm4gPD0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGVuY2UgPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh5ZCA9IDIgLSByYWQgLSBjb25uIC0gYWJzQ2hhcmdlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJnZSA9PSAwIHx8IGNoYXJnZSA9PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm4gPD0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxlbmNlID0gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHlkID0gMiAtIHJhZCAtIGNvbm4gLSBhYnNDaGFyZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29ubiA8PSA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxlbmNlID0gNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh5ZCA9IDQgLSByYWQgLSBjb25uIC0gYWJzQ2hhcmdlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJnZSA9PSAwICYmIGNvbm4gPD0gNikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGVuY2UgPSA2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh5ZCA9IDYgLSByYWQgLSBjb25uIC0gYWJzQ2hhcmdlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHlkID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSA3OlxyXG4gICAgICAgICAgICBpZiAobGFiZWwgPT0gJ0YnKSB7XHJcbiAgICAgICAgICAgICAgICB2YWxlbmNlID0gMTtcclxuICAgICAgICAgICAgICAgIGh5ZCA9IDEgLSByYWQgLSBjb25uIC0gYWJzQ2hhcmdlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsID09ICdDbCcgfHwgbGFiZWwgPT0gJ0JyJyB8fCBsYWJlbCA9PSAnSScgfHwgbGFiZWwgPT0gJ0F0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyZ2UgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29ubiA8PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxlbmNlID0gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh5ZCA9IDIgLSByYWQgLSBjb25uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm4gPT0gMyB8fCBjb25uID09IDUgfHwgY29ubiA+PSA3KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh5ZCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcmdlID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25uIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxlbmNlID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoeWQgPSAxIC0gcmFkIC0gY29ubjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGlsZSB0aGUgaGFsb2dlbnMgY2FuIGhhdmUgdmFsZW5jZSAzLCB0aGV5IGNhbiBub3QgaGF2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh5ZHJvZ2VucyBpbiB0aGF0IGNhc2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29ubiA9PSAyIHx8IGNvbm4gPT0gNCB8fCBjb25uID09IDYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhZCA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxlbmNlID0gY29ubjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh5ZCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHlkID0gLTE7IC8vIHdpbGwgdGhyb3cgYW4gZXJyb3IgaW4gdGhlIGVuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm4gPiA3KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHlkID0gLTE7IC8vIHdpbGwgdGhyb3cgYW4gZXJyb3IgaW4gdGhlIGVuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudmFsZW5jZSA9IHZhbGVuY2U7XHJcbiAgICB0aGlzLmltcGxpY2l0SCA9IGh5ZDtcclxuICAgIGlmICh0aGlzLmltcGxpY2l0SCA8IDApIHtcclxuICAgICAgICB0aGlzLnZhbGVuY2UgPSBjb25uO1xyXG4gICAgICAgIHRoaXMuaW1wbGljaXRIID0gMDtcclxuICAgICAgICB0aGlzLmJhZENvbm4gPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuQXRvbS5wcm90b3R5cGUuY2FsY1ZhbGVuY2VNaW51c0h5ZCA9IGZ1bmN0aW9uIChjb25uKSB7XHJcbiAgICB2YXIgYXRvbSA9IHRoaXM7XHJcbiAgICB2YXIgY2hhcmdlID0gYXRvbS5jaGFyZ2U7XHJcbiAgICB2YXIgbGFiZWwgPSBhdG9tLmxhYmVsO1xyXG4gICAgdmFyIGVsZW0gPSBlbGVtZW50LmdldEVsZW1lbnRCeUxhYmVsKGxhYmVsKTtcclxuICAgIGlmIChlbGVtID09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbGVtZW50ICcgKyBsYWJlbCArICcgdW5rbm93bicpO1xyXG4gICAgaWYgKGVsZW0gPCAwKSB7IC8vIHF1ZXJ5IGF0b20sIHNraXBcclxuICAgICAgICB0aGlzLmltcGxpY2l0SCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGdyb3Vwbm8gPSBlbGVtZW50LmdldChlbGVtKS5ncm91cDtcclxuICAgIHZhciByYWQgPSByYWRpY2FsRWxlY3Ryb25zKGF0b20ucmFkaWNhbCk7XHJcblxyXG4gICAgaWYgKGdyb3Vwbm8gPT0gMykge1xyXG4gICAgICAgIGlmIChsYWJlbCA9PSAnQicgfHwgbGFiZWwgPT0gJ0FsJyB8fCBsYWJlbCA9PSAnR2EnIHx8IGxhYmVsID09ICdJbicpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJnZSA9PSAtMSlcclxuICAgICAgICAgICAgICAgIGlmIChyYWQgKyBjb25uIDw9IDQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJhZCArIGNvbm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZ3JvdXBubyA9PSA1KSB7XHJcbiAgICAgICAgaWYgKGxhYmVsID09ICdOJyB8fCBsYWJlbCA9PSAnUCcpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJnZSA9PSAxKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhZCArIGNvbm47XHJcbiAgICAgICAgICAgIGlmIChjaGFyZ2UgPT0gMilcclxuICAgICAgICAgICAgICAgIHJldHVybiByYWQgKyBjb25uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsYWJlbCA9PSAnU2InIHx8IGxhYmVsID09ICdCaScgfHwgbGFiZWwgPT0gJ0FzJykge1xyXG4gICAgICAgICAgICBpZiAoY2hhcmdlID09IDEpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFkICsgY29ubjtcclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhcmdlID09IDIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFkICsgY29ubjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChncm91cG5vID09IDYpIHtcclxuICAgICAgICBpZiAobGFiZWwgPT0gJ08nKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFyZ2UgPj0gMSlcclxuICAgICAgICAgICAgICAgIHJldHVybiByYWQgKyBjb25uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsYWJlbCA9PSAnUycgfHwgbGFiZWwgPT0gJ1NlJyB8fCBsYWJlbCA9PSAnUG8nKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFyZ2UgPT0gMSlcclxuICAgICAgICAgICAgICAgIHJldHVybiByYWQgKyBjb25uO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGdyb3Vwbm8gPT0gNykge1xyXG4gICAgICAgIGlmIChsYWJlbCA9PSAnQ2wnIHx8IGxhYmVsID09ICdCcicgfHxcclxuXHRcdFx0bGFiZWwgPT0gJ0knIHx8IGxhYmVsID09ICdBdCcpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJnZSA9PSAxKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhZCArIGNvbm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByYWQgKyBjb25uICsgTWF0aC5hYnMoY2hhcmdlKTtcclxufTtcclxuXHJcbnZhciBBdG9tTGlzdCA9IGZ1bmN0aW9uIChwYXJhbXMpXHJcbntcclxuXHRpZiAoIXBhcmFtcyB8fCAhKCdub3RMaXN0JyBpbiBwYXJhbXMpIHx8ICEoJ2lkcycgaW4gcGFyYW1zKSlcclxuXHRcdHRocm93IG5ldyBFcnJvcignXFwnbm90TGlzdFxcJyBhbmQgXFwnaWRzXFwnIG11c3QgYmUgc3BlY2lmaWVkIScpO1xyXG5cclxuXHR0aGlzLm5vdExpc3QgPSBwYXJhbXMubm90TGlzdDsgLypib29sZWFuKi9cclxuXHR0aGlzLmlkcyA9IHBhcmFtcy5pZHM7IC8qQXJyYXkgb2YgaW50ZWdlcnMqL1xyXG59O1xyXG5cclxuQXRvbUxpc3QucHJvdG90eXBlLmxhYmVsTGlzdCA9IGZ1bmN0aW9uICgpXHJcbntcclxuXHR2YXIgbGFiZWxzID0gW107XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmlkcy5sZW5ndGg7ICsraSlcclxuXHRcdGxhYmVscy5wdXNoKGVsZW1lbnQuZ2V0KHRoaXMuaWRzW2ldKS5sYWJlbCk7XHJcblx0cmV0dXJuIGxhYmVscztcclxufTtcclxuXHJcbkF0b21MaXN0LnByb3RvdHlwZS5sYWJlbCA9IGZ1bmN0aW9uICgpXHJcbntcclxuXHR2YXIgbGFiZWwgPSAnWycgKyB0aGlzLmxhYmVsTGlzdCgpLmpvaW4oJywnKSArICddJztcclxuXHRpZiAodGhpcy5ub3RMaXN0KVxyXG5cdFx0bGFiZWwgPSAnIScgKyBsYWJlbDtcclxuXHRyZXR1cm4gbGFiZWw7XHJcbn07XHJcblxyXG5BdG9tTGlzdC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKHgpXHJcbntcclxuXHRyZXR1cm4gdGhpcy5ub3RMaXN0ID09IHgubm90TGlzdCAmJiAodGhpcy5pZHMgfHwgW10pLnNvcnQoKS50b1N0cmluZygpID09ICh4LmlkcyB8fCBbXSkuc29ydCgpLnRvU3RyaW5nKCk7XHJcbn07XHJcblxyXG5BdG9tLkxpc3QgPSBBdG9tTGlzdDtcclxubW9kdWxlLmV4cG9ydHMgPSBBdG9tO1xyXG4iLCJ2YXIgVmVjMiA9IHJlcXVpcmUoJy4uL3V0aWwvdmVjMicpO1xyXG5cclxudmFyIEJvbmQgPSBmdW5jdGlvbiAocGFyYW1zKVxyXG57XHJcblx0aWYgKCFwYXJhbXMgfHwgISgnYmVnaW4nIGluIHBhcmFtcykgfHwgISgnZW5kJyBpbiBwYXJhbXMpIHx8ICEoJ3R5cGUnIGluIHBhcmFtcykpXHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1xcJ2JlZ2luXFwnLCBcXCdlbmRcXCcgYW5kIFxcJ3R5cGVcXCcgcHJvcGVydGllcyBtdXN0IGJlIHNwZWNpZmllZCEnKTtcclxuXHJcblx0dGhpcy5iZWdpbiA9IHBhcmFtcy5iZWdpbjtcclxuXHR0aGlzLmVuZCA9IHBhcmFtcy5lbmQ7XHJcbiAgICB0aGlzLnR5cGUgPSBwYXJhbXMudHlwZTtcclxuICAgIHRoaXMuc3RlcmVvID0gQm9uZC5QQVRURVJOLlNURVJFTy5OT05FO1xyXG4gICAgdGhpcy50b3BvbG9neSA9IEJvbmQuUEFUVEVSTi5UT1BPTE9HWS5FSVRIRVI7XHJcbiAgICB0aGlzLnJlYWN0aW5nQ2VudGVyU3RhdHVzID0gMDtcclxuXHR0aGlzLmhiMSA9IG51bGw7IC8vIGhhbGYtYm9uZHNcclxuXHR0aGlzLmhiMiA9IG51bGw7XHJcblx0dGhpcy5sZW4gPSAwO1xyXG5cdHRoaXMuc2IgPSAwO1xyXG5cdHRoaXMuc2EgPSAwO1xyXG4gICAgdGhpcy5hbmdsZSA9IDA7XHJcblxyXG4gICAgaWYgKHBhcmFtcy5zdGVyZW8pXHJcbiAgICAgICAgdGhpcy5zdGVyZW8gPSBwYXJhbXMuc3RlcmVvO1xyXG4gICAgaWYgKHBhcmFtcy50b3BvbG9neSlcclxuICAgICAgICB0aGlzLnRvcG9sb2d5ID0gcGFyYW1zLnRvcG9sb2d5O1xyXG4gICAgaWYgKHBhcmFtcy5yZWFjdGluZ0NlbnRlclN0YXR1cylcclxuICAgICAgICB0aGlzLnJlYWN0aW5nQ2VudGVyU3RhdHVzID0gcGFyYW1zLnJlYWN0aW5nQ2VudGVyU3RhdHVzO1xyXG5cclxuICAgIHRoaXMuY2VudGVyID0gbmV3IFZlYzIoKTtcclxuXHJcbn07XHJcblxyXG5Cb25kLlBBVFRFUk4gPVxyXG57XHJcbiAgICBUWVBFOlxyXG4ge1xyXG4gICAgICAgIFNJTkdMRTogMSxcclxuICAgICAgICBET1VCTEU6IDIsXHJcbiAgICAgICAgVFJJUExFOiAzLFxyXG4gICAgICAgIEFST01BVElDOiA0LFxyXG4gICAgICAgIFNJTkdMRV9PUl9ET1VCTEU6IDUsXHJcbiAgICAgICAgU0lOR0xFX09SX0FST01BVElDOiA2LFxyXG4gICAgICAgIERPVUJMRV9PUl9BUk9NQVRJQzogNyxcclxuICAgICAgICBBTlk6IDhcclxuICAgIH0sXHJcblxyXG4gICAgU1RFUkVPOlxyXG4ge1xyXG4gICAgICAgIE5PTkU6IDAsXHJcbiAgICAgICAgVVA6IDEsXHJcbiAgICAgICAgRUlUSEVSOiA0LFxyXG4gICAgICAgIERPV046IDYsXHJcbiAgICAgICAgQ0lTX1RSQU5TOiAzXHJcbiAgICB9LFxyXG5cclxuICAgIFRPUE9MT0dZOlxyXG4ge1xyXG4gICAgICAgIEVJVEhFUjogMCxcclxuICAgICAgICBSSU5HOiAxLFxyXG4gICAgICAgIENIQUlOOiAyXHJcbiAgICB9LFxyXG5cclxuICAgIFJFQUNUSU5HX0NFTlRFUjpcclxuIHtcclxuICAgICAgICBOT1RfQ0VOVEVSOiAtMSxcclxuICAgICAgICBVTk1BUktFRDogMCxcclxuICAgICAgICBDRU5URVI6IDEsXHJcbiAgICAgICAgVU5DSEFOR0VEOiAyLFxyXG4gICAgICAgIE1BREVfT1JfQlJPS0VOOiA0LFxyXG4gICAgICAgIE9SREVSX0NIQU5HRUQ6IDgsXHJcbiAgICAgICAgTUFERV9PUl9CUk9LRU5fQU5EX0NIQU5HRUQ6IDEyXHJcbiAgICB9XHJcbn07XHJcblxyXG5Cb25kLmF0dHJsaXN0ID0ge1xyXG5cdCd0eXBlJzogQm9uZC5QQVRURVJOLlRZUEUuU0lOR0xFLFxyXG5cdCdzdGVyZW8nOiBCb25kLlBBVFRFUk4uU1RFUkVPLk5PTkUsXHJcblx0J3RvcG9sb2d5JzogQm9uZC5QQVRURVJOLlRPUE9MT0dZLkVJVEhFUixcclxuXHQncmVhY3RpbmdDZW50ZXJTdGF0dXMnOiAwXHJcbn07XHJcblxyXG5Cb25kLmdldEF0dHJIYXNoID0gZnVuY3Rpb24gKGJvbmQpIHtcclxuXHR2YXIgYXR0cnMgPSBuZXcgSGFzaCgpO1xyXG5cdGZvciAodmFyIGF0dHIgaW4gQm9uZC5hdHRybGlzdCkge1xyXG5cdFx0aWYgKHR5cGVvZihib25kW2F0dHJdKSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0YXR0cnMuc2V0KGF0dHIsIGJvbmRbYXR0cl0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gYXR0cnM7XHJcbn07XHJcblxyXG5Cb25kLmF0dHJHZXREZWZhdWx0ID0gZnVuY3Rpb24gKGF0dHIpIHtcclxuXHRpZiAoYXR0ciBpbiBCb25kLmF0dHJsaXN0KVxyXG5cdFx0cmV0dXJuIEJvbmQuYXR0cmxpc3RbYXR0cl07XHJcblx0dGhyb3cgbmV3IEVycm9yKCdBdHRyaWJ1dGUgdW5rbm93bicpO1xyXG59XHJcblxyXG5Cb25kLnByb3RvdHlwZS5oYXNSeG5Qcm9wcyA9ICBmdW5jdGlvbiAoKVxyXG57XHJcblx0cmV0dXJuICEhdGhpcy5yZWFjdGluZ0NlbnRlclN0YXR1cztcclxufTtcclxuXHJcbkJvbmQucHJvdG90eXBlLmdldENlbnRlciA9IGZ1bmN0aW9uIChzdHJ1Y3QpIHtcclxuXHR2YXIgcDEgPSBzdHJ1Y3QuYXRvbXMuZ2V0KHRoaXMuYmVnaW4pLnBwO1xyXG5cdHZhciBwMiA9IHN0cnVjdC5hdG9tcy5nZXQodGhpcy5lbmQpLnBwO1xyXG5cdHJldHVybiBWZWMyLmxjMihwMSwgMC41LCBwMiwgMC41KTtcclxufVxyXG5cclxuQm9uZC5wcm90b3R5cGUuZ2V0RGlyID0gZnVuY3Rpb24gKHN0cnVjdCkge1xyXG5cdHZhciBwMSA9IHN0cnVjdC5hdG9tcy5nZXQodGhpcy5iZWdpbikucHA7XHJcblx0dmFyIHAyID0gc3RydWN0LmF0b21zLmdldCh0aGlzLmVuZCkucHA7XHJcblx0cmV0dXJuIHAyLnN1YihwMSkubm9ybWFsaXplZCgpO1xyXG59XHJcblxyXG5Cb25kLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIChhaWRNYXApXHJcbntcclxuXHR2YXIgY3AgPSBuZXcgQm9uZCh0aGlzKTtcclxuXHRpZiAoYWlkTWFwKSB7XHJcblx0XHRjcC5iZWdpbiA9IGFpZE1hcFtjcC5iZWdpbl07XHJcblx0XHRjcC5lbmQgPSBhaWRNYXBbY3AuZW5kXTtcclxuXHR9XHJcblx0cmV0dXJuIGNwO1xyXG59O1xyXG5cclxuQm9uZC5wcm90b3R5cGUuZmluZE90aGVyRW5kID0gZnVuY3Rpb24gKGkpXHJcbntcclxuXHRpZiAoaSA9PSB0aGlzLmJlZ2luKVxyXG5cdFx0cmV0dXJuIHRoaXMuZW5kO1xyXG5cdGlmIChpID09IHRoaXMuZW5kKVxyXG5cdFx0cmV0dXJuIHRoaXMuYmVnaW47XHJcblx0dGhyb3cgbmV3IEVycm9yKCdib25kIGVuZCBub3QgZm91bmQnKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQm9uZDtcclxuIiwidmFyIE1hcCA9IHJlcXVpcmUoJy4uL3V0aWwvbWFwJyk7XHJcbnZhciBWZWMyID0gcmVxdWlyZSgnLi4vdXRpbC92ZWMyJyk7XHJcbnZhciBCb25kID0gcmVxdWlyZSgnLi9ib25kJyk7XHJcblxyXG52YXIgQ2lzVHJhbnMgPSBmdW5jdGlvbiAobW9sLCBuZWlnaGJvcnNGdW5jLCBjb250ZXh0KSB7XHJcblx0dGhpcy5tb2xlY3VsZSA9IG1vbDtcclxuXHR0aGlzLmJvbmRzID0gbmV3IE1hcCgpO1xyXG5cdHRoaXMuZ2V0TmVpZ2hib3JzID0gbmVpZ2hib3JzRnVuYztcclxuXHR0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG59O1xyXG5cclxuQ2lzVHJhbnMuUEFSSVRZID0ge1xyXG5cdE5PTkU6IDAsXHJcblx0Q0lTOiAxLFxyXG5cdFRSQU5TOiAyXHJcbn07XHJcblxyXG5DaXNUcmFucy5wcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uIChmdW5jLCBjb250ZXh0KSB7XHJcblx0dGhpcy5ib25kcy5lYWNoKGZ1bmMsIGNvbnRleHQpO1xyXG59O1xyXG5cclxuQ2lzVHJhbnMucHJvdG90eXBlLmdldFBhcml0eSA9IGZ1bmN0aW9uIChpZHgpIHtcclxuXHRyZXR1cm4gdGhpcy5ib25kcy5nZXQoaWR4KS5wYXJpdHk7XHJcbn07XHJcblxyXG5DaXNUcmFucy5wcm90b3R5cGUuZ2V0U3Vic3RpdHVlbnRzID0gZnVuY3Rpb24gKGlkeCkge1xyXG5cdHJldHVybiB0aGlzLmJvbmRzLmdldChpZHgpLnN1YnN0aXR1ZW50cztcclxufTtcclxuXHJcbkNpc1RyYW5zLnByb3RvdHlwZS5zYW1lc2lkZSA9IGZ1bmN0aW9uIChiZWcsIGVuZCwgbmVpQmVnLCBuZWlFbmQpIHtcclxuXHR2YXIgZGlmZiA9IFZlYzIuZGlmZihiZWcsIGVuZCk7XHJcblx0dmFyIG5vcm0gPSBuZXcgVmVjMigtZGlmZi55LCBkaWZmLngpO1xyXG5cclxuXHRpZiAoIW5vcm0ubm9ybWFsaXplKCkpIHtcclxuXHRcdHJldHVybiAwO1xyXG5cdH1cclxuXHJcblx0dmFyIG5vcm1CZWcgPSBWZWMyLmRpZmYobmVpQmVnLCBiZWcpO1xyXG5cdHZhciBub3JtRW5kID0gVmVjMi5kaWZmKG5laUVuZCwgZW5kKTtcclxuXHJcblx0aWYgKCFub3JtQmVnLm5vcm1hbGl6ZSgpKSB7XHJcblx0XHRyZXR1cm4gMDtcclxuXHR9XHJcblx0aWYgKCFub3JtRW5kLm5vcm1hbGl6ZSgpKSB7XHJcblx0XHRyZXR1cm4gMDtcclxuXHR9XHJcblxyXG5cdHZhciBwcm9kQmVnID0gVmVjMi5kb3Qobm9ybUJlZywgbm9ybSk7XHJcblx0dmFyIHByb2RFbmQgPSBWZWMyLmRvdChub3JtRW5kLCBub3JtKTtcclxuXHJcblx0aWYgKE1hdGguYWJzKHByb2RCZWcpIDwgMC4wMDEgfHwgTWF0aC5hYnMocHJvZEVuZCkgPCAwLjAwMSkge1xyXG5cdFx0cmV0dXJuIDA7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gKHByb2RCZWcgKiBwcm9kRW5kID4gMCkgPyAxIDogLTE7XHJcbn07XHJcblxyXG5DaXNUcmFucy5wcm90b3R5cGUuX3NhbWVzaWRlID0gZnVuY3Rpb24gKGlCZWcsIGlFbmQsIGlOZWlCZWcsIGlOZWlFbmQpIHtcclxuXHRyZXR1cm4gdGhpcy5zYW1lc2lkZSh0aGlzLm1vbGVjdWxlLmF0b21zLmdldChpQmVnKS5wcCwgdGhpcy5tb2xlY3VsZS5hdG9tcy5nZXQoaUVuZCkucHAsXHJcblx0XHR0aGlzLm1vbGVjdWxlLmF0b21zLmdldChpTmVpQmVnKS5wcCwgdGhpcy5tb2xlY3VsZS5hdG9tcy5nZXQoaU5laUVuZCkucHApO1xyXG59O1xyXG5cclxuQ2lzVHJhbnMucHJvdG90eXBlLl9zb3J0U3Vic3RpdHVlbnRzID0gZnVuY3Rpb24gKHN1YnN0aXR1ZW50cykge1xyXG5cdHZhciBoMCA9IHRoaXMubW9sZWN1bGUuYXRvbXMuZ2V0KHN1YnN0aXR1ZW50c1swXSkucHVyZUh5ZHJvZ2VuKCk7XHJcblx0dmFyIGgxID0gc3Vic3RpdHVlbnRzWzFdIDwgMCB8fCB0aGlzLm1vbGVjdWxlLmF0b21zLmdldChzdWJzdGl0dWVudHNbMV0pLnB1cmVIeWRyb2dlbigpO1xyXG5cdHZhciBoMiA9IHRoaXMubW9sZWN1bGUuYXRvbXMuZ2V0KHN1YnN0aXR1ZW50c1syXSkucHVyZUh5ZHJvZ2VuKCk7XHJcblx0dmFyIGgzID0gc3Vic3RpdHVlbnRzWzNdIDwgMCB8fCB0aGlzLm1vbGVjdWxlLmF0b21zLmdldChzdWJzdGl0dWVudHNbM10pLnB1cmVIeWRyb2dlbigpO1xyXG5cclxuXHRpZiAoaDAgJiYgaDEpIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblx0aWYgKGgyICYmIGgzKSB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHRpZiAoaDEpIHtcclxuXHRcdHN1YnN0aXR1ZW50c1sxXSA9IC0xO1xyXG5cdH0gZWxzZSBpZiAoaDApIHtcclxuXHRcdHN1YnN0aXR1ZW50c1swXSA9IHN1YnN0aXR1ZW50c1sxXTtcclxuXHRcdHN1YnN0aXR1ZW50c1sxXSA9IC0xO1xyXG5cdH0gZWxzZSBpZiAoc3Vic3RpdHVlbnRzWzBdID4gc3Vic3RpdHVlbnRzWzFdKSB7XHJcblx0XHRzdWJzdGl0dWVudHMuc3dhcCgwLCAxKTtcclxuXHR9XHJcblxyXG5cdGlmIChoMykge1xyXG5cdFx0c3Vic3RpdHVlbnRzWzNdID0gLTE7XHJcblx0fSBlbHNlIGlmIChoMikge1xyXG5cdFx0c3Vic3RpdHVlbnRzWzJdID0gc3Vic3RpdHVlbnRzWzNdO1xyXG5cdFx0c3Vic3RpdHVlbnRzWzNdID0gLTE7XHJcblx0fSBlbHNlIGlmIChzdWJzdGl0dWVudHNbMl0gPiBzdWJzdGl0dWVudHNbM10pIHtcclxuXHRcdHN1YnN0aXR1ZW50cy5zd2FwKDIsIDMpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG5DaXNUcmFucy5wcm90b3R5cGUuaXNHZW9tU3RlcmVvQm9uZCA9IGZ1bmN0aW9uIChib25kSWR4LCBzdWJzdGl0dWVudHMpIHtcclxuXHQvLyBpdCBtdXN0IGJlIFtDLE4sU2ldPVtDLE4sU2ldIGJvbmRcclxuXHR2YXIgYm9uZCA9IHRoaXMubW9sZWN1bGUuYm9uZHMuZ2V0KGJvbmRJZHgpO1xyXG5cclxuXHRpZiAoYm9uZC50eXBlICE9IEJvbmQuUEFUVEVSTi5UWVBFLkRPVUJMRSkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0dmFyIGxhYmVsMSA9IHRoaXMubW9sZWN1bGUuYXRvbXMuZ2V0KGJvbmQuYmVnaW4pLmxhYmVsO1xyXG5cdHZhciBsYWJlbDIgPSB0aGlzLm1vbGVjdWxlLmF0b21zLmdldChib25kLmVuZCkubGFiZWw7XHJcblxyXG5cdGlmIChsYWJlbDEgIT0gJ0MnICYmIGxhYmVsMSAhPSAnTicgJiYgbGFiZWwxICE9ICdTaScgJiYgbGFiZWwxICE9ICdHZScpIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblx0aWYgKGxhYmVsMiAhPSAnQycgJiYgbGFiZWwyICE9ICdOJyAmJiBsYWJlbDIgIT0gJ1NpJyAmJiBsYWJlbDIgIT0gJ0dlJykge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0Ly8gdGhlIGF0b21zIHNob3VsZCBoYXZlIDEgb3IgMiBzaW5nbGUgYm9uZHNcclxuXHQvLyAoYXBhcnQgZnJvbSB0aGUgZG91YmxlIGJvbmQgdW5kZXIgY29uc2lkZXJhdGlvbilcclxuXHR2YXIgbmVpQmVnaW4gPSB0aGlzLmdldE5laWdoYm9ycy5jYWxsKHRoaXMuY29udGV4dCwgYm9uZC5iZWdpbik7XHJcblx0dmFyIG5ladCVbmQgPSB0aGlzLmdldE5laWdoYm9ycy5jYWxsKHRoaXMuY29udGV4dCwgYm9uZC5lbmQpO1xyXG5cclxuXHRpZiAoXHJcblx0bmVpQmVnaW4ubGVuZ3RoIDwgMiB8fCBuZWlCZWdpbi5sZW5ndGggPiAzIHx8XHJcblx0bmVp0JVuZC5sZW5ndGggPCAyIHx8IG5ladCVbmQubGVuZ3RoID4gM1xyXG5cdCkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0c3Vic3RpdHVlbnRzWzBdID0gLTE7XHJcblx0c3Vic3RpdHVlbnRzWzFdID0gLTE7XHJcblx0c3Vic3RpdHVlbnRzWzJdID0gLTE7XHJcblx0c3Vic3RpdHVlbnRzWzNdID0gLTE7XHJcblxyXG5cdHZhciBpO1xyXG5cdHZhciBuZWk7XHJcblxyXG5cdGZvciAoaSA9IDA7IGkgPCBuZWlCZWdpbi5sZW5ndGg7IGkrKykge1xyXG5cdFx0bmVpID0gbmVpQmVnaW5baV07XHJcblxyXG5cdFx0aWYgKG5laS5iaWQgPT0gYm9uZElkeCkge1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5tb2xlY3VsZS5ib25kcy5nZXQobmVpLmJpZCkudHlwZSAhPSBCb25kLlBBVFRFUk4uVFlQRS5TSU5HTEUpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzdWJzdGl0dWVudHNbMF0gPT0gLTEpIHtcclxuXHRcdFx0c3Vic3RpdHVlbnRzWzBdID0gbmVpLmFpZDtcclxuXHRcdH1lbHNlIHsgLy8gKHN1YnN0aXR1ZW50c1sxXSA9PSAtMSlcclxuXHRcdFx0c3Vic3RpdHVlbnRzWzFdID0gbmVpLmFpZDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZvciAoaSA9IDA7IGkgPCBuZWnQlW5kLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRuZWkgPSBuZWnQlW5kW2ldO1xyXG5cclxuXHRcdGlmIChuZWkuYmlkID09IGJvbmRJZHgpIHtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMubW9sZWN1bGUuYm9uZHMuZ2V0KG5laS5iaWQpLnR5cGUgIT0gQm9uZC5QQVRURVJOLlRZUEUuU0lOR0xFKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc3Vic3RpdHVlbnRzWzJdID09IC0xKSB7XHJcblx0XHRcdHN1YnN0aXR1ZW50c1syXSA9IG5laS5haWQ7XHJcblx0XHR9XHJcblx0XHRlbHNlIHsgLy8gKHN1YnN0aXR1ZW50c1szXSA9PSAtMSlcclxuXHRcdFx0c3Vic3RpdHVlbnRzWzNdID0gbmVpLmFpZDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGlmIChzdWJzdGl0dWVudHNbMV0gIT0gLTEgJiYgdGhpcy5fc2FtZXNpZGUoYm9uZC5iZWdpbiwgYm9uZC5lbmQsIHN1YnN0aXR1ZW50c1swXSwgc3Vic3RpdHVlbnRzWzFdKSAhPSAtMSkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHRpZiAoc3Vic3RpdHVlbnRzWzNdICE9IC0xICYmIHRoaXMuX3NhbWVzaWRlKGJvbmQuYmVnaW4sIGJvbmQuZW5kLCBzdWJzdGl0dWVudHNbMl0sIHN1YnN0aXR1ZW50c1szXSkgIT0gLTEpIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuQ2lzVHJhbnMucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKGV4Y2x1ZGVfYm9uZHMpIHtcclxuXHR0aGlzLm1vbGVjdWxlLmJvbmRzLmVhY2goZnVuY3Rpb24gKGJpZCwgYm9uZCkge1xyXG5cdFx0dmFyIGN0ID0gdGhpcy5ib25kcy5zZXQoYmlkLFxyXG5cdFx0e1xyXG5cdFx0XHRwYXJpdHk6IDAsXHJcblx0XHRcdHN1YnN0aXR1ZW50czogbmV3IEFycmF5KDQpXHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAoT2JqZWN0LmlzQXJyYXkoZXhjbHVkZV9ib25kcykgJiYgZXhjbHVkZV9ib25kc1tiaWRdKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0aWYgKCF0aGlzLmlzR2VvbVN0ZXJlb0JvbmQoYmlkLCBjdC5zdWJzdGl0dWVudHMpKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9zb3J0U3Vic3RpdHVlbnRzKGN0LnN1YnN0aXR1ZW50cykpXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR2YXIgc2lnbiA9IHRoaXMuX3NhbWVzaWRlKGJvbmQuYmVnaW4sIGJvbmQuZW5kLCBjdC5zdWJzdGl0dWVudHNbMF0sIGN0LnN1YnN0aXR1ZW50c1syXSk7XHJcblxyXG5cdFx0aWYgKHNpZ24gPT0gMSlcclxuXHRcdFx0Y3QucGFyaXR5ID0gQ2lzVHJhbnMuUEFSSVRZLkNJUztcclxuXHRcdGVsc2UgaWYgKHNpZ24gPT0gLTEpXHJcblx0XHRcdGN0LnBhcml0eSA9IENpc1RyYW5zLlBBUklUWS5UUkFOUztcclxuXHR9LCB0aGlzKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2lzVHJhbnM7XHJcbiIsInZhciBTZXQgPSByZXF1aXJlKCcuLi91dGlsL3NldCcpO1xyXG5cclxudmFyIERmcyA9IGZ1bmN0aW9uIChtb2wsIGF0b21fZGF0YSwgY29tcG9uZW50cywgblJlYWN0YW50cykge1xyXG5cdHRoaXMubW9sZWN1bGUgPSBtb2w7XHJcblx0dGhpcy5hdG9tX2RhdGEgPSBhdG9tX2RhdGE7XHJcblx0dGhpcy5jb21wb25lbnRzID0gY29tcG9uZW50cztcclxuXHR0aGlzLm5Db21wb25lbnRzSW5SZWFjdGFudHMgPSAtMTtcclxuXHR0aGlzLm5SZWFjdGFudHMgPSBuUmVhY3RhbnRzO1xyXG5cclxuXHR0aGlzLnZlcnRpY2VzID0gbmV3IEFycmF5KHRoaXMubW9sZWN1bGUuYXRvbXMuY291bnQoKSk7IC8vIE1pbmltdW0gc2l6ZVxyXG5cdHRoaXMubW9sZWN1bGUuYXRvbXMuZWFjaChmdW5jdGlvbiAoYWlkKVxyXG5cdHtcclxuXHRcdHRoaXMudmVydGljZXNbYWlkXSA9IG5ldyBEZnMuVmVydGV4RGVzYygpO1xyXG5cdH0sIHRoaXMpO1xyXG5cclxuXHR0aGlzLmVkZ2VzID0gbmV3IEFycmF5KHRoaXMubW9sZWN1bGUuYm9uZHMuY291bnQoKSk7IC8vIE1pbmltdW0gc2l6ZVxyXG5cdHRoaXMubW9sZWN1bGUuYm9uZHMuZWFjaChmdW5jdGlvbiAoYmlkKVxyXG5cdHtcclxuXHRcdHRoaXMuZWRnZXNbYmlkXSA9IG5ldyBEZnMuRWRnZURlc2MoKTtcclxuXHR9LCB0aGlzKTtcclxuXHJcblx0dGhpcy52X3NlcSA9IFtdO1xyXG59O1xyXG5cclxuRGZzLlZlcnRleERlc2MgPSBmdW5jdGlvbiAoKVxyXG57XHJcblx0dGhpcy5kZnNfc3RhdGUgPSAwOyAgICAgICAvLyAwIC0tIG5vdCBvbiBzdGFja1xyXG5cdC8vIDEgLS0gb24gc3RhY2tcclxuXHQvLyAyIC0tIHJlbW92ZWQgZnJvbSBzdGFja1xyXG5cdHRoaXMucGFyZW50X3ZlcnRleCA9IDA7ICAgLy8gcGFyZW50IHZlcnRleCBpbiBERlMgdHJlZVxyXG5cdHRoaXMucGFyZW50X2VkZ2UgPSAwOyAgICAgLy8gZWRnZSB0byBwYXJlbnQgdmVydGV4XHJcblx0dGhpcy5icmFuY2hlcyA9IDA7ICAgIC8vIGhvdyBtYW55IERGUyBicmFuY2hlcyBnbyBvdXQgZnJvbSB0aGlzIHZlcnRleH1cclxufTtcclxuXHJcbkRmcy5FZGdlRGVzYyA9IGZ1bmN0aW9uICgpXHJcbntcclxuXHR0aGlzLm9wZW5pbmdfY3ljbGVzID0gMDsgLy8gaG93IG1hbnkgY3ljbGVzIGFyZVxyXG5cdC8vIChpKSBzdGFydGluZyB3aXRoIHRoaXMgZWRnZVxyXG5cdC8vIGFuZCAoaWkpIGVuZGluZyBpbiB0aGlzIGVkZ2UncyBmaXJzdCB2ZXJ0ZXhcclxuXHR0aGlzLmNsb3NpbmdfY3ljbGUgPSAwOyAgLy8gMSBpZiB0aGlzIGVkZ2UgY2xvc2VzIGEgY3ljbGVcclxufTtcclxuXHJcbkRmcy5TZXFFbGVtID0gZnVuY3Rpb24gKHZfaWR4LCBwYXJfdmVydGV4LCBwYXJfZWRnZSlcclxue1xyXG5cdHRoaXMuaWR4ID0gdl9pZHg7ICAgICAgICAgICAgICAgIC8vIGluZGV4IG9mIHZlcnRleCBpbiBfZ3JhcGhcclxuXHR0aGlzLnBhcmVudF92ZXJ0ZXggPSBwYXJfdmVydGV4OyAvLyBwYXJlbnQgdmVydGV4IGluIERGUyB0cmVlXHJcblx0dGhpcy5wYXJlbnRfZWRnZSA9IHBhcl9lZGdlOyAgICAgLy8gZWRnZSB0byBwYXJlbnQgdmVydGV4XHJcbn07XHJcblxyXG5EZnMucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiAoKVxyXG57XHJcblx0dmFyIHZfc3RhY2sgPSBbXTtcclxuXHR2YXIgaSwgajtcclxuXHR2YXIgY2lkID0gMDtcclxuXHR2YXIgY29tcG9uZW50ID0gMDtcclxuXHJcblx0d2hpbGUgKHRydWUpXHJcblx0e1xyXG5cdFx0aWYgKHZfc3RhY2subGVuZ3RoIDwgMSlcclxuXHRcdHtcclxuXHRcdFx0dmFyIHNlbGVjdGVkID0gLTE7XHJcblxyXG5cdFx0XHR2YXIgZmluZEZ1bmMgPSBmdW5jdGlvbiAoYWlkKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0aWYgKHRoaXMudmVydGljZXNbYWlkXS5kZnNfc3RhdGUgPT0gMClcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHRzZWxlY3RlZCA9IGFpZDtcclxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHR3aGlsZSAoY2lkIDwgdGhpcy5jb21wb25lbnRzLmxlbmd0aCAmJiBzZWxlY3RlZCA9PSAtMSkge1xyXG5cdFx0XHRcdHNlbGVjdGVkID0gU2V0LmZpbmQodGhpcy5jb21wb25lbnRzW2NpZF0sIGZpbmRGdW5jLCB0aGlzKTtcclxuXHRcdFx0XHRpZiAoc2VsZWN0ZWQgPT09IG51bGwpIHtcclxuXHRcdFx0XHRcdHNlbGVjdGVkID0gLTE7XHJcblx0XHRcdFx0XHRjaWQrKztcclxuXHRcdFx0XHRcdGlmIChjaWQgPT0gdGhpcy5uUmVhY3RhbnRzKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMubkNvbXBvbmVudHNJblJlYWN0YW50cyA9IGNvbXBvbmVudDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHNlbGVjdGVkIDwgLTEpIHtcclxuXHRcdFx0XHR0aGlzLm1vbGVjdWxlLmF0b21zLmZpbmQoZmluZEZ1bmMsIHRoaXMpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChzZWxlY3RlZCA9PSAtMSlcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0dGhpcy52ZXJ0aWNlc1tzZWxlY3RlZF0ucGFyZW50X3ZlcnRleCA9IC0xO1xyXG5cdFx0XHR0aGlzLnZlcnRpY2VzW3NlbGVjdGVkXS5wYXJlbnRfZWRnZSA9IC0xO1xyXG5cdFx0XHR2X3N0YWNrLnB1c2goc2VsZWN0ZWQpO1xyXG5cdFx0XHRjb21wb25lbnQrKztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdl9pZHggPSB2X3N0YWNrLnBvcCgpO1xyXG5cdFx0dmFyIHBhcmVudF92ZXJ0ZXggPSB0aGlzLnZlcnRpY2VzW3ZfaWR4XS5wYXJlbnRfdmVydGV4O1xyXG5cclxuXHRcdHZhciBzZXFfZWxlbSA9IG5ldyBEZnMuU2VxRWxlbSh2X2lkeCwgcGFyZW50X3ZlcnRleCwgdGhpcy52ZXJ0aWNlc1t2X2lkeF0ucGFyZW50X2VkZ2UpO1xyXG5cdFx0dGhpcy52X3NlcS5wdXNoKHNlcV9lbGVtKTtcclxuXHJcblx0XHR0aGlzLnZlcnRpY2VzW3ZfaWR4XS5kZnNfc3RhdGUgPSAyO1xyXG5cclxuXHRcdHZhciBhdG9tX2QgPSB0aGlzLmF0b21fZGF0YVt2X2lkeF07XHJcblxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGF0b21fZC5uZWlnaGJvdXJzLmxlbmd0aDsgaSsrKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgbmVpX2lkeCA9IGF0b21fZC5uZWlnaGJvdXJzW2ldLmFpZDtcclxuXHRcdFx0dmFyIGVkZ2VfaWR4ID0gYXRvbV9kLm5laWdoYm91cnNbaV0uYmlkO1xyXG5cclxuXHRcdFx0aWYgKG5laV9pZHggPT0gcGFyZW50X3ZlcnRleClcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdGlmICh0aGlzLnZlcnRpY2VzW25laV9pZHhdLmRmc19zdGF0ZSA9PSAyKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dGhpcy5lZGdlc1tlZGdlX2lkeF0uY2xvc2luZ19jeWNsZSA9IDE7XHJcblxyXG5cdFx0XHRcdGogPSB2X2lkeDtcclxuXHJcblx0XHRcdFx0d2hpbGUgKGogIT0gLTEpXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0aWYgKHRoaXMudmVydGljZXNbal0ucGFyZW50X3ZlcnRleCA9PSBuZWlfaWR4KVxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGogPSB0aGlzLnZlcnRpY2VzW2pdLnBhcmVudF92ZXJ0ZXg7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoaiA9PSAtMSlcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignY3ljbGUgdW53aW5kIGVycm9yJyk7XHJcblxyXG5cdFx0XHRcdHRoaXMuZWRnZXNbdGhpcy52ZXJ0aWNlc1tqXS5wYXJlbnRfZWRnZV0ub3BlbmluZ19jeWNsZXMrKztcclxuXHRcdFx0XHR0aGlzLnZlcnRpY2VzW3ZfaWR4XS5icmFuY2hlcysrO1xyXG5cclxuXHRcdFx0XHRzZXFfZWxlbSA9IG5ldyBEZnMuU2VxRWxlbShuZWlfaWR4LCB2X2lkeCwgZWRnZV9pZHgpO1xyXG5cdFx0XHRcdHRoaXMudl9zZXEucHVzaChzZXFfZWxlbSk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0aWYgKHRoaXMudmVydGljZXNbbmVpX2lkeF0uZGZzX3N0YXRlID09IDEpXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0aiA9IHZfc3RhY2suaW5kZXhPZihuZWlfaWR4KTtcclxuXHJcblx0XHRcdFx0XHRpZiAoaiA9PSAtMSlcclxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdpbnRlcm5hbDogcmVtb3ZpbmcgdmVydGV4IGZyb20gc3RhY2snKTtcclxuXHJcblx0XHRcdFx0XHR2X3N0YWNrLnNwbGljZShqLCAxKTtcclxuXHJcblx0XHRcdFx0XHR2YXIgcGFyZW50ID0gdGhpcy52ZXJ0aWNlc1tuZWlfaWR4XS5wYXJlbnRfdmVydGV4O1xyXG5cclxuXHRcdFx0XHRcdGlmIChwYXJlbnQgPj0gMClcclxuXHRcdFx0XHRcdFx0dGhpcy52ZXJ0aWNlc1twYXJlbnRdLmJyYW5jaGVzLS07XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLnZlcnRpY2VzW3ZfaWR4XS5icmFuY2hlcysrO1xyXG5cdFx0XHRcdHRoaXMudmVydGljZXNbbmVpX2lkeF0ucGFyZW50X3ZlcnRleCA9IHZfaWR4O1xyXG5cdFx0XHRcdHRoaXMudmVydGljZXNbbmVpX2lkeF0ucGFyZW50X2VkZ2UgPSBlZGdlX2lkeDtcclxuXHRcdFx0XHR0aGlzLnZlcnRpY2VzW25laV9pZHhdLmRmc19zdGF0ZSA9IDE7XHJcblx0XHRcdFx0dl9zdGFjay5wdXNoKG5laV9pZHgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuRGZzLnByb3RvdHlwZS5lZGdlQ2xvc2luZ0N5Y2xlID0gZnVuY3Rpb24gKGVfaWR4KVxyXG57XHJcblx0cmV0dXJuIHRoaXMuZWRnZXNbZV9pZHhdLmNsb3NpbmdfY3ljbGUgIT0gMDtcclxufTtcclxuXHJcbkRmcy5wcm90b3R5cGUubnVtQnJhbmNoZXMgPSBmdW5jdGlvbiAodl9pZHgpXHJcbntcclxuXHRyZXR1cm4gdGhpcy52ZXJ0aWNlc1t2X2lkeF0uYnJhbmNoZXM7XHJcbn07XHJcblxyXG5EZnMucHJvdG90eXBlLm51bU9wZW5pbmdDeWNsZXMgPSBmdW5jdGlvbiAoZV9pZHgpXHJcbntcclxuXHRyZXR1cm4gdGhpcy5lZGdlc1tlX2lkeF0ub3BlbmluZ19jeWNsZXM7XHJcbn07XHJcblxyXG5EZnMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKClcclxue1xyXG5cdHZhciBzdHIgPSAnJztcclxuXHR0aGlzLnZfc2VxLmVhY2goZnVuY3Rpb24gKHNlcV9lbGVtKSB7c3RyICs9IHNlcV9lbGVtLmlkeCArICcgLT4gJzt9KTtcclxuXHRzdHIgKz0gJyonO1xyXG5cdHJldHVybiBzdHI7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERmcztcclxuIiwidmFyIE1hcCA9IHJlcXVpcmUoJy4uL3V0aWwvbWFwJyk7XHJcblxyXG5mdW5jdGlvbiBlbChsYWJlbCwgcGVyaW9kLCBncm91cCwgcHV0SHlkcm9nZW5PblRoZUxlZnQsIGNvbG9yKSB7XHJcblx0cmV0dXJuIHtcclxuXHRcdGxhYmVsOiBsYWJlbCxcclxuXHRcdHBlcmlvZDogcGVyaW9kLFxyXG5cdFx0Z3JvdXA6IGdyb3VwLFxyXG5cdFx0cHV0SHlkcm9nZW5PblRoZUxlZnQ6IHB1dEh5ZHJvZ2VuT25UaGVMZWZ0LFxyXG5cdFx0Y29sb3I6IGNvbG9yIHx8ICcjMDAwMDAwJ1xyXG5cdH07XHJcbn07XHJcblxyXG52YXIgZWxlbWVudCA9IG5ldyBNYXAoe1xyXG5cdDE6IGVsKCAnSCcsIDEsIDEsIGZhbHNlLCAnIzAwMDAwMCcpLFxyXG5cdDI6IGVsKCdIZScsIDEsIDgsIGZhbHNlLCAnI2Q5ZmZmZicpLFxyXG5cdDM6IGVsKCdMaScsIDIsIDEsIGZhbHNlLCAnI2NjODBmZicpLFxyXG5cdDQ6IGVsKCdCZScsIDIsIDIsIGZhbHNlLCAnI2MyZmYwMCcpLFxyXG5cdDU6IGVsKCAnQicsIDIsIDMsIGZhbHNlLCAnI2ZmYjViNScpLFxyXG5cdDY6IGVsKCAnQycsIDIsIDQsIGZhbHNlLCAnIzAwMDAwMCcpLFxyXG5cdDc6IGVsKCAnTicsIDIsIDUsIGZhbHNlLCAnIzMwNGZmNycpLFxyXG5cdDg6IGVsKCAnTycsIDIsIDYsIHRydWUsICcjZmYwZDBkJyksXHJcblx0OTogZWwoICdGJywgMiwgNywgdHJ1ZSwgJyM4ZmUwNGYnKSxcclxuXHQxMDogZWwoJ05lJywgMiwgOCwgZmFsc2UsICcjYjNlM2Y1JyksXHJcblx0MTE6IGVsKCdOYScsIDMsIDEsIGZhbHNlLCAnI2FiNWNmMicpLFxyXG5cdDEyOiBlbCgnTWcnLCAzLCAyLCBmYWxzZSwgJyM4YWZmMDAnKSxcclxuXHQxMzogZWwoJ0FsJywgMywgMywgZmFsc2UsICcjYmZhNmE2JyksXHJcblx0MTQ6IGVsKCdTaScsIDMsIDQsIGZhbHNlLCAnI2YwYzdhMScpLFxyXG5cdDE1OiBlbCggJ1AnLCAzLCA1LCBmYWxzZSwgJyNmZjgwMDAnKSxcclxuXHQxNjogZWwoICdTJywgMywgNiwgdHJ1ZSwgJyNkOWE2MWEnKSxcclxuXHQxNzogZWwoJ0NsJywgMywgNywgdHJ1ZSwgJyMxZmQwMWYnKSxcclxuXHQxODogZWwoJ0FyJywgMywgOCwgZmFsc2UsICcjODBkMWUzJyksXHJcblx0MTk6IGVsKCAnSycsIDQsIDEsIGZhbHNlLCAnIzhmNDBkNCcpLFxyXG5cdDIwOiBlbCgnQ2EnLCA0LCAyLCBmYWxzZSwgJyMzZGZmMDAnKSxcclxuXHQyMTogZWwoJ1NjJywgNCwgMywgZmFsc2UsICcjZTZlNmU2JyksXHJcblx0MjI6IGVsKCdUaScsIDQsIDQsIGZhbHNlLCAnI2JmYzJjNycpLFxyXG5cdDIzOiBlbCggJ1YnLCA0LCA1LCBmYWxzZSwgJyNhNmE2YWInKSxcclxuXHQyNDogZWwoJ0NyJywgNCwgNiwgZmFsc2UsICcjOGE5OWM3JyksXHJcblx0MjU6IGVsKCdNbicsIDQsIDcsIGZhbHNlLCAnIzljN2FjNycpLFxyXG5cdDI2OiBlbCgnRmUnLCA0LCA4LCBmYWxzZSwgJyNlMDY2MzMnKSxcclxuXHQyNzogZWwoJ0NvJywgNCwgOCwgZmFsc2UsICcjZjA4ZmExJyksXHJcblx0Mjg6IGVsKCdOaScsIDQsIDgsIGZhbHNlLCAnIzRmZDE0ZicpLFxyXG5cdDI5OiBlbCgnQ3UnLCA0LCAxLCBmYWxzZSwgJyNjNzgwMzMnKSxcclxuXHQzMDogZWwoJ1puJywgNCwgMiwgZmFsc2UsICcjN2Q4MGIwJyksXHJcblx0MzE6IGVsKCdHYScsIDQsIDMsIGZhbHNlLCAnI2MyOGY4ZicpLFxyXG5cdDMyOiBlbCgnR2UnLCA0LCA0LCBmYWxzZSwgJyM2NjhmOGYnKSxcclxuXHQzMzogZWwoJ0FzJywgNCwgNSwgZmFsc2UsICcjYmQ4MGUzJyksXHJcblx0MzQ6IGVsKCdTZScsIDQsIDYsIHRydWUsICcjZmZhMTAwJyksXHJcblx0MzU6IGVsKCdCcicsIDQsIDcsIHRydWUsICcjYTYyOTI5JyksXHJcblx0MzY6IGVsKCdLcicsIDQsIDgsIGZhbHNlLCAnIzVjYjhkMScpLFxyXG5cdDM3OiBlbCgnUmInLCA1LCAxLCBmYWxzZSwgJyM3MDJlYjAnKSxcclxuXHQzODogZWwoJ1NyJywgNSwgMiwgZmFsc2UsICcjMDBmZjAwJyksXHJcblx0Mzk6IGVsKCAnWScsIDUsIDMsIGZhbHNlLCAnIzk0ZmZmZicpLFxyXG5cdDQwOiBlbCgnWnInLCA1LCA0LCBmYWxzZSwgJyM5NGUwZTAnKSxcclxuXHQ0MTogZWwoJ05iJywgNSwgNSwgZmFsc2UsICcjNzNjMmM5JyksXHJcblx0NDI6IGVsKCdNbycsIDUsIDYsIGZhbHNlLCAnIzU0YjViNScpLFxyXG5cdDQzOiBlbCgnVGMnLCA1LCA3LCBmYWxzZSwgJyMzYjllOWUnKSxcclxuXHQ0NDogZWwoJ1J1JywgNSwgOCwgZmFsc2UsICcjMjQ4ZjhmJyksXHJcblx0NDU6IGVsKCdSaCcsIDUsIDgsIGZhbHNlLCAnIzBhN2Q4YycpLFxyXG5cdDQ2OiBlbCgnUGQnLCA1LCA4LCBmYWxzZSwgJyMwMDY5ODUnKSxcclxuXHQ0NzogZWwoJ0FnJywgNSwgMSwgZmFsc2UsICcjYmZiZmJmJyksXHJcblx0NDg6IGVsKCdDZCcsIDUsIDIsIGZhbHNlLCAnI2ZmZDk4ZicpLFxyXG5cdDQ5OiBlbCgnSW4nLCA1LCAzLCBmYWxzZSwgJyNhNjc1NzMnKSxcclxuXHQ1MDogZWwoJ1NuJywgNSwgNCwgZmFsc2UsICcjNjY4MDgwJyksXHJcblx0NTE6IGVsKCdTYicsIDUsIDUsIGZhbHNlLCAnIzllNjNiNScpLFxyXG5cdDUyOiBlbCgnVGUnLCA1LCA2LCBmYWxzZSwgJyNkNDdhMDAnKSxcclxuXHQ1MzogZWwoICdJJywgNSwgNywgdHJ1ZSwgJyM5NDAwOTQnKSxcclxuXHQ1NDogZWwoJ1hlJywgNSwgOCwgZmFsc2UsICcjNDI5ZWIwJyksXHJcblx0NTU6IGVsKCdDcycsIDYsIDEsIGZhbHNlLCAnIzU3MTc4ZicpLFxyXG5cdDU2OiBlbCgnQmEnLCA2LCAyLCBmYWxzZSwgJyMwMGM5MDAnKSxcclxuXHQ1NzogZWwoJ0xhJywgNiwgMywgZmFsc2UsICcjNzBkNGZmJyksXHJcblx0NTg6IGVsKCdDZScsIDYsIDMsIGZhbHNlLCAnI2ZmZmZjNycpLFxyXG5cdDU5OiBlbCgnUHInLCA2LCAzLCBmYWxzZSwgJyNkOWZmYzcnKSxcclxuXHQ2MDogZWwoJ05kJywgNiwgMywgZmFsc2UsICcjYzdmZmM3JyksXHJcblx0NjE6IGVsKCdQbScsIDYsIDMsIGZhbHNlLCAnI2EzZmZjNycpLFxyXG5cdDYyOiBlbCgnU20nLCA2LCAzLCBmYWxzZSwgJyM4ZmZmYzcnKSxcclxuXHQ2MzogZWwoJ0V1JywgNiwgMywgZmFsc2UsICcjNjFmZmM3JyksXHJcblx0NjQ6IGVsKCdHZCcsIDYsIDMsIGZhbHNlLCAnIzQ1ZmZjNycpLFxyXG5cdDY1OiBlbCgnVGInLCA2LCAzLCBmYWxzZSwgJyMzMGZmYzcnKSxcclxuXHQ2NjogZWwoJ0R5JywgNiwgMywgZmFsc2UsICcjMWZmZmM3JyksXHJcblx0Njc6IGVsKCdIbycsIDYsIDMsIGZhbHNlLCAnIzAwZmY5YycpLFxyXG5cdDY4OiBlbCgnRXInLCA2LCAzLCBmYWxzZSwgJyMwMGU2NzUnKSxcclxuXHQ2OTogZWwoJ1RtJywgNiwgMywgZmFsc2UsICcjMDBkNDUyJyksXHJcblx0NzA6IGVsKCdZYicsIDYsIDMsIGZhbHNlLCAnIzAwYmYzOCcpLFxyXG5cdDcxOiBlbCgnTHUnLCA2LCAzLCBmYWxzZSwgJyMwMGFiMjQnKSxcclxuXHQ3MjogZWwoJ0hmJywgNiwgNCwgZmFsc2UsICcjNGRjMmZmJyksXHJcblx0NzM6IGVsKCdUYScsIDYsIDUsIGZhbHNlLCAnIzRkYTZmZicpLFxyXG5cdDc0OiBlbCggJ1cnLCA2LCA2LCBmYWxzZSwgJyMyMTk0ZDYnKSxcclxuXHQ3NTogZWwoJ1JlJywgNiwgNywgZmFsc2UsICcjMjY3ZGFiJyksXHJcblx0NzY6IGVsKCdPcycsIDYsIDgsIGZhbHNlLCAnIzI2NjY5NicpLFxyXG5cdDc3OiBlbCgnSXInLCA2LCA4LCBmYWxzZSwgJyMxNzU0ODcnKSxcclxuXHQ3ODogZWwoJ1B0JywgNiwgOCwgZmFsc2UsICcjZDFkMWUwJyksXHJcblx0Nzk6IGVsKCdBdScsIDYsIDEsIGZhbHNlLCAnI2ZmZDEyNCcpLFxyXG5cdDgwOiBlbCgnSGcnLCA2LCAyLCBmYWxzZSwgJyNiOGI4ZDEnKSxcclxuXHQ4MTogZWwoJ1RsJywgNiwgMywgZmFsc2UsICcjYTY1NDRkJyksXHJcblx0ODI6IGVsKCdQYicsIDYsIDQsIGZhbHNlLCAnIzU3NTk2MScpLFxyXG5cdDgzOiBlbCgnQmknLCA2LCA1LCBmYWxzZSwgJyM5ZTRmYjUnKSxcclxuXHQ4NDogZWwoJ1BvJywgNiwgNiwgZmFsc2UsICcjYWI1YzAwJyksXHJcblx0ODU6IGVsKCdBdCcsIDYsIDcsIGZhbHNlLCAnIzc1NGY0NScpLFxyXG5cdDg2OiBlbCgnUm4nLCA2LCA4LCBmYWxzZSwgJyM0MjgyOTYnKSxcclxuXHQ4NzogZWwoJ0ZyJywgNywgMSwgZmFsc2UsICcjNDIwMDY2JyksXHJcblx0ODg6IGVsKCdSYScsIDcsIDIsIGZhbHNlLCAnIzAwN2QwMCcpLFxyXG5cdDg5OiBlbCgnQWMnLCA3LCAzLCBmYWxzZSwgJyM3MGFiZmEnKSxcclxuXHQ5MDogZWwoJ1RoJywgNywgMywgZmFsc2UsICcjMDBiYWZmJyksXHJcblx0OTE6IGVsKCdQYScsIDcsIDMsIGZhbHNlLCAnIzAwYTFmZicpLFxyXG5cdDkyOiBlbCggJ1UnLCA3LCAzLCBmYWxzZSwgJyMwMDhmZmYnKSxcclxuXHQ5MzogZWwoJ05wJywgNywgMywgZmFsc2UsICcjMDA4MGZmJyksXHJcblx0OTQ6IGVsKCdQdScsIDcsIDMsIGZhbHNlLCAnIzAwNmJmZicpLFxyXG5cdDk1OiBlbCgnQW0nLCA3LCAzLCBmYWxzZSwgJyM1NDVjZjInKSxcclxuXHQ5NjogZWwoJ0NtJywgNywgMywgZmFsc2UsICcjNzg1Y2UzJyksXHJcblx0OTc6IGVsKCdCaycsIDcsIDMsIGZhbHNlLCAnIzhhNGZlMycpLFxyXG5cdDk4OiBlbCgnQ2YnLCA3LCAzLCBmYWxzZSwgJyNhMTM2ZDQnKSxcclxuXHQ5OTogZWwoJ0VzJywgNywgMywgZmFsc2UsICcjYjMxZmQ0JyksXHJcblx0Ly8gVE9ETyBuZWVkIHRvIGZpeCBjb2xvcnMgZm9yIHRoZSBlbGVtZW50cyBiZWxvd1xyXG5cdDEwMDogZWwoJ0ZtJywgNywgMywgZmFsc2UsICcjMDAwMDAwJyksXHJcblx0MTAxOiBlbCgnTWQnLCA3LCAzLCBmYWxzZSwgJyMwMDAwMDAnKSxcclxuXHQxMDI6IGVsKCdObycsIDcsIDMsIGZhbHNlLCAnIzAwMDAwMCcpLFxyXG5cdDEwMzogZWwoJ0xyJywgNywgMywgZmFsc2UsICcjMDAwMDAwJyksXHJcblx0MTA0OiBlbCgnUmYnLCA3LCA0LCBmYWxzZSwgJyM0ZGMyZmYnKSxcclxuXHQxMDU6IGVsKCdEYicsIDcsIDUsIGZhbHNlLCAnIzRkYTZmZicpLFxyXG5cdDEwNjogZWwoJ1NnJywgNywgNiwgZmFsc2UsICcjMjE5NGQ2JyksXHJcblx0MTA3OiBlbCgnQmgnLCA3LCA3LCBmYWxzZSwgJyMyNjdkYWInKSxcclxuXHQxMDg6IGVsKCdIcycsIDcsIDgsIGZhbHNlLCAnIzI2NjY5NicpLFxyXG5cdDEwOTogZWwoJ010JywgNywgOCwgZmFsc2UsICcjMTc1NDg3JyksXHJcblx0MTEwOiBlbCgnRHMnLCA3LCA4LCBmYWxzZSwgJyNkMWQxZTAnKSxcclxuXHQxMTE6IGVsKCdSZycsIDcsIDEsIGZhbHNlLCAnI2ZmZDEyNCcpLFxyXG5cdDExMjogZWwoJ0NuJywgNywgMiwgZmFsc2UsICcjYjhiOGQxJyksXHJcblx0MTEzOiBlbCgnVXV0JywgNywgMywgZmFsc2UpLFxyXG5cdDExNDogZWwoJ0ZsJywgNywgNCwgZmFsc2UpLFxyXG5cdDExNTogZWwoJ1V1cCcsIDcsIDUsIGZhbHNlKSxcclxuXHQxMTY6IGVsKCdMdicsIDcsIDYsIGZhbHNlKSxcclxuXHQxMTc6IGVsKCdVdXMnLCA3LCA3LCBmYWxzZSksXHJcblx0MTE4OiBlbCgnVXVvJywgNywgOCwgZmFsc2UpXHJcbn0pO1xyXG5cclxudmFyIGxhYmVsTWFwID0gbnVsbDtcclxuZWxlbWVudC5nZXRFbGVtZW50QnlMYWJlbCA9IGZ1bmN0aW9uIChsYWJlbCkge1xyXG5cdGlmICghbGFiZWxNYXApIHtcclxuXHRcdGxhYmVsTWFwID0ge307XHJcblx0XHRlbGVtZW50LmVhY2goZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuXHRcdFx0bGFiZWxNYXBbdmFsdWUubGFiZWxdID0ga2V5IC0gMDtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHRyZXR1cm4gbGFiZWxNYXBbbGFiZWxdIHx8IG51bGw7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGVsZW1lbnQ7XHJcbiIsInZhciBNYXAgPSByZXF1aXJlKCcuLi91dGlsL21hcCcpO1xyXG52YXIgU2V0ID0gcmVxdWlyZSgnLi4vdXRpbC9zZXQnKTtcclxudmFyIFZlYzIgPSByZXF1aXJlKCcuLi91dGlsL3ZlYzInKTtcclxudmFyIGVsZW1lbnQgPSByZXF1aXJlKCcuL2VsZW1lbnQnKTtcclxudmFyIFN0cnVjdCA9IHJlcXVpcmUoJy4vc3RydWN0Jyk7XHJcbnZhciBTR3JvdXAgPSByZXF1aXJlKCcuL3Nncm91cCcpO1xyXG52YXIgQXRvbSA9IHJlcXVpcmUoJy4vYXRvbScpO1xyXG52YXIgQm9uZCA9IHJlcXVpcmUoJy4vYm9uZCcpO1xyXG5cclxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XHJcblxyXG52YXIgRlJBR01FTlQgPSB7XHJcbiAgICBOT05FOiAwLFxyXG4gICAgUkVBQ1RBTlQ6IDEsXHJcbiAgICBQUk9EVUNUOiAyLFxyXG4gICAgQUdFTlQ6IDNcclxufTtcclxuXHJcbnZhciBNb2xmaWxlID0gZnVuY3Rpb24gKHYzMDAwKSB7XHJcbiAgICAvKiByZWFkZXIgKi9cclxuICAgIC8qIHNhdmVyICovXHJcbiAgICB0aGlzLm1vbGVjdWxlID0gbnVsbDtcclxuICAgIHRoaXMubW9sZmlsZSA9IG51bGw7XHJcbiAgICB0aGlzLnYzMDAwID0gdjMwMDAgfHwgZmFsc2U7XHJcbn07XHJcblxyXG5Nb2xmaWxlLmxvYWRSR3JvdXBGcmFnbWVudHMgPSB0cnVlOyAvLyBUT0RPOiBzZXQgdG8gbG9hZCB0aGUgZnJhZ21lbnRzXHJcblxyXG52YXIgcGFyc2VEZWNpbWFsSW50ID0gZnVuY3Rpb24gKHN0cilcclxue1xyXG4gICAgLyogcmVhZGVyICovXHJcblx0dmFyIHZhbCA9IHBhcnNlSW50KHN0ciwgMTApO1xyXG5cclxuXHRyZXR1cm4gaXNOYU4odmFsKSA/IDAgOiB2YWw7XHJcbn07XHJcblxyXG52YXIgcGFydGl0aW9uTGluZSA9IGZ1bmN0aW9uICgvKnN0cmluZyovIHN0ciwgLyphcnJheSBvZiBpbnQqLyBwYXJ0cywgLypib29sKi8gd2l0aHNwYWNlKVxyXG57XHJcbiAgICAvKiByZWFkZXIgKi9cclxuXHR2YXIgcmVzID0gW107XHJcblx0Zm9yICh2YXIgaSA9IDAsIHNoaWZ0ID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKVxyXG5cdHtcclxuXHRcdHJlcy5wdXNoKHN0ci5zbGljZShzaGlmdCwgc2hpZnQgKyBwYXJ0c1tpXSkpO1xyXG5cdFx0aWYgKHdpdGhzcGFjZSlcclxuXHRcdFx0c2hpZnQrKztcclxuXHRcdHNoaWZ0ICs9IHBhcnRzW2ldO1xyXG5cdH1cclxuXHRyZXR1cm4gcmVzO1xyXG59O1xyXG5cclxudmFyIHBhcnRpdGlvbkxpbmVGaXhlZCA9IGZ1bmN0aW9uICgvKnN0cmluZyovIHN0ciwgLyppbnQqLyBpdGVtTGVuZ3RoLCAvKmJvb2wqLyB3aXRoc3BhY2UpXHJcbntcclxuICAgIC8qIHJlYWRlciAqL1xyXG5cdHZhciByZXMgPSBbXTtcclxuXHRmb3IgKHZhciBzaGlmdCA9IDA7IHNoaWZ0IDwgc3RyLmxlbmd0aDsgc2hpZnQgKz0gaXRlbUxlbmd0aClcclxuXHR7XHJcblx0XHRyZXMucHVzaChzdHIuc2xpY2Uoc2hpZnQsIHNoaWZ0ICsgaXRlbUxlbmd0aCkpO1xyXG5cdFx0aWYgKHdpdGhzcGFjZSlcclxuXHRcdFx0c2hpZnQrKztcclxuXHR9XHJcblx0cmV0dXJuIHJlcztcclxufTtcclxuXHJcbk1vbGZpbGUucHJvdG90eXBlLnBhcnNlQ1RGaWxlID0gZnVuY3Rpb24gKG1vbGZpbGUpIHtcclxuXHR2YXIgbW9sZmlsZUxpbmVzID0gQXJyYXkuaXNBcnJheShtb2xmaWxlKSA/IG1vbGZpbGUgOiB1dGlsLnNwbGl0TmV3bGluZXMobW9sZmlsZSk7XHJcblx0dmFyIHJldCA9IG51bGw7XHJcblx0aWYgKG1vbGZpbGVMaW5lc1swXS5zZWFyY2goJ1xcXFwkUlhOJykgPT0gMClcclxuXHRcdHJldCA9IHBhcnNlUnhuKG1vbGZpbGVMaW5lcyk7XHJcblx0ZWxzZVxyXG5cdFx0cmV0ID0gcGFyc2VNb2wobW9sZmlsZUxpbmVzKTtcclxuXHRyZXQuaW5pdEhhbGZCb25kcygpO1xyXG5cdHJldC5pbml0TmVpZ2hib3JzKCk7XHJcblx0cmV0Lm1hcmtGcmFnbWVudHMoKTtcclxuXHRyZXR1cm4gcmV0O1xyXG59O1xyXG5cclxudmFyIGZtdEluZm8gPSB7XHJcblx0Ym9uZFR5cGVNYXA6IHtcclxuXHRcdDE6IEJvbmQuUEFUVEVSTi5UWVBFLlNJTkdMRSxcclxuXHRcdDI6IEJvbmQuUEFUVEVSTi5UWVBFLkRPVUJMRSxcclxuXHRcdDM6IEJvbmQuUEFUVEVSTi5UWVBFLlRSSVBMRSxcclxuXHRcdDQ6IEJvbmQuUEFUVEVSTi5UWVBFLkFST01BVElDLFxyXG5cdFx0NTogQm9uZC5QQVRURVJOLlRZUEUuU0lOR0xFX09SX0RPVUJMRSxcclxuXHRcdDY6IEJvbmQuUEFUVEVSTi5UWVBFLlNJTkdMRV9PUl9BUk9NQVRJQyxcclxuXHRcdDc6IEJvbmQuUEFUVEVSTi5UWVBFLkRPVUJMRV9PUl9BUk9NQVRJQyxcclxuXHRcdDg6IEJvbmQuUEFUVEVSTi5UWVBFLkFOWVxyXG5cdH0sXHJcblx0Ym9uZFN0ZXJlb01hcDoge1xyXG5cdFx0MDogQm9uZC5QQVRURVJOLlNURVJFTy5OT05FLFxyXG5cdFx0MTogQm9uZC5QQVRURVJOLlNURVJFTy5VUCxcclxuXHRcdDQ6IEJvbmQuUEFUVEVSTi5TVEVSRU8uRUlUSEVSLFxyXG5cdFx0NjogQm9uZC5QQVRURVJOLlNURVJFTy5ET1dOLFxyXG5cdFx0MzogQm9uZC5QQVRURVJOLlNURVJFTy5DSVNfVFJBTlNcclxuXHR9LFxyXG5cdHYzMGJvbmRTdGVyZW9NYXA6IHtcclxuXHRcdDA6IEJvbmQuUEFUVEVSTi5TVEVSRU8uTk9ORSxcclxuXHRcdDE6IEJvbmQuUEFUVEVSTi5TVEVSRU8uVVAsXHJcblx0XHQyOiBCb25kLlBBVFRFUk4uU1RFUkVPLkVJVEhFUixcclxuXHRcdDM6IEJvbmQuUEFUVEVSTi5TVEVSRU8uRE9XTlxyXG5cdH0sXHJcblx0Ym9uZFRvcG9sb2d5TWFwOiB7XHJcblx0XHQwOiBCb25kLlBBVFRFUk4uVE9QT0xPR1kuRUlUSEVSLFxyXG5cdFx0MTogQm9uZC5QQVRURVJOLlRPUE9MT0dZLlJJTkcsXHJcblx0XHQyOiBCb25kLlBBVFRFUk4uVE9QT0xPR1kuQ0hBSU5cclxuXHR9LFxyXG5cdGNvdW50c0xpbmVQYXJ0aXRpb246IFszLDMsMywzLDMsMywzLDMsMywzLDMsNl0sXHJcblx0YXRvbUxpbmVQYXJ0aXRpb246IFsxMCwxMCwxMCwxLDMsMiwzLDMsMywzLDMsMywzLDMsMywzLDNdLFxyXG5cdGJvbmRMaW5lUGFydGl0aW9uOiBbMywzLDMsMywzLDMsM10sXHJcblx0YXRvbUxpc3RIZWFkZXJQYXJ0aXRpb246IFszLDEsMSw0LDEsMV0sXHJcblx0YXRvbUxpc3RIZWFkZXJMZW5ndGg6IDExLCAvLyA9IGF0b21MaXN0SGVhZGVyUGFydGl0aW9uLnJlZHVjZShmdW5jdGlvbihhLGIpIHsgcmV0dXJuIGEgKyBiOyB9LCAwKVxyXG5cdGF0b21MaXN0SGVhZGVySXRlbUxlbmd0aDogNCxcclxuXHRjaGFyZ2VNYXA6IFswLCArMywgKzIsICsxLCAwLCAtMSwgLTIsIC0zXSxcclxuXHR2YWxlbmNlTWFwOiBbdW5kZWZpbmVkLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDBdLFxyXG5cdGltcGxpY2l0SHlkcm9nZW5NYXA6IFt1bmRlZmluZWQsIDAsIDEsIDIsIDMsIDRdLFxyXG5cdHYzMGF0b21Qcm9wTWFwOiB7XHJcblx0XHQnQ0hHJzonY2hhcmdlJyxcclxuXHRcdCdSQUQnOidyYWRpY2FsJyxcclxuXHRcdCdNQVNTJzonaXNvdG9wZScsXHJcblx0XHQnVkFMJzonZXhwbGljaXRWYWxlbmNlJyxcclxuXHRcdCdIQ09VTlQnOidoQ291bnQnLFxyXG5cdFx0J0lOVlJFVCc6J2ludlJldCcsXHJcblx0XHQnU1VCU1QnOidzdWJzdGl0dXRpb25Db3VudCcsXHJcblx0XHQnVU5TQVQnOid1bnNhdHVyYXRlZEF0b20nLFxyXG5cdFx0J1JCQ05UJzoncmluZ0JvbmRDb3VudCdcclxuXHR9LFxyXG5cdHJ4bkl0ZW1zUGFydGl0aW9uOiBbMywzLDNdXHJcbn07XHJcblxyXG52YXIgcGFyc2VBdG9tTGluZSA9IGZ1bmN0aW9uIChhdG9tTGluZSlcclxue1xyXG4gICAgLyogcmVhZGVyICovXHJcblx0dmFyIGF0b21TcGxpdCA9IHBhcnRpdGlvbkxpbmUoYXRvbUxpbmUsIGZtdEluZm8uYXRvbUxpbmVQYXJ0aXRpb24pO1xyXG5cdHZhciBwYXJhbXMgPVxyXG5cdHtcclxuXHRcdC8vIGdlbmVyaWNcclxuXHRcdHBwOiBuZXcgVmVjMihwYXJzZUZsb2F0KGF0b21TcGxpdFswXSksIC1wYXJzZUZsb2F0KGF0b21TcGxpdFsxXSkpLFxyXG5cdFx0bGFiZWw6IGF0b21TcGxpdFs0XS5zdHJpcCgpLFxyXG5cdFx0ZXhwbGljaXRWYWxlbmNlOiBmbXRJbmZvLnZhbGVuY2VNYXBbcGFyc2VEZWNpbWFsSW50KGF0b21TcGxpdFsxMF0pXSxcclxuXHJcblx0XHQvLyBvYnNvbGV0ZVxyXG5cdFx0bWFzc0RpZmZlcmVuY2U6IHBhcnNlRGVjaW1hbEludChhdG9tU3BsaXRbNV0pLFxyXG5cdFx0Y2hhcmdlOiBmbXRJbmZvLmNoYXJnZU1hcFtwYXJzZURlY2ltYWxJbnQoYXRvbVNwbGl0WzZdKV0sXHJcblxyXG5cdFx0Ly8gcXVlcnlcclxuXHRcdGhDb3VudDogcGFyc2VEZWNpbWFsSW50KHBhcnNlRGVjaW1hbEludChhdG9tU3BsaXRbOF0pKSxcclxuXHRcdHN0ZXJlb0NhcmU6IHBhcnNlRGVjaW1hbEludChhdG9tU3BsaXRbOV0pICE9IDAsXHJcblxyXG5cdFx0Ly8gcmVhY3Rpb25cclxuXHRcdGFhbTogcGFyc2VEZWNpbWFsSW50KGF0b21TcGxpdFsxNF0pLFxyXG5cdFx0aW52UmV0OiBwYXJzZURlY2ltYWxJbnQoYXRvbVNwbGl0WzE1XSksXHJcblxyXG5cdFx0Ly8gcmVhY3Rpb24gcXVlcnlcclxuXHRcdGV4YWN0Q2hhbmdlRmxhZzogcGFyc2VEZWNpbWFsSW50KGF0b21TcGxpdFsxNl0pICE9IDBcclxuXHR9O1xyXG5cdHJldHVybiBuZXcgQXRvbShwYXJhbXMpO1xyXG59O1xyXG5cclxudmFyIHN0cmlwVjMwID0gZnVuY3Rpb24gKGxpbmUpXHJcbntcclxuICAgIC8qIHJlYWRlciAqL1xyXG5cdGlmIChsaW5lLnNsaWNlKDAsIDcpICE9ICdNICBWMzAgJylcclxuXHRcdHRocm93IEVycm9yKCdQcmVmaXggaW52YWxpZCcpO1xyXG5cdHJldHVybiBsaW5lLnNsaWNlKDcpO1xyXG59O1xyXG5cclxudmFyIHBhcnNlQXRvbUxpbmVWMzAwMCA9IGZ1bmN0aW9uIChsaW5lKVxyXG57XHJcbiAgICAvKiByZWFkZXIgKi9cclxuXHR2YXIgc3BsaXQsIHN1YnNwbGl0LCBrZXksIHZhbHVlLCBpO1xyXG5cdHNwbGl0ID0gc3BhY2VwYXJzcGxpdChsaW5lKTtcclxuXHR2YXIgcGFyYW1zID0ge1xyXG5cdFx0cHA6IG5ldyBWZWMyKHBhcnNlRmxvYXQoc3BsaXRbMl0pLCAtcGFyc2VGbG9hdChzcGxpdFszXSkpLFxyXG5cdFx0YWFtOiBzcGxpdFs1XS5zdHJpcCgpXHJcblx0fTtcclxuXHR2YXIgbGFiZWwgPSBzcGxpdFsxXS5zdHJpcCgpO1xyXG5cdGlmIChsYWJlbC5jaGFyQXQoMCkgPT0gJ1wiJyAmJiBsYWJlbC5jaGFyQXQobGFiZWwubGVuZ3RoIC0gMSkgPT0gJ1wiJykge1xyXG5cdFx0bGFiZWwgPSBsYWJlbC5zdWJzdHIoMSwgbGFiZWwubGVuZ3RoIC0gMik7IC8vIHN0cmlwIHF1dGF0aW9uIG1hcmtzXHJcblx0fVxyXG5cdGlmIChsYWJlbC5jaGFyQXQobGFiZWwubGVuZ3RoIC0gMSkgPT0gJ10nKSB7IC8vIGFzc3VtZSBhdG9tIGxpc3RcclxuXHRcdGxhYmVsID0gbGFiZWwuc3Vic3RyKDAsIGxhYmVsLmxlbmd0aCAtIDEpOyAvLyByZW1vdmUgJ10nXHJcblx0XHR2YXIgYXRvbUxpc3RQYXJhbXMgPSB7fTtcclxuXHRcdGF0b21MaXN0UGFyYW1zLm5vdExpc3QgPSBmYWxzZTtcclxuXHRcdGlmIChsYWJlbC5zdWJzdHIoMCwgNSkgPT0gJ05PVCBbJykge1xyXG5cdFx0XHRhdG9tTGlzdFBhcmFtcy5ub3RMaXN0ID0gdHJ1ZTtcclxuXHRcdFx0bGFiZWwgPSBsYWJlbC5zdWJzdHIoNSk7IC8vIHJlbW92ZSAnTk9UIFsnXHJcblx0XHR9IGVsc2UgaWYgKGxhYmVsLmNoYXJBdCgwKSAhPSAnWycpIHtcclxuXHRcdFx0dGhyb3cgJ0Vycm9yOiBhdG9tIGxpc3QgZXhwZWN0ZWQsIGZvdW5kIFxcJycgKyBsYWJlbCArICdcXCcnO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bGFiZWwgPSBsYWJlbC5zdWJzdHIoMSk7IC8vIHJlbW92ZSAnWydcclxuXHRcdH1cclxuXHRcdGF0b21MaXN0UGFyYW1zLmlkcyA9IGxhYmVsc0xpc3RUb0lkcyhsYWJlbC5zcGxpdCgnLCcpKTtcclxuXHRcdHBhcmFtc1snYXRvbUxpc3QnXSA9IG5ldyBBdG9tLkxpc3QoYXRvbUxpc3RQYXJhbXMpO1xyXG5cdFx0cGFyYW1zWydsYWJlbCddID0gJ0wjJztcclxuXHR9IGVsc2Uge1xyXG5cdFx0cGFyYW1zWydsYWJlbCddID0gbGFiZWw7XHJcblx0fVxyXG5cdHNwbGl0LnNwbGljZSgwLCA2KTtcclxuXHRmb3IgKGkgPSAwOyBpIDwgc3BsaXQubGVuZ3RoOyArK2kpIHtcclxuXHRcdHN1YnNwbGl0ID0gc3BsaXRvbmNlKHNwbGl0W2ldLCAnPScpO1xyXG5cdFx0a2V5ID0gc3Vic3BsaXRbMF07XHJcblx0XHR2YWx1ZSA9IHN1YnNwbGl0WzFdO1xyXG5cdFx0aWYgKGtleSBpbiBmbXRJbmZvLnYzMGF0b21Qcm9wTWFwKSB7XHJcblx0XHRcdHZhciBpdmFsID0gcGFyc2VEZWNpbWFsSW50KHZhbHVlKTtcclxuXHRcdFx0aWYgKGtleSA9PSAnVkFMJykge1xyXG5cdFx0XHRcdGlmIChpdmFsID09IDApXHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRpZiAoaXZhbCA9PSAtMSlcclxuXHRcdFx0XHRcdGl2YWwgPSAwO1xyXG5cdFx0XHR9XHJcblx0XHRcdHBhcmFtc1tmbXRJbmZvLnYzMGF0b21Qcm9wTWFwW2tleV1dID0gaXZhbDtcclxuXHRcdH0gZWxzZSBpZiAoa2V5ID09ICdSR1JPVVBTJykge1xyXG5cdFx0XHR2YWx1ZSA9IHZhbHVlLnN0cmlwKCkuc3Vic3RyKDEsIHZhbHVlLmxlbmd0aCAtIDIpO1xyXG5cdFx0XHR2YXIgcmdyc3BsaXQgPSB2YWx1ZS5zcGxpdCgnICcpLnNsaWNlKDEpO1xyXG5cdFx0XHRwYXJhbXMucmdsYWJlbCA9IDA7XHJcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgcmdyc3BsaXQubGVuZ3RoOyArK2opIHtcclxuXHRcdFx0XHRwYXJhbXMucmdsYWJlbCB8PSAxIDw8IChyZ3JzcGxpdFtqXSAtIDEpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKGtleSA9PSAnQVRUQ0hQVCcpIHtcclxuXHRcdFx0cGFyYW1zLmF0dHBudCA9IHZhbHVlLnN0cmlwKCkgLSAwO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gbmV3IEF0b20ocGFyYW1zKTtcclxufTtcclxuXHJcbnZhciBwYXJzZUJvbmRMaW5lVjMwMDAgPSBmdW5jdGlvbiAobGluZSlcclxue1xyXG4gICAgLyogcmVhZGVyICovXHJcblx0dmFyIHNwbGl0LCBzdWJzcGxpdCwga2V5LCB2YWx1ZSwgaTtcclxuXHRzcGxpdCA9IHNwYWNlcGFyc3BsaXQobGluZSk7XHJcblx0dmFyIHBhcmFtcyA9IHtcclxuXHRcdGJlZ2luOiBwYXJzZURlY2ltYWxJbnQoc3BsaXRbMl0pIC0gMSxcclxuXHRcdGVuZDogcGFyc2VEZWNpbWFsSW50KHNwbGl0WzNdKSAtIDEsXHJcblx0XHR0eXBlOiBmbXRJbmZvLmJvbmRUeXBlTWFwW3BhcnNlRGVjaW1hbEludChzcGxpdFsxXSldXHJcblx0fTtcclxuXHRzcGxpdC5zcGxpY2UoMCwgNCk7XHJcblx0Zm9yIChpID0gMDsgaSA8IHNwbGl0Lmxlbmd0aDsgKytpKSB7XHJcblx0XHRzdWJzcGxpdCA9IHNwbGl0b25jZShzcGxpdFtpXSwgJz0nKTtcclxuXHRcdGtleSA9IHN1YnNwbGl0WzBdO1xyXG5cdFx0dmFsdWUgPSBzdWJzcGxpdFsxXTtcclxuXHRcdGlmIChrZXkgPT0gJ0NGRycpIHtcclxuXHRcdFx0cGFyYW1zLnN0ZXJlbyA9IGZtdEluZm8udjMwYm9uZFN0ZXJlb01hcFtwYXJzZURlY2ltYWxJbnQodmFsdWUpXTtcclxuXHRcdFx0aWYgKHBhcmFtcy50eXBlID09IEJvbmQuUEFUVEVSTi5UWVBFLkRPVUJMRSAmJiBwYXJhbXMuc3RlcmVvID09IEJvbmQuUEFUVEVSTi5TVEVSRU8uRUlUSEVSKVxyXG5cdFx0XHRcdHBhcmFtcy5zdGVyZW8gPSBCb25kLlBBVFRFUk4uU1RFUkVPLkNJU19UUkFOUztcclxuXHRcdH0gZWxzZSBpZiAoa2V5ID09ICdUT1BPJykge1xyXG5cdFx0XHRwYXJhbXMudG9wb2xvZ3kgPSBmbXRJbmZvLmJvbmRUb3BvbG9neU1hcFtwYXJzZURlY2ltYWxJbnQodmFsdWUpXTtcclxuXHRcdH0gZWxzZSBpZiAoa2V5ID09ICdSWENUUicpIHtcclxuXHRcdFx0cGFyYW1zLnJlYWN0aW5nQ2VudGVyU3RhdHVzID0gcGFyc2VEZWNpbWFsSW50KHZhbHVlKTtcclxuXHRcdH0gZWxzZSBpZiAoa2V5ID09ICdTVEJPWCcpIHtcclxuXHRcdFx0cGFyYW1zLnN0ZXJlb0NhcmUgPSBwYXJzZURlY2ltYWxJbnQodmFsdWUpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gbmV3IEJvbmQocGFyYW1zKTtcclxufTtcclxuXHJcbnZhciBwYXJzZUJvbmRMaW5lID0gZnVuY3Rpb24gKGJvbmRMaW5lKVxyXG57XHJcbiAgICAvKiByZWFkZXIgKi9cclxuXHR2YXIgYm9uZFNwbGl0ID0gcGFydGl0aW9uTGluZShib25kTGluZSwgZm10SW5mby5ib25kTGluZVBhcnRpdGlvbik7XHJcblx0dmFyIHBhcmFtcyA9XHJcblx0e1xyXG5cdFx0YmVnaW46IHBhcnNlRGVjaW1hbEludChib25kU3BsaXRbMF0pIC0gMSxcclxuXHRcdGVuZDogcGFyc2VEZWNpbWFsSW50KGJvbmRTcGxpdFsxXSkgLSAxLFxyXG5cdFx0dHlwZTogZm10SW5mby5ib25kVHlwZU1hcFtwYXJzZURlY2ltYWxJbnQoYm9uZFNwbGl0WzJdKV0sXHJcblx0XHRzdGVyZW86IGZtdEluZm8uYm9uZFN0ZXJlb01hcFtwYXJzZURlY2ltYWxJbnQoYm9uZFNwbGl0WzNdKV0sXHJcblx0XHR0b3BvbG9neTogZm10SW5mby5ib25kVG9wb2xvZ3lNYXBbcGFyc2VEZWNpbWFsSW50KGJvbmRTcGxpdFs1XSldLFxyXG5cdFx0cmVhY3RpbmdDZW50ZXJTdGF0dXM6IHBhcnNlRGVjaW1hbEludChib25kU3BsaXRbNl0pXHJcblx0fTtcclxuXHJcblx0cmV0dXJuIG5ldyBCb25kKHBhcmFtcyk7XHJcbn07XHJcblxyXG52YXIgcGFyc2VBdG9tTGlzdExpbmUgPSBmdW5jdGlvbiAoLyogc3RyaW5nICovYXRvbUxpc3RMaW5lKVxyXG57XHJcbiAgICAvKiByZWFkZXIgKi9cclxuXHR2YXIgc3BsaXQgPSBwYXJ0aXRpb25MaW5lKGF0b21MaXN0TGluZSwgZm10SW5mby5hdG9tTGlzdEhlYWRlclBhcnRpdGlvbik7XHJcblxyXG5cdHZhciBudW1iZXIgPSBwYXJzZURlY2ltYWxJbnQoc3BsaXRbMF0pIC0gMTtcclxuXHR2YXIgbm90TGlzdCA9IChzcGxpdFsyXS5zdHJpcCgpID09ICdUJyk7XHJcblx0dmFyIGNvdW50ID0gcGFyc2VEZWNpbWFsSW50KHNwbGl0WzRdLnN0cmlwKCkpO1xyXG5cclxuXHR2YXIgaWRzID0gYXRvbUxpc3RMaW5lLnNsaWNlKGZtdEluZm8uYXRvbUxpc3RIZWFkZXJMZW5ndGgpO1xyXG5cdHZhciBsaXN0ID0gW107XHJcblx0dmFyIGl0ZW1MZW5ndGggPSBmbXRJbmZvLmF0b21MaXN0SGVhZGVySXRlbUxlbmd0aDtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpXHJcblx0XHRsaXN0W2ldID0gcGFyc2VEZWNpbWFsSW50KGlkcy5zbGljZShpICogaXRlbUxlbmd0aCwgKGkgKyAxKSAqIGl0ZW1MZW5ndGggLSAxKSk7XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHQnYWlkJzogbnVtYmVyLFxyXG5cdFx0J2F0b21MaXN0JzogbmV3IEF0b20uTGlzdCh7XHJcblx0XHRcdCdub3RMaXN0Jzogbm90TGlzdCxcclxuXHRcdFx0J2lkcyc6IGxpc3RcclxuXHRcdH0pXHJcblx0fTtcclxufTtcclxuXHJcbnZhciByZWFkS2V5VmFsdWVQYWlycyA9IGZ1bmN0aW9uIChzdHIsIC8qIGJvb2wgKi8gdmFsdWVTdHJpbmcpXHJcbntcclxuICAgIC8qIHJlYWRlciAqL1xyXG5cdHZhciByZXQgPSB7fTtcclxuXHR2YXIgcGFydGl0aW9uID0gcGFydGl0aW9uTGluZUZpeGVkKHN0ciwgMywgdHJ1ZSk7XHJcblx0dmFyIGNvdW50ID0gcGFyc2VEZWNpbWFsSW50KHBhcnRpdGlvblswXSk7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKVxyXG5cdFx0cmV0W3BhcnNlRGVjaW1hbEludChwYXJ0aXRpb25bMiAqIGkgKyAxXSkgLSAxXSA9XHJcblx0XHRcdHZhbHVlU3RyaW5nID8gcGFydGl0aW9uWzIgKiBpICsgMl0uc3RyaXAoKSA6XHJcblx0XHRcdHBhcnNlRGVjaW1hbEludChwYXJ0aXRpb25bMiAqIGkgKyAyXSk7XHJcblx0cmV0dXJuIHJldDtcclxufTtcclxuXHJcbnZhciByZWFkS2V5TXVsdGlWYWx1ZVBhaXJzID0gZnVuY3Rpb24gKHN0ciwgLyogYm9vbCAqLyB2YWx1ZVN0cmluZylcclxue1xyXG4gICAgLyogcmVhZGVyICovXHJcblx0dmFyIHJldCA9IFtdO1xyXG5cdHZhciBwYXJ0aXRpb24gPSBwYXJ0aXRpb25MaW5lRml4ZWQoc3RyLCAzLCB0cnVlKTtcclxuXHR2YXIgY291bnQgPSBwYXJzZURlY2ltYWxJbnQocGFydGl0aW9uWzBdKTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpXHJcblx0XHRyZXQucHVzaChbXHJcblx0XHRcdHBhcnNlRGVjaW1hbEludChwYXJ0aXRpb25bMiAqIGkgKyAxXSkgLSAxLFxyXG5cdFx0XHRcdHZhbHVlU3RyaW5nID8gcGFydGl0aW9uWzIgKiBpICsgMl0uc3RyaXAoKSA6IHBhcnNlRGVjaW1hbEludChwYXJ0aXRpb25bMiAqIGkgKyAyXSlcclxuXHRcdFx0XSk7XHJcblx0cmV0dXJuIHJldDtcclxufTtcclxuXHJcbnZhciBsYWJlbHNMaXN0VG9JZHMgPSBmdW5jdGlvbiAobGFiZWxzKVxyXG57XHJcbiAgICAvKiByZWFkZXIgKi9cclxuXHR2YXIgaWRzID0gW107XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsYWJlbHMubGVuZ3RoOyArK2kpIHtcclxuXHRcdGlkcy5wdXNoKGVsZW1lbnQuZ2V0RWxlbWVudEJ5TGFiZWwobGFiZWxzW2ldLnN0cmlwKCkpKTtcclxuXHR9XHJcblx0cmV0dXJuIGlkcztcclxufTtcclxuXHJcbnZhciBwYXJzZVByb3BlcnR5TGluZUF0b21MaXN0ID0gZnVuY3Rpb24gKGhkciwgbHN0KVxyXG57XHJcbiAgICAvKiByZWFkZXIgKi9cclxuXHR2YXIgYWlkID0gcGFyc2VEZWNpbWFsSW50KGhkclsxXSkgLSAxO1xyXG5cdHZhciBjb3VudCA9IHBhcnNlRGVjaW1hbEludChoZHJbMl0pO1xyXG5cdHZhciBub3RMaXN0ID0gaGRyWzRdLnN0cmlwKCkgPT0gJ1QnO1xyXG5cdHZhciBpZHMgPSBsYWJlbHNMaXN0VG9JZHMobHN0LnNsaWNlKDAsIGNvdW50KSk7XHJcblx0dmFyIHJldCA9IHt9O1xyXG5cdHJldFthaWRdID0gbmV3IEF0b20uTGlzdCh7XHJcblx0XHQnbm90TGlzdCc6IG5vdExpc3QsXHJcblx0XHQnaWRzJzogaWRzXHJcblx0fSk7XHJcblx0cmV0dXJuIHJldDtcclxufTtcclxuXHJcbnZhciBpbml0U0dyb3VwID0gZnVuY3Rpb24gKHNHcm91cHMsIHByb3BEYXRhKVxyXG57XHJcbiAgICAvKiByZWFkZXIgKi9cclxuXHR2YXIga3YgPSByZWFkS2V5VmFsdWVQYWlycyhwcm9wRGF0YSwgdHJ1ZSk7XHJcblx0Zm9yICh2YXIga2V5IGluIGt2KSB7XHJcblx0XHR2YXIgdHlwZSA9IGt2W2tleV07XHJcblx0XHRpZiAoISh0eXBlIGluIFNHcm91cC5UWVBFUykpXHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgUy1ncm91cCB0eXBlJyk7XHJcblx0XHR2YXIgc2cgPSBuZXcgU0dyb3VwKHR5cGUpO1xyXG5cdFx0c2cubnVtYmVyID0ga2V5O1xyXG5cdFx0c0dyb3Vwc1trZXldID0gc2c7XHJcblx0fVxyXG59O1xyXG5cclxudmFyIGFwcGx5U0dyb3VwUHJvcCA9IGZ1bmN0aW9uIChzR3JvdXBzLCBwcm9wTmFtZSwgcHJvcERhdGEsIG51bWVyaWMsIGNvcmUpXHJcbntcclxuXHR2YXIga3YgPSByZWFkS2V5VmFsdWVQYWlycyhwcm9wRGF0YSwgIShudW1lcmljKSk7XHJcblx0Zm9yICh2YXIga2V5IGluIGt2KSB7XHJcblx0XHQvLyBcImNvcmVcIiBwcm9wZXJ0aWVzIGFyZSBzdG9yZWQgZGlyZWN0bHkgaW4gYW4gc2dyb3VwLCBub3QgaW4gc2dyb3VwLmRhdGFcclxuXHRcdChjb3JlID8gc0dyb3Vwc1trZXldIDogc0dyb3Vwc1trZXldLmRhdGEpIFtwcm9wTmFtZV0gPSBrdltrZXldO1xyXG5cdH1cclxufTtcclxuXHJcbnZhciB0b0ludEFycmF5ID0gZnVuY3Rpb24gKHN0ckFycmF5KVxyXG57XHJcbiAgICAvKiByZWFkZXIgKi9cclxuXHR2YXIgcmV0ID0gW107XHJcblx0Zm9yICh2YXIgaiA9IDA7IGogPCBzdHJBcnJheS5sZW5ndGg7ICsrailcclxuXHRcdHJldFtqXSA9IHBhcnNlRGVjaW1hbEludChzdHJBcnJheVtqXSk7XHJcblx0cmV0dXJuIHJldDtcclxufTtcclxuXHJcbnZhciBhcHBseVNHcm91cEFycmF5UHJvcCA9IGZ1bmN0aW9uIChzR3JvdXBzLCBwcm9wTmFtZSwgcHJvcERhdGEsIHNoaWZ0KVxyXG57XHJcbiAgICAvKiByZWFkZXIgKi9cclxuXHR2YXIgc2lkID0gcGFyc2VEZWNpbWFsSW50KHByb3BEYXRhLnNsaWNlKDEsIDQpKSAtIDE7XHJcblx0dmFyIG51bSA9IHBhcnNlRGVjaW1hbEludChwcm9wRGF0YS5zbGljZSg0LCA4KSk7XHJcblx0dmFyIHBhcnQgPSB0b0ludEFycmF5KHBhcnRpdGlvbkxpbmVGaXhlZChwcm9wRGF0YS5zbGljZSg4KSwgMywgdHJ1ZSkpO1xyXG5cclxuXHRpZiAocGFydC5sZW5ndGggIT0gbnVtKVxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdGaWxlIGZvcm1hdCBpbnZhbGlkJyk7XHJcblx0aWYgKHNoaWZ0KSB7XHJcblx0XHR1dGlsLmFwcGx5KHBhcnQsIGZ1bmN0aW9uICh2KSB7XHJcblx0XHRcdHJldHVybiB2ICsgc2hpZnQ7XHJcblx0XHR9KTtcclxuXHR9XHJcblx0c0dyb3Vwc1tzaWRdW3Byb3BOYW1lXSA9IHNHcm91cHNbc2lkXVtwcm9wTmFtZV0uY29uY2F0KHBhcnQpO1xyXG59O1xyXG5cclxudmFyIGFwcGx5RGF0YVNHcm91cE5hbWUgPSBmdW5jdGlvbiAoc2csIG5hbWUpIHtcclxuICAgIC8qIHJlYWRlciAqL1xyXG5cdHNnLmRhdGEuZmllbGROYW1lID0gbmFtZTtcclxufTtcclxuXHJcbnZhciBhcHBseURhdGFTR3JvdXBRdWVyeSA9IGZ1bmN0aW9uIChzZywgcXVlcnkpIHtcclxuICAgIC8qIHJlYWRlciAqL1xyXG5cdHNnLmRhdGEucXVlcnkgPSBxdWVyeTtcclxufTtcclxuXHJcbnZhciBhcHBseURhdGFTR3JvdXBRdWVyeU9wID0gZnVuY3Rpb24gKHNnLCBxdWVyeU9wKSB7XHJcbiAgICAvKiByZWFkZXIgKi9cclxuXHRzZy5kYXRhLnF1ZXJ5T3AgPSBxdWVyeU9wO1xyXG59O1xyXG5cclxudmFyIGFwcGx5RGF0YVNHcm91cERlc2MgPSBmdW5jdGlvbiAoc0dyb3VwcywgcHJvcERhdGEpIHtcclxuICAgIC8qIHJlYWRlciAqL1xyXG5cdHZhciBzcGxpdCA9IHBhcnRpdGlvbkxpbmUocHJvcERhdGEsIFs0LDMxLDIsMjAsMiwzXSwgZmFsc2UpO1xyXG5cdHZhciBpZCA9IHBhcnNlRGVjaW1hbEludChzcGxpdFswXSkgLSAxO1xyXG5cdHZhciBmaWVsZE5hbWUgPSBzcGxpdFsxXS5zdHJpcCgpO1xyXG5cdHZhciBmaWVsZFR5cGUgPSBzcGxpdFsyXS5zdHJpcCgpO1xyXG5cdHZhciB1bml0cyA9IHNwbGl0WzNdLnN0cmlwKCk7XHJcblx0dmFyIHF1ZXJ5ID0gc3BsaXRbNF0uc3RyaXAoKTtcclxuXHR2YXIgcXVlcnlPcCA9IHNwbGl0WzVdLnN0cmlwKCk7XHJcblx0dmFyIHNHcm91cCA9IHNHcm91cHNbaWRdO1xyXG5cdHNHcm91cC5kYXRhLmZpZWxkVHlwZSA9IGZpZWxkVHlwZTtcclxuXHRzR3JvdXAuZGF0YS5maWVsZE5hbWUgPSBmaWVsZE5hbWU7XHJcblx0c0dyb3VwLmRhdGEudW5pdHMgPSB1bml0cztcclxuXHRzR3JvdXAuZGF0YS5xdWVyeSA9IHF1ZXJ5O1xyXG5cdHNHcm91cC5kYXRhLnF1ZXJ5T3AgPSBxdWVyeU9wO1xyXG59O1xyXG5cclxudmFyIGFwcGx5RGF0YVNHcm91cEluZm8gPSBmdW5jdGlvbiAoc2csIHByb3BEYXRhKSB7XHJcbiAgICAvKiByZWFkZXIgKi9cclxuXHR2YXIgc3BsaXQgPSBwYXJ0aXRpb25MaW5lKHByb3BEYXRhLCBbMTAvKngueCovLDEwLyp5LnkqLyw0LyogZWVlKi8sMS8qZiovLDEvKmcqLywxLypoKi8sMy8qIGkgKi8sMy8qampqKi8sMy8qa2trKi8sMy8qbGwqLywyLyptKi8sMy8qbiovLDIvKm9vKi9dLCBmYWxzZSk7XHJcblxyXG5cdHZhciB4ID0gcGFyc2VGbG9hdChzcGxpdFswXSk7XHJcblx0dmFyIHkgPSBwYXJzZUZsb2F0KHNwbGl0WzFdKTtcclxuXHR2YXIgYXR0YWNoZWQgPSBzcGxpdFszXS5zdHJpcCgpID09ICdBJztcclxuXHR2YXIgYWJzb2x1dGUgPSBzcGxpdFs0XS5zdHJpcCgpID09ICdBJztcclxuXHR2YXIgc2hvd1VuaXRzID0gc3BsaXRbNV0uc3RyaXAoKSA9PSAnVSc7XHJcblx0dmFyIG5DaGFyc1RvRGlzcGxheSA9IHNwbGl0WzddLnN0cmlwKCk7XHJcblx0bkNoYXJzVG9EaXNwbGF5ID0gbkNoYXJzVG9EaXNwbGF5ID09ICdBTEwnID8gLTEgOiBwYXJzZURlY2ltYWxJbnQobkNoYXJzVG9EaXNwbGF5KTtcclxuXHR2YXIgdGFnQ2hhciA9IHNwbGl0WzEwXS5zdHJpcCgpO1xyXG5cdHZhciBkYXNwUG9zID0gcGFyc2VEZWNpbWFsSW50KHNwbGl0WzExXS5zdHJpcCgpKTtcclxuXHJcblx0c2cucHAgPSBuZXcgVmVjMih4LCAteSk7XHJcblx0c2cuZGF0YS5hdHRhY2hlZCA9IGF0dGFjaGVkO1xyXG5cdHNnLmRhdGEuYWJzb2x1dGUgPSBhYnNvbHV0ZTtcclxuXHRzZy5kYXRhLnNob3dVbml0cyA9IHNob3dVbml0cztcclxuXHRzZy5kYXRhLm5DaGFyc1RvRGlzcGxheSA9IG5DaGFyc1RvRGlzcGxheTtcclxuXHRzZy5kYXRhLnRhZ0NoYXIgPSB0YWdDaGFyO1xyXG5cdHNnLmRhdGEuZGFzcFBvcyA9IGRhc3BQb3M7XHJcbn07XHJcblxyXG52YXIgYXBwbHlEYXRhU0dyb3VwSW5mb0xpbmUgPSBmdW5jdGlvbiAoc0dyb3VwcywgcHJvcERhdGEpIHtcclxuICAgIC8qIHJlYWRlciAqL1xyXG5cdHZhciBpZCA9IHBhcnNlRGVjaW1hbEludChwcm9wRGF0YS5zdWJzdHIoMCw0KSkgLSAxO1xyXG5cdHZhciBzZyA9IHNHcm91cHNbaWRdO1xyXG5cdGFwcGx5RGF0YVNHcm91cEluZm8oc2csIHByb3BEYXRhLnN1YnN0cig1KSk7XHJcbn07XHJcblxyXG52YXIgYXBwbHlEYXRhU0dyb3VwRGF0YSA9IGZ1bmN0aW9uIChzZywgZGF0YSwgZmluYWxpemUpIHtcclxuICAgIC8qIHJlYWRlciAqL1xyXG5cdHNnLmRhdGEuZmllbGRWYWx1ZSA9IChzZy5kYXRhLmZpZWxkVmFsdWUgfHwgJycpICsgZGF0YTtcclxuXHRpZiAoZmluYWxpemUpIHtcclxuXHRcdHNnLmRhdGEuZmllbGRWYWx1ZSA9IHV0aWwuc3RyaXBSaWdodChzZy5kYXRhLmZpZWxkVmFsdWUpO1xyXG5cdFx0aWYgKHNnLmRhdGEuZmllbGRWYWx1ZS5zdGFydHNXaXRoKCdcIicpICYmIHNnLmRhdGEuZmllbGRWYWx1ZS5lbmRzV2l0aCgnXCInKSlcclxuXHRcdFx0c2cuZGF0YS5maWVsZFZhbHVlID0gc2cuZGF0YS5maWVsZFZhbHVlLnN1YnN0cigxLCBzZy5kYXRhLmZpZWxkVmFsdWUubGVuZ3RoIC0gMik7XHJcblx0XHQvLyBQYXJ0aWFsbHkgcmV2ZXJ0IGY1NTZlOCwgZnJvbSBLRVRDSEVSLTQ1NyBhbmQgUkIgd2l0aCBsb3ZlXHJcblx0XHQvLyBzZy5kYXRhLmZpZWxkVmFsdWUgKz0gJ1xcbic7XHJcblx0fVxyXG59O1xyXG5cclxudmFyIGFwcGx5RGF0YVNHcm91cERhdGFMaW5lID0gZnVuY3Rpb24gKHNHcm91cHMsIHByb3BEYXRhLCBmaW5hbGl6ZSkge1xyXG4gICAgLyogcmVhZGVyICovXHJcblx0dmFyIGlkID0gcGFyc2VEZWNpbWFsSW50KHByb3BEYXRhLnN1YnN0cigwLDUpKSAtIDE7XHJcblx0dmFyIGRhdGEgPSBwcm9wRGF0YS5zdWJzdHIoNSk7XHJcblx0dmFyIHNnID0gc0dyb3Vwc1tpZF07XHJcblx0YXBwbHlEYXRhU0dyb3VwRGF0YShzZywgZGF0YSwgZmluYWxpemUpO1xyXG59O1xyXG5cclxudmFyIHBhcnNlUHJvcGVydHlMaW5lcyA9IGZ1bmN0aW9uIChjdGFiLCBjdGFiTGluZXMsIHNoaWZ0LCBlbmQsIHNHcm91cHMsIHJMb2dpYylcclxue1xyXG4gICAgLyogcmVhZGVyICovXHJcblx0dmFyIHByb3BzID0gbmV3IE1hcCgpO1xyXG5cdHdoaWxlIChzaGlmdCA8IGVuZClcclxuXHR7XHJcblx0XHR2YXIgbGluZSA9IGN0YWJMaW5lc1tzaGlmdF07XHJcblx0XHRpZiAobGluZS5jaGFyQXQoMCkgPT0gJ0EnKSB7XHJcblx0XHRcdGlmICghcHJvcHMuZ2V0KCdsYWJlbCcpKVxyXG5cdFx0XHRcdHByb3BzLnNldCgnbGFiZWwnLCBuZXcgTWFwKCkpO1xyXG5cdFx0XHRwcm9wcy5nZXQoJ2xhYmVsJykuc2V0KHBhcnNlRGVjaW1hbEludChsaW5lLnNsaWNlKDMsIDYpKSAtIDEsIGN0YWJMaW5lc1srK3NoaWZ0XSk7XHJcblx0XHR9IGVsc2UgaWYgKGxpbmUuY2hhckF0KDApID09ICdNJykge1xyXG5cdFx0XHR2YXIgdHlwZSA9IGxpbmUuc2xpY2UoMywgNik7XHJcblx0XHRcdHZhciBwcm9wZXJ0eURhdGEgPSBsaW5lLnNsaWNlKDYpO1xyXG5cdFx0XHRpZiAodHlwZSA9PSAnRU5EJykge1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT0gJ0NIRycpIHtcclxuXHRcdFx0XHRpZiAoIXByb3BzLmdldCgnY2hhcmdlJykpXHJcblx0XHRcdFx0XHRwcm9wcy5zZXQoJ2NoYXJnZScsIG5ldyBNYXAoKSk7XHJcblx0XHRcdFx0cHJvcHMuZ2V0KCdjaGFyZ2UnKS51cGRhdGUocmVhZEtleVZhbHVlUGFpcnMocHJvcGVydHlEYXRhKSk7XHJcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PSAnUkFEJykge1xyXG5cdFx0XHRcdGlmICghcHJvcHMuZ2V0KCdyYWRpY2FsJykpXHJcblx0XHRcdFx0XHRwcm9wcy5zZXQoJ3JhZGljYWwnLCBuZXcgTWFwKCkpO1xyXG5cdFx0XHRcdHByb3BzLmdldCgncmFkaWNhbCcpLnVwZGF0ZShyZWFkS2V5VmFsdWVQYWlycyhwcm9wZXJ0eURhdGEpKTtcclxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09ICdJU08nKSB7XHJcblx0XHRcdFx0aWYgKCFwcm9wcy5nZXQoJ2lzb3RvcGUnKSlcclxuXHRcdFx0XHRcdHByb3BzLnNldCgnaXNvdG9wZScsIG5ldyBNYXAoKSk7XHJcblx0XHRcdFx0cHJvcHMuZ2V0KCdpc290b3BlJykudXBkYXRlKHJlYWRLZXlWYWx1ZVBhaXJzKHByb3BlcnR5RGF0YSkpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT0gJ1JCQycpIHtcclxuXHRcdFx0XHRpZiAoIXByb3BzLmdldCgncmluZ0JvbmRDb3VudCcpKVxyXG5cdFx0XHRcdFx0cHJvcHMuc2V0KCdyaW5nQm9uZENvdW50JywgbmV3IE1hcCgpKTtcclxuXHRcdFx0XHRwcm9wcy5nZXQoJ3JpbmdCb25kQ291bnQnKS51cGRhdGUocmVhZEtleVZhbHVlUGFpcnMocHJvcGVydHlEYXRhKSk7XHJcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PSAnU1VCJykge1xyXG5cdFx0XHRcdGlmICghcHJvcHMuZ2V0KCdzdWJzdGl0dXRpb25Db3VudCcpKVxyXG5cdFx0XHRcdFx0cHJvcHMuc2V0KCdzdWJzdGl0dXRpb25Db3VudCcsIG5ldyBNYXAoKSk7XHJcblx0XHRcdFx0cHJvcHMuZ2V0KCdzdWJzdGl0dXRpb25Db3VudCcpLnVwZGF0ZShyZWFkS2V5VmFsdWVQYWlycyhwcm9wZXJ0eURhdGEpKTtcclxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09ICdVTlMnKSB7XHJcblx0XHRcdFx0aWYgKCFwcm9wcy5nZXQoJ3Vuc2F0dXJhdGVkQXRvbScpKVxyXG5cdFx0XHRcdFx0cHJvcHMuc2V0KCd1bnNhdHVyYXRlZEF0b20nLCBuZXcgTWFwKCkpO1xyXG5cdFx0XHRcdHByb3BzLmdldCgndW5zYXR1cmF0ZWRBdG9tJykudXBkYXRlKHJlYWRLZXlWYWx1ZVBhaXJzKHByb3BlcnR5RGF0YSkpO1xyXG5cdFx0XHRcdC8vIGVsc2UgaWYgKHR5cGUgPT0gXCJMSU5cIikgLy8gbGluayBhdG9tXHJcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PSAnUkdQJykgeyAvLyByZ3JvdXAgYXRvbVxyXG5cdFx0XHRcdGlmICghcHJvcHMuZ2V0KCdyZ2xhYmVsJykpXHJcblx0XHRcdFx0XHRwcm9wcy5zZXQoJ3JnbGFiZWwnLCBuZXcgTWFwKCkpO1xyXG5cdFx0XHRcdHZhciByZ2xhYmVscyA9IHByb3BzLmdldCgncmdsYWJlbCcpO1xyXG5cdFx0XHRcdHZhciBhMnJzID0gcmVhZEtleU11bHRpVmFsdWVQYWlycyhwcm9wZXJ0eURhdGEpO1xyXG5cdFx0XHRcdGZvciAodmFyIGEycmkgPSAwOyBhMnJpIDwgYTJycy5sZW5ndGg7IGEycmkrKykge1xyXG5cdFx0XHRcdFx0dmFyIGEyciA9IGEycnNbYTJyaV07XHJcblx0XHRcdFx0XHRyZ2xhYmVscy5zZXQoYTJyWzBdLCAocmdsYWJlbHMuZ2V0KGEyclswXSkgfHwgMCkgfCAoMSA8PCAoYTJyWzFdIC0gMSkpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PSAnTE9HJykgeyAvLyByZ3JvdXAgYXRvbVxyXG5cdFx0XHRcdHByb3BlcnR5RGF0YSA9IHByb3BlcnR5RGF0YS5zbGljZSg0KTtcclxuXHRcdFx0XHR2YXIgcmdpZCA9IHBhcnNlRGVjaW1hbEludChwcm9wZXJ0eURhdGEuc2xpY2UoMCwzKS5zdHJpcCgpKTtcclxuXHRcdFx0XHR2YXIgaWlpID0gcGFyc2VEZWNpbWFsSW50KHByb3BlcnR5RGF0YS5zbGljZSg0LDcpLnN0cmlwKCkpO1xyXG5cdFx0XHRcdHZhciBoaGggPSBwYXJzZURlY2ltYWxJbnQocHJvcGVydHlEYXRhLnNsaWNlKDgsMTEpLnN0cmlwKCkpO1xyXG5cdFx0XHRcdHZhciBvb28gPSBwcm9wZXJ0eURhdGEuc2xpY2UoMTIpLnN0cmlwKCk7XHJcblx0XHRcdFx0dmFyIGxvZ2ljID0ge307XHJcblx0XHRcdFx0aWYgKGlpaSA+IDApXHJcblx0XHRcdFx0XHRsb2dpYy5pZnRoZW4gPSBpaWk7XHJcblx0XHRcdFx0bG9naWMucmVzdGggPSBoaGggPT0gMTtcclxuXHRcdFx0XHRsb2dpYy5yYW5nZSA9IG9vbztcclxuXHRcdFx0XHRyTG9naWNbcmdpZF0gPSBsb2dpYztcclxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09ICdBUE8nKSB7XHJcblx0XHRcdFx0aWYgKCFwcm9wcy5nZXQoJ2F0dHBudCcpKVxyXG5cdFx0XHRcdFx0cHJvcHMuc2V0KCdhdHRwbnQnLCBuZXcgTWFwKCkpO1xyXG5cdFx0XHRcdHByb3BzLmdldCgnYXR0cG50JykudXBkYXRlKHJlYWRLZXlWYWx1ZVBhaXJzKHByb3BlcnR5RGF0YSkpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT0gJ0FMUycpIHsgLy8gYXRvbSBsaXN0XHJcblx0XHRcdFx0aWYgKCFwcm9wcy5nZXQoJ2F0b21MaXN0JykpXHJcblx0XHRcdFx0XHRwcm9wcy5zZXQoJ2F0b21MaXN0JywgbmV3IE1hcCgpKTtcclxuXHRcdFx0XHR2YXIgbGlzdCA9IHBhcnNlUHJvcGVydHlMaW5lQXRvbUxpc3QoXHJcblx0XHRcdFx0cGFydGl0aW9uTGluZShwcm9wZXJ0eURhdGEsIFsxLDMsMywxLDEsMV0pLFxyXG5cdFx0XHRcdHBhcnRpdGlvbkxpbmVGaXhlZChwcm9wZXJ0eURhdGEuc2xpY2UoMTApLCA0LCBmYWxzZSkpO1xyXG5cdFx0XHRcdHByb3BzLmdldCgnYXRvbUxpc3QnKS51cGRhdGUoXHJcblx0XHRcdFx0XHRsaXN0KTtcclxuXHRcdFx0XHRpZiAoIXByb3BzLmdldCgnbGFiZWwnKSlcclxuXHRcdFx0XHRcdHByb3BzLnNldCgnbGFiZWwnLCBuZXcgTWFwKCkpO1xyXG5cdFx0XHRcdGZvciAodmFyIGFpZCBpbiBsaXN0KSBwcm9wcy5nZXQoJ2xhYmVsJykuc2V0KGFpZCwgJ0wjJyk7XHJcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PSAnU1RZJykgeyAvLyBpbnRyb2R1Y2Ugcy1ncm91cFxyXG5cdFx0XHRcdGluaXRTR3JvdXAoc0dyb3VwcywgcHJvcGVydHlEYXRhKTtcclxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09ICdTU1QnKSB7XHJcblx0XHRcdFx0YXBwbHlTR3JvdXBQcm9wKHNHcm91cHMsICdzdWJ0eXBlJywgcHJvcGVydHlEYXRhKTtcclxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09ICdTTEInKSB7XHJcblx0XHRcdFx0YXBwbHlTR3JvdXBQcm9wKHNHcm91cHMsICdsYWJlbCcsIHByb3BlcnR5RGF0YSwgdHJ1ZSk7XHJcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PSAnU1BMJykge1xyXG5cdFx0XHRcdGFwcGx5U0dyb3VwUHJvcChzR3JvdXBzLCAncGFyZW50JywgcHJvcGVydHlEYXRhLCB0cnVlLCB0cnVlKTtcclxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09ICdTQ04nKSB7XHJcblx0XHRcdFx0YXBwbHlTR3JvdXBQcm9wKHNHcm91cHMsICdjb25uZWN0aXZpdHknLCBwcm9wZXJ0eURhdGEpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT0gJ1NBTCcpIHtcclxuXHRcdFx0XHRhcHBseVNHcm91cEFycmF5UHJvcChzR3JvdXBzLCAnYXRvbXMnLCBwcm9wZXJ0eURhdGEsIC0xKTtcclxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09ICdTQkwnKSB7XHJcblx0XHRcdFx0YXBwbHlTR3JvdXBBcnJheVByb3Aoc0dyb3VwcywgJ2JvbmRzJywgcHJvcGVydHlEYXRhLCAtMSk7XHJcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PSAnU1BBJykge1xyXG5cdFx0XHRcdGFwcGx5U0dyb3VwQXJyYXlQcm9wKHNHcm91cHMsICdwYXRvbXMnLCBwcm9wZXJ0eURhdGEsIC0xKTtcclxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09ICdTTVQnKSB7XHJcblx0XHRcdFx0dmFyIHNpZCA9IHBhcnNlRGVjaW1hbEludChwcm9wZXJ0eURhdGEuc2xpY2UoMCwgNCkpIC0gMTtcclxuXHRcdFx0XHRzR3JvdXBzW3NpZF0uZGF0YS5zdWJzY3JpcHQgPSBwcm9wZXJ0eURhdGEuc2xpY2UoNCkuc3RyaXAoKTtcclxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09ICdTRFQnKSB7XHJcblx0XHRcdFx0YXBwbHlEYXRhU0dyb3VwRGVzYyhzR3JvdXBzLCBwcm9wZXJ0eURhdGEpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT0gJ1NERCcpIHtcclxuXHRcdFx0XHRhcHBseURhdGFTR3JvdXBJbmZvTGluZShzR3JvdXBzLCBwcm9wZXJ0eURhdGEpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT0gJ1NDRCcpIHtcclxuXHRcdFx0XHRhcHBseURhdGFTR3JvdXBEYXRhTGluZShzR3JvdXBzLCBwcm9wZXJ0eURhdGEsIGZhbHNlKTtcclxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09ICdTRUQnKSB7XHJcblx0XHRcdFx0YXBwbHlEYXRhU0dyb3VwRGF0YUxpbmUoc0dyb3VwcywgcHJvcGVydHlEYXRhLCB0cnVlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0KytzaGlmdDtcclxuXHR9XHJcblx0cmV0dXJuIHByb3BzO1xyXG59O1xyXG5cclxudmFyIGFwcGx5QXRvbVByb3AgPSBmdW5jdGlvbiAoYXRvbXMgLyogUG9vbCAqLywgdmFsdWVzIC8qIE1hcCAqLywgcHJvcElkIC8qIHN0cmluZyAqLywgY2xlYW4gLyogYm9vbGVhbiAqLylcclxue1xyXG4gICAgLyogcmVhZGVyICovXHJcblx0dmFsdWVzLmVhY2goZnVuY3Rpb24gKGFpZCwgcHJvcFZhbCl7XHJcblx0XHRhdG9tcy5nZXQoYWlkKVtwcm9wSWRdID0gcHJvcFZhbDtcclxuXHR9KTtcclxufTtcclxuXHJcbnZhciBhZGRHcm91cCA9IGZ1bmN0aW9uIChtb2wsIHNnLCBhdG9tTWFwKSB7XHJcbiAgICAvLyBhZGQgdGhlIGdyb3VwIHRvIHRoZSBtb2xlY3VsZVxyXG4gICAgc2cuaWQgPSBtb2wuc2dyb3Vwcy5hZGQoc2cpO1xyXG5cclxuICAgIC8vIGFwcGx5IHR5cGUtc3BlY2lmaWMgcG9zdC1wcm9jZXNzaW5nXHJcbiAgICBzZy5wb3N0TG9hZChtb2wsIGF0b21NYXApO1xyXG5cclxuICAgIC8vIG1hcmsgYXRvbXMgaW4gdGhlIGdyb3VwIGFzIGJlbG9uZ2luZyB0byBpdFxyXG4gICAgZm9yICh2YXIgcyA9IDA7IHMgPCBzZy5hdG9tcy5sZW5ndGg7ICsrcylcclxuICAgICAgICBpZiAobW9sLmF0b21zLmhhcyhzZy5hdG9tc1tzXSkpXHJcbiAgICAgICAgICAgIFNldC5hZGQobW9sLmF0b21zLmdldChzZy5hdG9tc1tzXSkuc2dzLCBzZy5pZCk7XHJcblxyXG4gICAgbW9sLnNHcm91cEZvcmVzdC5pbnNlcnQoc2cuaWQpO1xyXG4gICAgcmV0dXJuIHNnLmlkO1xyXG59O1xyXG5cclxudmFyIGZpbHRlckF0b21zID0gZnVuY3Rpb24gKGF0b21zLCBtYXApIHtcclxuICAgIHZhciBuZXdBdG9tcyA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdG9tcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIHZhciBhaWQgPSBhdG9tc1tpXTtcclxuICAgICAgICBpZiAodHlwZW9mIChtYXBbYWlkXSkgIT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgbmV3QXRvbXMucHVzaChhaWQpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWFwW2FpZF0gPj0gMCkge1xyXG4gICAgICAgICAgICBuZXdBdG9tcy5wdXNoKG1hcFthaWRdKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBuZXdBdG9tcy5wdXNoKC0xKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3QXRvbXM7XHJcbn07XHJcblxyXG52YXIgcmVtb3ZlTmVnYXRpdmUgPSBmdW5jdGlvbiAoYXRvbXMpIHtcclxuICAgIHZhciBuZXdBdG9tcyA9IFtdO1xyXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBhdG9tcy5sZW5ndGg7ICsrailcclxuICAgICAgICBpZiAoYXRvbXNbal0gPj0gMClcclxuICAgICAgICAgICAgbmV3QXRvbXMucHVzaChhdG9tc1tqXSk7XHJcbiAgICByZXR1cm4gbmV3QXRvbXM7XHJcbn07XHJcblxyXG52YXIgU0dyb3VwX2ZpbHRlciA9IGZ1bmN0aW9uIChtb2wsIHNnLCBhdG9tTWFwKSB7XHJcbiAgICBzZy5hdG9tcyA9IHJlbW92ZU5lZ2F0aXZlKGZpbHRlckF0b21zKHNnLmF0b21zLCBhdG9tTWFwKSk7XHJcbn07XHJcblxyXG52YXIgcGFyc2VDVGFiVjIwMDAgPSBmdW5jdGlvbiAoY3RhYkxpbmVzLCBjb3VudHNTcGxpdClcclxue1xyXG4gICAgLyogcmVhZGVyICovXHJcblx0dmFyIGN0YWIgPSBuZXcgU3RydWN0KCk7XHJcblx0dmFyIGk7XHJcblx0dmFyIGF0b21Db3VudCA9IHBhcnNlRGVjaW1hbEludChjb3VudHNTcGxpdFswXSk7XHJcblx0dmFyIGJvbmRDb3VudCA9IHBhcnNlRGVjaW1hbEludChjb3VudHNTcGxpdFsxXSk7XHJcblx0dmFyIGF0b21MaXN0Q291bnQgPSBwYXJzZURlY2ltYWxJbnQoY291bnRzU3BsaXRbMl0pO1xyXG5cdGN0YWIuaXNDaGlyYWwgPSBwYXJzZURlY2ltYWxJbnQoY291bnRzU3BsaXRbNF0pICE9IDA7XHJcblx0dmFyIHN0ZXh0TGluZXNDb3VudCA9IHBhcnNlRGVjaW1hbEludChjb3VudHNTcGxpdFs1XSk7XHJcblx0dmFyIHByb3BlcnR5TGluZXNDb3VudCA9IHBhcnNlRGVjaW1hbEludChjb3VudHNTcGxpdFsxMF0pO1xyXG5cclxuXHR2YXIgc2hpZnQgPSAwO1xyXG5cdHZhciBhdG9tTGluZXMgPSBjdGFiTGluZXMuc2xpY2Uoc2hpZnQsIHNoaWZ0ICsgYXRvbUNvdW50KTtcclxuXHRzaGlmdCArPSBhdG9tQ291bnQ7XHJcblx0dmFyIGJvbmRMaW5lcyA9IGN0YWJMaW5lcy5zbGljZShzaGlmdCwgc2hpZnQgKyBib25kQ291bnQpO1xyXG5cdHNoaWZ0ICs9IGJvbmRDb3VudDtcclxuXHR2YXIgYXRvbUxpc3RMaW5lcyA9IGN0YWJMaW5lcy5zbGljZShzaGlmdCwgc2hpZnQgKyBhdG9tTGlzdENvdW50KTtcclxuXHRzaGlmdCArPSBhdG9tTGlzdENvdW50ICsgc3RleHRMaW5lc0NvdW50O1xyXG5cclxuXHR2YXIgYXRvbXMgPSBhdG9tTGluZXMubWFwKHBhcnNlQXRvbUxpbmUpO1xyXG5cdGZvciAoaSA9IDA7IGkgPCBhdG9tcy5sZW5ndGg7ICsraSlcclxuXHRcdGN0YWIuYXRvbXMuYWRkKGF0b21zW2ldKTtcclxuXHR2YXIgYm9uZHMgPSBib25kTGluZXMubWFwKHBhcnNlQm9uZExpbmUpO1xyXG5cdGZvciAoaSA9IDA7IGkgPCBib25kcy5sZW5ndGg7ICsraSlcclxuXHRcdGN0YWIuYm9uZHMuYWRkKGJvbmRzW2ldKTtcclxuXHJcblx0dmFyIGF0b21MaXN0cyA9IGF0b21MaXN0TGluZXMubWFwKHBhcnNlQXRvbUxpc3RMaW5lKTtcclxuXHRhdG9tTGlzdHMuZWFjaChmdW5jdGlvbiAocGFpcil7XHJcblx0XHRjdGFiLmF0b21zLmdldChwYWlyLmFpZCkuYXRvbUxpc3QgPSBwYWlyLmF0b21MaXN0O1xyXG5cdFx0Y3RhYi5hdG9tcy5nZXQocGFpci5haWQpLmxhYmVsID0gJ0wjJztcclxuXHR9KTtcclxuXHJcblx0dmFyIHNHcm91cHMgPSB7fSwgckxvZ2ljID0ge307XHJcblx0dmFyIHByb3BzID0gcGFyc2VQcm9wZXJ0eUxpbmVzKGN0YWIsIGN0YWJMaW5lcywgc2hpZnQsXHJcblx0TWF0aC5taW4oY3RhYkxpbmVzLmxlbmd0aCwgc2hpZnQgKyBwcm9wZXJ0eUxpbmVzQ291bnQpLCBzR3JvdXBzLCByTG9naWMpO1xyXG5cdHByb3BzLmVhY2goZnVuY3Rpb24gKHByb3BJZCwgdmFsdWVzKSB7XHJcblx0XHRhcHBseUF0b21Qcm9wKGN0YWIuYXRvbXMsIHZhbHVlcywgcHJvcElkKTtcclxuXHR9KTtcclxuXHJcblx0dmFyIGF0b21NYXAgPSB7fTtcclxuXHR2YXIgc2lkO1xyXG5cdGZvciAoc2lkIGluIHNHcm91cHMpIHtcclxuXHRcdHZhciBzZyA9IHNHcm91cHNbc2lkXTtcclxuXHRcdGlmIChzZy50eXBlID09PSAnREFUJyAmJiBzZy5hdG9tcy5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0dmFyIHBhcmVudCA9IHNHcm91cHNbc2lkXS5wYXJlbnQ7XHJcblx0XHRcdGlmIChwYXJlbnQgPj0gMCkge1xyXG5cdFx0XHRcdHZhciBwc2cgPSBzR3JvdXBzW3BhcmVudCAtIDFdO1xyXG5cdFx0XHRcdGlmIChwc2cudHlwZSA9PT0gJ0dFTicpIHtcclxuXHRcdFx0XHRcdHNnLmF0b21zID0gdXRpbC5hcnJheShwc2cuYXRvbXMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRmb3IgKHNpZCBpbiBzR3JvdXBzKSB7XHJcblx0XHRhZGRHcm91cChjdGFiLCBzR3JvdXBzW3NpZF0sIGF0b21NYXApO1xyXG5cdH1cclxuXHR2YXIgZW1wdHlHcm91cHMgPSBbXTtcclxuXHRmb3IgKHNpZCBpbiBzR3JvdXBzKSB7IC8vIFRPRE86IHdoeSBkbyB3ZSBuZWVkIHRoYXQ/XHJcbiAgICAgICAgc0dyb3Vwc1tzaWRdLmF0b21zID0gU0dyb3VwX2ZpbHRlcihzR3JvdXBzW3NpZF0uYXRvbXMsIGF0b21NYXApO1xyXG5cdFx0aWYgKHNHcm91cHNbc2lkXS5hdG9tcy5sZW5ndGggPT0gMCAmJiAhc0dyb3Vwc1tzaWRdLmFsbEF0b21zKVxyXG5cdFx0XHRlbXB0eUdyb3Vwcy5wdXNoKHNpZCk7XHJcblx0fVxyXG5cdGZvciAoaSA9IDA7IGkgPCBlbXB0eUdyb3Vwcy5sZW5ndGg7ICsraSkge1xyXG5cdFx0Y3RhYi5zR3JvdXBGb3Jlc3QucmVtb3ZlKGVtcHR5R3JvdXBzW2ldKTtcclxuXHRcdGN0YWIuc2dyb3Vwcy5yZW1vdmUoZW1wdHlHcm91cHNbaV0pO1xyXG5cdH1cclxuXHRmb3IgKHZhciByZ2lkIGluIHJMb2dpYykge1xyXG5cdFx0Y3RhYi5yZ3JvdXBzLnNldChyZ2lkLCBuZXcgU3RydWN0LlJHcm91cChyTG9naWNbcmdpZF0pKTtcclxuXHR9XHJcblx0cmV0dXJuIGN0YWI7XHJcbn07XHJcblxyXG4vLyBzcGxpdCBhIGxpbmUgYnkgc3BhY2VzIG91dHNpZGUgcGFyZW50aGVzZXNcclxudmFyIHNwYWNlcGFyc3BsaXQgPSBmdW5jdGlvbiAobGluZSlcclxue1xyXG4gICAgLyogcmVhZGVyICovXHJcblx0dmFyIHNwbGl0ID0gW10sIHBjID0gMCwgYywgaSwgaTAgPSAtMTtcclxuXHR2YXIgbGluZV9hcnJheSA9IGxpbmUudG9BcnJheSgpOyAvLyBJRTcgZG9lc24ndCBzdXBwb3J0IGxpbmVbaV1cclxuXHR2YXIgcXVvdGVkID0gZmFsc2U7XHJcblxyXG5cdGZvciAoaSA9IDA7IGkgPCBsaW5lLmxlbmd0aDsgKytpKVxyXG5cdHtcclxuXHRcdGMgPSBsaW5lX2FycmF5W2ldO1xyXG5cdFx0aWYgKGMgPT0gJygnKVxyXG5cdFx0XHRwYysrO1xyXG5cdFx0ZWxzZSBpZiAoYyA9PSAnKScpXHJcblx0XHRcdHBjLS07XHJcblx0XHRpZiAoYyA9PSAnXCInKVxyXG5cdFx0XHRxdW90ZWQgPSAhcXVvdGVkO1xyXG5cdFx0aWYgKCFxdW90ZWQgJiYgbGluZV9hcnJheVtpXSA9PSAnICcgJiYgcGMgPT0gMCkge1xyXG5cdFx0XHRpZiAoaSA+IGkwICsgMSlcclxuXHRcdFx0XHRzcGxpdC5wdXNoKGxpbmUuc2xpY2UoaTAgKyAxLCBpKSk7XHJcblx0XHRcdGkwID0gaTtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKGkgPiBpMCArIDEpXHJcblx0XHRzcGxpdC5wdXNoKGxpbmUuc2xpY2UoaTAgKyAxLCBpKSk7XHJcblx0aTAgPSBpO1xyXG5cdHJldHVybiBzcGxpdDtcclxufTtcclxuXHJcbnZhciBzcGxpdG9uY2UgPSBmdW5jdGlvbiAobGluZSwgZGVsaW0pXHJcbntcclxuICAgIC8qIHJlYWRlciAqL1xyXG5cdHZhciBwID0gbGluZS5pbmRleE9mKGRlbGltKTtcclxuXHRyZXR1cm4gW2xpbmUuc2xpY2UoMCxwKSxsaW5lLnNsaWNlKHAgKyAxKV07XHJcbn07XHJcblxyXG52YXIgc3BsaXRTR3JvdXBEZWYgPSBmdW5jdGlvbiAobGluZSlcclxue1xyXG4gICAgLyogcmVhZGVyICovXHJcblx0dmFyIHNwbGl0ID0gW107XHJcblx0dmFyIGJyYWNlQmFsYW5jZSA9IDA7XHJcblx0dmFyIHF1b3RlZCA9IGZhbHNlO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS5sZW5ndGg7ICsraSkge1xyXG5cdFx0dmFyIGMgPSBsaW5lLmNoYXJBdChpKTtcclxuXHRcdGlmIChjID09ICdcIicpIHtcclxuXHRcdFx0cXVvdGVkID0gIXF1b3RlZDtcclxuXHRcdH0gZWxzZSBpZiAoIXF1b3RlZCkge1xyXG5cdFx0XHRpZiAoYyA9PSAnKCcpIHtcclxuXHRcdFx0XHRicmFjZUJhbGFuY2UrKztcclxuXHRcdFx0fSBlbHNlIGlmIChjID09ICcpJykge1xyXG5cdFx0XHRcdGJyYWNlQmFsYW5jZS0tO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGMgPT0gJyAnICYmIGJyYWNlQmFsYW5jZSA9PSAwKSB7XHJcblx0XHRcdFx0c3BsaXQucHVzaChsaW5lLnNsaWNlKDAsIGkpKTtcclxuXHRcdFx0XHRsaW5lID0gbGluZS5zbGljZShpICsgMSkuc3RyaXAoKTtcclxuXHRcdFx0XHRpID0gMDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAoYnJhY2VCYWxhbmNlICE9IDApXHJcblx0XHR0aHJvdyAnQnJhY2UgYmFsYW5jZSBicm9rZW4uIFMtZ3JvdXAgcHJvcGVyaWVzIGludmFsaWQhJztcclxuXHRpZiAobGluZS5sZW5ndGggPiAwKVxyXG5cdFx0c3BsaXQucHVzaChsaW5lLnN0cmlwKCkpO1xyXG5cdHJldHVybiBzcGxpdDtcclxufTtcclxuXHJcbnZhciBwYXJzZUJyYWNlZE51bWJlckxpc3QgPSBmdW5jdGlvbiAobGluZSwgc2hpZnQpXHJcbntcclxuICAgIC8qIHJlYWRlciAqL1xyXG5cdGlmICghbGluZSlcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdHZhciBsaXN0ID0gW107XHJcblx0bGluZSA9IGxpbmUuc3RyaXAoKTtcclxuXHRsaW5lID0gbGluZS5zdWJzdHIoMSwgbGluZS5sZW5ndGggLSAyKTtcclxuXHR2YXIgc3BsaXQgPSBsaW5lLnNwbGl0KCcgJyk7XHJcblx0c2hpZnQgPSBzaGlmdCB8fCAwO1xyXG5cdGZvciAodmFyIGkgPSAxOyBpIDwgc3BsaXQubGVuZ3RoOyArK2kpIHsgLy8gc2tpcCB0aGUgZmlyc3QgZWxlbWVudFxyXG5cdFx0bGlzdC5wdXNoKHNwbGl0W2ldIC0gMCArIHNoaWZ0KTtcclxuXHR9XHJcblx0cmV0dXJuIGxpc3Q7XHJcbn07XHJcblxyXG52YXIgdjMwMDBwYXJzZUNvbGxlY3Rpb24gPSBmdW5jdGlvbiAoY3RhYiwgY3RhYkxpbmVzLCBzaGlmdClcclxue1xyXG4gICAgLyogcmVhZGVyICovXHJcblx0c2hpZnQrKztcclxuXHR3aGlsZSAoY3RhYkxpbmVzW3NoaWZ0XS5zdHJpcCgpICE9ICdNICBWMzAgRU5EIENPTExFQ1RJT04nKVxyXG5cdFx0c2hpZnQrKztcclxuXHRzaGlmdCsrO1xyXG5cdHJldHVybiBzaGlmdDtcclxufTtcclxuXHJcbnZhciB2MzAwMHBhcnNlU0dyb3VwID0gZnVuY3Rpb24gKGN0YWIsIGN0YWJMaW5lcywgc2dyb3VwcywgYXRvbU1hcCwgc2hpZnQpXHJcbntcclxuICAgIC8qIHJlYWRlciAqL1xyXG5cdHZhciBsaW5lID0gJyc7XHJcblx0c2hpZnQrKztcclxuXHR3aGlsZSAoc2hpZnQgPCBjdGFiTGluZXMubGVuZ3RoKSB7XHJcblx0XHRsaW5lID1zdHJpcFYzMChjdGFiTGluZXNbc2hpZnQrK10pLnN0cmlwKCk7XHJcblx0XHRpZiAobGluZS5zdHJpcCgpID09ICdFTkQgU0dST1VQJylcclxuXHRcdFx0cmV0dXJuIHNoaWZ0O1xyXG5cdFx0d2hpbGUgKGxpbmUuY2hhckF0KGxpbmUubGVuZ3RoIC0gMSkgPT0gJy0nKVxyXG5cdFx0XHRsaW5lID0gKGxpbmUuc3Vic3RyKDAsIGxpbmUubGVuZ3RoIC0gMSkgK1xyXG5cdFx0XHRzdHJpcFYzMChjdGFiTGluZXNbc2hpZnQrK10pKS5zdHJpcCgpO1xyXG5cdFx0dmFyIHNwbGl0ID0gc3BsaXRTR3JvdXBEZWYobGluZSk7XHJcblx0XHR2YXIgdHlwZSA9IHNwbGl0WzFdO1xyXG5cdFx0dmFyIHNnID0gbmV3IFNHcm91cCh0eXBlKTtcclxuXHRcdHNnLm51bWJlciA9IHNwbGl0WzBdIC0gMDtcclxuXHRcdHNnLnR5cGUgPSB0eXBlO1xyXG5cdFx0c2cubGFiZWwgPSBzcGxpdFsyXSAtIDA7XHJcblx0XHRzZ3JvdXBzW3NnLm51bWJlcl0gPSBzZztcclxuXHRcdHZhciBwcm9wcyA9IHt9O1xyXG5cdFx0Zm9yICh2YXIgaSA9IDM7IGkgPCBzcGxpdC5sZW5ndGg7ICsraSkge1xyXG5cdFx0XHR2YXIgc3Vic3BsaXQgPSBzcGxpdG9uY2Uoc3BsaXRbaV0sJz0nKTtcclxuXHRcdFx0aWYgKHN1YnNwbGl0Lmxlbmd0aCAhPSAyKSB7XHJcblx0XHRcdFx0dGhyb3cgJ0EgcmVjb3JkIG9mIGZvcm0gQUFBPUJCQiBvciBBQUE9KC4uLikgZXhwZWN0ZWQsIGdvdCBcXCcnICsgc3BsaXRbaV0gKyAnXFwnJztcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgbmFtZSA9IHN1YnNwbGl0WzBdO1xyXG5cdFx0XHRpZiAoIShuYW1lIGluIHByb3BzKSlcclxuXHRcdFx0XHRwcm9wc1tuYW1lXSA9IFtdO1xyXG5cdFx0XHRwcm9wc1tuYW1lXS5wdXNoKHN1YnNwbGl0WzFdKTtcclxuXHRcdH1cclxuXHRcdHNnLmF0b21zID0gcGFyc2VCcmFjZWROdW1iZXJMaXN0KHByb3BzWydBVE9NUyddWzBdLCAtMSk7XHJcblx0XHRpZiAocHJvcHNbJ1BBVE9NUyddKVxyXG5cdFx0XHRzZy5wYXRvbXMgPSBwYXJzZUJyYWNlZE51bWJlckxpc3QocHJvcHNbJ1BBVE9NUyddWzBdLCAtMSk7XHJcblx0XHRzZy5ib25kcyA9IHByb3BzWydCT05EUyddID8gcGFyc2VCcmFjZWROdW1iZXJMaXN0KHByb3BzWydCT05EUyddWzBdLCAtMSkgOiBbXTtcclxuXHRcdHZhciBicmt4eXpTdHJzID0gcHJvcHNbJ0JSS1hZWiddO1xyXG5cdFx0c2cuYnJreHl6ID0gW107XHJcblx0XHRpZiAoYnJreHl6U3Rycykge1xyXG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGJya3h5elN0cnMubGVuZ3RoOyArK2opXHJcblx0XHRcdFx0c2cuYnJreHl6LnB1c2gocGFyc2VCcmFjZWROdW1iZXJMaXN0KGJya3h5elN0cnNbal0pKTtcclxuXHRcdH1cclxuXHRcdGlmIChwcm9wc1snTVVMVCddKSB7XHJcblx0XHRcdHNnLmRhdGEuc3Vic2NyaXB0ID0gcHJvcHNbJ01VTFQnXVswXSAtIDA7XHJcblx0XHR9XHJcblx0XHRpZiAocHJvcHNbJ0xBQkVMJ10pIHtcclxuXHRcdFx0c2cuZGF0YS5zdWJzY3JpcHQgPSBwcm9wc1snTEFCRUwnXVswXS5zdHJpcCgpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHByb3BzWydDT05ORUNUJ10pIHtcclxuXHRcdFx0c2cuZGF0YS5jb25uZWN0aXZpdHkgPSBwcm9wc1snQ09OTkVDVCddWzBdLnRvTG93ZXJDYXNlKCk7XHJcblx0XHR9XHJcblx0XHRpZiAocHJvcHNbJ0ZJRUxERElTUCddKSB7XHJcblx0XHRcdGFwcGx5RGF0YVNHcm91cEluZm8oc2csIHV0aWwuc3RyaXBRdW90ZXMocHJvcHNbJ0ZJRUxERElTUCddWzBdKSk7XHJcblx0XHR9XHJcblx0XHRpZiAocHJvcHNbJ0ZJRUxEREFUQSddKSB7XHJcblx0XHRcdGFwcGx5RGF0YVNHcm91cERhdGEoc2csIHByb3BzWydGSUVMRERBVEEnXVswXSwgdHJ1ZSk7XHJcblx0XHR9XHJcblx0XHRpZiAocHJvcHNbJ0ZJRUxETkFNRSddKSB7XHJcblx0XHRcdGFwcGx5RGF0YVNHcm91cE5hbWUoc2csIHByb3BzWydGSUVMRE5BTUUnXVswXSk7XHJcblx0XHR9XHJcblx0XHRpZiAocHJvcHNbJ1FVRVJZVFlQRSddKSB7XHJcblx0XHRcdGFwcGx5RGF0YVNHcm91cFF1ZXJ5KHNnLCBwcm9wc1snUVVFUllUWVBFJ11bMF0pO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHByb3BzWydRVUVSWU9QJ10pIHtcclxuXHRcdFx0YXBwbHlEYXRhU0dyb3VwUXVlcnlPcChzZywgcHJvcHNbJ1FVRVJZT1AnXVswXSk7XHJcblx0XHR9XHJcblx0XHRhZGRHcm91cChjdGFiLCBzZywgYXRvbU1hcCk7XHJcblx0fVxyXG5cdHRocm93IG5ldyBFcnJvcignUy1ncm91cCBkZWNsYXJhdGlvbiBpbmNvbXBsZXRlLicpO1xyXG59O1xyXG5cclxudmFyIHBhcnNlQ1RhYlYzMDAwID0gZnVuY3Rpb24gKGN0YWJMaW5lcywgbm9yZ3JvdXBzKVxyXG57XHJcbiAgICAvKiByZWFkZXIgKi9cclxuXHR2YXIgY3RhYiA9IG5ldyBTdHJ1Y3QoKTtcclxuXHJcblx0dmFyIHNoaWZ0ID0gMDtcclxuXHRpZiAoY3RhYkxpbmVzW3NoaWZ0KytdLnN0cmlwKCkgIT0gJ00gIFYzMCBCRUdJTiBDVEFCJylcclxuXHRcdHRocm93IEVycm9yKCdDVEFCIFYzMDAwIGludmFsaWQnKTtcclxuXHRpZiAoY3RhYkxpbmVzW3NoaWZ0XS5zbGljZSgwLCAxMykgIT0gJ00gIFYzMCBDT1VOVFMnKVxyXG5cdFx0dGhyb3cgRXJyb3IoJ0NUQUIgVjMwMDAgaW52YWxpZCcpO1xyXG5cdHZhciB2YWxzID0gY3RhYkxpbmVzW3NoaWZ0XS5zbGljZSgxNCkuc3BsaXQoJyAnKTtcclxuXHRjdGFiLmlzQ2hpcmFsID0gKHBhcnNlRGVjaW1hbEludCh2YWxzWzRdKSA9PSAxKTtcclxuXHRzaGlmdCsrO1xyXG5cclxuXHRpZiAoY3RhYkxpbmVzW3NoaWZ0XS5zdHJpcCgpID09ICdNICBWMzAgQkVHSU4gQVRPTScpIHtcclxuXHRcdHNoaWZ0Kys7XHJcblx0XHR2YXIgbGluZTtcclxuXHRcdHdoaWxlIChzaGlmdCA8IGN0YWJMaW5lcy5sZW5ndGgpIHtcclxuXHRcdFx0bGluZSA9c3RyaXBWMzAoY3RhYkxpbmVzW3NoaWZ0KytdKS5zdHJpcCgpO1xyXG5cdFx0XHRpZiAobGluZSA9PSAnRU5EIEFUT00nKVxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR3aGlsZSAobGluZS5jaGFyQXQobGluZS5sZW5ndGggLSAxKSA9PSAnLScpXHJcblx0XHRcdFx0bGluZSA9IChsaW5lLnN1YnN0cmluZygwLCBsaW5lLmxlbmd0aCAtIDEpICtzdHJpcFYzMChjdGFiTGluZXNbc2hpZnQrK10pKS5zdHJpcCgpO1xyXG5cdFx0XHRjdGFiLmF0b21zLmFkZChwYXJzZUF0b21MaW5lVjMwMDAobGluZSkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjdGFiTGluZXNbc2hpZnRdLnN0cmlwKCkgPT0gJ00gIFYzMCBCRUdJTiBCT05EJylcclxuXHRcdHtcclxuXHRcdFx0c2hpZnQrKztcclxuXHRcdFx0d2hpbGUgKHNoaWZ0IDwgY3RhYkxpbmVzLmxlbmd0aCkge1xyXG5cdFx0XHRcdGxpbmUgPXN0cmlwVjMwKGN0YWJMaW5lc1tzaGlmdCsrXSkuc3RyaXAoKTtcclxuXHRcdFx0XHRpZiAobGluZSA9PSAnRU5EIEJPTkQnKVxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0d2hpbGUgKGxpbmUuY2hhckF0KGxpbmUubGVuZ3RoIC0gMSkgPT0gJy0nKVxyXG5cdFx0XHRcdFx0bGluZSA9IChsaW5lLnN1YnN0cmluZygwLCBsaW5lLmxlbmd0aCAtIDEpICtzdHJpcFYzMChjdGFiTGluZXNbc2hpZnQrK10pKS5zdHJpcCgpO1xyXG5cdFx0XHRcdGN0YWIuYm9uZHMuYWRkKHBhcnNlQm9uZExpbmVWMzAwMChsaW5lKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBUT0RPOiBsZXQgc2VjdGlvbnMgZm9sbG93IGluIGFyYml0cmFyeSBvcmRlclxyXG5cdFx0dmFyIHNncm91cHMgPSB7fTtcclxuXHRcdHZhciBhdG9tTWFwID0ge307XHJcblxyXG5cdFx0d2hpbGUgKGN0YWJMaW5lc1tzaGlmdF0uc3RyaXAoKSAhPSAnTSAgVjMwIEVORCBDVEFCJykge1xyXG5cdFx0XHRpZiAoY3RhYkxpbmVzW3NoaWZ0XS5zdHJpcCgpID09ICdNICBWMzAgQkVHSU4gQ09MTEVDVElPTicpIHtcclxuXHRcdFx0XHQvLyBUT0RPOiByZWFkIGNvbGxlY3Rpb24gaW5mb3JtYXRpb25cclxuXHRcdFx0XHRzaGlmdCA9IHYzMDAwcGFyc2VDb2xsZWN0aW9uKGN0YWIsIGN0YWJMaW5lcywgc2hpZnQpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGN0YWJMaW5lc1tzaGlmdF0uc3RyaXAoKSA9PSAnTSAgVjMwIEJFR0lOIFNHUk9VUCcpIHtcclxuXHRcdFx0XHRzaGlmdCA9IHYzMDAwcGFyc2VTR3JvdXAoY3RhYiwgY3RhYkxpbmVzLCBzZ3JvdXBzLCBhdG9tTWFwLCBzaGlmdCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhyb3cgRXJyb3IoJ0NUQUIgVjMwMDAgaW52YWxpZCcpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChjdGFiTGluZXNbc2hpZnQrK10uc3RyaXAoKSAhPSAnTSAgVjMwIEVORCBDVEFCJylcclxuXHRcdHRocm93IEVycm9yKCdDVEFCIFYzMDAwIGludmFsaWQnKTtcclxuXHJcblx0aWYgKCFub3Jncm91cHMpIHtcclxuXHRcdHJlYWRSR3JvdXBzMzAwMChjdGFiLCBjdGFiTGluZXMuc2xpY2Uoc2hpZnQpKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBjdGFiO1xyXG59O1xyXG5cclxudmFyIHJlYWRSR3JvdXBzMzAwMCA9IGZ1bmN0aW9uIChjdGFiLCAvKiBzdHJpbmcgKi8gY3RhYkxpbmVzKSAvKiBTdHJ1Y3QgKi9cclxue1xyXG4gICAgLyogcmVhZGVyICovXHJcblx0dmFyIHJmcmFncyA9IHt9O1xyXG5cdHZhciByTG9naWMgPSB7fTtcclxuXHR2YXIgc2hpZnQgPSAwO1xyXG5cdHdoaWxlIChzaGlmdCA8IGN0YWJMaW5lcy5sZW5ndGggJiYgY3RhYkxpbmVzW3NoaWZ0XS5zZWFyY2goJ00gIFYzMCBCRUdJTiBSR1JPVVAnKSA9PSAwKVxyXG5cdHtcclxuXHRcdHZhciBpZCA9IGN0YWJMaW5lc1tzaGlmdCsrXS5zcGxpdCgnICcpLnBvcCgpO1xyXG5cdFx0cmZyYWdzW2lkXSA9IFtdO1xyXG5cdFx0ckxvZ2ljW2lkXSA9IHt9O1xyXG5cdFx0d2hpbGUgKHRydWUpIHtcclxuXHRcdFx0dmFyIGxpbmUgPSBjdGFiTGluZXNbc2hpZnRdLnN0cmlwKCk7XHJcblx0XHRcdGlmIChsaW5lLnNlYXJjaCgnTSAgVjMwIFJMT0dJQycpID09IDApIHtcclxuXHRcdFx0XHRsaW5lID0gbGluZS5zbGljZSgxMyk7XHJcblx0XHRcdFx0dmFyIHJsc3BsaXQgPSBsaW5lLnN0cmlwKCkuc3BsaXQoL1xccysvZyk7XHJcblx0XHRcdFx0dmFyIGlpaSA9IHBhcnNlRGVjaW1hbEludChybHNwbGl0WzBdKTtcclxuXHRcdFx0XHR2YXIgaGhoID0gcGFyc2VEZWNpbWFsSW50KHJsc3BsaXRbMV0pO1xyXG5cdFx0XHRcdHZhciBvb28gPSBybHNwbGl0LnNsaWNlKDIpLmpvaW4oJyAnKTtcclxuXHRcdFx0XHR2YXIgbG9naWMgPSB7fTtcclxuXHRcdFx0XHRpZiAoaWlpID4gMClcclxuXHRcdFx0XHRcdGxvZ2ljLmlmdGhlbiA9IGlpaTtcclxuXHRcdFx0XHRsb2dpYy5yZXN0aCA9IGhoaCA9PSAxO1xyXG5cdFx0XHRcdGxvZ2ljLnJhbmdlID0gb29vO1xyXG5cdFx0XHRcdHJMb2dpY1tpZF0gPSBsb2dpYztcclxuXHRcdFx0XHRzaGlmdCsrO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChsaW5lICE9ICdNICBWMzAgQkVHSU4gQ1RBQicpXHJcblx0XHRcdFx0dGhyb3cgRXJyb3IoJ0NUQUIgVjMwMDAgaW52YWxpZCcpO1xyXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGN0YWJMaW5lcy5sZW5ndGg7ICsraSlcclxuXHRcdFx0XHRpZiAoY3RhYkxpbmVzW3NoaWZ0ICsgaV0uc3RyaXAoKSA9PSAnTSAgVjMwIEVORCBDVEFCJylcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR2YXIgbGluZXMgPSBjdGFiTGluZXMuc2xpY2Uoc2hpZnQsIHNoaWZ0ICsgaSArIDEpO1xyXG5cdFx0XHR2YXIgcmZyYWcgPSBwYXJzZUNUYWJWMzAwMChsaW5lcywgdHJ1ZSk7XHJcblx0XHRcdHJmcmFnc1tpZF0ucHVzaChyZnJhZyk7XHJcblx0XHRcdHNoaWZ0ID0gc2hpZnQgKyBpICsgMTtcclxuXHRcdFx0aWYgKGN0YWJMaW5lc1tzaGlmdF0uc3RyaXAoKSA9PSAnTSAgVjMwIEVORCBSR1JPVVAnKSB7XHJcblx0XHRcdFx0c2hpZnQrKztcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Zm9yICh2YXIgcmdpZCBpbiByZnJhZ3MpIHtcclxuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgcmZyYWdzW3JnaWRdLmxlbmd0aDsgKytqKSB7XHJcblx0XHRcdHZhciByZyA9IHJmcmFnc1tyZ2lkXVtqXTtcclxuXHRcdFx0cmcucmdyb3Vwcy5zZXQocmdpZCwgbmV3IFN0cnVjdC5SR3JvdXAockxvZ2ljW3JnaWRdKSk7XHJcblx0XHRcdHZhciBmcmlkID0gcmcuZnJhZ3MuYWRkKG5ldyBTdHJ1Y3QuRnJhZ21lbnQoKSk7XHJcblx0XHRcdHJnLnJncm91cHMuZ2V0KHJnaWQpLmZyYWdzLmFkZChmcmlkKTtcclxuXHRcdFx0cmcuYXRvbXMuZWFjaChmdW5jdGlvbiAoYWlkLCBhdG9tKSB7YXRvbS5mcmFnbWVudCA9IGZyaWQ7fSk7XHJcblx0XHRcdHJnLm1lcmdlSW50byhjdGFiKTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxyXG52YXIgcGFyc2VNb2wgPSBmdW5jdGlvbiAoLyogc3RyaW5nICovIGN0YWJMaW5lcykgLyogU3RydWN0ICovXHJcbntcclxuICAgIC8qIHJlYWRlciAqL1xyXG5cdGlmIChjdGFiTGluZXNbMF0uc2VhcmNoKCdcXFxcJE1ETCcpID09IDApIHtcclxuXHRcdHJldHVybiBwYXJzZVJnMjAwMChjdGFiTGluZXMpO1xyXG5cdH1cclxuXHR2YXIgc3RydWN0ID0gcGFyc2VDVGFiKGN0YWJMaW5lcy5zbGljZSgzKSk7XHJcblx0c3RydWN0Lm5hbWUgPSBjdGFiTGluZXNbMF0uc3RyaXAoKTtcclxuXHRyZXR1cm4gc3RydWN0O1xyXG59O1xyXG5cclxudmFyIHBhcnNlQ1RhYiA9IGZ1bmN0aW9uICgvKiBzdHJpbmcgKi8gY3RhYkxpbmVzKSAvKiBTdHJ1Y3QgKi9cclxue1xyXG4gICAgLyogcmVhZGVyICovXHJcblx0dmFyIGNvdW50c1NwbGl0ID0gcGFydGl0aW9uTGluZShjdGFiTGluZXNbMF0sIGZtdEluZm8uY291bnRzTGluZVBhcnRpdGlvbik7XHJcblx0dmFyIHZlcnNpb24gPSBjb3VudHNTcGxpdFsxMV0uc3RyaXAoKTtcclxuXHRjdGFiTGluZXMgPSBjdGFiTGluZXMuc2xpY2UoMSk7XHJcblx0aWYgKHZlcnNpb24gPT0gJ1YyMDAwJylcclxuXHRcdHJldHVybiBwYXJzZUNUYWJWMjAwMChjdGFiTGluZXMsIGNvdW50c1NwbGl0KTtcclxuXHRlbHNlIGlmICh2ZXJzaW9uID09ICdWMzAwMCcpXHJcblx0XHRyZXR1cm4gcGFyc2VDVGFiVjMwMDAoY3RhYkxpbmVzLCAhTW9sZmlsZS5sb2FkUkdyb3VwRnJhZ21lbnRzKTtcclxuXHRlbHNlXHJcblx0XHR0aHJvdyBFcnJvcignTW9sZmlsZSB2ZXJzaW9uIHVua25vd246ICcgKyB2ZXJzaW9uKTtcclxufTtcclxuXHJcbk1vbGZpbGUucHJvdG90eXBlLnByZXBhcmVTR3JvdXBzID0gZnVuY3Rpb24gKHNraXBFcnJvcnMsIHByZXNlcnZlSW5kaWdvRGVzYykge1xyXG4gICAgdmFyIG1vbCA9IHRoaXMubW9sZWN1bGU7XHJcbiAgICB2YXIgc2dyb3VwcyA9IG1vbC5zZ3JvdXBzO1xyXG4gICAgdmFyIHRvUmVtb3ZlID0gW107XHJcbiAgICB2YXIgZXJyb3JzID0gMDtcclxuXHJcbiAgICB1dGlsLmVhY2godGhpcy5tb2xlY3VsZS5zR3JvdXBGb3Jlc3QuZ2V0U0dyb3Vwc0JGUygpLnJldmVyc2UoKSwgZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgdmFyIHNnID0gbW9sLnNncm91cHMuZ2V0KGlkKTtcclxuICAgICAgICB2YXIgZXJyb3JJZ25vcmUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgc2cucHJlcGFyZUZvclNhdmluZyhtb2wpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XHJcbiAgICAgICAgICAgIGlmICghc2tpcEVycm9ycyB8fCB0eXBlb2YgKGV4LmlkKSAhPSAnbnVtYmVyJylcclxuICAgICAgICAgICAgICAgIHRocm93IGV4O1xyXG4gICAgICAgICAgICBlcnJvcklnbm9yZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlcnJvcklnbm9yZSB8fFxyXG5cdFx0ICAgICFwcmVzZXJ2ZUluZGlnb0Rlc2MgJiYgL15JTkRJR09fLitfREVTQyQvaS50ZXN0KHNnLmRhdGEuZmllbGROYW1lKSkge1xyXG4gICAgICAgICAgICBlcnJvcnMgKz0gZXJyb3JJZ25vcmU7XHJcbiAgICAgICAgICAgIHRvUmVtb3ZlLnB1c2goc2cuaWQpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIHRoaXMpO1xyXG4gICAgaWYgKGVycm9ycykge1xyXG4gICAgICAgIGFsZXJ0KCdXQVJOSU5HOiAnICsgZXJyb3JzICsgJyBpbnZhbGlkIFMtZ3JvdXBzIHdlcmUgZGV0ZWN0ZWQuIFRoZXkgd2lsbCBiZSBvbWl0dGVkLicpO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9SZW1vdmUubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBtb2wuc0dyb3VwRGVsZXRlKHRvUmVtb3ZlW2ldKTtcclxuICAgIH1cclxuICAgIHJldHVybiBtb2w7XHJcbn07XHJcblxyXG5Nb2xmaWxlLnByb3RvdHlwZS5nZXRDVGFiID0gZnVuY3Rpb24gKG1vbGVjdWxlLCByZ3JvdXBzKVxyXG57XHJcbiAgICAvKiBzYXZlciAqL1xyXG5cdHRoaXMubW9sZWN1bGUgPSBtb2xlY3VsZS5jbG9uZSgpO1xyXG5cdHRoaXMubW9sZmlsZSA9ICcnO1xyXG5cdHRoaXMud3JpdGVDVGFiMjAwMChyZ3JvdXBzKTtcclxuXHRyZXR1cm4gdGhpcy5tb2xmaWxlO1xyXG59O1xyXG5cclxuTW9sZmlsZS5wcm90b3R5cGUuc2F2ZU1vbGVjdWxlID0gZnVuY3Rpb24gKG1vbGVjdWxlLCBza2lwU0dyb3VwRXJyb3JzLCBub3Jncm91cHMsIHByZXNlcnZlSW5kaWdvRGVzYylcclxue1xyXG4gICAgLyogc2F2ZXIgKi9cclxuXHR0aGlzLnJlYWN0aW9uID0gbW9sZWN1bGUucnhuQXJyb3dzLmNvdW50KCkgPiAwO1xyXG5cdGlmIChtb2xlY3VsZS5yeG5BcnJvd3MuY291bnQoKSA+IDEpXHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0aW9uIG1heSBub3QgY29udGFpbiBtb3JlIHRoYW4gb25lIGFycm93Jyk7XHJcblx0dGhpcy5tb2xmaWxlID0gJyc7XHJcblx0aWYgKHRoaXMucmVhY3Rpb24pIHtcclxuXHRcdGlmIChtb2xlY3VsZS5yZ3JvdXBzLmNvdW50KCkgPiAwKVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBzYXZlIHRoZSBzdHJ1Y3R1cmUgLSByZWFjdGlvbnMgd2l0aCByLWdyb3VwcyBhcmUgbm90IHN1cHBvcnRlZCBhdCB0aGUgbW9tZW50Jyk7XHJcblx0XHR2YXIgY29tcG9uZW50cyA9IG1vbGVjdWxlLmdldENvbXBvbmVudHMoKTtcclxuXHJcblx0XHR2YXIgcmVhY3RhbnRzID0gY29tcG9uZW50cy5yZWFjdGFudHMsIHByb2R1Y3RzID0gY29tcG9uZW50cy5wcm9kdWN0cywgYWxsID0gcmVhY3RhbnRzLmNvbmNhdChwcm9kdWN0cyk7XHJcblx0XHR0aGlzLm1vbGZpbGUgPSAnJFJYTlxcblxcblxcblxcbicgKyB1dGlsLnBhZGRlZEludChyZWFjdGFudHMubGVuZ3RoLCAzKSArIHV0aWwucGFkZGVkSW50KHByb2R1Y3RzLmxlbmd0aCwgMykgKyB1dGlsLnBhZGRlZEludCgwLCAzKSArICdcXG4nO1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyArK2kpIHtcclxuXHRcdFx0dmFyIHNhdmVyID0gbmV3IE1vbGZpbGUoZmFsc2UpO1xyXG5cdFx0XHR2YXIgc3VibW9sID0gbW9sZWN1bGUuY2xvbmUoYWxsW2ldLCBudWxsLCB0cnVlKTtcclxuXHRcdFx0dmFyIG1vbGZpbGUgPSBzYXZlci5zYXZlTW9sZWN1bGUoc3VibW9sLCBmYWxzZSwgdHJ1ZSk7XHJcblx0XHRcdHRoaXMubW9sZmlsZSArPSAnJE1PTFxcbicgKyBtb2xmaWxlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMubW9sZmlsZTtcclxuXHR9XHJcblxyXG5cdGlmIChtb2xlY3VsZS5yZ3JvdXBzLmNvdW50KCkgPiAwKSB7XHJcblx0XHRpZiAobm9yZ3JvdXBzKSB7XHJcblx0XHRcdG1vbGVjdWxlID0gbW9sZWN1bGUuZ2V0U2NhZmZvbGQoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZhciBzY2FmZm9sZCA9IG5ldyBNb2xmaWxlKGZhbHNlKS5nZXRDVGFiKG1vbGVjdWxlLmdldFNjYWZmb2xkKCksIG1vbGVjdWxlLnJncm91cHMpO1xyXG5cdFx0XHR0aGlzLm1vbGZpbGUgPSAnJE1ETCAgUkVWICAxXFxuJE1PTFxcbiRIRFJcXG5cXG5cXG5cXG4kRU5EIEhEUlxcbic7XHJcblx0XHRcdHRoaXMubW9sZmlsZSArPSAnJENUQUJcXG4nICsgc2NhZmZvbGQgKyAnJEVORCBDVEFCXFxuJztcclxuXHJcblx0XHRcdG1vbGVjdWxlLnJncm91cHMuZWFjaChmdW5jdGlvbiAocmdpZCwgcmcpe1xyXG5cdFx0XHRcdHRoaXMubW9sZmlsZSArPSAnJFJHUFxcbic7XHJcblx0XHRcdFx0dGhpcy53cml0ZVBhZGRlZE51bWJlcihyZ2lkLCAzKTtcclxuXHRcdFx0XHR0aGlzLm1vbGZpbGUgKz0gJ1xcbic7XHJcblx0XHRcdFx0cmcuZnJhZ3MuZWFjaChmdW5jdGlvbiAoZm51bSwgZmlkKSB7XHJcblx0XHRcdFx0XHR2YXIgZ3JvdXAgPSBuZXcgTW9sZmlsZShmYWxzZSkuZ2V0Q1RhYihtb2xlY3VsZS5nZXRGcmFnbWVudChmaWQpKTtcclxuXHRcdFx0XHRcdHRoaXMubW9sZmlsZSArPSAnJENUQUJcXG4nICsgZ3JvdXAgKyAnJEVORCBDVEFCXFxuJztcclxuXHRcdFx0XHR9LCB0aGlzKTtcclxuXHRcdFx0XHR0aGlzLm1vbGZpbGUgKz0gJyRFTkQgUkdQXFxuJztcclxuXHRcdFx0fSwgdGhpcyk7XHJcblx0XHRcdHRoaXMubW9sZmlsZSArPSAnJEVORCBNT0xcXG4nO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMubW9sZmlsZTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHRoaXMubW9sZWN1bGUgPSBtb2xlY3VsZS5jbG9uZSgpO1xyXG5cclxuXHR0aGlzLnByZXBhcmVTR3JvdXBzKHNraXBTR3JvdXBFcnJvcnMsIHByZXNlcnZlSW5kaWdvRGVzYyk7XHJcblxyXG5cdHRoaXMud3JpdGVIZWFkZXIoKTtcclxuXHJcblx0Ly8gVE9ETzogc2F2aW5nIHRvIFYzMDAwXHJcblx0dGhpcy53cml0ZUNUYWIyMDAwKCk7XHJcblxyXG5cdHJldHVybiB0aGlzLm1vbGZpbGU7XHJcbn07XHJcblxyXG5Nb2xmaWxlLnByb3RvdHlwZS53cml0ZUhlYWRlciA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIC8qIHNhdmVyICovXHJcblxyXG5cdHZhciBkYXRlID0gbmV3IERhdGUoKTtcclxuXHJcblx0dGhpcy53cml0ZUNSKCk7IC8vIFRPRE86IHdyaXRlIHN0cnVjdHVyZSBuYW1lXHJcblx0dGhpcy53cml0ZVdoaXRlU3BhY2UoMik7XHJcblx0dGhpcy53cml0ZSgnS2V0Y2hlcicpO1xyXG5cdHRoaXMud3JpdGVXaGl0ZVNwYWNlKCk7XHJcblx0dGhpcy53cml0ZUNSKChkYXRlLmdldE1vbnRoKCkgKyAxKS50b1BhZGRlZFN0cmluZygyKSArIGRhdGUuZ2V0RGF0ZSgpLnRvUGFkZGVkU3RyaW5nKDIpICsgKGRhdGUuZ2V0RnVsbFllYXIoKSAlIDEwMCkudG9QYWRkZWRTdHJpbmcoMikgK1xyXG5cdGRhdGUuZ2V0SG91cnMoKS50b1BhZGRlZFN0cmluZygyKSArIGRhdGUuZ2V0TWludXRlcygpLnRvUGFkZGVkU3RyaW5nKDIpICsgJzJEIDEgICAxLjAwMDAwICAgICAwLjAwMDAwICAgICAwJyk7XHJcblx0dGhpcy53cml0ZUNSKCk7XHJcbn07XHJcblxyXG5Nb2xmaWxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChzdHIpXHJcbntcclxuICAgIC8qIHNhdmVyICovXHJcblx0dGhpcy5tb2xmaWxlICs9IHN0cjtcclxufTtcclxuXHJcbk1vbGZpbGUucHJvdG90eXBlLndyaXRlQ1IgPSBmdW5jdGlvbiAoc3RyKVxyXG57XHJcbiAgICAvKiBzYXZlciAqL1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09IDApXHJcblx0XHRzdHIgPSAnJztcclxuXHJcblx0dGhpcy5tb2xmaWxlICs9IHN0ciArICdcXG4nO1xyXG59O1xyXG5cclxuTW9sZmlsZS5wcm90b3R5cGUud3JpdGVXaGl0ZVNwYWNlID0gZnVuY3Rpb24gKGxlbmd0aClcclxue1xyXG4gICAgLyogc2F2ZXIgKi9cclxuXHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMClcclxuXHRcdGxlbmd0aCA9IDE7XHJcblxyXG5cdGxlbmd0aC50aW1lcyhmdW5jdGlvbiAoKVxyXG5cdHtcclxuXHRcdHRoaXMud3JpdGUoJyAnKTtcclxuXHR9LCB0aGlzKTtcclxufTtcclxuXHJcbk1vbGZpbGUucHJvdG90eXBlLndyaXRlUGFkZGVkID0gZnVuY3Rpb24gKHN0ciwgd2lkdGgpXHJcbntcclxuICAgIC8qIHNhdmVyICovXHJcblx0dGhpcy53cml0ZShzdHIpO1xyXG5cdHRoaXMud3JpdGVXaGl0ZVNwYWNlKHdpZHRoIC0gc3RyLmxlbmd0aCk7XHJcbn07XHJcblxyXG5Nb2xmaWxlLnByb3RvdHlwZS53cml0ZVBhZGRlZE51bWJlciA9IGZ1bmN0aW9uIChudW1iZXIsIHdpZHRoKVxyXG57XHJcbiAgICAvKiBzYXZlciAqL1xyXG5cclxuXHR2YXIgc3RyID0gKG51bWJlciAtIDApLnRvU3RyaW5nKCk7XHJcblxyXG5cdHRoaXMud3JpdGVXaGl0ZVNwYWNlKHdpZHRoIC0gc3RyLmxlbmd0aCk7XHJcblx0dGhpcy53cml0ZShzdHIpO1xyXG59O1xyXG5cclxuTW9sZmlsZS5wcm90b3R5cGUud3JpdGVQYWRkZWRGbG9hdCA9IGZ1bmN0aW9uIChudW1iZXIsIHdpZHRoLCBwcmVjaXNpb24pXHJcbntcclxuICAgIC8qIHNhdmVyICovXHJcblxyXG5cdHRoaXMud3JpdGUodXRpbC5wYWRkZWRGbG9hdChudW1iZXIsIHdpZHRoLCBwcmVjaXNpb24pKTtcclxufTtcclxuXHJcbk1vbGZpbGUucHJvdG90eXBlLndyaXRlQ1RhYjIwMDBIZWFkZXIgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICAvKiBzYXZlciAqL1xyXG5cclxuXHR0aGlzLndyaXRlUGFkZGVkTnVtYmVyKHRoaXMubW9sZWN1bGUuYXRvbXMuY291bnQoKSwgMyk7XHJcblx0dGhpcy53cml0ZVBhZGRlZE51bWJlcih0aGlzLm1vbGVjdWxlLmJvbmRzLmNvdW50KCksIDMpO1xyXG5cclxuXHR0aGlzLndyaXRlUGFkZGVkTnVtYmVyKDAsIDMpO1xyXG5cdHRoaXMud3JpdGVXaGl0ZVNwYWNlKDMpO1xyXG5cdHRoaXMud3JpdGVQYWRkZWROdW1iZXIodGhpcy5tb2xlY3VsZS5pc0NoaXJhbCA/IDEgOiAwLCAzKTtcclxuXHR0aGlzLndyaXRlUGFkZGVkTnVtYmVyKDAsIDMpO1xyXG5cdHRoaXMud3JpdGVXaGl0ZVNwYWNlKDEyKTtcclxuXHR0aGlzLndyaXRlUGFkZGVkTnVtYmVyKDk5OSwgMyk7XHJcblx0dGhpcy53cml0ZUNSKCcgVjIwMDAnKTtcclxufTtcclxuXHJcbk1vbGZpbGUucHJvdG90eXBlLndyaXRlQ1RhYjIwMDAgPSBmdW5jdGlvbiAocmdyb3Vwcylcclxue1xyXG4gICAgLyogc2F2ZXIgKi9cclxuXHR0aGlzLndyaXRlQ1RhYjIwMDBIZWFkZXIoKTtcclxuXHJcblx0dGhpcy5tYXBwaW5nID0ge307XHJcblx0dmFyIGkgPSAxO1xyXG5cclxuXHR2YXIgYXRvbUxpc3RfbGlzdCA9IFtdO1xyXG5cdHZhciBhdG9tTGFiZWxfbGlzdCA9IFtdO1xyXG5cdHRoaXMubW9sZWN1bGUuYXRvbXMuZWFjaChmdW5jdGlvbiAoaWQsIGF0b20pXHJcblx0e1xyXG5cdFx0dGhpcy53cml0ZVBhZGRlZEZsb2F0KGF0b20ucHAueCwgMTAsIDQpO1xyXG5cdFx0dGhpcy53cml0ZVBhZGRlZEZsb2F0KC1hdG9tLnBwLnksIDEwLCA0KTtcclxuXHRcdHRoaXMud3JpdGVQYWRkZWRGbG9hdCgwLCAxMCwgNCk7XHJcblx0XHR0aGlzLndyaXRlV2hpdGVTcGFjZSgpO1xyXG5cclxuXHRcdHZhciBsYWJlbCA9IGF0b20ubGFiZWw7XHJcblx0XHRpZiAoYXRvbS5hdG9tTGlzdCAhPSBudWxsKSB7XHJcblx0XHRcdGxhYmVsID0gJ0wnO1xyXG5cdFx0XHRhdG9tTGlzdF9saXN0LnB1c2goaWQpO1xyXG5cdFx0fSBlbHNlIGlmIChlbGVtZW50LmdldEVsZW1lbnRCeUxhYmVsKGxhYmVsKSA9PSBudWxsICYmIFsnQScsICdRJywgJ1gnLCAnKicsICdSIyddLmluZGV4T2YobGFiZWwpID09IC0xKSB7XHJcblx0XHRcdGxhYmVsID0gJ0MnO1xyXG5cdFx0XHRhdG9tTGFiZWxfbGlzdC5wdXNoKGlkKTtcclxuXHRcdH1cclxuXHRcdHRoaXMud3JpdGVQYWRkZWQobGFiZWwsIDMpO1xyXG5cdFx0dGhpcy53cml0ZVBhZGRlZE51bWJlcigwLCAyKTtcclxuXHRcdHRoaXMud3JpdGVQYWRkZWROdW1iZXIoMCwgMyk7XHJcblx0XHR0aGlzLndyaXRlUGFkZGVkTnVtYmVyKDAsIDMpO1xyXG5cclxuXHRcdGlmIChPYmplY3QuaXNVbmRlZmluZWQoYXRvbS5oQ291bnQpKVxyXG5cdFx0XHRhdG9tLmhDb3VudCA9IDA7XHJcblx0XHR0aGlzLndyaXRlUGFkZGVkTnVtYmVyKGF0b20uaENvdW50LCAzKTtcclxuXHJcblx0XHRpZiAoT2JqZWN0LmlzVW5kZWZpbmVkKGF0b20uc3RlcmVvQ2FyZSkpXHJcblx0XHRcdGF0b20uc3RlcmVvQ2FyZSA9IDA7XHJcblx0XHR0aGlzLndyaXRlUGFkZGVkTnVtYmVyKGF0b20uc3RlcmVvQ2FyZSwgMyk7XHJcblxyXG5cdFx0dGhpcy53cml0ZVBhZGRlZE51bWJlcihhdG9tLmV4cGxpY2l0VmFsZW5jZSA8IDAgPyAwIDogKGF0b20uZXhwbGljaXRWYWxlbmNlID09IDAgPyAxNSA6IGF0b20uZXhwbGljaXRWYWxlbmNlKSwgMyk7XHJcblxyXG5cdFx0dGhpcy53cml0ZVBhZGRlZE51bWJlcigwLCAzKTtcclxuXHRcdHRoaXMud3JpdGVQYWRkZWROdW1iZXIoMCwgMyk7XHJcblx0XHR0aGlzLndyaXRlUGFkZGVkTnVtYmVyKDAsIDMpO1xyXG5cclxuXHRcdGlmIChPYmplY3QuaXNVbmRlZmluZWQoYXRvbS5hYW0pKVxyXG5cdFx0XHRhdG9tLmFhbSA9IDA7XHJcblx0XHR0aGlzLndyaXRlUGFkZGVkTnVtYmVyKGF0b20uYWFtLCAzKTtcclxuXHJcblx0XHRpZiAoT2JqZWN0LmlzVW5kZWZpbmVkKGF0b20uaW52UmV0KSlcclxuXHRcdFx0YXRvbS5pbnZSZXQgPSAwO1xyXG5cdFx0dGhpcy53cml0ZVBhZGRlZE51bWJlcihhdG9tLmludlJldCwgMyk7XHJcblxyXG5cdFx0aWYgKE9iamVjdC5pc1VuZGVmaW5lZChhdG9tLmV4YWN0Q2hhbmdlRmxhZykpXHJcblx0XHRcdGF0b20uZXhhY3RDaGFuZ2VGbGFnID0gMDtcclxuXHRcdHRoaXMud3JpdGVQYWRkZWROdW1iZXIoYXRvbS5leGFjdENoYW5nZUZsYWcsIDMpO1xyXG5cclxuXHRcdHRoaXMud3JpdGVDUigpO1xyXG5cclxuXHRcdHRoaXMubWFwcGluZ1tpZF0gPSBpO1xyXG5cdFx0aSsrO1xyXG5cdH0sIHRoaXMpO1xyXG5cclxuXHR0aGlzLmJvbmRNYXBwaW5nID0ge307XHJcblx0aSA9IDE7XHJcblx0dGhpcy5tb2xlY3VsZS5ib25kcy5lYWNoKGZ1bmN0aW9uIChpZCwgYm9uZClcclxuXHR7XHJcblx0XHR0aGlzLmJvbmRNYXBwaW5nW2lkXSA9IGkrKztcclxuXHRcdHRoaXMud3JpdGVQYWRkZWROdW1iZXIodGhpcy5tYXBwaW5nW2JvbmQuYmVnaW5dLCAzKTtcclxuXHRcdHRoaXMud3JpdGVQYWRkZWROdW1iZXIodGhpcy5tYXBwaW5nW2JvbmQuZW5kXSwgMyk7XHJcblx0XHR0aGlzLndyaXRlUGFkZGVkTnVtYmVyKGJvbmQudHlwZSwgMyk7XHJcblxyXG5cdFx0aWYgKE9iamVjdC5pc1VuZGVmaW5lZChib25kLnN0ZXJlbykpXHJcblx0XHRcdGJvbmQuc3RlcmVvID0gMDtcclxuXHRcdHRoaXMud3JpdGVQYWRkZWROdW1iZXIoYm9uZC5zdGVyZW8sIDMpO1xyXG5cclxuXHRcdHRoaXMud3JpdGVXaGl0ZVNwYWNlKDMpO1xyXG5cclxuXHRcdGlmIChPYmplY3QuaXNVbmRlZmluZWQoYm9uZC50b3BvbG9neSkpXHJcblx0XHRcdGJvbmQudG9wb2xvZ3kgPSAwO1xyXG5cdFx0dGhpcy53cml0ZVBhZGRlZE51bWJlcihib25kLnRvcG9sb2d5LCAzKTtcclxuXHJcblx0XHRpZiAoT2JqZWN0LmlzVW5kZWZpbmVkKGJvbmQucmVhY3RpbmdDZW50ZXJTdGF0dXMpKVxyXG5cdFx0XHRib25kLnJlYWN0aW5nQ2VudGVyU3RhdHVzID0gMDtcclxuXHRcdHRoaXMud3JpdGVQYWRkZWROdW1iZXIoYm9uZC5yZWFjdGluZ0NlbnRlclN0YXR1cywgMyk7XHJcblxyXG5cdFx0dGhpcy53cml0ZUNSKCk7XHJcblx0fSwgdGhpcyk7XHJcblxyXG5cdHdoaWxlIChhdG9tTGFiZWxfbGlzdC5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLndyaXRlKCdBICAnKTt0aGlzLndyaXRlUGFkZGVkTnVtYmVyKGF0b21MYWJlbF9saXN0WzBdICsgMSwgMyk7dGhpcy53cml0ZUNSKCk7XHJcblx0XHR0aGlzLndyaXRlQ1IodGhpcy5tb2xlY3VsZS5hdG9tcy5nZXQoYXRvbUxhYmVsX2xpc3RbMF0pLmxhYmVsKTtcclxuXHRcdGF0b21MYWJlbF9saXN0LnNwbGljZSgwLCAxKTtcclxuXHR9XHJcblxyXG5cdHZhciBjaGFyZ2VfbGlzdCA9IG5ldyBBcnJheSgpO1xyXG5cdHZhciBpc290b3BlX2xpc3QgPSBuZXcgQXJyYXkoKTtcclxuXHR2YXIgcmFkaWNhbF9saXN0ID0gbmV3IEFycmF5KCk7XHJcblx0dmFyIHJnbGFiZWxfbGlzdCA9IG5ldyBBcnJheSgpO1xyXG5cdHZhciByZ2xvZ2ljX2xpc3QgPSBuZXcgQXJyYXkoKTtcclxuXHR2YXIgYXBsYWJlbF9saXN0ID0gbmV3IEFycmF5KCk7XHJcblx0dmFyIHJiY291bnRfbGlzdCA9IG5ldyBBcnJheSgpO1xyXG5cdHZhciB1bnNhdHVyYXRlZF9saXN0ID0gbmV3IEFycmF5KCk7XHJcblx0dmFyIHN1YnN0Y291bnRfbGlzdCA9IG5ldyBBcnJheSgpO1xyXG5cclxuXHR0aGlzLm1vbGVjdWxlLmF0b21zLmVhY2goZnVuY3Rpb24gKGlkLCBhdG9tKVxyXG5cdHtcclxuXHRcdGlmIChhdG9tLmNoYXJnZSAhPSAwKVxyXG5cdFx0XHRjaGFyZ2VfbGlzdC5wdXNoKFtpZCwgYXRvbS5jaGFyZ2VdKTtcclxuXHRcdGlmIChhdG9tLmlzb3RvcGUgIT0gMClcclxuXHRcdFx0aXNvdG9wZV9saXN0LnB1c2goW2lkLCBhdG9tLmlzb3RvcGVdKTtcclxuXHRcdGlmIChhdG9tLnJhZGljYWwgIT0gMClcclxuXHRcdFx0cmFkaWNhbF9saXN0LnB1c2goW2lkLCBhdG9tLnJhZGljYWxdKTtcclxuXHRcdGlmIChhdG9tLnJnbGFiZWwgIT0gbnVsbCAmJiBhdG9tLmxhYmVsID09ICdSIycpIHsgLy8gVE9ETyBuZWVkIHRvIGZvcmNlIHJnbGFiZWw9bnVsbCB3aGVuIGxhYmVsIGlzIG5vdCAnUiMnXHJcblx0XHRcdGZvciAodmFyIHJnaSA9IDA7IHJnaSA8IDMyOyByZ2krKykge1xyXG5cdFx0XHRcdGlmIChhdG9tLnJnbGFiZWwgJiAoMSA8PCByZ2kpKSByZ2xhYmVsX2xpc3QucHVzaChbaWQsIHJnaSArIDFdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKGF0b20uYXR0cG50ICE9IG51bGwpXHJcblx0XHRcdGFwbGFiZWxfbGlzdC5wdXNoKFtpZCwgYXRvbS5hdHRwbnRdKTtcclxuXHRcdGlmIChhdG9tLnJpbmdCb25kQ291bnQgIT0gMClcclxuXHRcdFx0cmJjb3VudF9saXN0LnB1c2goW2lkLCBhdG9tLnJpbmdCb25kQ291bnRdKTtcclxuXHRcdGlmIChhdG9tLnN1YnN0aXR1dGlvbkNvdW50ICE9IDApXHJcblx0XHRcdHN1YnN0Y291bnRfbGlzdC5wdXNoKFtpZCwgYXRvbS5zdWJzdGl0dXRpb25Db3VudF0pO1xyXG5cdFx0aWYgKGF0b20udW5zYXR1cmF0ZWRBdG9tICE9IDApXHJcblx0XHRcdHVuc2F0dXJhdGVkX2xpc3QucHVzaChbaWQsIGF0b20udW5zYXR1cmF0ZWRBdG9tXSk7XHJcblx0fSk7XHJcblxyXG5cdGlmIChyZ3JvdXBzKVxyXG5cdFx0cmdyb3Vwcy5lYWNoKGZ1bmN0aW9uIChyZ2lkLCByZykge1xyXG5cdFx0XHRpZiAocmcucmVzdGggfHwgcmcuaWZ0aGVuID4gMCB8fCByZy5yYW5nZS5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0dmFyIGxpbmUgPSAnICAxICcgKyB1dGlsLnBhZGRlZEludChyZ2lkLCAzKSArICcgJyArIHV0aWwucGFkZGVkSW50KHJnLmlmdGhlbiwgMykgKyAnICcgKyB1dGlsLnBhZGRlZEludChyZy5yZXN0aCA/IDEgOiAwLCAzKSArICcgICAnICsgcmcucmFuZ2U7XHJcblx0XHRcdFx0cmdsb2dpY19saXN0LnB1c2gobGluZSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHR2YXIgd3JpdGVBdG9tUHJvcExpc3QgPSBmdW5jdGlvbiAocHJvcF9pZCwgdmFsdWVzKVxyXG5cdHtcclxuXHRcdHdoaWxlICh2YWx1ZXMubGVuZ3RoID4gMClcclxuXHRcdHtcclxuXHRcdFx0dmFyIHBhcnQgPSBuZXcgQXJyYXkoKTtcclxuXHJcblx0XHRcdHdoaWxlICh2YWx1ZXMubGVuZ3RoID4gMCAmJiBwYXJ0Lmxlbmd0aCA8IDgpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRwYXJ0LnB1c2godmFsdWVzWzBdKTtcclxuXHRcdFx0XHR2YWx1ZXMuc3BsaWNlKDAsIDEpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLndyaXRlKHByb3BfaWQpO1xyXG5cdFx0XHR0aGlzLndyaXRlUGFkZGVkTnVtYmVyKHBhcnQubGVuZ3RoLCAzKTtcclxuXHJcblx0XHRcdHBhcnQuZWFjaChmdW5jdGlvbiAodmFsdWUpXHJcblx0XHRcdHtcclxuXHRcdFx0XHR0aGlzLndyaXRlV2hpdGVTcGFjZSgpO1xyXG5cdFx0XHRcdHRoaXMud3JpdGVQYWRkZWROdW1iZXIodGhpcy5tYXBwaW5nW3ZhbHVlWzBdXSwgMyk7XHJcblx0XHRcdFx0dGhpcy53cml0ZVdoaXRlU3BhY2UoKTtcclxuXHRcdFx0XHR0aGlzLndyaXRlUGFkZGVkTnVtYmVyKHZhbHVlWzFdLCAzKTtcclxuXHRcdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0XHR0aGlzLndyaXRlQ1IoKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHR3cml0ZUF0b21Qcm9wTGlzdC5jYWxsKHRoaXMsICdNICBDSEcnLCBjaGFyZ2VfbGlzdCk7XHJcblx0d3JpdGVBdG9tUHJvcExpc3QuY2FsbCh0aGlzLCAnTSAgSVNPJywgaXNvdG9wZV9saXN0KTtcclxuXHR3cml0ZUF0b21Qcm9wTGlzdC5jYWxsKHRoaXMsICdNICBSQUQnLCByYWRpY2FsX2xpc3QpO1xyXG5cdHdyaXRlQXRvbVByb3BMaXN0LmNhbGwodGhpcywgJ00gIFJHUCcsIHJnbGFiZWxfbGlzdCk7XHJcblx0Zm9yICh2YXIgaiA9IDA7IGogPCByZ2xvZ2ljX2xpc3QubGVuZ3RoOyArK2opIHtcclxuXHRcdHRoaXMud3JpdGUoJ00gIExPRycgKyByZ2xvZ2ljX2xpc3Rbal0gKyAnXFxuJyk7XHJcblx0fVxyXG5cdHdyaXRlQXRvbVByb3BMaXN0LmNhbGwodGhpcywgJ00gIEFQTycsIGFwbGFiZWxfbGlzdCk7XHJcblx0d3JpdGVBdG9tUHJvcExpc3QuY2FsbCh0aGlzLCAnTSAgUkJDJywgcmJjb3VudF9saXN0KTtcclxuXHR3cml0ZUF0b21Qcm9wTGlzdC5jYWxsKHRoaXMsICdNICBTVUInLCBzdWJzdGNvdW50X2xpc3QpO1xyXG5cdHdyaXRlQXRvbVByb3BMaXN0LmNhbGwodGhpcywgJ00gIFVOUycsIHVuc2F0dXJhdGVkX2xpc3QpO1xyXG5cclxuXHRpZiAoYXRvbUxpc3RfbGlzdC5sZW5ndGggPiAwKVxyXG5cdHtcclxuXHRcdGZvciAoaiA9IDA7IGogPCBhdG9tTGlzdF9saXN0Lmxlbmd0aDsgKytqKSB7XHJcblx0XHRcdHZhciBhaWQgPSBhdG9tTGlzdF9saXN0W2pdO1xyXG5cdFx0XHR2YXIgYXRvbUxpc3QgPSB0aGlzLm1vbGVjdWxlLmF0b21zLmdldChhaWQpLmF0b21MaXN0O1xyXG5cdFx0XHR0aGlzLndyaXRlKCdNICBBTFMnKTtcclxuXHRcdFx0dGhpcy53cml0ZVBhZGRlZE51bWJlcihhaWQgKyAxLCA0KTtcclxuXHRcdFx0dGhpcy53cml0ZVBhZGRlZE51bWJlcihhdG9tTGlzdC5pZHMubGVuZ3RoLCAzKTtcclxuXHRcdFx0dGhpcy53cml0ZVdoaXRlU3BhY2UoKTtcclxuXHRcdFx0dGhpcy53cml0ZShhdG9tTGlzdC5ub3RMaXN0ID8gJ1QnIDogJ0YnKTtcclxuXHJcblx0XHRcdHZhciBsYWJlbExpc3QgPSBhdG9tTGlzdC5sYWJlbExpc3QoKTtcclxuXHRcdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBsYWJlbExpc3QubGVuZ3RoOyArK2spIHtcclxuXHRcdFx0XHR0aGlzLndyaXRlV2hpdGVTcGFjZSgpO1xyXG5cdFx0XHRcdHRoaXMud3JpdGVQYWRkZWQobGFiZWxMaXN0W2tdLCAzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLndyaXRlQ1IoKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHZhciBzZ21hcCA9IHt9LCBjbnQgPSAxLCBzZ21hcGJhY2sgPSB7fTtcclxuXHR2YXIgc2dvcmRlciA9IHRoaXMubW9sZWN1bGUuc0dyb3VwRm9yZXN0LmdldFNHcm91cHNCRlMoKTtcclxuXHR1dGlsLmVhY2goc2dvcmRlciwgZnVuY3Rpb24gKGlkKSB7XHJcblx0XHRzZ21hcGJhY2tbY250XSA9IGlkO1xyXG5cdFx0c2dtYXBbaWRdID0gY250Kys7XHJcblx0fSwgdGhpcyk7XHJcblx0Zm9yICh2YXIgcSA9IDE7IHEgPCBjbnQ7ICsrcSkgeyAvLyBlYWNoIGdyb3VwIG9uIGl0cyBvd25cclxuXHRcdHZhciBpZCA9IHNnbWFwYmFja1txXTtcclxuXHRcdHZhciBzZ3JvdXAgPSB0aGlzLm1vbGVjdWxlLnNncm91cHMuZ2V0KGlkKTtcclxuXHRcdHRoaXMud3JpdGUoJ00gIFNUWScpO1xyXG5cdFx0dGhpcy53cml0ZVBhZGRlZE51bWJlcigxLCAzKTtcclxuXHRcdHRoaXMud3JpdGVXaGl0ZVNwYWNlKDEpO1xyXG5cdFx0dGhpcy53cml0ZVBhZGRlZE51bWJlcihxLCAzKTtcclxuXHRcdHRoaXMud3JpdGVXaGl0ZVNwYWNlKDEpO1xyXG5cdFx0dGhpcy53cml0ZVBhZGRlZChzZ3JvdXAudHlwZSwgMyk7XHJcblx0XHR0aGlzLndyaXRlQ1IoKTtcclxuXHJcblx0XHQvLyBUT0RPOiB3cml0ZSBzdWJ0eXBlLCBNIFNTVFxyXG5cclxuXHRcdHRoaXMud3JpdGUoJ00gIFNMQicpO1xyXG5cdFx0dGhpcy53cml0ZVBhZGRlZE51bWJlcigxLCAzKTtcclxuXHRcdHRoaXMud3JpdGVXaGl0ZVNwYWNlKDEpO1xyXG5cdFx0dGhpcy53cml0ZVBhZGRlZE51bWJlcihxLCAzKTtcclxuXHRcdHRoaXMud3JpdGVXaGl0ZVNwYWNlKDEpO1xyXG5cdFx0dGhpcy53cml0ZVBhZGRlZE51bWJlcihxLCAzKTtcclxuXHRcdHRoaXMud3JpdGVDUigpO1xyXG5cclxuXHRcdHZhciBwYXJlbnRpZCA9IHRoaXMubW9sZWN1bGUuc0dyb3VwRm9yZXN0LnBhcmVudC5nZXQoaWQpO1xyXG5cdFx0aWYgKHBhcmVudGlkID49IDApIHtcclxuXHRcdFx0dGhpcy53cml0ZSgnTSAgU1BMJyk7XHJcblx0XHRcdHRoaXMud3JpdGVQYWRkZWROdW1iZXIoMSwgMyk7XHJcblx0XHRcdHRoaXMud3JpdGVXaGl0ZVNwYWNlKDEpO1xyXG5cdFx0XHR0aGlzLndyaXRlUGFkZGVkTnVtYmVyKHEsIDMpO1xyXG5cdFx0XHR0aGlzLndyaXRlV2hpdGVTcGFjZSgxKTtcclxuXHRcdFx0dGhpcy53cml0ZVBhZGRlZE51bWJlcihzZ21hcFtwYXJlbnRpZF0sIDMpO1xyXG5cdFx0XHR0aGlzLndyaXRlQ1IoKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBjb25uZWN0aXZpdHlcclxuXHRcdGlmIChzZ3JvdXAudHlwZSA9PSAnU1JVJyAmJiBzZ3JvdXAuZGF0YS5jb25uZWN0aXZpdHkpIHtcclxuXHRcdFx0dmFyIGNvbm5lY3Rpdml0eSA9ICcnO1xyXG5cdFx0XHRjb25uZWN0aXZpdHkgKz0gJyAnO1xyXG5cdFx0XHRjb25uZWN0aXZpdHkgKz0gdXRpbC5zdHJpbmdQYWRkZWQocS50b1N0cmluZygpLCAzKTtcclxuXHRcdFx0Y29ubmVjdGl2aXR5ICs9ICcgJztcclxuXHRcdFx0Y29ubmVjdGl2aXR5ICs9IHV0aWwuc3RyaW5nUGFkZGVkKHNncm91cC5kYXRhLmNvbm5lY3Rpdml0eSwgMywgdHJ1ZSk7XHJcblx0XHRcdHRoaXMud3JpdGUoJ00gIFNDTicpO1xyXG5cdFx0XHR0aGlzLndyaXRlUGFkZGVkTnVtYmVyKDEsIDMpO1xyXG5cdFx0XHR0aGlzLndyaXRlKGNvbm5lY3Rpdml0eS50b1VwcGVyQ2FzZSgpKTtcclxuXHRcdFx0dGhpcy53cml0ZUNSKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHNncm91cC50eXBlID09ICdTUlUnKSB7XHJcblx0XHRcdHRoaXMud3JpdGUoJ00gIFNNVCAnKTtcclxuXHRcdFx0dGhpcy53cml0ZVBhZGRlZE51bWJlcihxLCAzKTtcclxuXHRcdFx0dGhpcy53cml0ZVdoaXRlU3BhY2UoKTtcclxuXHRcdFx0dGhpcy53cml0ZShzZ3JvdXAuZGF0YS5zdWJzY3JpcHQgfHwgJ24nKTtcclxuXHRcdFx0dGhpcy53cml0ZUNSKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy53cml0ZUNSKHNncm91cC5zYXZlVG9Nb2xmaWxlKHRoaXMubW9sZWN1bGUsIHNnbWFwLCB0aGlzLm1hcHBpbmcsIHRoaXMuYm9uZE1hcHBpbmcpKTtcclxuXHR9XHJcblxyXG5cdC8vIFRPRE86IHdyaXRlIE0gIEFQT1xyXG5cdC8vIFRPRE86IHdyaXRlIE0gIEFBTFxyXG5cdC8vIFRPRE86IHdyaXRlIE0gIFJHUFxyXG5cdC8vIFRPRE86IHdyaXRlIE0gIExPR1xyXG5cclxuXHR0aGlzLndyaXRlQ1IoJ00gIEVORCcpO1xyXG59O1xyXG5cclxudmFyIHBhcnNlUnhuID0gZnVuY3Rpb24gKC8qIHN0cmluZ1tdICovIGN0YWJMaW5lcykgLyogU3RydWN0ICovXHJcbntcclxuICAgIC8qIHJlYWRlciAqL1xyXG5cdHZhciBzcGxpdCA9IGN0YWJMaW5lc1swXS5zdHJpcCgpLnNwbGl0KCcgJyk7XHJcblx0aWYgKHNwbGl0Lmxlbmd0aCA+IDEgJiYgc3BsaXRbMV0gPT0gJ1YzMDAwJylcclxuXHRcdHJldHVybiBwYXJzZVJ4bjMwMDAoY3RhYkxpbmVzKTtcclxuXHRlbHNlXHJcblx0XHRyZXR1cm4gcGFyc2VSeG4yMDAwKGN0YWJMaW5lcyk7XHJcbn07XHJcblxyXG52YXIgcGFyc2VSeG4yMDAwID0gZnVuY3Rpb24gKC8qIHN0cmluZ1tdICovIGN0YWJMaW5lcykgLyogU3RydWN0ICovXHJcbntcclxuICAgIC8qIHJlYWRlciAqL1xyXG5cdGN0YWJMaW5lcyA9IGN0YWJMaW5lcy5zbGljZSg0KTtcclxuXHR2YXIgY291bnRzU3BsaXQgPSBwYXJ0aXRpb25MaW5lKGN0YWJMaW5lc1swXSwgZm10SW5mby5yeG5JdGVtc1BhcnRpdGlvbik7XHJcblx0dmFyIG5SZWFjdGFudHMgPSBjb3VudHNTcGxpdFswXSAtIDAsXHJcblx0blByb2R1Y3RzID0gY291bnRzU3BsaXRbMV0gLSAwLFxyXG5cdG5BZ2VudHMgPSBjb3VudHNTcGxpdFsyXSAtIDA7XHJcblx0Y3RhYkxpbmVzID0gY3RhYkxpbmVzLnNsaWNlKDEpOyAvLyBjb25zdW1lIGNvdW50cyBsaW5lXHJcblxyXG5cdHZhciBtb2xzID0gW107XHJcblx0d2hpbGUgKGN0YWJMaW5lcy5sZW5ndGggPiAwICYmIGN0YWJMaW5lc1swXS5zdWJzdHIoMCwgNCkgPT0gJyRNT0wnKSB7XHJcblx0XHRjdGFiTGluZXMgPSBjdGFiTGluZXMuc2xpY2UoMSk7XHJcblx0XHR2YXIgbiA9IDA7IHdoaWxlIChuIDwgY3RhYkxpbmVzLmxlbmd0aCAmJiBjdGFiTGluZXNbbl0uc3Vic3RyKDAsIDQpICE9ICckTU9MJykgbisrO1xyXG5cdFx0bW9scy5wdXNoKHBhcnNlTW9sKGN0YWJMaW5lcy5zbGljZSgwLCBuKSkpO1xyXG5cdFx0Y3RhYkxpbmVzID0gY3RhYkxpbmVzLnNsaWNlKG4pO1xyXG5cdH1cclxuXHRyZXR1cm4gcnhuTWVyZ2UobW9scywgblJlYWN0YW50cywgblByb2R1Y3RzLCBuQWdlbnRzKTtcclxufTtcclxuXHJcbnZhciBwYXJzZVJ4bjMwMDAgPSBmdW5jdGlvbiAoLyogc3RyaW5nW10gKi8gY3RhYkxpbmVzKSAvKiBTdHJ1Y3QgKi9cclxue1xyXG4gICAgLyogcmVhZGVyICovXHJcblx0Y3RhYkxpbmVzID0gY3RhYkxpbmVzLnNsaWNlKDQpO1xyXG5cdHZhciBjb3VudHNTcGxpdCA9IGN0YWJMaW5lc1swXS5zcGxpdCgvXFxzKy9nKS5zbGljZSgzKTtcclxuXHR2YXIgblJlYWN0YW50cyA9IGNvdW50c1NwbGl0WzBdIC0gMCxcclxuXHRuUHJvZHVjdHMgPSBjb3VudHNTcGxpdFsxXSAtIDAsXHJcblx0bkFnZW50cyA9IGNvdW50c1NwbGl0Lmxlbmd0aCA+IDIgPyBjb3VudHNTcGxpdFsyXSAtIDAgOiAwO1xyXG5cclxuXHR2YXIgYXNzZXJ0ID0gZnVuY3Rpb24gKGNvbmRpdGlvbikge1xyXG5cdFx0dXRpbC5hc3NlcnQoY29uZGl0aW9uLCAnQ1RhYiBmb3JtYXQgaW52YWxpZCcpO1xyXG5cdH07XHJcblxyXG5cdHZhciBmaW5kQ3RhYkVuZCA9IGZ1bmN0aW9uIChpKSB7XHJcblx0XHRmb3IgKHZhciBqID0gaTsgaiA8IGN0YWJMaW5lcy5sZW5ndGg7ICsraikge1xyXG5cdFx0XHRpZiAoY3RhYkxpbmVzW2pdLnN0cmlwKCkgPT0gJ00gIFYzMCBFTkQgQ1RBQicpXHJcblx0XHRcdFx0cmV0dXJuIGo7XHJcblx0XHR9XHJcblx0XHRhc3NlcnQoZmFsc2UpO1xyXG5cdH07XHJcblxyXG5cdHZhciBmaW5kUkdyb3VwRW5kID0gZnVuY3Rpb24gKGkpIHtcclxuXHRcdGZvciAodmFyIGogPSBpOyBqIDwgY3RhYkxpbmVzLmxlbmd0aDsgKytqKVxyXG5cdFx0XHRpZiAoY3RhYkxpbmVzW2pdLnN0cmlwKCkgPT0gJ00gIFYzMCBFTkQgUkdST1VQJylcclxuXHRcdFx0XHRyZXR1cm4gajtcclxuXHRcdGFzc2VydChmYWxzZSk7XHJcblx0fTtcclxuXHJcblx0dmFyIG1vbExpbmVzUmVhY3RhbnRzID0gW10sIG1vbExpbmVzUHJvZHVjdHMgPSBbXSwgY3VycmVudCA9IG51bGwsIHJHcm91cHMgPSBbXTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGN0YWJMaW5lcy5sZW5ndGg7ICsraSkge1xyXG5cdFx0dmFyIGxpbmUgPSBjdGFiTGluZXNbaV0uc3RyaXAoKTtcclxuXHJcblx0XHRpZiAobGluZS5zdGFydHNXaXRoKCdNICBWMzAgQ09VTlRTJykpIHtcclxuXHRcdFx0Ly8gZG8gbm90aGluZ1xyXG5cdFx0fSBlbHNlIGlmIChsaW5lID09ICdNICBFTkQnKSB7XHJcblx0XHRcdGJyZWFrOyAvLyBzdG9wIHJlYWRpbmdcclxuXHRcdH0gZWxzZSBpZiAobGluZSA9PSAnTSAgVjMwIEJFR0lOIFBST0RVQ1QnKSB7XHJcblx0XHRcdGFzc2VydChjdXJyZW50ID09IG51bGwpO1xyXG5cdFx0XHRjdXJyZW50ID0gbW9sTGluZXNQcm9kdWN0cztcclxuXHRcdH0gZWxzZSBpZiAobGluZSA9PSAnTSAgVjMwIEVORCBQUk9EVUNUJykge1xyXG5cdFx0XHRhc3NlcnQoY3VycmVudCA9PT0gbW9sTGluZXNQcm9kdWN0cyk7XHJcblx0XHRcdGN1cnJlbnQgPSBudWxsO1xyXG5cdFx0fSBlbHNlIGlmIChsaW5lID09ICdNICBWMzAgQkVHSU4gUkVBQ1RBTlQnKSB7XHJcblx0XHRcdGFzc2VydChjdXJyZW50ID09IG51bGwpO1xyXG5cdFx0XHRjdXJyZW50ID0gbW9sTGluZXNSZWFjdGFudHM7XHJcblx0XHR9IGVsc2UgaWYgKGxpbmUgPT0gJ00gIFYzMCBFTkQgUkVBQ1RBTlQnKSB7XHJcblx0XHRcdGFzc2VydChjdXJyZW50ID09PSBtb2xMaW5lc1JlYWN0YW50cyk7XHJcblx0XHRcdGN1cnJlbnQgPSBudWxsO1xyXG5cdFx0fSBlbHNlIGlmIChsaW5lLnN0YXJ0c1dpdGgoJ00gIFYzMCBCRUdJTiBSR1JPVVAnKSkge1xyXG5cdFx0XHRhc3NlcnQoY3VycmVudCA9PSBudWxsKTtcclxuXHRcdFx0dmFyIGogPSBmaW5kUkdyb3VwRW5kKGkpO1xyXG5cdFx0XHRyR3JvdXBzLnB1c2goY3RhYkxpbmVzLnNsaWNlKGksaiArIDEpKTtcclxuXHRcdFx0aSA9IGo7XHJcblx0XHR9IGVsc2UgaWYgKGxpbmUgPT0gJ00gIFYzMCBCRUdJTiBDVEFCJykge1xyXG5cdFx0XHR2YXIgaiA9IGZpbmRDdGFiRW5kKGkpO1xyXG5cdFx0XHRjdXJyZW50LnB1c2goY3RhYkxpbmVzLnNsaWNlKGksaiArIDEpKTtcclxuXHRcdFx0aSA9IGo7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2xpbmUgdW5yZWNvZ25pemVkOiAnICsgbGluZSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHZhciBtb2xzID0gW107XHJcblx0dmFyIG1vbExpbmVzID0gbW9sTGluZXNSZWFjdGFudHMuY29uY2F0KG1vbExpbmVzUHJvZHVjdHMpO1xyXG5cdGZvciAodmFyIGogPSAwOyBqIDwgbW9sTGluZXMubGVuZ3RoOyArK2opIHtcclxuXHRcdHZhciBtb2wgPSBwYXJzZUNUYWJWMzAwMChtb2xMaW5lc1tqXSwgY291bnRzU3BsaXQpO1xyXG5cdFx0bW9scy5wdXNoKG1vbCk7XHJcblx0fVxyXG5cdHZhciBjdGFiID0gcnhuTWVyZ2UobW9scywgblJlYWN0YW50cywgblByb2R1Y3RzLCBuQWdlbnRzKTtcclxuXHJcblx0cmVhZFJHcm91cHMzMDAwKGN0YWIsIGZ1bmN0aW9uIChhcnJheSkge1xyXG5cdFx0dmFyIHJlcyA9IFtdO1xyXG5cdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBhcnJheS5sZW5ndGg7ICsraykge1xyXG5cdFx0XHRyZXMgPSByZXMuY29uY2F0KGFycmF5W2tdKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiByZXM7XHJcblx0fShyR3JvdXBzKSk7XHJcblxyXG5cdHJldHVybiBjdGFiO1xyXG59O1xyXG5cclxudmFyIHJ4bk1lcmdlID0gZnVuY3Rpb24gKG1vbHMsIG5SZWFjdGFudHMsIG5Qcm9kdWN0cywgbkFnZW50cykgLyogU3RydWN0ICovXHJcbntcclxuICAgIC8qIHJlYWRlciAqL1xyXG5cdHZhciByZXQgPSBuZXcgU3RydWN0KCk7XHJcblx0dmFyIGJiUmVhY3QgPSBbXSxcclxuXHRiYkFnZW50ID0gW10sXHJcblx0YmJQcm9kID0gW107XHJcblx0dmFyIG1vbFJlYWN0ID0gW10sXHJcblx0bW9sQWdlbnQgPSBbXSxcclxuXHRtb2xQcm9kID0gW107XHJcblx0dmFyIGo7XHJcblx0dmFyIGJvbmRMZW5ndGhEYXRhID0ge2NudDowLHRvdGFsTGVuZ3RoOjB9O1xyXG5cdGZvciAoaiA9IDA7IGogPCBtb2xzLmxlbmd0aDsgKytqKSB7XHJcblx0XHR2YXIgbW9sID0gbW9sc1tqXTtcclxuXHRcdHZhciBib25kTGVuZ3RoRGF0YU1vbCA9IG1vbC5nZXRCb25kTGVuZ3RoRGF0YSgpO1xyXG5cdFx0Ym9uZExlbmd0aERhdGEuY250ICs9IGJvbmRMZW5ndGhEYXRhTW9sLmNudDtcclxuXHRcdGJvbmRMZW5ndGhEYXRhLnRvdGFsTGVuZ3RoICs9IGJvbmRMZW5ndGhEYXRhTW9sLnRvdGFsTGVuZ3RoO1xyXG5cdH1cclxuXHR2YXIgYXZnQm9uZExlbmd0aCA9IDEgLyAoYm9uZExlbmd0aERhdGEuY250ID09IDAgPyAxIDogYm9uZExlbmd0aERhdGEudG90YWxMZW5ndGggLyBib25kTGVuZ3RoRGF0YS5jbnQpO1xyXG5cdGZvciAoaiA9IDA7IGogPCBtb2xzLmxlbmd0aDsgKytqKSB7XHJcblx0XHRtb2wgPSBtb2xzW2pdO1xyXG5cdFx0bW9sLnNjYWxlKGF2Z0JvbmRMZW5ndGgpO1xyXG5cdH1cclxuXHJcblx0Zm9yIChqID0gMDsgaiA8IG1vbHMubGVuZ3RoOyArK2opIHtcclxuXHRcdG1vbCA9IG1vbHNbal07XHJcblx0XHR2YXIgYmIgPSBtb2wuZ2V0Q29vcmRCb3VuZGluZ0JveE9iaigpO1xyXG5cdFx0aWYgKCFiYilcclxuXHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0dmFyIGZyYWdtZW50VHlwZSA9IChqIDwgblJlYWN0YW50cyA/IEZSQUdNRU5ULlJFQUNUQU5UIDpcclxuXHRcdFx0KGogPCBuUmVhY3RhbnRzICsgblByb2R1Y3RzID8gRlJBR01FTlQuUFJPRFVDVCA6XHJcblx0XHRcdFx0XHRGUkFHTUVOVC5BR0VOVCkpO1xyXG5cdFx0aWYgKGZyYWdtZW50VHlwZSA9PSBGUkFHTUVOVC5SRUFDVEFOVCkge1xyXG5cdFx0XHRiYlJlYWN0LnB1c2goYmIpO1xyXG5cdFx0XHRtb2xSZWFjdC5wdXNoKG1vbCk7XHJcblx0XHR9IGVsc2UgaWYgKGZyYWdtZW50VHlwZSA9PSBGUkFHTUVOVC5BR0VOVCkge1xyXG5cdFx0XHRiYkFnZW50LnB1c2goYmIpO1xyXG5cdFx0XHRtb2xBZ2VudC5wdXNoKG1vbCk7XHJcblx0XHR9IGVsc2UgaWYgKGZyYWdtZW50VHlwZSA9PSBGUkFHTUVOVC5QUk9EVUNUKSB7XHJcblx0XHRcdGJiUHJvZC5wdXNoKGJiKTtcclxuXHRcdFx0bW9sUHJvZC5wdXNoKG1vbCk7XHJcblx0XHR9XHJcblxyXG5cdFx0bW9sLmF0b21zLmVhY2goZnVuY3Rpb24gKGFpZCwgYXRvbSl7XHJcblx0XHRcdGF0b20ucnhuRnJhZ21lbnRUeXBlID0gZnJhZ21lbnRUeXBlO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHQvLyByZWFjdGlvbiBmcmFnbWVudCBsYXlvdXRcclxuXHR2YXIgeG9yaWcgPSAwO1xyXG5cdHZhciBzaGlmdE1vbCA9IGZ1bmN0aW9uIChyZXQsIG1vbCwgYmIsIHhvcmlnLCBvdmVyKSB7XHJcblx0XHR2YXIgZCA9IG5ldyBWZWMyKHhvcmlnIC0gYmIubWluLngsIG92ZXIgPyAxIC0gYmIubWluLnkgOiAtKGJiLm1pbi55ICsgYmIubWF4LnkpIC8gMik7XHJcblx0XHRtb2wuYXRvbXMuZWFjaChmdW5jdGlvbiAoYWlkLCBhdG9tKXtcclxuXHRcdFx0YXRvbS5wcC5hZGRfKGQpO1xyXG5cdFx0fSk7XHJcblx0XHRtb2wuc2dyb3Vwcy5lYWNoKGZ1bmN0aW9uIChpZCwgaXRlbSl7XHJcblx0XHRcdGlmIChpdGVtLnBwKVxyXG5cdFx0XHRcdGl0ZW0ucHAuYWRkXyhkKTtcclxuXHRcdH0pO1xyXG5cdFx0YmIubWluLmFkZF8oZCk7XHJcblx0XHRiYi5tYXguYWRkXyhkKTtcclxuXHRcdG1vbC5tZXJnZUludG8ocmV0KTtcclxuXHRcdHJldHVybiBiYi5tYXgueCAtIGJiLm1pbi54O1xyXG5cdH07XHJcblxyXG5cdGZvciAoaiA9IDA7IGogPCBtb2xSZWFjdC5sZW5ndGg7ICsraikge1xyXG5cdFx0eG9yaWcgKz0gc2hpZnRNb2wocmV0LCBtb2xSZWFjdFtqXSwgYmJSZWFjdFtqXSwgeG9yaWcsIGZhbHNlKSArIDIuMDtcclxuXHR9XHJcblx0eG9yaWcgKz0gMi4wO1xyXG5cdGZvciAoaiA9IDA7IGogPCBtb2xBZ2VudC5sZW5ndGg7ICsraikge1xyXG5cdFx0eG9yaWcgKz0gc2hpZnRNb2wocmV0LCBtb2xBZ2VudFtqXSwgYmJBZ2VudFtqXSwgeG9yaWcsIHRydWUpICsgMi4wO1xyXG5cdH1cclxuXHR4b3JpZyArPSAyLjA7XHJcblxyXG5cdGZvciAoaiA9IDA7IGogPCBtb2xQcm9kLmxlbmd0aDsgKytqKSB7XHJcblx0XHR4b3JpZyArPSBzaGlmdE1vbChyZXQsIG1vbFByb2Rbal0sIGJiUHJvZFtqXSwgeG9yaWcsIGZhbHNlKSArIDIuMDtcclxuXHR9XHJcblxyXG5cdHZhciBiYjEsIGJiMiwgeCwgeSwgYmJSZWFjdEFsbCA9IG51bGwsIGJiUHJvZEFsbCA9IG51bGw7XHJcblx0Zm9yIChqID0gMDsgaiA8XHRiYlJlYWN0Lmxlbmd0aCAtIDE7ICsraikge1xyXG5cdFx0YmIxID0gYmJSZWFjdFtqXTtcclxuXHRcdGJiMiA9IGJiUmVhY3RbaiArIDFdO1xyXG5cclxuXHRcdHggPSAoYmIxLm1heC54ICsgYmIyLm1pbi54KSAvIDI7XHJcblx0XHR5ID0gKGJiMS5tYXgueSArIGJiMS5taW4ueSArIGJiMi5tYXgueSArIGJiMi5taW4ueSkgLyA0O1xyXG5cclxuXHRcdHJldC5yeG5QbHVzZXMuYWRkKG5ldyBTdHJ1Y3QuUnhuUGx1cyh7J3BwJzpuZXcgVmVjMih4LCB5KX0pKTtcclxuXHR9XHJcblx0Zm9yIChqID0gMDsgaiA8XHRiYlJlYWN0Lmxlbmd0aDsgKytqKSB7XHJcblx0XHRpZiAoaiA9PSAwKSB7XHJcblx0XHRcdGJiUmVhY3RBbGwgPSB7fTtcclxuXHRcdFx0YmJSZWFjdEFsbC5tYXggPSBuZXcgVmVjMihiYlJlYWN0W2pdLm1heCk7XHJcblx0XHRcdGJiUmVhY3RBbGwubWluID0gbmV3IFZlYzIoYmJSZWFjdFtqXS5taW4pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0YmJSZWFjdEFsbC5tYXggPSBWZWMyLm1heChiYlJlYWN0QWxsLm1heCwgYmJSZWFjdFtqXS5tYXgpO1xyXG5cdFx0XHRiYlJlYWN0QWxsLm1pbiA9IFZlYzIubWluKGJiUmVhY3RBbGwubWluLCBiYlJlYWN0W2pdLm1pbik7XHJcblx0XHR9XHJcblx0fVxyXG5cdGZvciAoaiA9IDA7IGogPFx0YmJQcm9kLmxlbmd0aCAtIDE7ICsraikge1xyXG5cdFx0YmIxID0gYmJQcm9kW2pdO1xyXG5cdFx0YmIyID0gYmJQcm9kW2ogKyAxXTtcclxuXHJcblx0XHR4ID0gKGJiMS5tYXgueCArIGJiMi5taW4ueCkgLyAyO1xyXG5cdFx0eSA9IChiYjEubWF4LnkgKyBiYjEubWluLnkgKyBiYjIubWF4LnkgKyBiYjIubWluLnkpIC8gNDtcclxuXHJcblx0XHRyZXQucnhuUGx1c2VzLmFkZChuZXcgU3RydWN0LlJ4blBsdXMoeydwcCc6bmV3IFZlYzIoeCwgeSl9KSk7XHJcblx0fVxyXG5cdGZvciAoaiA9IDA7IGogPFx0YmJQcm9kLmxlbmd0aDsgKytqKSB7XHJcblx0XHRpZiAoaiA9PSAwKSB7XHJcblx0XHRcdGJiUHJvZEFsbCA9IHt9O1xyXG5cdFx0XHRiYlByb2RBbGwubWF4ID0gbmV3IFZlYzIoYmJQcm9kW2pdLm1heCk7XHJcblx0XHRcdGJiUHJvZEFsbC5taW4gPSBuZXcgVmVjMihiYlByb2Rbal0ubWluKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGJiUHJvZEFsbC5tYXggPSBWZWMyLm1heChiYlByb2RBbGwubWF4LCBiYlByb2Rbal0ubWF4KTtcclxuXHRcdFx0YmJQcm9kQWxsLm1pbiA9IFZlYzIubWluKGJiUHJvZEFsbC5taW4sIGJiUHJvZFtqXS5taW4pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRiYjEgPSBiYlJlYWN0QWxsO1xyXG5cdGJiMiA9IGJiUHJvZEFsbDtcclxuXHRpZiAoIWJiMSAmJiAhYmIyKSB7XHJcblx0XHRyZXQucnhuQXJyb3dzLmFkZChuZXcgU3RydWN0LlJ4bkFycm93KHsncHAnOm5ldyBWZWMyKDAsIDApfSkpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR2YXIgdjEgPSBiYjEgPyBuZXcgVmVjMihiYjEubWF4LngsIChiYjEubWF4LnkgKyBiYjEubWluLnkpIC8gMikgOiBudWxsO1xyXG5cdFx0dmFyIHYyID0gYmIyID8gbmV3IFZlYzIoYmIyLm1pbi54LCAoYmIyLm1heC55ICsgYmIyLm1pbi55KSAvIDIpIDogbnVsbDtcclxuXHRcdHZhciBkZWZhdWx0T2Zmc2V0ID0gMztcclxuXHRcdGlmICghdjEpXHJcblx0XHRcdHYxID0gbmV3IFZlYzIodjIueCAtIGRlZmF1bHRPZmZzZXQsIHYyLnkpO1xyXG5cdFx0aWYgKCF2MilcclxuXHRcdFx0djIgPSBuZXcgVmVjMih2MS54ICsgZGVmYXVsdE9mZnNldCwgdjEueSk7XHJcblx0XHRyZXQucnhuQXJyb3dzLmFkZChuZXcgU3RydWN0LlJ4bkFycm93KHsgJ3BwJzogVmVjMi5sYzIodjEsIDAuNSwgdjIsIDAuNSApIH0pKTtcclxuXHR9XHJcblx0cmV0LmlzUmVhY3Rpb24gPSB0cnVlO1xyXG5cdHJldHVybiByZXQ7XHJcbn07XHJcblxyXG52YXIgcmdNZXJnZSA9IGZ1bmN0aW9uIChzY2FmZm9sZCwgcmdyb3VwcykgLyogU3RydWN0ICovXHJcbntcclxuICAgIC8qIHJlYWRlciAqL1xyXG5cdHZhciByZXQgPSBuZXcgU3RydWN0KCk7XHJcblxyXG5cdHNjYWZmb2xkLm1lcmdlSW50byhyZXQsIG51bGwsIG51bGwsIGZhbHNlLCB0cnVlKTtcclxuXHRmb3IgKHZhciByZ2lkIGluIHJncm91cHMpIHtcclxuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgcmdyb3Vwc1tyZ2lkXS5sZW5ndGg7ICsraikge1xyXG5cdFx0XHR2YXIgY3RhYiA9IHJncm91cHNbcmdpZF1bal07XHJcblx0XHRcdGN0YWIucmdyb3Vwcy5zZXQocmdpZCwgbmV3IFN0cnVjdC5SR3JvdXAoKSk7XHJcblx0XHRcdHZhciBmcmlkID0gY3RhYi5mcmFncy5hZGQobmV3IFN0cnVjdC5GcmFnbWVudCgpKTtcclxuXHRcdFx0Y3RhYi5yZ3JvdXBzLmdldChyZ2lkKS5mcmFncy5hZGQoZnJpZCk7XHJcblx0XHRcdGN0YWIuYXRvbXMuZWFjaChmdW5jdGlvbiAoYWlkLCBhdG9tKSB7YXRvbS5mcmFnbWVudCA9IGZyaWQ7fSk7XHJcblx0XHRcdGN0YWIubWVyZ2VJbnRvKHJldCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcmV0O1xyXG59O1xyXG5cclxudmFyIHBhcnNlUmcyMDAwID0gZnVuY3Rpb24gKC8qIHN0cmluZ1tdICovIGN0YWJMaW5lcykgLyogU3RydWN0ICovXHJcbntcclxuXHRjdGFiTGluZXMgPSBjdGFiTGluZXMuc2xpY2UoNyk7XHJcblx0aWYgKGN0YWJMaW5lc1swXS5zdHJpcCgpICE9ICckQ1RBQicpXHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1JHRmlsZSBmb3JtYXQgaW52YWxpZCcpO1xyXG5cdHZhciBpID0gMTsgd2hpbGUgKGN0YWJMaW5lc1tpXS5jaGFyQXQoMCkgIT0gJyQnKSBpKys7XHJcblx0aWYgKGN0YWJMaW5lc1tpXS5zdHJpcCgpICE9ICckRU5EIENUQUInKVxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdSR0ZpbGUgZm9ybWF0IGludmFsaWQnKTtcclxuXHR2YXIgY29yZUxpbmVzID0gY3RhYkxpbmVzLnNsaWNlKDEsIGkpO1xyXG5cdGN0YWJMaW5lcyA9IGN0YWJMaW5lcy5zbGljZShpICsgMSk7XHJcblx0dmFyIGZyYWdtZW50TGluZXMgPSB7fTtcclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0aWYgKGN0YWJMaW5lcy5sZW5ndGggPT0gMClcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBmaWxlJyk7XHJcblx0XHR2YXIgbGluZSA9IGN0YWJMaW5lc1swXS5zdHJpcCgpO1xyXG5cdFx0aWYgKGxpbmUgPT0gJyRFTkQgTU9MJykge1xyXG5cdFx0XHRjdGFiTGluZXMgPSBjdGFiTGluZXMuc2xpY2UoMSk7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGxpbmUgIT0gJyRSR1AnKVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1JHRmlsZSBmb3JtYXQgaW52YWxpZCcpO1xyXG5cdFx0dmFyIHJnaWQgPSBjdGFiTGluZXNbMV0uc3RyaXAoKSAtIDA7XHJcblx0XHRmcmFnbWVudExpbmVzW3JnaWRdID0gW107XHJcblx0XHRjdGFiTGluZXMgPSBjdGFiTGluZXMuc2xpY2UoMik7XHJcblx0XHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0XHRpZiAoY3RhYkxpbmVzLmxlbmd0aCA9PSAwKVxyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgZmlsZScpO1xyXG5cdFx0XHRsaW5lID0gY3RhYkxpbmVzWzBdLnN0cmlwKCk7XHJcblx0XHRcdGlmIChsaW5lID09ICckRU5EIFJHUCcpIHtcclxuXHRcdFx0XHRjdGFiTGluZXMgPSBjdGFiTGluZXMuc2xpY2UoMSk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGxpbmUgIT0gJyRDVEFCJylcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1JHRmlsZSBmb3JtYXQgaW52YWxpZCcpO1xyXG5cdFx0XHRpID0gMTsgd2hpbGUgKGN0YWJMaW5lc1tpXS5jaGFyQXQoMCkgIT0gJyQnKSBpKys7XHJcblx0XHRcdGlmIChjdGFiTGluZXNbaV0uc3RyaXAoKSAhPSAnJEVORCBDVEFCJylcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1JHRmlsZSBmb3JtYXQgaW52YWxpZCcpO1xyXG5cdFx0XHRmcmFnbWVudExpbmVzW3JnaWRdLnB1c2goY3RhYkxpbmVzLnNsaWNlKDEsIGkpKTtcclxuXHRcdFx0Y3RhYkxpbmVzID0gY3RhYkxpbmVzLnNsaWNlKGkgKyAxKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHZhciBjb3JlID0gcGFyc2VDVGFiKGNvcmVMaW5lcyksIGZyYWcgPSB7fTtcclxuXHRpZiAoTW9sZmlsZS5sb2FkUkdyb3VwRnJhZ21lbnRzKSB7XHJcblx0XHRmb3IgKHZhciBpZCBpbiBmcmFnbWVudExpbmVzKSB7XHJcblx0XHRcdGZyYWdbaWRdID0gW107XHJcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZnJhZ21lbnRMaW5lc1tpZF0ubGVuZ3RoOyArK2opIHtcclxuXHRcdFx0XHRmcmFnW2lkXS5wdXNoKHBhcnNlQ1RhYihmcmFnbWVudExpbmVzW2lkXVtqXSkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiByZ01lcmdlKGNvcmUsIGZyYWcpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0c3RyaW5naWZ5OiBmdW5jdGlvbiAobW9sZWN1bGUsIG9wdGlvbnMpIHtcclxuXHRcdHZhciBvcHRzID0gb3B0aW9ucyB8fCB7fTtcclxuXHRcdHJldHVybiBuZXcgTW9sZmlsZShvcHRzLnYzMDAwKS5zYXZlTW9sZWN1bGUobW9sZWN1bGUsIG9wdHMuaWdub3JlRXJyb3JzLFxyXG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRzLm5vUmdyb3Vwcywgb3B0cy5wcmVzZXJ2ZUluZGlnb0Rlc2MpO1xyXG5cdH0sXHJcblx0cGFyc2U6IGZ1bmN0aW9uIChzdHIpIHtcclxuXHRcdHJldHVybiBuZXcgTW9sZmlsZSgpLnBhcnNlQ1RGaWxlKHN0cik7XHJcblx0fVxyXG59O1xyXG4iLCJ2YXIgTWFwID0gcmVxdWlyZSgnLi4vdXRpbC9tYXAnKTtcclxudmFyIFNldCA9IHJlcXVpcmUoJy4uL3V0aWwvc2V0Jyk7XHJcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xyXG5cclxudmFyIFNHcm91cEZvcmVzdCA9IGZ1bmN0aW9uIChtb2xlY3VsZSkge1xyXG5cdHRoaXMucGFyZW50ID0gbmV3IE1hcCgpOyAvLyBjaGlsZCBpZCAtPiBwYXJlbnQgaWRcclxuXHR0aGlzLmNoaWxkcmVuID0gbmV3IE1hcCgpOyAvLyBwYXJlbnQgaWQgLT4gbGlzdCBvZiBjaGlsZCBpZHNcclxuXHR0aGlzLmNoaWxkcmVuLnNldCgtMSwgW10pOyAvLyBleHRyYSByb290IG5vZGVcclxuXHR0aGlzLm1vbGVjdWxlID0gbW9sZWN1bGU7XHJcbn1cclxuXHJcbi8vIHJldHVybnMgYW4gYXJyYXkgb3Igcy1ncm91cCBpZHMgaW4gdGhlIG9yZGVyIG9mIGJyZWFkdGgtZmlyc3Qgc2VhcmNoXHJcblNHcm91cEZvcmVzdC5wcm90b3R5cGUuZ2V0U0dyb3Vwc0JGUyA9IGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgb3JkZXIgPSBbXSwgcXVldWUgPSBbXSwgaWQgPSAtMTtcclxuXHRxdWV1ZSA9IHV0aWwuYXJyYXkodGhpcy5jaGlsZHJlbi5nZXQoLTEpKTtcclxuXHR3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xyXG5cdFx0dmFyIGlkID0gcXVldWUuc2hpZnQoKTtcclxuXHRcdHF1ZXVlID0gcXVldWUuY29uY2F0KHRoaXMuY2hpbGRyZW4uZ2V0KGlkKSk7XHJcblx0XHRvcmRlci5wdXNoKGlkKTtcclxuXHR9XHJcblx0cmV0dXJuIG9yZGVyO1xyXG59XHJcblxyXG5TR3JvdXBGb3Jlc3QucHJvdG90eXBlLmdldEF0b21TZXRzID0gZnVuY3Rpb24gKCkge1xyXG5cdHJldHVybiB0aGlzLm1vbGVjdWxlLnNncm91cHMubWFwKGZ1bmN0aW9uIChzZ2lkLCBzZ3JvdXApe1xyXG5cdFx0cmV0dXJuIFNldC5mcm9tTGlzdChzZ3JvdXAuYXRvbXMpO1xyXG5cdH0pO1xyXG59XHJcblxyXG5TR3JvdXBGb3Jlc3QucHJvdG90eXBlLmdldEF0b21TZXRSZWxhdGlvbnMgPSBmdW5jdGlvbiAobmV3SWQsIGF0b21zIC8qIFNldCAqLywgYXRvbVNldHMgLyogTWFwIG9mIFNldCAqLykge1xyXG5cdC8vIGZpbmQgdGhlIGxvd2VzdCBzdXBlcnNldCBpbiB0aGUgaGllcmFyY2h5XHJcblx0dmFyIGlzU3RyaWN0U3VwZXJzZXQgPSBuZXcgTWFwKCksIGlzU3Vic2V0ID0gbmV3IE1hcCgpO1xyXG5cdHZhciBhdG9tU2V0cyA9IHRoaXMuZ2V0QXRvbVNldHMoKTtcclxuXHRhdG9tU2V0cy51bnNldChuZXdJZCk7XHJcblx0YXRvbVNldHMuZWFjaChmdW5jdGlvbiAoaWQsIGF0b21TZXQpIHtcclxuXHRcdGlzU3Vic2V0LnNldChpZCwgU2V0LnN1YnNldChhdG9tcywgYXRvbVNldCkpO1xyXG5cdFx0aXNTdHJpY3RTdXBlcnNldC5zZXQoaWQsIFNldC5zdWJzZXQoYXRvbVNldCwgYXRvbXMpICYmICFTZXQuZXEoYXRvbVNldCwgYXRvbXMpKTtcclxuXHR9LCB0aGlzKTtcclxuXHR2YXIgcGFyZW50cyA9IGF0b21TZXRzLmZpbmRBbGwoZnVuY3Rpb24gKGlkKSB7XHJcblx0XHRpZiAoIWlzU3Vic2V0LmdldChpZCkpXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdGlmICh1dGlsLmZpbmRJbmRleCh0aGlzLmNoaWxkcmVuLmdldChpZCksIGZ1bmN0aW9uIChjaGlsZElkKSB7XHJcblx0XHRcdHJldHVybiBpc1N1YnNldC5nZXQoY2hpbGRJZCk7XHJcblx0XHR9LCB0aGlzKSA+PSAwKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH0sIHRoaXMpO1xyXG5cdHV0aWwuYXNzZXJ0KHBhcmVudHMubGVuZ3RoIDw9IDEpOyAvLyB0aGVyZSBzaG91bGQgYmUgb25seSBvbmUgcGFyZW50XHJcblx0dmFyIGNoaWxkcmVuID0gYXRvbVNldHMuZmluZEFsbChmdW5jdGlvbiAoaWQsIHNldCkge1xyXG5cdFx0cmV0dXJuIGlzU3RyaWN0U3VwZXJzZXQuZ2V0KGlkKSAmJiAhaXNTdHJpY3RTdXBlcnNldC5nZXQodGhpcy5wYXJlbnQuZ2V0KGlkKSk7XHJcblx0fSwgdGhpcyk7XHJcblx0cmV0dXJuIHtcclxuXHRcdCdjaGlsZHJlbic6IGNoaWxkcmVuLFxyXG5cdFx0J3BhcmVudCc6IHBhcmVudHMubGVuZ3RoID09PSAwID8gLTEgOiBwYXJlbnRzWzBdXHJcblx0fTtcclxufVxyXG5cclxuU0dyb3VwRm9yZXN0LnByb3RvdHlwZS5nZXRQYXRoVG9Sb290ID0gZnVuY3Rpb24gKHNnaWQpIHtcclxuXHR2YXIgcGF0aCA9IFtdO1xyXG5cdGZvciAodmFyIGlkID0gc2dpZDsgaWQgPj0gMDsgaWQgPSB0aGlzLnBhcmVudC5nZXQoaWQpKSB7XHJcblx0XHR1dGlsLmFzc2VydChwYXRoLmluZGV4T2YoaWQpIDwgMCwgJ1NHcm91cEZvcmVzdDogbG9vcCBkZXRlY3RlZCcpO1xyXG5cdFx0cGF0aC5wdXNoKGlkKTtcclxuXHR9XHJcblx0cmV0dXJuIHBhdGg7XHJcbn1cclxuXHJcblNHcm91cEZvcmVzdC5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0dmFyIGF0b21TZXRzID0gdGhpcy5nZXRBdG9tU2V0cygpO1xyXG5cdHRoaXMubW9sZWN1bGUuc2dyb3Vwcy5lYWNoKGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0dGhpcy5nZXRQYXRoVG9Sb290KGlkKTsgLy8gdGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiB0aGVyZSBpcyBhIGxvb3AgaW4gdGhlIHBhdGggdG8gcm9vdFxyXG5cdH0sIHRoaXMpO1xyXG5cclxuXHR2YXIgdmFsaWQgPSB0cnVlO1xyXG5cdC8vIDEpIGNoaWxkIGdyb3VwJ3MgYXRvbSBzZXQgaXMgYSBzdWJzZXQgb2YgdGhlIHBhcmVudCBvbmUnc1xyXG5cdHRoaXMucGFyZW50LmVhY2goZnVuY3Rpb24gKGlkLCBwYXJlbnRJZCkge1xyXG5cdFx0aWYgKHBhcmVudElkID49IDAgJiYgIVNldC5zdWJzZXQoYXRvbVNldHMuZ2V0KGlkKSwgYXRvbVNldHMuZ2V0KHBhcmVudElkKSkpXHJcblx0XHRcdHZhbGlkID0gZmFsc2U7XHJcblx0fSwgdGhpcyk7XHJcblxyXG5cdC8vIDIpIHNpYmxpbmdzIGhhdmUgZGlzam9pbnQgYXRvbSBzZXRzXHJcblx0dGhpcy5jaGlsZHJlbi5lYWNoKGZ1bmN0aW9uIChwYXJlbnRJZCkge1xyXG5cdFx0dmFyIGxpc3QgPSB0aGlzLmNoaWxkcmVuLmdldChwYXJlbnRJZCk7XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpXHJcblx0XHRcdGZvciAodmFyIGogPSBpICsgMTsgaiA8IGxpc3QubGVuZ3RoOyArK2opXHJcblx0XHRcdFx0aWYgKCFTZXQuZGlzam9pbnQoYXRvbVNldHMuZ2V0KGxpc3RbaV0pLCBhdG9tU2V0cy5nZXQobGlzdFtqXSkpKVxyXG5cdFx0XHRcdFx0dmFsaWQgPSBmYWxzZTtcclxuXHR9LCB0aGlzKTtcclxuXHRyZXR1cm4gdmFsaWQ7XHJcbn1cclxuXHJcblNHcm91cEZvcmVzdC5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKGlkLCBwYXJlbnQgLyogaW50LCBvcHRpb25hbCAqLywgY2hpbGRyZW4gLyogW2ludF0sIG9wdGlvbmFsICovKSB7XHJcblx0dXRpbC5hc3NlcnQoIXRoaXMucGFyZW50LmhhcyhpZCksICdzZ2lkIGFscmVhZHkgcHJlc2VudCBpbiB0aGUgZm9yZXN0Jyk7XHJcblx0dXRpbC5hc3NlcnQoIXRoaXMuY2hpbGRyZW4uaGFzKGlkKSwgJ3NnaWQgYWxyZWFkeSBwcmVzZW50IGluIHRoZSBmb3Jlc3QnKTtcclxuXHJcblx0dXRpbC5hc3NlcnQodGhpcy52YWxpZGF0ZSgpLCAncy1ncm91cCBmb3Jlc3QgaW52YWxpZCcpO1xyXG5cdHZhciBhdG9tU2V0cyA9IHRoaXMuZ2V0QXRvbVNldHMoKTtcclxuXHR2YXIgYXRvbXMgPSBTZXQuZnJvbUxpc3QodGhpcy5tb2xlY3VsZS5zZ3JvdXBzLmdldChpZCkuYXRvbXMpO1xyXG5cdGlmICh1dGlsLmlzVW5kZWZpbmVkKHBhcmVudCkgfHwgdXRpbC5pc1VuZGVmaW5lZChjaGlsZHJlbikpIHsgLy8gaWYgdGhlc2UgYXJlIG5vdCBwcm92aWRlZCwgZGVkdWNlIGF1dG9tYXRpY2FsbHlcclxuXHRcdHZhciBndWVzcyA9IHRoaXMuZ2V0QXRvbVNldFJlbGF0aW9ucyhpZCwgYXRvbXMsIGF0b21TZXRzKTtcclxuXHRcdHBhcmVudCA9IGd1ZXNzLnBhcmVudDtcclxuXHRcdGNoaWxkcmVuID0gZ3Vlc3MuY2hpbGRyZW47XHJcblx0fVxyXG5cclxuXHQvLyBUT0RPOiBtYWtlIGNoaWxkcmVuIE1hcDxpbnQsIFNldD4gaW5zdGVhZCBvZiBNYXA8aW50LCBbXT4/XHJcblx0dXRpbC5lYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGRJZCl7IC8vIHJlc2V0IHBhcmVudCBsaW5rc1xyXG5cdFx0dXRpbC5hc3NlcnQodXRpbC5hcnJheVJlbW92ZUJ5VmFsdWUodGhpcy5jaGlsZHJlbi5nZXQodGhpcy5wYXJlbnQuZ2V0KGNoaWxkSWQpKSwgY2hpbGRJZCkgPT09IDEpO1xyXG5cdFx0dGhpcy5wYXJlbnQuc2V0KGNoaWxkSWQsIGlkKTtcclxuXHR9LCB0aGlzKTtcclxuXHR0aGlzLmNoaWxkcmVuLnNldChpZCwgY2hpbGRyZW4pO1xyXG5cdHRoaXMucGFyZW50LnNldChpZCwgcGFyZW50KTtcclxuXHR0aGlzLmNoaWxkcmVuLmdldChwYXJlbnQpLnB1c2goaWQpO1xyXG5cdHV0aWwuYXNzZXJ0KHRoaXMudmFsaWRhdGUoKSwgJ3MtZ3JvdXAgZm9yZXN0IGludmFsaWQnKTtcclxuXHRyZXR1cm4ge3BhcmVudDogcGFyZW50LCBjaGlsZHJlbjogY2hpbGRyZW59O1xyXG59XHJcblxyXG5TR3JvdXBGb3Jlc3QucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChpZCkge1xyXG5cdHV0aWwuYXNzZXJ0KHRoaXMucGFyZW50LmhhcyhpZCksICdzZ2lkIGlzIG5vdCBpbiB0aGUgZm9yZXN0Jyk7XHJcblx0dXRpbC5hc3NlcnQodGhpcy5jaGlsZHJlbi5oYXMoaWQpLCAnc2dpZCBpcyBub3QgaW4gdGhlIGZvcmVzdCcpO1xyXG5cclxuXHR1dGlsLmFzc2VydCh0aGlzLnZhbGlkYXRlKCksICdzLWdyb3VwIGZvcmVzdCBpbnZhbGlkJyk7XHJcblx0dmFyIHBhcmVudElkID0gdGhpcy5wYXJlbnQuZ2V0KGlkKTtcclxuXHR1dGlsLmVhY2godGhpcy5jaGlsZHJlbi5nZXQoaWQpLCBmdW5jdGlvbiAoY2hpbGRJZCl7IC8vIHJlc2V0IHBhcmVudCBsaW5rc1xyXG5cdFx0dGhpcy5wYXJlbnQuc2V0KGNoaWxkSWQsIHBhcmVudElkKTtcclxuXHRcdHRoaXMuY2hpbGRyZW4uZ2V0KHBhcmVudElkKS5wdXNoKGNoaWxkSWQpO1xyXG5cdH0sIHRoaXMpO1xyXG5cdHV0aWwuYXNzZXJ0KHV0aWwuYXJyYXlSZW1vdmVCeVZhbHVlKHRoaXMuY2hpbGRyZW4uZ2V0KHBhcmVudElkKSwgaWQpID09PSAxKTtcclxuXHR0aGlzLmNoaWxkcmVuLnVuc2V0KGlkKTtcclxuXHR0aGlzLnBhcmVudC51bnNldChpZCk7XHJcblx0dXRpbC5hc3NlcnQodGhpcy52YWxpZGF0ZSgpLCAncy1ncm91cCBmb3Jlc3QgaW52YWxpZCcpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNHcm91cEZvcmVzdDtcclxuIiwidmFyIEJveDJBYnMgPSByZXF1aXJlKCcuLi91dGlsL2JveDJhYnMnKTtcclxudmFyIFNldCA9IHJlcXVpcmUoJy4uL3V0aWwvc2V0Jyk7XHJcbnZhciBWZWMyID0gcmVxdWlyZSgnLi4vdXRpbC92ZWMyJyk7XHJcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xyXG5cclxudmFyIEF0b20gPSByZXF1aXJlKCcuL2F0b20nKTtcclxudmFyIEJvbmQgPSByZXF1aXJlKCcuL2JvbmQnKTtcclxuXHJcbnZhciBybmQgPSBnbG9iYWwucm5kID0gZ2xvYmFsLnJuZCB8fCB7fTtcclxuXHJcbnZhciBTR3JvdXAgPSBmdW5jdGlvbiAodHlwZSkge1xyXG5cdGlmICghdHlwZSB8fCAhKHR5cGUgaW4gU0dyb3VwLlRZUEVTKSlcclxuXHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBvciB1bnN1cHBvcnRlZCBzLWdyb3VwIHR5cGUnKTtcclxuXHJcblx0dGhpcy50eXBlID0gdHlwZTtcclxuXHR0aGlzLmlkID0gLTE7XHJcblx0U0dyb3VwLmVxdWlwKHRoaXMsIHR5cGUpO1xyXG5cdHRoaXMubGFiZWwgPSAtMTtcclxuXHR0aGlzLmJyYWNrZXRCb3ggPSBudWxsO1xyXG5cdHRoaXMuYnJhY2tldERpciA9IG5ldyBWZWMyKDEsMCk7XHJcblx0dGhpcy5hcmVhcyA9IFtdO1xyXG5cclxuXHR0aGlzLmhpZ2hsaWdodCA9IGZhbHNlO1xyXG5cdHRoaXMuaGlnaGxpZ2h0aW5nID0gbnVsbDtcclxuXHR0aGlzLnNlbGVjdGVkID0gZmFsc2U7XHJcblx0dGhpcy5zZWxlY3Rpb25QbGF0ZSA9IG51bGw7XHJcblxyXG5cdHRoaXMuYXRvbXMgPSBbXTtcclxuXHR0aGlzLnBhdG9tcyA9IFtdO1xyXG5cdHRoaXMuYm9uZHMgPSBbXTtcclxuXHR0aGlzLnhCb25kcyA9IFtdO1xyXG5cdHRoaXMubmVpQXRvbXMgPSBbXTtcclxuXHR0aGlzLnBwID0gbnVsbDtcclxuXHR0aGlzLmRhdGEgPSB7XHJcblx0XHQnbXVsJzogMSwgLy8gbXVsdGlwbGljYXRpb24gY291bnQgZm9yIE1VTCBncm91cFxyXG5cdFx0J2Nvbm5lY3Rpdml0eSc6ICdodCcsIC8vIGhlYWQtdG8taGVhZCwgaGVhZC10by10YWlsIG9yIGVpdGhlci11bmtub3duXHJcblx0XHQnbmFtZSc6ICcnLFxyXG5cdFx0J3N1YnNjcmlwdCc6ICduJyxcclxuXHJcblx0XHQvLyBkYXRhIHMtZ3JvdXAgZmllbGRzXHJcblx0XHQnYXR0YWNoZWQnOiBmYWxzZSxcclxuXHRcdCdhYnNvbHV0ZSc6IHRydWUsXHJcblx0XHQnc2hvd1VuaXRzJzogZmFsc2UsXHJcblx0XHQnbkNoYXJzVG9EaXNwbGF5JzogLTEsXHJcblx0XHQndGFnQ2hhcic6ICcnLFxyXG5cdFx0J2Rhc3BQb3MnOiAxLFxyXG5cdFx0J2ZpZWxkVHlwZSc6ICdGJyxcclxuXHRcdCdmaWVsZE5hbWUnOiAnJyxcclxuXHRcdCdmaWVsZFZhbHVlJzogJycsXHJcblx0XHQndW5pdHMnOiAnJyxcclxuXHRcdCdxdWVyeSc6ICcnLFxyXG5cdFx0J3F1ZXJ5T3AnOiAnJ1xyXG5cdH1cclxufTtcclxuXHJcbi8vIFRPRE86IHRoZXNlIG1ldGhvZHMgc2hvdWxkIGJlIG92ZXJyaWRkZW5cclxuLy8gICAgICBhbmQgc2hvdWxkIG9ubHkgYWNjZXB0IHZhbGlkIGF0dHJpYnV0ZXMgZm9yIGVhY2ggUy1ncm91cCB0eXBlLlxyXG4vLyAgICAgIFRoZSBhdHRyaWJ1dGVzIHNob3VsZCBiZSBhY2Nlc3NlZCB2aWEgdGhlc2UgbWV0aG9kcyBvbmx5IGFuZCBub3QgZGlyZWN0bHkgdGhyb3VnaCB0aGlzLmRhdGEuXHJcbi8vIHN0dWJcclxuU0dyb3VwLnByb3RvdHlwZS5nZXRBdHRyID0gZnVuY3Rpb24gKGF0dHIpIHtcclxuXHRyZXR1cm4gdGhpcy5kYXRhW2F0dHJdO1xyXG59O1xyXG5cclxuLy8gVE9ETzogc2hvdWxkIGJlIGdyb3VwLXNwZWNpZmljXHJcblNHcm91cC5wcm90b3R5cGUuZ2V0QXR0cnMgPSBmdW5jdGlvbiAoKSB7XHJcblx0dmFyIGF0dHJzID0ge307XHJcblx0Zm9yICh2YXIgYXR0ciBpbiB0aGlzLmRhdGEpXHJcblx0XHRhdHRyc1thdHRyXSA9IHRoaXMuZGF0YVthdHRyXTtcclxuXHRyZXR1cm4gYXR0cnM7XHJcbn07XHJcblxyXG4vLyBzdHViXHJcblNHcm91cC5wcm90b3R5cGUuc2V0QXR0ciA9IGZ1bmN0aW9uIChhdHRyLCB2YWx1ZSkge1xyXG5cdHZhciBvbGRWYWx1ZSA9IHRoaXMuZGF0YVthdHRyXTtcclxuXHR0aGlzLmRhdGFbYXR0cl0gPSB2YWx1ZTtcclxuXHRyZXR1cm4gb2xkVmFsdWU7XHJcbn07XHJcblxyXG4vLyBzdHViXHJcblNHcm91cC5wcm90b3R5cGUuY2hlY2tBdHRyID0gZnVuY3Rpb24gKGF0dHIsIHZhbHVlKSB7XHJcblx0cmV0dXJuIHRoaXMuZGF0YVthdHRyXSA9PSB2YWx1ZTtcclxufTtcclxuXHJcblNHcm91cC5lcXVpcCA9IGZ1bmN0aW9uIChzZ3JvdXAsIHR5cGUpIHtcclxuXHR2YXIgaW1wbCA9IFNHcm91cC5UWVBFU1t0eXBlXTtcclxuXHRmb3IgKHZhciBtZXRob2QgaW4gaW1wbClcclxuXHRcdHNncm91cFttZXRob2RdID0gaW1wbFttZXRob2RdO1xyXG59O1xyXG5cclxuU0dyb3VwLm51bWJlckFycmF5VG9TdHJpbmcgPSBmdW5jdGlvbiAobnVtYmVycywgbWFwKSB7XHJcblx0dmFyIHN0ciA9IHV0aWwuc3RyaW5nUGFkZGVkKG51bWJlcnMubGVuZ3RoLCAzKTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IG51bWJlcnMubGVuZ3RoOyArK2kpIHtcclxuXHRcdHN0ciArPSAnICcgKyB1dGlsLnN0cmluZ1BhZGRlZChtYXBbbnVtYmVyc1tpXV0sIDMpO1xyXG5cdH1cclxuXHRyZXR1cm4gc3RyO1xyXG59O1xyXG5cclxuXHJcblNHcm91cC5icmFja2V0c1RvTW9sZmlsZSA9IGZ1bmN0aW9uIChtb2wsIHNnLCBpZHN0cikge1xyXG5cdHZhciBpbkJvbmRzID0gW10sIHhCb25kcyA9IFtdO1xyXG5cdHZhciBhdG9tU2V0ID0gU2V0LmZyb21MaXN0KHNnLmF0b21zKTtcclxuXHRTR3JvdXAuZ2V0Q3Jvc3NCb25kcyhpbkJvbmRzLCB4Qm9uZHMsIG1vbCwgYXRvbVNldCk7XHJcblx0U0dyb3VwLmJyYWNrZXRQb3Moc2csIG51bGwsIG1vbCwgeEJvbmRzKTtcclxuXHR2YXIgYmIgPSBzZy5icmFja2V0Qm94O1xyXG5cdHZhciBkID0gc2cuYnJhY2tldERpciwgbiA9IGQucm90YXRlU0MoMSwgMCk7XHJcblx0dmFyIGJyYWNrZXRzID0gU0dyb3VwLmdldEJyYWNrZXRQYXJhbWV0ZXJzKG1vbCwgeEJvbmRzLCBhdG9tU2V0LCBiYiwgZCwgbiwgbnVsbCwgc2cuaWQpO1xyXG5cdHZhciBsaW5lcyA9IFtdO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYnJhY2tldHMubGVuZ3RoOyArK2kpIHtcclxuXHRcdHZhciBicmFja2V0ID0gYnJhY2tldHNbaV07XHJcblx0XHR2YXIgYTAgPSBicmFja2V0LmMuYWRkU2NhbGVkKGJyYWNrZXQubiwgLTAuNSAqIGJyYWNrZXQuaCkueUNvbXBsZW1lbnQoKTtcclxuXHRcdHZhciBhMSA9IGJyYWNrZXQuYy5hZGRTY2FsZWQoYnJhY2tldC5uLCAwLjUgKiBicmFja2V0LmgpLnlDb21wbGVtZW50KCk7XHJcblx0XHR2YXIgbGluZSA9ICdNICBTREkgJyArIGlkc3RyICsgdXRpbC5wYWRkZWRJbnQoNCwgMyk7XHJcblx0XHR2YXIgY29vcmQgPSBbYTAueCwgYTAueSwgYTEueCwgYTEueV07XHJcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGNvb3JkLmxlbmd0aDsgKytqKSB7XHJcblx0XHRcdGxpbmUgKz0gdXRpbC5wYWRkZWRGbG9hdChjb29yZFtqXSwgMTAsIDQpO1xyXG5cdFx0fVxyXG5cdFx0bGluZXMucHVzaChsaW5lKTtcclxuXHR9XHJcblx0cmV0dXJuIGxpbmVzO1xyXG59O1xyXG5cclxudmFyIGZpbHRlckF0b21zID0gZnVuY3Rpb24gKGF0b21zLCBtYXApIHtcclxuXHR2YXIgbmV3QXRvbXMgPSBbXTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGF0b21zLmxlbmd0aDsgKytpKSB7XHJcblx0XHR2YXIgYWlkID0gYXRvbXNbaV07XHJcblx0XHRpZiAodHlwZW9mKG1hcFthaWRdKSAhPSAnbnVtYmVyJykge1xyXG5cdFx0XHRuZXdBdG9tcy5wdXNoKGFpZCk7XHJcblx0XHR9IGVsc2UgaWYgKG1hcFthaWRdID49IDApIHtcclxuXHRcdFx0bmV3QXRvbXMucHVzaChtYXBbYWlkXSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRuZXdBdG9tcy5wdXNoKC0xKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIG5ld0F0b21zO1xyXG59O1xyXG5cclxudmFyIHJlbW92ZU5lZ2F0aXZlID0gZnVuY3Rpb24gKGF0b21zKSB7XHJcbiAgICB2YXIgbmV3QXRvbXMgPSBbXTtcclxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXRvbXMubGVuZ3RoOyArK2opXHJcbiAgICAgICAgaWYgKGF0b21zW2pdID49IDApXHJcbiAgICAgICAgICAgIG5ld0F0b21zLnB1c2goYXRvbXNbal0pO1xyXG4gICAgcmV0dXJuIG5ld0F0b21zO1xyXG59O1xyXG5cclxuU0dyb3VwLmNsb25lID0gZnVuY3Rpb24gKHNncm91cCwgYWlkTWFwLCBiaWRNYXApXHJcbntcclxuXHR2YXIgY3AgPSBuZXcgU0dyb3VwKHNncm91cC50eXBlKTtcclxuXHJcblx0Zm9yICh2YXIgZmllbGQgaW4gc2dyb3VwLmRhdGEpIHsgLy8gVE9ETzogcmVtb3ZlIGFsbCBub24tcHJpbWl0aXZlIHByb3BlcnRpZXMgZnJvbSAnZGF0YSdcclxuXHRcdGNwLmRhdGFbZmllbGRdID0gc2dyb3VwLmRhdGFbZmllbGRdO1xyXG5cdH1cclxuXHRjcC5hdG9tcyA9IHV0aWwubWFwQXJyYXkoc2dyb3VwLmF0b21zLCBhaWRNYXApO1xyXG5cdGNwLnBwID0gc2dyb3VwLnBwO1xyXG5cdGNwLmJyYWNrZXRCb3ggPSBzZ3JvdXAuYnJhY2tldEJveDtcclxuXHRjcC5wYXRvbXMgPSBudWxsO1xyXG5cdGNwLmJvbmRzID0gbnVsbDtcclxuXHRjcC5hbGxBdG9tcyA9IHNncm91cC5hbGxBdG9tcztcclxuXHRyZXR1cm4gY3A7XHJcbn07XHJcblxyXG5TR3JvdXAuYWRkQXRvbSA9IGZ1bmN0aW9uIChzZ3JvdXAsIGFpZClcclxue1xyXG5cdHNncm91cC5hdG9tcy5wdXNoKGFpZCk7XHJcbn07XHJcblxyXG5TR3JvdXAucmVtb3ZlQXRvbSA9IGZ1bmN0aW9uIChzZ3JvdXAsIGFpZClcclxue1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc2dyb3VwLmF0b21zLmxlbmd0aDsgKytpKSB7XHJcblx0XHRpZiAoc2dyb3VwLmF0b21zW2ldID09PSBhaWQpIHtcclxuXHRcdFx0c2dyb3VwLmF0b21zLnNwbGljZShpLCAxKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdH1cclxuXHR0aHJvdyBuZXcgRXJyb3IoJ1RoZSBhdG9tIGlzIG5vdCBmb3VuZCBpbiB0aGUgZ2l2ZW4gcy1ncm91cCcpO1xyXG59O1xyXG5cclxuU0dyb3VwLmdldENyb3NzQm9uZHMgPSBmdW5jdGlvbiAoaW5Cb25kcywgeEJvbmRzLCBtb2wsIHBhcmVudEF0b21TZXQpIHtcclxuXHRtb2wuYm9uZHMuZWFjaChmdW5jdGlvbiAoYmlkLCBib25kKXtcclxuXHRcdGlmIChTZXQuY29udGFpbnMocGFyZW50QXRvbVNldCwgYm9uZC5iZWdpbikgJiYgU2V0LmNvbnRhaW5zKHBhcmVudEF0b21TZXQsIGJvbmQuZW5kKSkge1xyXG5cdFx0XHRpZiAoIXV0aWwuaXNOdWxsKGluQm9uZHMpKVxyXG5cdFx0XHRcdGluQm9uZHMucHVzaChiaWQpO1xyXG5cdFx0fSBlbHNlIGlmIChTZXQuY29udGFpbnMocGFyZW50QXRvbVNldCwgYm9uZC5iZWdpbikgfHwgU2V0LmNvbnRhaW5zKHBhcmVudEF0b21TZXQsIGJvbmQuZW5kKSkge1xyXG5cdFx0XHRpZiAoIXV0aWwuaXNOdWxsKHhCb25kcykpXHJcblx0XHRcdFx0eEJvbmRzLnB1c2goYmlkKTtcclxuXHRcdH1cclxuXHR9LCB0aGlzKTtcclxufTtcclxuXHJcblNHcm91cC5icmFja2V0UG9zID0gZnVuY3Rpb24gKHNnLCByZW5kZXIsIG1vbCwgeGJvbmRzKSB7XHJcblx0dmFyIGF0b21zID0gc2cuYXRvbXM7XHJcblx0aWYgKCF4Ym9uZHMgfHwgeGJvbmRzLmxlbmd0aCAhPT0gMikge1xyXG5cdFx0c2cuYnJhY2tldERpciA9IG5ldyBWZWMyKDEsIDApO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR2YXIgYjEgPSBtb2wuYm9uZHMuZ2V0KHhib25kc1swXSksIGIyID0gbW9sLmJvbmRzLmdldCh4Ym9uZHNbMV0pO1xyXG5cdFx0dmFyIHAxID0gYjEuZ2V0Q2VudGVyKG1vbCksIHAyID0gYjIuZ2V0Q2VudGVyKG1vbCk7XHJcblx0XHRzZy5icmFja2V0RGlyID0gVmVjMi5kaWZmKHAyLCBwMSkubm9ybWFsaXplZCgpO1xyXG5cdH1cclxuXHR2YXIgZCA9IHNnLmJyYWNrZXREaXI7XHJcblx0dmFyIG4gPSBkLnJvdGF0ZVNDKDEsIDApO1xyXG5cclxuXHR2YXIgYmIgPSBudWxsO1xyXG5cdHZhciBjb250ZW50Qm94ZXMgPSBbXTtcclxuXHR1dGlsLmVhY2goYXRvbXMsIGZ1bmN0aW9uIChhaWQpIHtcclxuXHRcdHZhciBhdG9tID0gbW9sLmF0b21zLmdldChhaWQpO1xyXG5cdFx0dmFyIGJiYSA9IHJlbmRlciA/IHJlbmRlci5jdGFiLmF0b21zLmdldChhaWQpLnZpc2VsLmJvdW5kaW5nQm94IDogbnVsbDtcclxuXHRcdHZhciBwb3MgPSBuZXcgVmVjMihhdG9tLnBwKTtcclxuXHRcdGlmICh1dGlsLmlzTnVsbChiYmEpKSB7XHJcblx0XHRcdGJiYSA9IG5ldyBCb3gyQWJzKHBvcywgcG9zKTtcclxuXHRcdFx0dmFyIGV4dCA9IG5ldyBWZWMyKDAuMDUgKiAzLCAwLjA1ICogMyk7XHJcblx0XHRcdGJiYSA9IGJiYS5leHRlbmQoZXh0LCBleHQpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0YmJhID0gYmJhLnRyYW5zbGF0ZSgocmVuZGVyLm9mZnNldCB8fCBuZXcgVmVjMigpKS5uZWdhdGVkKCkpLnRyYW5zZm9ybShyZW5kZXIuc2NhbGVkMm9iaiwgcmVuZGVyKTtcclxuXHRcdH1cclxuXHRcdGNvbnRlbnRCb3hlcy5wdXNoKGJiYSk7XHJcblx0fSwgdGhpcyk7XHJcblx0dXRpbC5lYWNoKG1vbC5zR3JvdXBGb3Jlc3QuY2hpbGRyZW4uZ2V0KHNnLmlkKSwgZnVuY3Rpb24gKHNnaWQpIHtcclxuXHRcdHZhciBiYmEgPSByZW5kZXIgPyByZW5kZXIuY3RhYi5zZ3JvdXBzLmdldChzZ2lkKS52aXNlbC5ib3VuZGluZ0JveCA6IG51bGw7XHJcblx0XHRpZiAodXRpbC5pc051bGwoYmJhKSlcclxuXHRcdFx0cmV0dXJuOyAvLyBUT0RPOiB1c2Ugb2JqZWN0IGJveCBpbnN0ZWFkXHJcblx0XHRiYmEgPSBiYmEudHJhbnNsYXRlKChyZW5kZXIub2Zmc2V0IHx8IG5ldyBWZWMyKCkpLm5lZ2F0ZWQoKSkudHJhbnNmb3JtKHJlbmRlci5zY2FsZWQyb2JqLCByZW5kZXIpO1xyXG5cdFx0Y29udGVudEJveGVzLnB1c2goYmJhKTtcclxuXHR9LCB0aGlzKTtcclxuXHR1dGlsLmVhY2goY29udGVudEJveGVzLCBmdW5jdGlvbiAoYmJhKSB7XHJcblx0XHR2YXIgYmJiID0gbnVsbDtcclxuXHRcdHV0aWwuZWFjaChbYmJhLnAwLngsIGJiYS5wMS54XSwgZnVuY3Rpb24gKHgpIHtcclxuXHRcdFx0dXRpbC5lYWNoKFtiYmEucDAueSwgYmJhLnAxLnldLCBmdW5jdGlvbiAoeSkge1xyXG5cdFx0XHRcdHZhciB2ID0gbmV3IFZlYzIoeCwgeSk7XHJcblx0XHRcdFx0dmFyIHAgPSBuZXcgVmVjMihWZWMyLmRvdCh2LCBkKSwgVmVjMi5kb3QodiwgbikpO1xyXG5cdFx0XHRcdGJiYiA9IHV0aWwuaXNOdWxsKGJiYikgPyBuZXcgQm94MkFicyhwLCBwKSA6IGJiYi5pbmNsdWRlKHApO1xyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdFx0YmIgPSB1dGlsLmlzTnVsbChiYikgPyBiYmIgOiBCb3gyQWJzLnVuaW9uKGJiLCBiYmIpO1xyXG5cdH0sIHRoaXMpO1xyXG5cdHZhciB2ZXh0ID0gbmV3IFZlYzIoMC4yLCAwLjQpO1xyXG5cdGlmICghdXRpbC5pc051bGwoYmIpKVxyXG5cdFx0YmIgPSBiYi5leHRlbmQodmV4dCwgdmV4dCk7XHJcblx0c2cuYnJhY2tldEJveCA9IGJiO1xyXG59O1xyXG5cclxuU0dyb3VwLmRyYXdCcmFja2V0cyA9IGZ1bmN0aW9uIChzZXQsIHJlbmRlciwgc2csIHhib25kcywgYXRvbVNldCwgYmIsIGQsIG4sIGxvd2VySW5kZXhUZXh0LCB1cHBlckluZGV4VGV4dCwgaW5kZXhBdHRyaWJ1dGUpIHtcclxuXHR2YXIgYnJhY2tldHMgPSBTR3JvdXAuZ2V0QnJhY2tldFBhcmFtZXRlcnMocmVuZGVyLmN0YWIubW9sZWN1bGUsIHhib25kcywgYXRvbVNldCwgYmIsIGQsIG4sIHJlbmRlciwgc2cuaWQpO1xyXG5cdHZhciBpciA9IC0xO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYnJhY2tldHMubGVuZ3RoOyArK2kpIHtcclxuXHRcdHZhciBicmFja2V0ID0gYnJhY2tldHNbaV07XHJcblx0XHR2YXIgcGF0aCA9IFNHcm91cC5kcmF3QnJhY2tldChyZW5kZXIsIHJlbmRlci5wYXBlciwgcmVuZGVyLnN0eWxlcywgYnJhY2tldC5kLCBicmFja2V0Lm4sIGJyYWNrZXQuYywgYnJhY2tldC53LCBicmFja2V0LmgpO1xyXG5cdFx0c2V0LnB1c2gocGF0aCk7XHJcblx0XHRpZiAoaXIgPCAwIHx8IGJyYWNrZXRzW2lyXS5kLnggPCBicmFja2V0LmQueCB8fCAoYnJhY2tldHNbaXJdLmQueCA9PSBicmFja2V0LmQueCAmJiBicmFja2V0c1tpcl0uZC55ID4gYnJhY2tldC5kLnkpKVxyXG5cdFx0XHRpciA9IGk7XHJcblx0fVxyXG5cdHZhciBicmFja2V0UiA9IGJyYWNrZXRzW2lyXTtcclxuXHR2YXIgcmVuZGVySW5kZXggPSBmdW5jdGlvbiAodGV4dCwgc2hpZnQpIHtcclxuXHRcdHZhciBpbmRleFBvcyA9IHJlbmRlci5wcyhicmFja2V0Ui5jLmFkZFNjYWxlZChicmFja2V0Ui5uLCBzaGlmdCAqIGJyYWNrZXRSLmgpKTtcclxuXHRcdHZhciBpbmRleFBhdGggPSByZW5kZXIucGFwZXIudGV4dChpbmRleFBvcy54LCBpbmRleFBvcy55LCB0ZXh0KVxyXG5cdFx0LmF0dHIoe1xyXG5cdFx0XHQnZm9udCc6IHJlbmRlci5zZXR0aW5ncy5mb250LFxyXG5cdFx0XHQnZm9udC1zaXplJzogcmVuZGVyLnNldHRpbmdzLmZvbnRzenN1YlxyXG5cdFx0fSk7XHJcblx0XHRpZiAoaW5kZXhBdHRyaWJ1dGUpXHJcblx0XHRcdGluZGV4UGF0aC5hdHRyKGluZGV4QXR0cmlidXRlKTtcclxuXHRcdHZhciBpbmRleEJveCA9IEJveDJBYnMuZnJvbVJlbEJveCh1dGlsLnJlbEJveChpbmRleFBhdGguZ2V0QkJveCgpKSk7XHJcblx0XHR2YXIgdCA9IE1hdGgubWF4KFZlYzIuc2hpZnRSYXlCb3goaW5kZXhQb3MsIGJyYWNrZXRSLmQubmVnYXRlZCgpLCBpbmRleEJveCksIDMpICsgMjtcclxuXHRcdGluZGV4UGF0aC50cmFuc2xhdGVBYnModCAqIGJyYWNrZXRSLmQueCwgdCAqIGJyYWNrZXRSLmQueSk7XHJcblx0XHRzZXQucHVzaChpbmRleFBhdGgpO1xyXG5cdH07XHJcblx0aWYgKGxvd2VySW5kZXhUZXh0KSB7XHJcblx0XHRyZW5kZXJJbmRleChsb3dlckluZGV4VGV4dCwgMC41KTtcclxuXHR9XHJcblx0aWYgKHVwcGVySW5kZXhUZXh0KSB7XHJcblx0XHRyZW5kZXJJbmRleCh1cHBlckluZGV4VGV4dCwgLTAuNSk7XHJcblx0fVxyXG59O1xyXG5cclxuU0dyb3VwLmRyYXdCcmFja2V0ID0gZnVuY3Rpb24gKHJlbmRlciwgcGFwZXIsIHN0eWxlcywgZCwgbiwgYywgYnJhY2tldFdpZHRoLCBicmFja2V0SGVpZ2h0KSB7XHJcblx0YnJhY2tldFdpZHRoID0gYnJhY2tldFdpZHRoIHx8IDAuMjU7XHJcblx0YnJhY2tldEhlaWdodCA9IGJyYWNrZXRIZWlnaHQgfHwgMS4wO1xyXG5cdHZhciBhMCA9IGMuYWRkU2NhbGVkKG4sIC0wLjUgKiBicmFja2V0SGVpZ2h0KTtcclxuXHR2YXIgYTEgPSBjLmFkZFNjYWxlZChuLCAwLjUgKiBicmFja2V0SGVpZ2h0KTtcclxuXHR2YXIgYjAgPSBhMC5hZGRTY2FsZWQoZCwgLWJyYWNrZXRXaWR0aCk7XHJcblx0dmFyIGIxID0gYTEuYWRkU2NhbGVkKGQsIC1icmFja2V0V2lkdGgpO1xyXG5cclxuXHRhMCA9IHJlbmRlci5vYmoyc2NhbGVkKGEwKTtcclxuXHRhMSA9IHJlbmRlci5vYmoyc2NhbGVkKGExKTtcclxuXHRiMCA9IHJlbmRlci5vYmoyc2NhbGVkKGIwKTtcclxuXHRiMSA9IHJlbmRlci5vYmoyc2NhbGVkKGIxKTtcclxuXHJcblx0cmV0dXJuIHBhcGVyLnBhdGgoJ00gezB9LCB7MX0gTCB7Mn0gLCB7M30gTCB7NH0gLCB7NX0gTCB7Nn0gLCB7N30nLFxyXG5cdFx0YjAueCwgYjAueSwgYTAueCwgYTAueSwgYTEueCwgYTEueSwgYjEueCwgYjEueSlcclxuXHQuYXR0cihzdHlsZXMuc2dyb3VwQnJhY2tldFN0eWxlKTtcclxufTtcclxuXHJcblNHcm91cC5nZXRCcmFja2V0UGFyYW1ldGVycyA9IGZ1bmN0aW9uIChtb2wsIHhib25kcywgYXRvbVNldCwgYmIsIGQsIG4sIHJlbmRlciwgaWQpIHtcclxuXHR2YXIgYnJhY2tldFBhcmFtcyA9IGZ1bmN0aW9uIChjLCBkLCB3LCBoKSB7XHJcblx0XHR0aGlzLmMgPSBjO1xyXG5cdFx0dGhpcy5kID0gZDtcclxuXHRcdHRoaXMubiA9IGQucm90YXRlU0MoMSwwKTtcclxuXHRcdHRoaXMudyA9IHc7XHJcblx0XHR0aGlzLmggPSBoO1xyXG5cdH07XHJcblx0dmFyIGJyYWNrZXRzID0gW107XHJcblx0aWYgKHhib25kcy5sZW5ndGggPCAyKSB7XHJcblx0XHQoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRkID0gZCB8fCBuZXcgVmVjMigxLCAwKTtcclxuXHRcdFx0biA9IG4gfHwgZC5yb3RhdGVTQygxLCAwKTtcclxuXHRcdFx0dmFyIGJyYWNrZXRXaWR0aCA9IE1hdGgubWluKDAuMjUsIGJiLnN6KCkueCAqIDAuMyk7XHJcblx0XHRcdHZhciBjbCA9IFZlYzIubGMyKGQsIGJiLnAwLngsIG4sIDAuNSAqIChiYi5wMC55ICsgYmIucDEueSkpO1xyXG5cdFx0XHR2YXIgY3IgPSBWZWMyLmxjMihkLCBiYi5wMS54LCBuLCAwLjUgKiAoYmIucDAueSArIGJiLnAxLnkpKTtcclxuXHRcdFx0dmFyIGJyYWNrZXRIZWlnaHQgPSBiYi5zeigpLnk7XHJcblxyXG5cdFx0XHRicmFja2V0cy5wdXNoKG5ldyBicmFja2V0UGFyYW1zKGNsLCBkLm5lZ2F0ZWQoKSwgYnJhY2tldFdpZHRoLCBicmFja2V0SGVpZ2h0KSwgbmV3IGJyYWNrZXRQYXJhbXMoY3IsIGQsIGJyYWNrZXRXaWR0aCwgYnJhY2tldEhlaWdodCkpO1xyXG5cdFx0fSkoKTtcclxuXHR9IGVsc2UgaWYgKHhib25kcy5sZW5ndGggPT09IDIpIHtcclxuXHRcdChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHZhciBiMSA9IG1vbC5ib25kcy5nZXQoeGJvbmRzWzBdKSwgYjIgPSBtb2wuYm9uZHMuZ2V0KHhib25kc1sxXSk7XHJcblx0XHRcdHZhciBjbDAgPSBiMS5nZXRDZW50ZXIobW9sKSwgY3IwID0gYjIuZ2V0Q2VudGVyKG1vbCksIHRsID0gLTEsIHRyID0gLTEsIHR0ID0gLTEsIHRiID0gLTEsIGNjID0gVmVjMi5jZW50cmUoY2wwLCBjcjApO1xyXG5cdFx0XHR2YXIgZHIgPSBWZWMyLmRpZmYoY3IwLCBjbDApLm5vcm1hbGl6ZWQoKSwgZGwgPSBkci5uZWdhdGVkKCksIGR0ID0gZHIucm90YXRlU0MoMSwwKSwgZGIgPSBkdC5uZWdhdGVkKCk7XHJcblxyXG5cdFx0XHR1dGlsLmVhY2gobW9sLnNHcm91cEZvcmVzdC5jaGlsZHJlbi5nZXQoaWQpLCBmdW5jdGlvbiAoc2dpZCkge1xyXG5cdFx0XHRcdHZhciBiYmEgPSByZW5kZXIgPyByZW5kZXIuY3RhYi5zZ3JvdXBzLmdldChzZ2lkKS52aXNlbC5ib3VuZGluZ0JveCA6IG51bGw7XHJcblx0XHRcdFx0aWYgKHV0aWwuaXNOdWxsKGJiYSkpXHJcblx0XHRcdFx0XHRyZXR1cm47IC8vIFRPRE86IHVzZSBvYmplY3QgYm94IGluc3RlYWRcclxuXHRcdFx0XHRiYmEgPSBiYmEudHJhbnNsYXRlKChyZW5kZXIub2Zmc2V0IHx8IG5ldyBWZWMyKCkpLm5lZ2F0ZWQoKSkudHJhbnNmb3JtKHJlbmRlci5zY2FsZWQyb2JqLCByZW5kZXIpO1xyXG5cdFx0XHRcdHRsID0gTWF0aC5tYXgodGwsIFZlYzIuc2hpZnRSYXlCb3goY2wwLCBkbCwgYmJhKSk7XHJcblx0XHRcdFx0dHIgPSBNYXRoLm1heCh0ciwgVmVjMi5zaGlmdFJheUJveChjcjAsIGRyLCBiYmEpKTtcclxuXHRcdFx0XHR0dCA9IE1hdGgubWF4KHR0LCBWZWMyLnNoaWZ0UmF5Qm94KGNjLCBkdCwgYmJhKSk7XHJcblx0XHRcdFx0dGIgPSBNYXRoLm1heCh0YiwgVmVjMi5zaGlmdFJheUJveChjYywgZGIsIGJiYSkpO1xyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdFx0dGwgPSBNYXRoLm1heCh0bCArIDAuMiwgMCk7XHJcblx0XHRcdHRyID0gTWF0aC5tYXgodHIgKyAwLjIsIDApO1xyXG5cdFx0XHR0dCA9IE1hdGgubWF4KE1hdGgubWF4KHR0LCB0YikgKyAwLjEsIDApO1xyXG5cdFx0XHR2YXIgYnJhY2tldFdpZHRoID0gMC4yNSwgYnJhY2tldEhlaWdodCA9IDEuNSArIHR0O1xyXG5cdFx0XHRicmFja2V0cy5wdXNoKG5ldyBicmFja2V0UGFyYW1zKGNsMC5hZGRTY2FsZWQoZGwsIHRsKSwgZGwsIGJyYWNrZXRXaWR0aCwgYnJhY2tldEhlaWdodCksXHJcblx0XHRcdG5ldyBicmFja2V0UGFyYW1zKGNyMC5hZGRTY2FsZWQoZHIsIHRyKSwgZHIsIGJyYWNrZXRXaWR0aCwgYnJhY2tldEhlaWdodCkpO1xyXG5cdFx0fSkoKTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHRcdChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeGJvbmRzLmxlbmd0aDsgKytpKSB7XHJcblx0XHRcdFx0dmFyIGIgPSBtb2wuYm9uZHMuZ2V0KHhib25kc1tpXSk7XHJcblx0XHRcdFx0dmFyIGMgPSBiLmdldENlbnRlcihtb2wpO1xyXG5cdFx0XHRcdHZhciBkID0gU2V0LmNvbnRhaW5zKGF0b21TZXQsIGIuYmVnaW4pID8gYi5nZXREaXIobW9sKSA6IGIuZ2V0RGlyKG1vbCkubmVnYXRlZCgpO1xyXG5cdFx0XHRcdGJyYWNrZXRzLnB1c2gobmV3IGJyYWNrZXRQYXJhbXMoYywgZCwgMC4yLCAxLjApKTtcclxuXHRcdFx0fVxyXG5cdFx0fSkoKTtcclxuXHR9XHJcblx0cmV0dXJuIGJyYWNrZXRzO1xyXG59O1xyXG5cclxuU0dyb3VwLmdldE9iakJCb3ggPSBmdW5jdGlvbiAoYXRvbXMsIG1vbClcclxue1xyXG5cdGlmIChhdG9tcy5sZW5ndGggPT0gMClcclxuXHRcdHRocm93IG5ldyBFcnJvcignQXRvbSBsaXN0IGlzIGVtcHR5Jyk7XHJcblxyXG5cdHZhciBhMCA9IG1vbC5hdG9tcy5nZXQoYXRvbXNbMF0pLnBwO1xyXG5cdHZhciBiYiA9IG5ldyBCb3gyQWJzKGEwLCBhMCk7XHJcblx0Zm9yICh2YXIgaSA9IDE7IGkgPCBhdG9tcy5sZW5ndGg7ICsraSkge1xyXG5cdFx0dmFyIGFpZCA9IGF0b21zW2ldO1xyXG5cdFx0dmFyIGF0b20gPSBtb2wuYXRvbXMuZ2V0KGFpZCk7XHJcblx0XHR2YXIgcCA9IGF0b20ucHA7XHJcblx0XHRiYiA9IGJiLmluY2x1ZGUocCk7XHJcblx0fVxyXG5cdHJldHVybiBiYjtcclxufTtcclxuXHJcblNHcm91cC5tYWtlQXRvbUJvbmRMaW5lcyA9IGZ1bmN0aW9uIChwcmVmaXgsIGlkc3RyLCBpZHMsIG1hcCkge1xyXG5cdGlmICghaWRzKVxyXG5cdFx0cmV0dXJuIFtdO1xyXG5cdHZhciBsaW5lcyA9IFtdO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgTWF0aC5mbG9vcigoaWRzLmxlbmd0aCArIDE0KSAvIDE1KTsgKytpKSB7XHJcblx0XHR2YXIgcmVtID0gTWF0aC5taW4oaWRzLmxlbmd0aCAtIDE1ICogaSwgMTUpO1xyXG5cdFx0dmFyIHNhbExpbmUgPSAnTSAgJyArIHByZWZpeCArICcgJyArIGlkc3RyICsgJyAnICsgdXRpbC5wYWRkZWRJbnQocmVtLCAyKTtcclxuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgcmVtOyArK2opIHtcclxuXHRcdFx0c2FsTGluZSArPSAnICcgKyB1dGlsLnBhZGRlZEludChtYXBbaWRzW2kgKiAxNSArIGpdXSwgMyk7XHJcblx0XHR9XHJcblx0XHRsaW5lcy5wdXNoKHNhbExpbmUpO1xyXG5cdH1cclxuXHRyZXR1cm4gbGluZXM7XHJcbn07XHJcblxyXG5TR3JvdXAuZ2V0QXRvbXMgPSBmdW5jdGlvbiAobW9sLCBzZykge1xyXG5cdGlmICghc2cuYWxsQXRvbXMpXHJcblx0XHRyZXR1cm4gc2cuYXRvbXM7XHJcblx0dmFyIGF0b21zID0gW107XHJcblx0bW9sLmF0b21zLmVhY2goZnVuY3Rpb24gKGFpZCl7XHJcblx0XHRhdG9tcy5wdXNoKGFpZCk7XHJcblx0fSk7XHJcblx0cmV0dXJuIGF0b21zO1xyXG59O1xyXG5cclxuU0dyb3VwLmdldEJvbmRzID0gZnVuY3Rpb24gKG1vbCwgc2cpIHtcclxuXHR2YXIgYXRvbXMgPSBTR3JvdXAuZ2V0QXRvbXMobW9sLCBzZyk7XHJcblx0dmFyIGJvbmRzID0gW107XHJcblx0bW9sLmJvbmRzLmVhY2goZnVuY3Rpb24gKGJpZCwgYm9uZCl7XHJcblx0XHRpZiAoYXRvbXMuaW5kZXhPZihib25kLmJlZ2luKSA+PSAwICYmIGF0b21zLmluZGV4T2YoYm9uZC5lbmQpID49IDApIGJvbmRzLnB1c2goYmlkKTtcclxuXHR9KTtcclxuXHRyZXR1cm4gYm9uZHM7XHJcbn07XHJcblxyXG52YXIgR3JvdXBNdWwgPSB7XHJcblx0ZHJhdzogZnVuY3Rpb24gKHJlbW9sKSB7XHJcblx0XHR2YXIgcmVuZGVyID0gcmVtb2wucmVuZGVyO1xyXG5cdFx0dmFyIHNldCA9IHJlbmRlci5wYXBlci5zZXQoKTtcclxuXHRcdHZhciBpbkJvbmRzID0gW10sIHhCb25kcyA9IFtdO1xyXG5cdFx0dmFyIGF0b21TZXQgPSBTZXQuZnJvbUxpc3QodGhpcy5hdG9tcyk7XHJcblx0XHRTR3JvdXAuZ2V0Q3Jvc3NCb25kcyhpbkJvbmRzLCB4Qm9uZHMsIHJlbW9sLm1vbGVjdWxlLCBhdG9tU2V0KTtcclxuXHRcdFNHcm91cC5icmFja2V0UG9zKHRoaXMsIHJlbmRlciwgcmVtb2wubW9sZWN1bGUsIHhCb25kcyk7XHJcblx0XHR2YXIgYmIgPSB0aGlzLmJyYWNrZXRCb3g7XHJcblx0XHR2YXIgZCA9IHRoaXMuYnJhY2tldERpciwgbiA9IGQucm90YXRlU0MoMSwgMCk7XHJcblx0XHR0aGlzLmFyZWFzID0gW2JiXTtcclxuXHRcdFNHcm91cC5kcmF3QnJhY2tldHMoc2V0LCByZW5kZXIsIHRoaXMsIHhCb25kcywgYXRvbVNldCwgYmIsIGQsIG4sIHRoaXMuZGF0YS5tdWwpO1xyXG5cdFx0cmV0dXJuIHNldDtcclxuXHR9LFxyXG5cclxuXHRzYXZlVG9Nb2xmaWxlOiBmdW5jdGlvbiAobW9sLCBzZ01hcCwgYXRvbU1hcCwgYm9uZE1hcCkge1xyXG5cdFx0dmFyIGlkc3RyID0gdXRpbC5zdHJpbmdQYWRkZWQoc2dNYXBbdGhpcy5pZF0sIDMpO1xyXG5cclxuXHRcdHZhciBsaW5lcyA9IFtdO1xyXG5cdFx0bGluZXMgPSBsaW5lcy5jb25jYXQoU0dyb3VwLm1ha2VBdG9tQm9uZExpbmVzKCdTQUwnLCBpZHN0ciwgdXRpbC5pZExpc3QodGhpcy5hdG9tU2V0KSwgYXRvbU1hcCkpOyAvLyBUT0RPOiBjaGVjayBhdG9tU2V0XHJcblx0XHRsaW5lcyA9IGxpbmVzLmNvbmNhdChTR3JvdXAubWFrZUF0b21Cb25kTGluZXMoJ1NQQScsIGlkc3RyLCB1dGlsLmlkTGlzdCh0aGlzLnBhcmVudEF0b21TZXQpLCBhdG9tTWFwKSk7XHJcblx0XHRsaW5lcyA9IGxpbmVzLmNvbmNhdChTR3JvdXAubWFrZUF0b21Cb25kTGluZXMoJ1NCTCcsIGlkc3RyLCB0aGlzLmJvbmRzLCBib25kTWFwKSk7XHJcblx0XHR2YXIgc210TGluZSA9ICdNICBTTVQgJyArIGlkc3RyICsgJyAnICsgdGhpcy5kYXRhLm11bDtcclxuXHRcdGxpbmVzLnB1c2goc210TGluZSk7XHJcblx0XHRsaW5lcyA9IGxpbmVzLmNvbmNhdChTR3JvdXAuYnJhY2tldHNUb01vbGZpbGUobW9sLCB0aGlzLCBpZHN0cikpO1xyXG5cdFx0cmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xyXG5cdH0sXHJcblxyXG5cdHByZXBhcmVGb3JTYXZpbmc6IGZ1bmN0aW9uIChtb2wpIHtcclxuXHRcdHZhciBqO1xyXG5cdFx0dGhpcy5hdG9tcy5zb3J0KCk7XHJcblx0XHR0aGlzLmF0b21TZXQgPSBTZXQuZnJvbUxpc3QodGhpcy5hdG9tcyk7XHJcblx0XHR0aGlzLnBhcmVudEF0b21TZXQgPSBTZXQuY2xvbmUodGhpcy5hdG9tU2V0KTtcclxuXHRcdHZhciBpbkJvbmRzID0gW107XHJcblx0XHR2YXIgeEJvbmRzID0gW107XHJcblxyXG5cdFx0bW9sLmJvbmRzLmVhY2goZnVuY3Rpb24gKGJpZCwgYm9uZCl7XHJcblx0XHRcdGlmIChTZXQuY29udGFpbnModGhpcy5wYXJlbnRBdG9tU2V0LCBib25kLmJlZ2luKSAmJiBTZXQuY29udGFpbnModGhpcy5wYXJlbnRBdG9tU2V0LCBib25kLmVuZCkpXHJcblx0XHRcdFx0aW5Cb25kcy5wdXNoKGJpZCk7XHJcblx0XHRcdGVsc2UgaWYgKFNldC5jb250YWlucyh0aGlzLnBhcmVudEF0b21TZXQsIGJvbmQuYmVnaW4pIHx8IFNldC5jb250YWlucyh0aGlzLnBhcmVudEF0b21TZXQsYm9uZC5lbmQpKVxyXG5cdFx0XHRcdHhCb25kcy5wdXNoKGJpZCk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHRcdGlmICh4Qm9uZHMubGVuZ3RoICE9IDAgJiYgeEJvbmRzLmxlbmd0aCAhPSAyKVxyXG5cdFx0XHR0aHJvdyB7XHJcblx0XHRcdFx0J2lkJzp0aGlzLmlkLFxyXG5cdFx0XHRcdCdlcnJvci10eXBlJzonY3Jvc3MtYm9uZC1udW1iZXInLFxyXG5cdFx0XHRcdCdtZXNzYWdlJzonVW5zdXBwb3J0ZWQgY3Jvc3MtYm9uZHMgbnVtYmVyJ1xyXG5cdFx0XHR9O1xyXG5cclxuXHRcdHZhciB4QXRvbTEgPSAtMSxcclxuXHRcdHhBdG9tMiA9IC0xO1xyXG5cdFx0dmFyIGNyb3NzQm9uZCA9IG51bGw7XHJcblx0XHRpZiAoeEJvbmRzLmxlbmd0aCA9PSAyKSB7XHJcblx0XHRcdHZhciBib25kMSA9IG1vbC5ib25kcy5nZXQoeEJvbmRzWzBdKTtcclxuXHRcdFx0aWYgKFNldC5jb250YWlucyh0aGlzLnBhcmVudEF0b21TZXQsIGJvbmQxLmJlZ2luKSkge1xyXG5cdFx0XHRcdHhBdG9tMSA9IGJvbmQxLmJlZ2luO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHhBdG9tMSA9IGJvbmQxLmVuZDtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgYm9uZDIgPSBtb2wuYm9uZHMuZ2V0KHhCb25kc1sxXSk7XHJcblx0XHRcdGlmIChTZXQuY29udGFpbnModGhpcy5wYXJlbnRBdG9tU2V0LCBib25kMi5iZWdpbikpIHtcclxuXHRcdFx0XHR4QXRvbTIgPSBib25kMi5iZWdpbjtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR4QXRvbTIgPSBib25kMi5lbmQ7XHJcblx0XHRcdH1cclxuXHRcdFx0Y3Jvc3NCb25kID0gYm9uZDI7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGFtYXAgPSBudWxsO1xyXG5cdFx0dmFyIHRhaWxBdG9tID0geEF0b20xO1xyXG5cclxuXHRcdHZhciBuZXdBdG9tcyA9IFtdO1xyXG5cdFx0Zm9yIChqID0gMDsgaiA8IHRoaXMuZGF0YS5tdWwgLSAxOyArK2opIHtcclxuXHRcdFx0YW1hcCA9IHt9O1xyXG5cdFx0XHR1dGlsLmVhY2godGhpcy5hdG9tcywgZnVuY3Rpb24gKGFpZCkge1xyXG5cdFx0XHRcdHZhciBhdG9tID0gbW9sLmF0b21zLmdldChhaWQpO1xyXG5cdFx0XHRcdHZhciBhaWQyID0gbW9sLmF0b21zLmFkZChuZXcgQXRvbShhdG9tKSk7XHJcblx0XHRcdFx0bmV3QXRvbXMucHVzaChhaWQyKTtcclxuXHRcdFx0XHR0aGlzLmF0b21TZXRbYWlkMl0gPSAxO1xyXG5cdFx0XHRcdGFtYXBbYWlkXSA9IGFpZDI7XHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0XHR1dGlsLmVhY2goaW5Cb25kcywgZnVuY3Rpb24gKGJpZCkge1xyXG5cdFx0XHRcdHZhciBib25kID0gbW9sLmJvbmRzLmdldChiaWQpO1xyXG5cdFx0XHRcdHZhciBuZXdCb25kID0gbmV3IEJvbmQoYm9uZCk7XHJcblx0XHRcdFx0bmV3Qm9uZC5iZWdpbiA9IGFtYXBbbmV3Qm9uZC5iZWdpbl07XHJcblx0XHRcdFx0bmV3Qm9uZC5lbmQgPSBhbWFwW25ld0JvbmQuZW5kXTtcclxuXHRcdFx0XHRtb2wuYm9uZHMuYWRkKG5ld0JvbmQpO1xyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdFx0aWYgKGNyb3NzQm9uZCAhPSBudWxsKSB7XHJcblx0XHRcdFx0dmFyIG5ld0Nyb3NzQm9uZCA9IG5ldyBCb25kKGNyb3NzQm9uZCk7XHJcblx0XHRcdFx0bmV3Q3Jvc3NCb25kLmJlZ2luID0gdGFpbEF0b207XHJcblx0XHRcdFx0bmV3Q3Jvc3NCb25kLmVuZCA9IGFtYXBbeEF0b20yXTtcclxuXHRcdFx0XHRtb2wuYm9uZHMuYWRkKG5ld0Nyb3NzQm9uZCk7XHJcblx0XHRcdFx0dGFpbEF0b20gPSBhbWFwW3hBdG9tMV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR1dGlsLmVhY2gobmV3QXRvbXMsIGZ1bmN0aW9uIChhaWQpIHtcclxuXHRcdFx0dXRpbC5lYWNoKG1vbC5zR3JvdXBGb3Jlc3QuZ2V0UGF0aFRvUm9vdCh0aGlzLmlkKS5yZXZlcnNlKCksIGZ1bmN0aW9uIChzZ2lkKSB7XHJcblx0XHRcdFx0bW9sLmF0b21BZGRUb1NHcm91cChzZ2lkLCBhaWQpO1xyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdFx0aWYgKHRhaWxBdG9tID49IDApIHtcclxuXHRcdFx0dmFyIHhCb25kMiA9IG1vbC5ib25kcy5nZXQoeEJvbmRzWzBdKTtcclxuXHRcdFx0aWYgKHhCb25kMi5iZWdpbiA9PSB4QXRvbTEpXHJcblx0XHRcdFx0eEJvbmQyLmJlZ2luID0gdGFpbEF0b207XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHR4Qm9uZDIuZW5kID0gdGFpbEF0b207XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5ib25kcyA9IHhCb25kcztcclxuXHR9LFxyXG5cclxuXHRwb3N0TG9hZDogZnVuY3Rpb24gKG1vbCwgYXRvbU1hcClcclxuXHR7XHJcblx0XHR0aGlzLmRhdGEubXVsID0gdGhpcy5kYXRhLnN1YnNjcmlwdCAtIDA7XHJcblx0XHR2YXIgYXRvbVJlZHVjdGlvbk1hcCA9IHt9O1xyXG5cclxuXHRcdHRoaXMuYXRvbXMgPSBmaWx0ZXJBdG9tcyh0aGlzLmF0b21zLCBhdG9tTWFwKTtcclxuXHRcdHRoaXMucGF0b21zID0gZmlsdGVyQXRvbXModGhpcy5wYXRvbXMsIGF0b21NYXApO1xyXG5cclxuXHRcdC8vIG1hcmsgcmVwZXRpdGlvbnMgZm9yIHJlbW92YWxcclxuXHRcdGZvciAodmFyIGsgPSAxOyBrIDwgdGhpcy5kYXRhLm11bDsgKytrKSB7XHJcblx0XHRcdGZvciAodmFyIG0gPSAwOyBtIDwgdGhpcy5wYXRvbXMubGVuZ3RoOyArK20pIHtcclxuXHRcdFx0XHR2YXIgcmFpZCA9IHRoaXMuYXRvbXNbayAqIHRoaXMucGF0b21zLmxlbmd0aCArIG1dO1xyXG5cdFx0XHRcdGlmIChyYWlkIDwgMClcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdGlmICh0aGlzLnBhdG9tc1ttXSA8IDApIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcigncGFyZW50IGF0b20gbWlzc2luZycpO1xyXG5cdFx0XHRcdH1cclxuLy8gICAgICAgICAgICAgICAgbW9sLmF0b21zLmdldChyYWlkKS5wcC55IC09IDMqazsgLy8gZm9yIGRlYnVnZ2luZyBwdXJwb3Nlc1xyXG5cdFx0XHRcdGF0b21SZWR1Y3Rpb25NYXBbcmFpZF0gPSB0aGlzLnBhdG9tc1ttXTsgLy8gXCJtZXJnZVwiIGF0b20gaW4gcGFyZW50XHJcblx0XHRcdH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wYXRvbXMgPSByZW1vdmVOZWdhdGl2ZSh0aGlzLnBhdG9tcyk7XHJcblxyXG5cdFx0dmFyIHBhdG9tc01hcCA9IHV0aWwuaWRlbnRpdHlNYXAodGhpcy5wYXRvbXMpO1xyXG5cclxuXHRcdHZhciBib25kc1RvUmVtb3ZlID0gW107XHJcblx0XHRtb2wuYm9uZHMuZWFjaChmdW5jdGlvbiAoYmlkLCBib25kKXtcclxuXHRcdFx0dmFyIGJlZ2luSW4gPSBib25kLmJlZ2luIGluIGF0b21SZWR1Y3Rpb25NYXA7XHJcblx0XHRcdHZhciBlbmRJbiA9IGJvbmQuZW5kIGluIGF0b21SZWR1Y3Rpb25NYXA7XHJcblx0XHRcdC8vIGlmIGJvdGggYWRqYWNlbnQgYXRvbXMgb2YgYSBib25kIGFyZSB0byBiZSBtZXJnZWQsIHJlbW92ZSBpdFxyXG5cdFx0XHRpZiAoYmVnaW5JbiAmJiBlbmRJblxyXG5cdFx0XHRcdCB8fCBiZWdpbkluICYmIGJvbmQuZW5kIGluIHBhdG9tc01hcFxyXG5cdFx0XHRcdCB8fCBlbmRJbiAmJiBib25kLmJlZ2luIGluIHBhdG9tc01hcCkge1xyXG5cdFx0XHRcdGJvbmRzVG9SZW1vdmUucHVzaChiaWQpO1xyXG5cdFx0XHRcdC8vIGlmIGp1c3Qgb25lIGF0b20gaXMgbWVyZ2VkLCBtb2RpZnkgdGhlIGJvbmQgYWNjb3JkaW5nbHlcclxuXHRcdFx0fSBlbHNlIGlmIChiZWdpbkluKSB7XHJcblx0XHRcdFx0Ym9uZC5iZWdpbiA9IGF0b21SZWR1Y3Rpb25NYXBbYm9uZC5iZWdpbl07XHJcblx0XHRcdH0gZWxzZSBpZiAoZW5kSW4pIHtcclxuXHRcdFx0XHRib25kLmVuZCA9IGF0b21SZWR1Y3Rpb25NYXBbYm9uZC5lbmRdO1xyXG5cdFx0XHR9XHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHQvLyBhcHBseSByZW1vdmFsIGxpc3RzXHJcblx0XHRmb3IgKHZhciBiID0gMDsgYiA8IGJvbmRzVG9SZW1vdmUubGVuZ3RoOyArK2IpIHtcclxuXHRcdFx0bW9sLmJvbmRzLnJlbW92ZShib25kc1RvUmVtb3ZlW2JdKTtcclxuXHRcdH1cclxuXHRcdGZvciAodmFyIGEgaW4gYXRvbVJlZHVjdGlvbk1hcCkge1xyXG5cdFx0XHRtb2wuYXRvbXMucmVtb3ZlKGEpO1xyXG5cdFx0XHRhdG9tTWFwW2FdID0gLTE7XHJcblx0XHR9XHJcblx0XHR0aGlzLmF0b21zID0gdGhpcy5wYXRvbXM7XHJcblx0XHR0aGlzLnBhdG9tcyA9IG51bGw7XHJcblx0fVxyXG59O1xyXG5cclxudmFyIEdyb3VwU3J1ID0ge1xyXG5cdGRyYXc6IGZ1bmN0aW9uIChyZW1vbCkge1xyXG5cdFx0dmFyIHJlbmRlciA9IHJlbW9sLnJlbmRlcjtcclxuXHRcdHZhciBzZXQgPSByZW5kZXIucGFwZXIuc2V0KCk7XHJcblx0XHR2YXIgaW5Cb25kcyA9IFtdLCB4Qm9uZHMgPSBbXTtcclxuXHRcdHZhciBhdG9tU2V0ID0gU2V0LmZyb21MaXN0KHRoaXMuYXRvbXMpO1xyXG5cdFx0U0dyb3VwLmdldENyb3NzQm9uZHMoaW5Cb25kcywgeEJvbmRzLCByZW1vbC5tb2xlY3VsZSwgYXRvbVNldCk7XHJcblx0XHRTR3JvdXAuYnJhY2tldFBvcyh0aGlzLCByZW5kZXIsIHJlbW9sLm1vbGVjdWxlLCB4Qm9uZHMpO1xyXG5cdFx0dmFyIGJiID0gdGhpcy5icmFja2V0Qm94O1xyXG5cdFx0dmFyIGQgPSB0aGlzLmJyYWNrZXREaXIsIG4gPSBkLnJvdGF0ZVNDKDEsIDApO1xyXG5cdFx0dGhpcy5hcmVhcyA9IFtiYl07XHJcblx0XHR2YXIgY29ubmVjdGl2aXR5ID0gdGhpcy5kYXRhLmNvbm5lY3Rpdml0eSB8fCAnZXUnO1xyXG5cdFx0aWYgKGNvbm5lY3Rpdml0eSA9PSAnaHQnKVxyXG5cdFx0XHRjb25uZWN0aXZpdHkgPSAnJztcclxuXHRcdHZhciBzdWJzY3JpcHQgPSB0aGlzLmRhdGEuc3Vic2NyaXB0IHx8ICduJztcclxuXHRcdFNHcm91cC5kcmF3QnJhY2tldHMoc2V0LCByZW5kZXIsIHRoaXMsIHhCb25kcywgYXRvbVNldCwgYmIsIGQsIG4sIHN1YnNjcmlwdCwgY29ubmVjdGl2aXR5KTtcclxuXHRcdHJldHVybiBzZXQ7XHJcblx0fSxcclxuXHJcblx0c2F2ZVRvTW9sZmlsZTogZnVuY3Rpb24gKG1vbCwgc2dNYXAsIGF0b21NYXAsIGJvbmRNYXApIHtcclxuXHRcdHZhciBpZHN0ciA9IHV0aWwuc3RyaW5nUGFkZGVkKHNnTWFwW3RoaXMuaWRdLCAzKTtcclxuXHJcblx0XHR2YXIgbGluZXMgPSBbXTtcclxuXHRcdGxpbmVzID0gbGluZXMuY29uY2F0KFNHcm91cC5tYWtlQXRvbUJvbmRMaW5lcygnU0FMJywgaWRzdHIsIHRoaXMuYXRvbXMsIGF0b21NYXApKTtcclxuXHRcdGxpbmVzID0gbGluZXMuY29uY2F0KFNHcm91cC5tYWtlQXRvbUJvbmRMaW5lcygnU0JMJywgaWRzdHIsIHRoaXMuYm9uZHMsIGJvbmRNYXApKTtcclxuXHRcdGxpbmVzID0gbGluZXMuY29uY2F0KFNHcm91cC5icmFja2V0c1RvTW9sZmlsZShtb2wsIHRoaXMsIGlkc3RyKSk7XHJcblx0XHRyZXR1cm4gbGluZXMuam9pbignXFxuJyk7XHJcblx0fSxcclxuXHJcblx0cHJlcGFyZUZvclNhdmluZzogZnVuY3Rpb24gKG1vbCkge1xyXG5cdFx0dmFyIHhCb25kcyA9IFtdO1xyXG5cdFx0bW9sLmJvbmRzLmVhY2goZnVuY3Rpb24gKGJpZCwgYm9uZCl7XHJcblx0XHRcdHZhciBhMSA9IG1vbC5hdG9tcy5nZXQoYm9uZC5iZWdpbik7XHJcblx0XHRcdHZhciBhMiA9IG1vbC5hdG9tcy5nZXQoYm9uZC5lbmQpO1xyXG5cdFx0XHRpZiAoU2V0LmNvbnRhaW5zKGExLnNncywgdGhpcy5pZCkgJiYgIVNldC5jb250YWlucyhhMi5zZ3MsIHRoaXMuaWQpIHx8XHJcblx0XHRcdFNldC5jb250YWlucyhhMi5zZ3MsIHRoaXMuaWQpICYmICFTZXQuY29udGFpbnMoYTEuc2dzLCB0aGlzLmlkKSlcclxuXHRcdFx0XHR4Qm9uZHMucHVzaChiaWQpO1xyXG5cdFx0fSx0aGlzKTtcclxuXHRcdGlmICh4Qm9uZHMubGVuZ3RoICE9IDAgJiYgeEJvbmRzLmxlbmd0aCAhPSAyKVxyXG5cdFx0XHR0aHJvdyB7J2lkJzp0aGlzLmlkLCAnZXJyb3ItdHlwZSc6J2Nyb3NzLWJvbmQtbnVtYmVyJywgJ21lc3NhZ2UnOidVbnN1cHBvcnRlZCBjcm9zcy1ib25kcyBudW1iZXInfTtcclxuXHRcdHRoaXMuYm9uZHMgPSB4Qm9uZHM7XHJcblx0fSxcclxuXHJcblx0cG9zdExvYWQ6IGZ1bmN0aW9uIChtb2wsIGF0b21NYXApIHtcclxuXHRcdHRoaXMuZGF0YS5jb25uZWN0aXZpdHkgPSAodGhpcy5kYXRhLmNvbm5lY3Rpdml0eSB8fCAnRVUnKS5zdHJpcCgpLnRvTG93ZXJDYXNlKCk7XHJcblx0fVxyXG59O1xyXG5cclxudmFyIEdyb3VwU3VwID0ge1xyXG5cdGRyYXc6IGZ1bmN0aW9uIChyZW1vbCkge1xyXG5cdFx0dmFyIHJlbmRlciA9IHJlbW9sLnJlbmRlcjtcclxuXHRcdHZhciBzZXQgPSByZW5kZXIucGFwZXIuc2V0KCk7XHJcblx0XHR2YXIgaW5Cb25kcyA9IFtdLCB4Qm9uZHMgPSBbXTtcclxuXHRcdHZhciBhdG9tU2V0ID0gU2V0LmZyb21MaXN0KHRoaXMuYXRvbXMpO1xyXG5cdFx0U0dyb3VwLmdldENyb3NzQm9uZHMoaW5Cb25kcywgeEJvbmRzLCByZW1vbC5tb2xlY3VsZSwgYXRvbVNldCk7XHJcblx0XHRTR3JvdXAuYnJhY2tldFBvcyh0aGlzLCByZW5kZXIsIHJlbW9sLm1vbGVjdWxlLCB4Qm9uZHMpO1xyXG5cdFx0dmFyIGJiID0gdGhpcy5icmFja2V0Qm94O1xyXG5cdFx0dmFyIGQgPSB0aGlzLmJyYWNrZXREaXIsIG4gPSBkLnJvdGF0ZVNDKDEsIDApO1xyXG5cdFx0dGhpcy5hcmVhcyA9IFtiYl07XHJcblx0XHRTR3JvdXAuZHJhd0JyYWNrZXRzKHNldCwgcmVuZGVyLCB0aGlzLCB4Qm9uZHMsIGF0b21TZXQsIGJiLCBkLCBuLCB0aGlzLmRhdGEubmFtZSwgbnVsbCwge1xyXG5cdFx0XHQnZm9udC1zdHlsZSc6ICdpdGFsaWMnXHJcblx0XHR9KTtcclxuXHRcdHJldHVybiBzZXQ7XHJcblx0fSxcclxuXHJcblx0c2F2ZVRvTW9sZmlsZTogZnVuY3Rpb24gKG1vbCwgc2dNYXAsIGF0b21NYXAsIGJvbmRNYXApIHtcclxuXHRcdHZhciBpZHN0ciA9IHV0aWwuc3RyaW5nUGFkZGVkKHNnTWFwW3RoaXMuaWRdLCAzKTtcclxuXHJcblx0XHR2YXIgbGluZXMgPSBbXTtcclxuXHRcdGxpbmVzID0gbGluZXMuY29uY2F0KFNHcm91cC5tYWtlQXRvbUJvbmRMaW5lcygnU0FMJywgaWRzdHIsIHRoaXMuYXRvbXMsIGF0b21NYXApKTtcclxuXHRcdGxpbmVzID0gbGluZXMuY29uY2F0KFNHcm91cC5tYWtlQXRvbUJvbmRMaW5lcygnU0JMJywgaWRzdHIsIHRoaXMuYm9uZHMsIGJvbmRNYXApKTtcclxuXHRcdGlmICh0aGlzLmRhdGEubmFtZSAmJiB0aGlzLmRhdGEubmFtZSAhPSAnJylcclxuXHRcdFx0bGluZXMucHVzaCgnTSAgU01UICcgKyBpZHN0ciArICcgJyArIHRoaXMuZGF0YS5uYW1lKTtcclxuXHRcdHJldHVybiBsaW5lcy5qb2luKCdcXG4nKTtcclxuXHR9LFxyXG5cclxuXHRwcmVwYXJlRm9yU2F2aW5nOiBmdW5jdGlvbiAobW9sKSB7XHJcblx0XHQvLyBUaGlzIGNvZGUgaXMgYWxzbyB1c2VkIGZvciBHcm91cFNydSBhbmQgc2hvdWxkIGJlIG1vdmVkIGludG8gYSBzZXBhcmF0ZSBjb21tb24gbWV0aG9kXHJcblx0XHQvLyBJdCBzZWVtcyB0aGF0IHN1Y2ggY29kZSBzaG91bGQgYmUgdXNlZCBmb3IgYW55IHNncm91cCBieSB0aGlzIHRoaXMgc2hvdWxkIGJlIGNoZWNrZWRcclxuXHRcdHZhciB4Qm9uZHMgPSBbXTtcclxuXHRcdG1vbC5ib25kcy5lYWNoKGZ1bmN0aW9uIChiaWQsIGJvbmQpe1xyXG5cdFx0XHR2YXIgYTEgPSBtb2wuYXRvbXMuZ2V0KGJvbmQuYmVnaW4pO1xyXG5cdFx0XHR2YXIgYTIgPSBtb2wuYXRvbXMuZ2V0KGJvbmQuZW5kKTtcclxuXHRcdFx0aWYgKFNldC5jb250YWlucyhhMS5zZ3MsIHRoaXMuaWQpICYmICFTZXQuY29udGFpbnMoYTIuc2dzLCB0aGlzLmlkKSB8fFxyXG5cdFx0XHRTZXQuY29udGFpbnMoYTIuc2dzLCB0aGlzLmlkKSAmJiAhU2V0LmNvbnRhaW5zKGExLnNncywgdGhpcy5pZCkpXHJcblx0XHRcdFx0eEJvbmRzLnB1c2goYmlkKTtcclxuXHRcdH0sdGhpcyk7XHJcblx0XHR0aGlzLmJvbmRzID0geEJvbmRzO1xyXG5cdH0sXHJcblxyXG5cdHBvc3RMb2FkOiBmdW5jdGlvbiAobW9sLCBhdG9tTWFwKSB7XHJcblx0XHR0aGlzLmRhdGEubmFtZSA9ICh0aGlzLmRhdGEuc3Vic2NyaXB0IHx8ICcnKS5zdHJpcCgpO1xyXG5cdFx0dGhpcy5kYXRhLnN1YnNjcmlwdCA9ICcnO1xyXG5cdH1cclxufTtcclxuXHJcbnZhciBHcm91cEdlbiA9IHtcclxuXHRkcmF3OiBmdW5jdGlvbiAocmVtb2wpIHtcclxuXHRcdHZhciByZW5kZXIgPSByZW1vbC5yZW5kZXI7XHJcblx0XHR2YXIgc2V0dGluZ3MgPSByZW5kZXIuc2V0dGluZ3M7XHJcblx0XHR2YXIgc3R5bGVzID0gcmVuZGVyLnN0eWxlcztcclxuXHRcdHZhciBwYXBlciA9IHJlbmRlci5wYXBlcjtcclxuXHRcdHZhciBzZXQgPSBwYXBlci5zZXQoKTtcclxuXHRcdHZhciBpbkJvbmRzID0gW10sIHhCb25kcyA9IFtdO1xyXG5cdFx0dmFyIGF0b21TZXQgPSBTZXQuZnJvbUxpc3QodGhpcy5hdG9tcyk7XHJcblx0XHRTR3JvdXAuZ2V0Q3Jvc3NCb25kcyhpbkJvbmRzLCB4Qm9uZHMsIHJlbW9sLm1vbGVjdWxlLCBhdG9tU2V0KTtcclxuXHRcdFNHcm91cC5icmFja2V0UG9zKHRoaXMsIHJlbmRlciwgcmVtb2wubW9sZWN1bGUsIHhCb25kcyk7XHJcblx0XHR2YXIgYmIgPSB0aGlzLmJyYWNrZXRCb3g7XHJcblx0XHR2YXIgZCA9IHRoaXMuYnJhY2tldERpciwgbiA9IGQucm90YXRlU0MoMSwgMCk7XHJcblx0XHR0aGlzLmFyZWFzID0gW2JiXTtcclxuXHRcdFNHcm91cC5kcmF3QnJhY2tldHMoc2V0LCByZW5kZXIsIHRoaXMsIHhCb25kcywgYXRvbVNldCwgYmIsIGQsIG4pO1xyXG5cdFx0cmV0dXJuIHNldDtcclxuXHR9LFxyXG5cclxuXHRzYXZlVG9Nb2xmaWxlOiBmdW5jdGlvbiAobW9sLCBzZ01hcCwgYXRvbU1hcCwgYm9uZE1hcCkge1xyXG5cdFx0dmFyIGlkc3RyID0gdXRpbC5zdHJpbmdQYWRkZWQoc2dNYXBbdGhpcy5pZF0sIDMpO1xyXG5cclxuXHRcdHZhciBsaW5lcyA9IFtdO1xyXG5cdFx0bGluZXMgPSBsaW5lcy5jb25jYXQoU0dyb3VwLm1ha2VBdG9tQm9uZExpbmVzKCdTQUwnLCBpZHN0ciwgdGhpcy5hdG9tcywgYXRvbU1hcCkpO1xyXG5cdFx0bGluZXMgPSBsaW5lcy5jb25jYXQoU0dyb3VwLm1ha2VBdG9tQm9uZExpbmVzKCdTQkwnLCBpZHN0ciwgdGhpcy5ib25kcywgYm9uZE1hcCkpO1xyXG5cdFx0bGluZXMgPSBsaW5lcy5jb25jYXQoU0dyb3VwLmJyYWNrZXRzVG9Nb2xmaWxlKG1vbCwgdGhpcywgaWRzdHIpKTtcclxuXHRcdHJldHVybiBsaW5lcy5qb2luKCdcXG4nKTtcclxuXHR9LFxyXG5cclxuXHRwcmVwYXJlRm9yU2F2aW5nOiBmdW5jdGlvbiAobW9sKSB7XHJcblx0fSxcclxuXHJcblx0cG9zdExvYWQ6IGZ1bmN0aW9uIChtb2wsIGF0b21NYXApIHtcclxuXHR9XHJcbn07XHJcblxyXG5TR3JvdXAuZ2V0TWFzc0NlbnRyZSA9IGZ1bmN0aW9uIChtb2wsIGF0b21zKSB7XHJcblx0dmFyIGMgPSBuZXcgVmVjMigpOyAvLyBtYXNzIGNlbnRyZVxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXRvbXMubGVuZ3RoOyArK2kpIHtcclxuXHRcdGMgPSBjLmFkZFNjYWxlZChtb2wuYXRvbXMuZ2V0KGF0b21zW2ldKS5wcCwgMS4wIC8gYXRvbXMubGVuZ3RoKTtcclxuXHR9XHJcblx0cmV0dXJuIGM7XHJcbn07XHJcblxyXG5TR3JvdXAuc2V0UG9zID0gZnVuY3Rpb24gKHJlbW9sLCBzZywgcG9zKSB7XHJcblx0c2cucHAgPSBwb3M7XHJcbn07XHJcblxyXG52YXIgR3JvdXBEYXQgPSB7XHJcblx0c2hvd1ZhbHVlOiBmdW5jdGlvbiAocGFwZXIsIHBvcywgc2csIHNldHRpbmdzKSB7XHJcblx0XHR2YXIgdGV4dCA9IHBhcGVyLnRleHQocG9zLngsIHBvcy55LCBzZy5kYXRhLmZpZWxkVmFsdWUpXHJcblx0XHQgICAgLmF0dHIoe1xyXG5cdFx0XHQgICAgJ2ZvbnQnOiBzZXR0aW5ncy5mb250LFxyXG5cdFx0XHQgICAgJ2ZvbnQtc2l6ZSc6IHNldHRpbmdzLmZvbnRzelxyXG5cdFx0ICAgIH0pO1xyXG5cdFx0dmFyIGJveCA9IHRleHQuZ2V0QkJveCgpO1xyXG5cdFx0dmFyIHJlY3QgPSBwYXBlci5yZWN0KGJveC54IC0gMSwgYm94LnkgLSAxLFxyXG5cdFx0ICAgICAgICAgICAgICAgICAgICAgIGJveC53aWR0aCArIDIsIGJveC5oZWlnaHQgKyAyLCAzLCAzKVxyXG5cdFx0ICAgIC5hdHRyKHtcclxuXHRcdFx0ICAgIGZpbGw6ICcjZmZmJyxcclxuXHRcdFx0ICAgIHN0cm9rZTogJyNmZmYnXHJcblx0XHQgICAgfSk7XHJcblx0XHR2YXIgc3QgPSBwYXBlci5zZXQoKTtcclxuXHRcdHN0LnB1c2goXHJcblx0XHRcdHJlY3QsXHJcblx0XHRcdHRleHQudG9Gcm9udCgpXHJcblx0XHQpO1xyXG5cdFx0cmV0dXJuIHN0O1xyXG5cdH0sXHJcblxyXG5cdGRyYXc6IGZ1bmN0aW9uIChyZW1vbCkge1xyXG5cdFx0dmFyIHJlbmRlciA9IHJlbW9sLnJlbmRlcjtcclxuXHRcdHZhciBzZXR0aW5ncyA9IHJlbmRlci5zZXR0aW5ncztcclxuXHRcdHZhciBwYXBlciA9IHJlbmRlci5wYXBlcjtcclxuXHRcdHZhciBzZXQgPSBwYXBlci5zZXQoKTtcclxuXHRcdHZhciBhdG9tcyA9IFNHcm91cC5nZXRBdG9tcyhyZW1vbCwgdGhpcyk7XHJcblx0XHR2YXIgaTtcclxuXHRcdFNHcm91cC5icmFja2V0UG9zKHRoaXMsIHJlbmRlciwgcmVtb2wubW9sZWN1bGUpO1xyXG5cdFx0dGhpcy5hcmVhcyA9IHRoaXMuYnJhY2tldEJveCA/IFt0aGlzLmJyYWNrZXRCb3hdIDogW107XHJcblx0XHRpZiAodGhpcy5wcCA9PSBudWxsKSB7XHJcblx0XHRcdC8vIE5COiB3ZSBkaWQgbm90IHBhc3MgeGJvbmRzIHBhcmFtZXRlciB0byB0aGUgYmFja2V0UG9zIG1ldGhvZCBhYm92ZSxcclxuXHRcdFx0Ly8gIHNvIHRoZSByZXN1bHQgd2lsbCBiZSBpbiB0aGUgcmVndWxhciBjb29yZGluYXRlIHN5c3RlbVxyXG5cdFx0XHRTR3JvdXAuc2V0UG9zKHJlbW9sLCB0aGlzLCB0aGlzLmJyYWNrZXRCb3gucDEuYWRkKG5ldyBWZWMyKDAuNSwgMC41KSkpO1xyXG5cdFx0fVxyXG5cdFx0dmFyIHBzID0gdGhpcy5wcC5zY2FsZWQoc2V0dGluZ3Muc2NhbGVGYWN0b3IpO1xyXG5cclxuXHRcdGlmICh0aGlzLmRhdGEuYXR0YWNoZWQpIHtcclxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGF0b21zLmxlbmd0aDsgKytpKSB7XHJcblx0XHRcdFx0dmFyIGF0b20gPSByZW1vbC5hdG9tcy5nZXQoYXRvbXNbaV0pO1xyXG5cdFx0XHRcdHZhciBwID0gcmVuZGVyLnBzKGF0b20uYS5wcCk7XHJcblx0XHRcdFx0dmFyIGJiID0gYXRvbS52aXNlbC5ib3VuZGluZ0JveDtcclxuXHRcdFx0XHRpZiAoYmIgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0cC54ID0gTWF0aC5tYXgocC54LCBiYi5wMS54KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cC54ICs9IHNldHRpbmdzLmxpbmVXaWR0aDsgLy8gc2hpZnQgYSBiaXQgdG8gdGhlIHJpZ2h0XHJcblx0XHRcdFx0dmFyIG5hbWVfaSA9IHRoaXMuc2hvd1ZhbHVlKHBhcGVyLCBwLCB0aGlzLCBzZXR0aW5ncyk7XHJcblx0XHRcdFx0dmFyIGJveF9pID0gdXRpbC5yZWxCb3gobmFtZV9pLmdldEJCb3goKSk7XHJcblx0XHRcdFx0bmFtZV9pLnRyYW5zbGF0ZUFicygwLjUgKiBib3hfaS53aWR0aCwgLTAuMyAqIGJveF9pLmhlaWdodCk7XHJcblx0XHRcdFx0c2V0LnB1c2gobmFtZV9pKTtcclxuXHRcdFx0XHR2YXIgc2JveF9pID0gQm94MkFicy5mcm9tUmVsQm94KHV0aWwucmVsQm94KG5hbWVfaS5nZXRCQm94KCkpKTtcclxuXHRcdFx0XHRzYm94X2kgPSBzYm94X2kudHJhbnNmb3JtKHJlbmRlci5zY2FsZWQyb2JqLCByZW5kZXIpO1xyXG5cdFx0XHRcdHRoaXMuYXJlYXMucHVzaChzYm94X2kpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgbmFtZSA9IHRoaXMuc2hvd1ZhbHVlKHBhcGVyLCBwcywgdGhpcywgc2V0dGluZ3MpO1xyXG5cdFx0XHR2YXIgYm94ID0gdXRpbC5yZWxCb3gobmFtZS5nZXRCQm94KCkpO1xyXG5cdFx0XHRuYW1lLnRyYW5zbGF0ZUFicygwLjUgKiBib3gud2lkdGgsIC0wLjUgKiBib3guaGVpZ2h0KTtcclxuXHRcdFx0c2V0LnB1c2gobmFtZSk7XHJcblx0XHRcdHZhciBzYm94ID0gQm94MkFicy5mcm9tUmVsQm94KHV0aWwucmVsQm94KG5hbWUuZ2V0QkJveCgpKSk7XHJcblx0XHRcdHRoaXMuZGF0YUFyZWEgPSBzYm94LnRyYW5zZm9ybShyZW5kZXIuc2NhbGVkMm9iaiwgcmVuZGVyKTtcclxuXHRcdFx0aWYgKCFyZW1vbC5zZ3JvdXBEYXRhLmhhcyh0aGlzLmlkKSlcclxuXHRcdFx0XHRyZW1vbC5zZ3JvdXBEYXRhLnNldCh0aGlzLmlkLCBuZXcgcm5kLlJlRGF0YVNHcm91cERhdGEodGhpcykpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHNldDtcclxuXHR9LFxyXG5cclxuXHRzYXZlVG9Nb2xmaWxlOiBmdW5jdGlvbiAobW9sLCBzZ01hcCwgYXRvbU1hcCwgYm9uZE1hcCkge1xyXG5cdFx0dmFyIGlkc3RyID0gdXRpbC5zdHJpbmdQYWRkZWQoc2dNYXBbdGhpcy5pZF0sIDMpO1xyXG5cclxuXHRcdHZhciBkYXRhID0gdGhpcy5kYXRhO1xyXG5cdFx0dmFyIHBwID0gdGhpcy5wcDtcclxuXHRcdGlmICghZGF0YS5hYnNvbHV0ZSlcclxuXHRcdFx0cHAgPSBwcC5zdWIoU0dyb3VwLmdldE1hc3NDZW50cmUobW9sLCB0aGlzLmF0b21zKSk7XHJcblx0XHR2YXIgbGluZXMgPSBbXTtcclxuXHRcdGxpbmVzID0gbGluZXMuY29uY2F0KFNHcm91cC5tYWtlQXRvbUJvbmRMaW5lcygnU0FMJywgaWRzdHIsIHRoaXMuYXRvbXMsIGF0b21NYXApKTtcclxuXHRcdHZhciBzZHRMaW5lID0gJ00gIFNEVCAnICsgaWRzdHIgK1xyXG5cdFx0XHQnICcgKyB1dGlsLnN0cmluZ1BhZGRlZChkYXRhLmZpZWxkTmFtZSwgMzAsIHRydWUpICtcclxuXHRcdHV0aWwuc3RyaW5nUGFkZGVkKGRhdGEuZmllbGRUeXBlLCAyKSArXHJcblx0XHR1dGlsLnN0cmluZ1BhZGRlZChkYXRhLnVuaXRzLCAyMCwgdHJ1ZSkgK1xyXG5cdFx0dXRpbC5zdHJpbmdQYWRkZWQoZGF0YS5xdWVyeSwgMikgK1xyXG5cdFx0dXRpbC5zdHJpbmdQYWRkZWQoZGF0YS5xdWVyeU9wLCAzKTtcclxuXHRcdGxpbmVzLnB1c2goc2R0TGluZSk7XHJcblx0XHR2YXIgc2RkTGluZSA9ICdNICBTREQgJyArIGlkc3RyICtcclxuXHRcdFx0JyAnICsgdXRpbC5wYWRkZWRGbG9hdChwcC54LCAxMCwgNCkgKyB1dGlsLnBhZGRlZEZsb2F0KC1wcC55LCAxMCwgNCkgK1xyXG5cdFx0XHQnICAgICcgKyAvLyAnIGVlZSdcclxuXHRcdFx0KGRhdGEuYXR0YWNoZWQgPyAnQScgOiAnRCcpICsgLy8gZlxyXG5cdFx0XHQoZGF0YS5hYnNvbHV0ZSA/ICdBJyA6ICdSJykgKyAvLyBnXHJcblx0XHRcdChkYXRhLnNob3dVbml0cyA/ICdVJyA6ICcgJykgKyAvLyBoXHJcblx0XHRcdCcgICAnICsgLy8gIGlcclxuXHRcdFx0KGRhdGEubkNoYXJuQ2hhcnNUb0Rpc3BsYXkgPj0gMCA/IHV0aWwucGFkZGVkSW50KGRhdGEubkNoYXJuQ2hhcnNUb0Rpc3BsYXksIDMpIDogJ0FMTCcpICsgLy8gampqXHJcblx0XHRcdCcgIDEgICAnICsgLy8gJ2trayBsbCAnXHJcblx0XHR1dGlsLnN0cmluZ1BhZGRlZChkYXRhLnRhZ0NoYXIsIDEpICsgLy8gbVxyXG5cdFx0XHQnICAnICsgdXRpbC5wYWRkZWRJbnQoZGF0YS5kYXNwUG9zLCAxKSArIC8vIG5cclxuXHRcdFx0JyAgJzsgLy8gb29cclxuXHRcdFx0bGluZXMucHVzaChzZGRMaW5lKTtcclxuXHRcdHZhciB2YWwgPSB1dGlsLm5vcm1hbGl6ZU5ld2xpbmVzKGRhdGEuZmllbGRWYWx1ZSkucmVwbGFjZSgvXFxuKiQvLCAnJyk7XHJcblx0XHR2YXIgY2hhcnNQZXJMaW5lID0gNjk7XHJcblx0XHR2YWwuc3BsaXQoJ1xcbicpLmVhY2goZnVuY3Rpb24gKGNoYXJzKSB7XHJcblx0XHRcdHdoaWxlIChjaGFycy5sZW5ndGggPiBjaGFyc1BlckxpbmUpIHtcclxuXHRcdFx0XHRsaW5lcy5wdXNoKCdNICBTQ0QgJyArIGlkc3RyICsgJyAnICsgY2hhcnMuc2xpY2UoMCwgY2hhcnNQZXJMaW5lKSk7XHJcblx0XHRcdFx0Y2hhcnMgPSBjaGFycy5zbGljZShjaGFyc1BlckxpbmUpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGxpbmVzLnB1c2goJ00gIFNFRCAnICsgaWRzdHIgKyAnICcgKyBjaGFycyk7XHJcblx0XHR9KTtcclxuXHRcdHJldHVybiBsaW5lcy5qb2luKCdcXG4nKTtcclxuXHR9LFxyXG5cclxuXHRwcmVwYXJlRm9yU2F2aW5nOiBmdW5jdGlvbiAobW9sKSB7XHJcblx0XHR0aGlzLmF0b21zID0gU0dyb3VwLmdldEF0b21zKG1vbCwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0cG9zdExvYWQ6IGZ1bmN0aW9uIChtb2wsIGF0b21NYXApIHtcclxuXHRcdGlmICghdGhpcy5kYXRhLmFic29sdXRlKVxyXG5cdFx0XHR0aGlzLnBwID0gdGhpcy5wcC5hZGQoU0dyb3VwLmdldE1hc3NDZW50cmUobW9sLCB0aGlzLmF0b21zKSk7XHJcblx0XHQvLyBbTktdIFRlbXBvcmFyeSBjb21tZW50IGluY29wbGV0ZSAnYWxsQXRvbXMnIGJlaGF2aW9yXHJcblx0XHQvLyBUT0RPOiBuZWVkIGV0aGVyIHJlbW92ZSAnYWxsQXRvbXMnIGZsYWcgb3IgaGFkbGUgaXRcclxuXHRcdC8vIGNvbnNpc3RlbnRseSAob3RoZXIgZmxhZ3M6ICpfS0VZLCAqX1JBRElDQUw/KVxyXG5cdFx0Ly8gdmFyIGFsbEF0b21zSW5Hcm91cCA9IHRoaXMuYXRvbXMubGVuZ3RoID09IG1vbC5hdG9tcy5jb3VudCgpO1xyXG5cdFx0Ly8gaWYgKGFsbEF0b21zSW5Hcm91cCAmJlxyXG5cdFx0Ly8gICAgICh0aGlzLmRhdGEuZmllbGROYW1lID09ICdNRExCR19GUkFHTUVOVF9TVEVSRU8nIHx8XHJcblx0XHQvLyAgICAgIHRoaXMuZGF0YS5maWVsZE5hbWUgPT0gJ01ETEJHX0ZSQUdNRU5UX0NPRUZGSUNJRU5UJyB8fFxyXG5cdFx0Ly8gICAgICB0aGlzLmRhdGEuZmllbGROYW1lID09ICdNRExCR19GUkFHTUVOVF9DSEFSR0UnKSkge1xyXG5cdFx0Ly8gXHR0aGlzLmF0b21zID0gW107XHJcblx0XHQvLyBcdHRoaXMuYWxsQXRvbXMgPSB0cnVlO1xyXG5cdFx0Ly8gfVxyXG5cdH1cclxufTtcclxuXHJcblNHcm91cC5UWVBFUyA9IHtcclxuXHQnTVVMJzogR3JvdXBNdWwsXHJcblx0J1NSVSc6IEdyb3VwU3J1LFxyXG5cdCdTVVAnOiBHcm91cFN1cCxcclxuXHQnREFUJzogR3JvdXBEYXQsXHJcblx0J0dFTic6IEdyb3VwR2VuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNHcm91cDtcclxuIiwidmFyIFNldCA9IHJlcXVpcmUoJy4uL3V0aWwvc2V0Jyk7XHJcbnZhciBBdG9tID0gcmVxdWlyZSgnLi9hdG9tJyk7XHJcbnZhciBCb25kID0gcmVxdWlyZSgnLi9ib25kJyk7XHJcbnZhciBDaXNUcmFucyA9IHJlcXVpcmUoJy4vY2lzX3RyYW5zJyk7XHJcbnZhciBEZnMgPSByZXF1aXJlKCcuL2RmcycpO1xyXG52YXIgU3RlcmVvY2VudGVycyA9IHJlcXVpcmUoJy4vc3RlcmVvY2VudGVycycpO1xyXG5cclxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XHJcblxyXG52YXIgU21pbGVzID0gZnVuY3Rpb24gKClcclxue1xyXG5cdHRoaXMuc21pbGVzID0gJyc7XHJcblx0dGhpcy5fd3JpdHRlbl9hdG9tcyA9IFtdO1xyXG5cdHRoaXMuX3dyaXR0ZW5fY29tcG9uZW50cyA9IDA7XHJcblxyXG5cdHRoaXMuaWdub3JlX2Vycm9ycyA9IGZhbHNlO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX0F0b20oaF9jb3VudCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuZWlnaGJvdXJzOiBbXSwgIC8vIEFycmF5IG9mIGludGVnZXIgcGFpcnMge2EsIGJ9XHJcbiAgICAgICAgYXJvbWF0aWM6ZmFsc2UsICAgICAgICAgIC8vIGhhcyBhcm9tYXRpYyBib25kXHJcbiAgICAgICAgbG93ZXJjYXNlOmZhbHNlLCAgICAgICAgIC8vIGFyb21hdGljIGFuZCBoYXMgdG8gYmUgd3JpdHRlbiBsb3dlcmNhc2VcclxuICAgICAgICBjaGlyYWxpdHk6IDAsICAgICAgICAgICAgIC8vIDAgbWVhbnMgbm8gY2hpcmFsaXR5LCAxIG1lYW5zIENDVyBweXJhbWlkLCAyIG1lYW5zIENXIHB5cmFtaWRcclxuICAgICAgICBicmFuY2hfY250OiAwLCAgICAgICAgICAgIC8vIHJ1bnMgZnJvbSAwIHRvIChicmFuY2hlcyAtIDEpXHJcbiAgICAgICAgcGFyZW5fd3JpdHRlbjpmYWxzZSxcclxuICAgICAgICBoX2NvdW50OmhfY291bnQsXHJcbiAgICAgICAgcGFyZW50OiAxXHJcbiAgICB9O1xyXG59O1xyXG5cclxuLy8gTkI6IG9ubHkgbG9vcHMgb2YgbGVuZ3RoIHVwIHRvIDYgYXJlIGluY2x1ZGVkIGhlcmVcclxuU21pbGVzLnByb3RvdHlwZS5pc0JvbmRJblJpbmcgPSBmdW5jdGlvbiAoYmlkKSB7XHJcblx0aWYgKHV0aWwuaXNVbmRlZmluZWQodGhpcy5pbkxvb3ApIHx8IHV0aWwuaXNOdWxsKHRoaXMuaW5Mb29wKSlcclxuXHRcdHRocm93IG5ldyBFcnJvcignSW5pdCB0aGlzLmluTG9vcCBwcmlvciB0byBjYWxsaW5nIHRoaXMgbWV0aG9kJyk7XHJcblx0cmV0dXJuIHRoaXMuaW5Mb29wW2JpZF07XHJcbn07XHJcblxyXG5TbWlsZXMucHJvdG90eXBlLnNhdmVNb2xlY3VsZSA9IGZ1bmN0aW9uIChtb2xlY3VsZSwgaWdub3JlX2Vycm9ycylcclxue1xyXG5cdHZhciBpLCBqLCBrO1xyXG5cclxuXHRpZiAoIU9iamVjdC5pc1VuZGVmaW5lZChpZ25vcmVfZXJyb3JzKSlcclxuXHRcdHRoaXMuaWdub3JlX2Vycm9ycyA9IGlnbm9yZV9lcnJvcnM7XHJcblxyXG5cdC8vW1JCXTogS0VUQ0hFUi00OTggKEluY29ycmVjdCBzbWlsZS1zdHJpbmcgZm9yIG11bHRpcGxlIFNncm91cClcclxuXHQvL1RPRE8gdGhlIGZpeCBpcyB0ZW1wb3JhcnksIHN0aWxsIG5lZWQgdG8gaW1wbGVtZW50IGVycm9yIGhhbmRsaW5nL3JlcG9ydGluZ1xyXG5cdC8vQkVHSU5cclxuLy8gICAgaWYgKG1vbGVjdWxlLnNncm91cHMuY291bnQoKSA+IDAgJiYgIXRoaXMuaWdub3JlX2Vycm9ycylcclxuLy8gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNNSUxFUyBkb2Vzbid0IHN1cHBvcnQgcy1ncm91cHNcIik7XHJcblx0bW9sZWN1bGUgPSBtb2xlY3VsZS5jbG9uZSgpO1xyXG5cdG1vbGVjdWxlLmluaXRIYWxmQm9uZHMoKTtcclxuXHRtb2xlY3VsZS5pbml0TmVpZ2hib3JzKCk7XHJcblx0bW9sZWN1bGUuc29ydE5laWdoYm9ycygpO1xyXG5cdG1vbGVjdWxlLnNldEltcGxpY2l0SHlkcm9nZW4oKTtcclxuXHRtb2xlY3VsZS5zZ3JvdXBzLmVhY2goZnVuY3Rpb24gKHNnaWQsIHNnKSB7XHJcblx0XHRpZiAoc2cudHlwZSA9PSAnTVVMJykge1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdHNnLnByZXBhcmVGb3JTYXZpbmcobW9sZWN1bGUpO1xyXG5cdFx0XHR9IGNhdGNoKGV4KSB7XHJcblx0XHRcdFx0XHR0aHJvdyB7IG1lc3NhZ2U6ICdCYWQgcy1ncm91cCAoJyArIGV4Lm1lc3NhZ2UgKyAnKScgfTtcclxuXHRcdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKCF0aGlzLmlnbm9yZV9lcnJvcnMpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdTTUlMRVMgZGF0YSBmb3JtYXQgZG9lc25cXCd0IHN1cHBvcnQgcy1ncm91cHMnKTtcclxuXHRcdH1cclxuXHR9LCB0aGlzKTtcclxuXHQvL0VORFxyXG5cclxuXHR0aGlzLmF0b21zID0gbmV3IEFycmF5KG1vbGVjdWxlLmF0b21zLmNvdW50KCkpO1xyXG5cclxuXHRtb2xlY3VsZS5hdG9tcy5lYWNoKGZ1bmN0aW9uIChhaWQsIGF0b20pXHJcblx0e1xyXG5cdFx0dGhpcy5hdG9tc1thaWRdID0gX0F0b20oYXRvbS5pbXBsaWNpdEgpO1xyXG5cdH0sIHRoaXMpO1xyXG5cclxuXHQvLyBGcm9tIHRoZSBTTUlMRVMgc3BlY2lmaWNhdGlvbjpcclxuXHQvLyBQbGVhc2Ugbm90ZSB0aGF0IG9ubHkgYXRvbXMgb24gdGhlIGZvbGxvd2luZyBsaXN0XHJcblx0Ly8gY2FuIGJlIGNvbnNpZGVyZWQgYXJvbWF0aWM6IEMsIE4sIE8sIFAsIFMsIEFzLCBTZSwgYW5kICogKHdpbGRjYXJkKS5cclxuXHR2YXIgYWxsb3dlZF9sb3dlcmNhc2UgPSBbJ0InLCAnQycsICdOJywgJ08nLCAnUCcsICdTJywgJ1NlJywgJ0FzJ107XHJcblxyXG5cdC8vIERldGVjdCBhdG9tcyB0aGF0IGhhdmUgYXJvbWF0aWMgYm9uZHMgYW5kIGNvdW50IG5laWdoYm91cnNcclxuXHRtb2xlY3VsZS5ib25kcy5lYWNoKGZ1bmN0aW9uIChiaWQsIGJvbmQpXHJcblx0e1xyXG5cdFx0aWYgKGJvbmQudHlwZSA9PSBCb25kLlBBVFRFUk4uVFlQRS5BUk9NQVRJQylcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5hdG9tc1tib25kLmJlZ2luXS5hcm9tYXRpYyA9IHRydWU7XHJcblx0XHRcdGlmIChhbGxvd2VkX2xvd2VyY2FzZS5pbmRleE9mKG1vbGVjdWxlLmF0b21zLmdldChib25kLmJlZ2luKS5sYWJlbCkgIT0gLTEpXHJcblx0XHRcdFx0dGhpcy5hdG9tc1tib25kLmJlZ2luXS5sb3dlcmNhc2UgPSB0cnVlO1xyXG5cdFx0XHR0aGlzLmF0b21zW2JvbmQuZW5kXS5hcm9tYXRpYyA9IHRydWU7XHJcblx0XHRcdGlmIChhbGxvd2VkX2xvd2VyY2FzZS5pbmRleE9mKG1vbGVjdWxlLmF0b21zLmdldChib25kLmVuZCkubGFiZWwpICE9IC0xKVxyXG5cdFx0XHRcdHRoaXMuYXRvbXNbYm9uZC5lbmRdLmxvd2VyY2FzZSA9IHRydWU7XHJcblx0XHR9XHJcblx0XHR0aGlzLmF0b21zW2JvbmQuYmVnaW5dLm5laWdoYm91cnMucHVzaCh7YWlkOiBib25kLmVuZCwgYmlkOiBiaWR9KTtcclxuXHRcdHRoaXMuYXRvbXNbYm9uZC5lbmRdLm5laWdoYm91cnMucHVzaCh7YWlkOiBib25kLmJlZ2luLCBiaWQ6IGJpZH0pO1xyXG5cdH0sIHRoaXMpO1xyXG5cclxuXHR0aGlzLmluTG9vcCA9IChmdW5jdGlvbiAoKSB7XHJcblx0XHRtb2xlY3VsZS5wcmVwYXJlTG9vcFN0cnVjdHVyZSgpO1xyXG5cdFx0dmFyIGJvbmRzSW5Mb29wcyA9IFNldC5lbXB0eSgpO1xyXG5cdFx0bW9sZWN1bGUubG9vcHMuZWFjaChmdW5jdGlvbiAobGlkLCBsb29wKSB7XHJcblx0XHRcdGlmIChsb29wLmhicy5sZW5ndGggPD0gNilcclxuXHRcdFx0XHRTZXQubWVyZ2VJbihib25kc0luTG9vcHMsIFNldC5mcm9tTGlzdCh1dGlsLm1hcChsb29wLmhicywgZnVuY3Rpb24gKGhiaWQpIHtcclxuXHRcdFx0XHRcdHJldHVybiBtb2xlY3VsZS5oYWxmQm9uZHMuZ2V0KGhiaWQpLmJpZDtcclxuXHRcdFx0XHR9LCB0aGlzKSkpO1xyXG5cdFx0fSwgdGhpcyk7XHJcblx0XHR2YXIgaW5Mb29wID0ge307XHJcblx0XHRTZXQuZWFjaChib25kc0luTG9vcHMsIGZ1bmN0aW9uIChiaWQpIHtcclxuXHRcdFx0aW5Mb29wW2JpZF0gPSAxO1xyXG5cdFx0fSwgdGhpcyk7XHJcblx0XHRyZXR1cm4gaW5Mb29wO1xyXG5cdH0pKCk7XHJcblxyXG5cdHRoaXMuX3RvdWNoZWRfY2lzdHJhbnNib25kcyA9IDA7XHJcblx0dGhpcy5fbWFya0Npc1RyYW5zKG1vbGVjdWxlKTtcclxuXHJcblx0dmFyIGNvbXBvbmVudHMgPSBtb2xlY3VsZS5nZXRDb21wb25lbnRzKCk7XHJcblx0dmFyIGNvbXBvbmVudHNBbGwgPSBjb21wb25lbnRzLnJlYWN0YW50cy5jb25jYXQoY29tcG9uZW50cy5wcm9kdWN0cyk7XHJcblxyXG5cdHZhciB3YWxrID0gbmV3IERmcyhtb2xlY3VsZSwgdGhpcy5hdG9tcywgY29tcG9uZW50c0FsbCwgY29tcG9uZW50cy5yZWFjdGFudHMubGVuZ3RoKTtcclxuXHJcblx0d2Fsay53YWxrKCk7XHJcblxyXG5cdHRoaXMuYXRvbXMuZWFjaChmdW5jdGlvbiAoYXRvbSlcclxuXHR7XHJcblx0XHRhdG9tLm5laWdoYm91cnMuY2xlYXIoKTtcclxuXHR9LCB0aGlzKTtcclxuXHJcblx0Ly8gZmlsbCB1cCBuZWlnaGJvciBsaXN0cyBmb3IgdGhlIHN0ZXJlb2NlbnRlcnMgY2FsY3VsYXRpb25cclxuXHRmb3IgKGkgPSAwOyBpIDwgd2Fsay52X3NlcS5sZW5ndGg7IGkrKylcclxuXHR7XHJcblx0XHR2YXIgc2VxX2VsID0gd2Fsay52X3NlcVtpXTtcclxuXHRcdHZhciB2X2lkeCA9IHNlcV9lbC5pZHg7XHJcblx0XHR2YXIgZV9pZHggPSBzZXFfZWwucGFyZW50X2VkZ2U7XHJcblx0XHR2YXIgdl9wcmV2X2lkeCA9IHNlcV9lbC5wYXJlbnRfdmVydGV4O1xyXG5cclxuXHRcdGlmIChlX2lkeCA+PSAwKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgYXRvbSA9IHRoaXMuYXRvbXNbdl9pZHhdO1xyXG5cclxuXHRcdFx0dmFyIG9wZW5pbmdfY3ljbGVzID0gd2Fsay5udW1PcGVuaW5nQ3ljbGVzKGVfaWR4KTtcclxuXHJcblx0XHRcdGZvciAoaiA9IDA7IGogPCBvcGVuaW5nX2N5Y2xlczsgaisrKVxyXG5cdFx0XHRcdHRoaXMuYXRvbXNbdl9wcmV2X2lkeF0ubmVpZ2hib3Vycy5wdXNoKHthaWQ6IC0xLCBiaWQ6IC0xfSk7XHJcblxyXG5cdFx0XHRpZiAod2Fsay5lZGdlQ2xvc2luZ0N5Y2xlKGVfaWR4KSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGZvciAoayA9IDA7IGsgPCBhdG9tLm5laWdoYm91cnMubGVuZ3RoOyBrKyspXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0aWYgKGF0b20ubmVpZ2hib3Vyc1trXS5haWQgPT0gLTEpXHJcblx0XHRcdFx0XHR7XHJcblx0XHRcdFx0XHRcdGF0b20ubmVpZ2hib3Vyc1trXS5haWQgPSB2X3ByZXZfaWR4O1xyXG5cdFx0XHRcdFx0XHRhdG9tLm5laWdoYm91cnNba10uYmlkID0gZV9pZHg7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoayA9PSBhdG9tLm5laWdoYm91cnMubGVuZ3RoKVxyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdpbnRlcm5hbDogY2FuIG5vdCBwdXQgY2xvc2luZyBib25kIHRvIGl0cyBwbGFjZScpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGF0b20ubmVpZ2hib3Vycy5wdXNoKHthaWQ6IHZfcHJldl9pZHgsIGJpZDogZV9pZHh9KTtcclxuXHRcdFx0XHRhdG9tLnBhcmVudCA9IHZfcHJldl9pZHg7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5hdG9tc1t2X3ByZXZfaWR4XS5uZWlnaGJvdXJzLnB1c2goe2FpZDogdl9pZHgsIGJpZDogZV9pZHh9KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHRyeSB7XHJcblx0XHQvLyBkZXRlY3QgY2hpcmFsIGNvbmZpZ3VyYXRpb25zXHJcblx0XHR2YXIgc3RlcmVvY2VudGVycyA9IG5ldyBTdGVyZW9jZW50ZXJzKG1vbGVjdWxlLCBmdW5jdGlvbiAoaWR4KVxyXG5cdFx0e1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5hdG9tc1tpZHhdLm5laWdoYm91cnM7XHJcblx0XHR9LCB0aGlzKTtcclxuXHRcdHN0ZXJlb2NlbnRlcnMuYnVpbGRGcm9tQm9uZHModGhpcy5pZ25vcmVfZXJyb3JzKTtcclxuXHJcblx0XHRzdGVyZW9jZW50ZXJzLmVhY2ggKGZ1bmN0aW9uIChhdG9tX2lkeCwgc2MpXHJcblx0XHR7XHJcblx0XHRcdC8vaWYgKHNjLnR5cGUgPCBNb2xlY3VsZVN0ZXJlb2NlbnRlcnM6OkFUT01fQU5EKVxyXG5cdFx0XHQvLyAgICBjb250aW51ZTtcclxuXHJcblx0XHRcdHZhciBpbXBsaWNpdF9oX2lkeCA9IC0xO1xyXG5cclxuXHRcdFx0aWYgKHNjLnB5cmFtaWRbM10gPT0gLTEpXHJcblx0XHRcdFx0aW1wbGljaXRfaF9pZHggPSAzO1xyXG5cdFx0XHQvKlxyXG4gICAgICAgICAgICBlbHNlIGZvciAoaiA9IDA7IGogPCA0OyBqKyspXHJcbiAgICAgICAgICAgICAgICBpZiAoaWdub3JlZF92ZXJ0aWNlc1tweXJhbWlkW2pdXSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpbXBsaWNpdF9oX2lkeCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAqL1xyXG5cclxuXHRcdFx0dmFyIHB5cmFtaWRfbWFwcGluZyA9IG5ldyBBcnJheSg0KTtcclxuXHRcdFx0dmFyIGNvdW50ZXIgPSAwO1xyXG5cclxuXHRcdFx0dmFyIGF0b20gPSB0aGlzLmF0b21zW2F0b21faWR4XTtcclxuXHJcblx0XHRcdGlmIChhdG9tLnBhcmVudCAhPSAtMSlcclxuXHRcdFx0XHRmb3IgKGsgPSAwOyBrIDwgNDsgaysrKVxyXG5cdFx0XHRcdFx0aWYgKHNjLnB5cmFtaWRba10gPT0gYXRvbS5wYXJlbnQpXHJcblx0XHRcdFx0XHR7XHJcblx0XHRcdFx0XHRcdHB5cmFtaWRfbWFwcGluZ1tjb3VudGVyKytdID0gaztcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoaW1wbGljaXRfaF9pZHggIT0gLTEpXHJcblx0XHRcdFx0cHlyYW1pZF9tYXBwaW5nW2NvdW50ZXIrK10gPSBpbXBsaWNpdF9oX2lkeDtcclxuXHJcblx0XHRcdGZvciAoaiA9IDA7IGogIT0gYXRvbS5uZWlnaGJvdXJzLmxlbmd0aDsgaisrKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0aWYgKGF0b20ubmVpZ2hib3Vyc1tqXS5haWQgPT0gYXRvbS5wYXJlbnQpXHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdFx0Zm9yIChrID0gMDsgayA8IDQ7IGsrKylcclxuXHRcdFx0XHRcdGlmIChhdG9tLm5laWdoYm91cnNbal0uYWlkID09IHNjLnB5cmFtaWRba10pXHJcblx0XHRcdFx0XHR7XHJcblx0XHRcdFx0XHRcdGlmIChjb3VudGVyID49IDQpXHJcblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdpbnRlcm5hbDogcHlyYW1pZCBvdmVyZmxvdycpO1xyXG5cdFx0XHRcdFx0XHRweXJhbWlkX21hcHBpbmdbY291bnRlcisrXSA9IGs7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoY291bnRlciA9PSA0KVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0Ly8gbW92ZSB0aGUgJ2Zyb20nIGF0b20gdG8gdGhlIGVuZFxyXG5cdFx0XHRcdGNvdW50ZXIgPSBweXJhbWlkX21hcHBpbmdbMF07XHJcblx0XHRcdFx0cHlyYW1pZF9tYXBwaW5nWzBdID0gcHlyYW1pZF9tYXBwaW5nWzFdO1xyXG5cdFx0XHRcdHB5cmFtaWRfbWFwcGluZ1sxXSA9IHB5cmFtaWRfbWFwcGluZ1syXTtcclxuXHRcdFx0XHRweXJhbWlkX21hcHBpbmdbMl0gPSBweXJhbWlkX21hcHBpbmdbM107XHJcblx0XHRcdFx0cHlyYW1pZF9tYXBwaW5nWzNdID0gY291bnRlcjtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmIChjb3VudGVyICE9IDMpXHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgY2FsY3VsYXRlIGNoaXJhbGl0eScpO1xyXG5cclxuXHRcdFx0aWYgKFN0ZXJlb2NlbnRlcnMuaXNQeXJhbWlkTWFwcGluZ1JpZ2lkKHB5cmFtaWRfbWFwcGluZykpXHJcblx0XHRcdFx0dGhpcy5hdG9tc1thdG9tX2lkeF0uY2hpcmFsaXR5ID0gMTtcclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdHRoaXMuYXRvbXNbYXRvbV9pZHhdLmNoaXJhbGl0eSA9IDI7XHJcblx0XHR9LCB0aGlzKTtcclxuXHR9IGNhdGNoIChleCkge1xyXG5cdFx0XHRhbGVydCgnV2FybmluZzogJyArIGV4Lm1lc3NhZ2UpO1xyXG5cdFx0fVxyXG5cclxuXHQvLyB3cml0ZSB0aGUgU01JTEVTIGl0c2VsZlxyXG5cclxuXHQvLyBjeWNsZV9udW1iZXJzW2ldID09IC0xIG1lYW5zIHRoYXQgdGhlIG51bWJlciBpcyBhdmFpbGFibGVcclxuXHQvLyBjeWNsZV9udW1iZXJzW2ldID09IG4gbWVhbnMgdGhhdCB0aGUgbnVtYmVyIGlzIHVzZWQgYnkgdmVydGV4IG5cclxuXHR2YXIgY3ljbGVfbnVtYmVycyA9IFtdO1xyXG5cclxuXHRjeWNsZV9udW1iZXJzLnB1c2goMCk7IC8vIG5ldmVyIHVzZWRcclxuXHJcblx0dmFyIGZpcnN0X2NvbXBvbmVudCA9IHRydWU7XHJcblxyXG5cdGZvciAoaSA9IDA7IGkgPCB3YWxrLnZfc2VxLmxlbmd0aDsgaSsrKVxyXG5cdHtcclxuXHRcdHNlcV9lbCA9IHdhbGsudl9zZXFbaV07XHJcblx0XHR2X2lkeCA9IHNlcV9lbC5pZHg7XHJcblx0XHRlX2lkeCA9IHNlcV9lbC5wYXJlbnRfZWRnZTtcclxuXHRcdHZfcHJldl9pZHggPSBzZXFfZWwucGFyZW50X3ZlcnRleDtcclxuXHRcdHZhciB3cml0ZV9hdG9tID0gdHJ1ZTtcclxuXHJcblx0XHRpZiAodl9wcmV2X2lkeCA+PSAwKVxyXG5cdFx0e1xyXG5cdFx0XHRpZiAod2Fsay5udW1CcmFuY2hlcyh2X3ByZXZfaWR4KSA+IDEpXHJcblx0XHRcdGlmICh0aGlzLmF0b21zW3ZfcHJldl9pZHhdLmJyYW5jaF9jbnQgPiAwICYmIHRoaXMuYXRvbXNbdl9wcmV2X2lkeF0ucGFyZW5fd3JpdHRlbilcclxuXHRcdFx0XHR0aGlzLnNtaWxlcyArPSAnKSc7XHJcblxyXG5cdFx0XHRvcGVuaW5nX2N5Y2xlcyA9IHdhbGsubnVtT3BlbmluZ0N5Y2xlcyhlX2lkeCk7XHJcblxyXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgb3BlbmluZ19jeWNsZXM7IGorKylcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGZvciAoayA9IDE7IGsgPCBjeWNsZV9udW1iZXJzLmxlbmd0aDsgaysrKVxyXG5cdFx0XHRcdFx0aWYgKGN5Y2xlX251bWJlcnNba10gPT0gLTEpXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGlmIChrID09IGN5Y2xlX251bWJlcnMubGVuZ3RoKVxyXG5cdFx0XHRcdFx0Y3ljbGVfbnVtYmVycy5wdXNoKHZfcHJldl9pZHgpO1xyXG5cdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdGN5Y2xlX251bWJlcnNba10gPSB2X3ByZXZfaWR4O1xyXG5cclxuXHRcdFx0XHR0aGlzLl93cml0ZUN5Y2xlTnVtYmVyKGspO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAodl9wcmV2X2lkeCA+PSAwKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dmFyIGJyYW5jaGVzID0gd2Fsay5udW1CcmFuY2hlcyh2X3ByZXZfaWR4KTtcclxuXHJcblx0XHRcdFx0aWYgKGJyYW5jaGVzID4gMSlcclxuXHRcdFx0XHRpZiAodGhpcy5hdG9tc1t2X3ByZXZfaWR4XS5icmFuY2hfY250IDwgYnJhbmNoZXMgLSAxKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdGlmICh3YWxrLmVkZ2VDbG9zaW5nQ3ljbGUoZV9pZHgpKVxyXG5cdFx0XHRcdFx0XHR0aGlzLmF0b21zW3ZfcHJldl9pZHhdLnBhcmVuX3dyaXR0ZW4gPSBmYWxzZTtcclxuXHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdHtcclxuXHRcdFx0XHRcdFx0dGhpcy5zbWlsZXMgKz0gJygnO1xyXG5cdFx0XHRcdFx0XHR0aGlzLmF0b21zW3ZfcHJldl9pZHhdLnBhcmVuX3dyaXR0ZW4gPSB0cnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5hdG9tc1t2X3ByZXZfaWR4XS5icmFuY2hfY250Kys7XHJcblxyXG5cdFx0XHRcdGlmICh0aGlzLmF0b21zW3ZfcHJldl9pZHhdLmJyYW5jaF9jbnQgPiBicmFuY2hlcylcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBicmFuY2gnKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGJvbmQgPSBtb2xlY3VsZS5ib25kcy5nZXQoZV9pZHgpO1xyXG5cdFx0XHR2YXIgYm9uZF93cml0dGVuID0gdHJ1ZTtcclxuXHJcblx0XHRcdHZhciBkaXIgPSAwO1xyXG5cclxuXHRcdFx0aWYgKGJvbmQudHlwZSA9PSBCb25kLlBBVFRFUk4uVFlQRS5TSU5HTEUpXHJcblx0XHRcdFx0ZGlyID0gdGhpcy5fY2FsY0JvbmREaXJlY3Rpb24obW9sZWN1bGUsIGVfaWR4LCB2X3ByZXZfaWR4KTtcclxuXHJcblx0XHRcdGlmICgoZGlyID09IDEgJiYgdl9pZHggPT0gYm9uZC5lbmQpIHx8IChkaXIgPT0gMiAmJiB2X2lkeCA9PSBib25kLmJlZ2luKSlcclxuXHRcdFx0XHR0aGlzLnNtaWxlcyArPSAnLyc7XHJcblx0XHRcdGVsc2UgaWYgKChkaXIgPT0gMiAmJiB2X2lkeCA9PSBib25kLmVuZCkgfHwgKGRpciA9PSAxICYmIHZfaWR4ID09IGJvbmQuYmVnaW4pKVxyXG5cdFx0XHRcdHRoaXMuc21pbGVzICs9ICdcXFxcJztcclxuXHRcdFx0ZWxzZSBpZiAoYm9uZC50eXBlID09IEJvbmQuUEFUVEVSTi5UWVBFLkFOWSlcclxuXHRcdFx0XHR0aGlzLnNtaWxlcyArPSAnfic7XHJcblx0XHRcdGVsc2UgaWYgKGJvbmQudHlwZSA9PSBCb25kLlBBVFRFUk4uVFlQRS5ET1VCTEUpXHJcblx0XHRcdFx0dGhpcy5zbWlsZXMgKz0gJz0nO1xyXG5cdFx0XHRlbHNlIGlmIChib25kLnR5cGUgPT0gQm9uZC5QQVRURVJOLlRZUEUuVFJJUExFKVxyXG5cdFx0XHRcdHRoaXMuc21pbGVzICs9ICcjJztcclxuXHRcdFx0ZWxzZSBpZiAoYm9uZC50eXBlID09IEJvbmQuUEFUVEVSTi5UWVBFLkFST01BVElDICYmXHJcblx0XHRcdCghdGhpcy5hdG9tc1tib25kLmJlZ2luXS5sb3dlcmNhc2UgfHwgIXRoaXMuYXRvbXNbYm9uZC5lbmRdLmxvd2VyY2FzZSB8fCAhdGhpcy5pc0JvbmRJblJpbmcoZV9pZHgpKSlcclxuXHRcdFx0XHR0aGlzLnNtaWxlcyArPSAnOic7IC8vIFRPRE86IENoZWNrIGlmIHRoaXMgOiBpcyBuZWVkZWRcclxuXHRcdFx0ZWxzZSBpZiAoYm9uZC50eXBlID09IEJvbmQuUEFUVEVSTi5UWVBFLlNJTkdMRSAmJiB0aGlzLmF0b21zW2JvbmQuYmVnaW5dLmFyb21hdGljICYmIHRoaXMuYXRvbXNbYm9uZC5lbmRdLmFyb21hdGljKVxyXG5cdFx0XHRcdHRoaXMuc21pbGVzICs9ICctJztcclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdGJvbmRfd3JpdHRlbiA9IGZhbHNlO1xyXG5cclxuXHJcblx0XHRcdGlmICh3YWxrLmVkZ2VDbG9zaW5nQ3ljbGUoZV9pZHgpKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0Zm9yIChqID0gMTsgaiA8IGN5Y2xlX251bWJlcnMubGVuZ3RoOyBqKyspXHJcblx0XHRcdFx0XHRpZiAoY3ljbGVfbnVtYmVyc1tqXSA9PSB2X2lkeClcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGlmIChqID09IGN5Y2xlX251bWJlcnMubGVuZ3RoKVxyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdjeWNsZSBudW1iZXIgbm90IGZvdW5kJyk7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3dyaXRlQ3ljbGVOdW1iZXIoaik7XHJcblxyXG5cdFx0XHRcdGN5Y2xlX251bWJlcnNbal0gPSAtMTtcclxuXHRcdFx0XHR3cml0ZV9hdG9tID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGVsc2VcclxuXHRcdHtcclxuXHRcdFx0aWYgKCFmaXJzdF9jb21wb25lbnQpXHJcblx0XHRcdFx0dGhpcy5zbWlsZXMgKz0gKHRoaXMuX3dyaXR0ZW5fY29tcG9uZW50cyA9PSB3YWxrLm5Db21wb25lbnRzSW5SZWFjdGFudHMpID8gJz4+JyA6ICcuJztcclxuXHRcdFx0Zmlyc3RfY29tcG9uZW50ID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuX3dyaXR0ZW5fY29tcG9uZW50cysrO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHdyaXRlX2F0b20pIHtcclxuXHRcdFx0dGhpcy5fd3JpdGVBdG9tKG1vbGVjdWxlLCB2X2lkeCwgdGhpcy5hdG9tc1t2X2lkeF0uYXJvbWF0aWMsIHRoaXMuYXRvbXNbdl9pZHhdLmxvd2VyY2FzZSwgdGhpcy5hdG9tc1t2X2lkeF0uY2hpcmFsaXR5KTtcclxuXHRcdFx0dGhpcy5fd3JpdHRlbl9hdG9tcy5wdXNoKHNlcV9lbC5pZHgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0dGhpcy5jb21tYSA9IGZhbHNlO1xyXG5cclxuXHQvL3RoaXMuX3dyaXRlU3RlcmVvZ3JvdXBzKG1vbCwgYXRvbXMpO1xyXG5cdHRoaXMuX3dyaXRlUmFkaWNhbHMobW9sZWN1bGUpO1xyXG5cdC8vdGhpcy5fd3JpdGVQc2V1ZG9BdG9tcyhtb2wpO1xyXG5cdC8vdGhpcy5fd3JpdGVIaWdobGlnaHRpbmcoKTtcclxuXHJcblx0aWYgKHRoaXMuY29tbWEpXHJcblx0XHR0aGlzLnNtaWxlcyArPSAnfCc7XHJcblxyXG5cdHJldHVybiB0aGlzLnNtaWxlcztcclxuXHJcbn07XHJcblxyXG5TbWlsZXMucHJvdG90eXBlLl93cml0ZUN5Y2xlTnVtYmVyID0gZnVuY3Rpb24gKG4pXHJcbntcclxuXHRpZiAobiA+IDAgJiYgbiA8IDEwKVxyXG5cdFx0dGhpcy5zbWlsZXMgKz0gbjtcclxuXHRlbHNlIGlmIChuID49IDEwICYmIG4gPCAxMDApXHJcblx0XHR0aGlzLnNtaWxlcyArPSAnJScgKyBuO1xyXG5cdGVsc2UgaWYgKG4gPj0gMTAwICYmIG4gPCAxMDAwKVxyXG5cdFx0dGhpcy5zbWlsZXMgKz0gJyUlJyArIG47XHJcblx0ZWxzZVxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdiYWQgY3ljbGUgbnVtYmVyOiAnICsgbik7XHJcbn07XHJcblxyXG5TbWlsZXMucHJvdG90eXBlLl93cml0ZUF0b20gPSBmdW5jdGlvbiAobW9sLCBpZHgsIGFyb21hdGljLCBsb3dlcmNhc2UsIGNoaXJhbGl0eSlcclxue1xyXG5cdHZhciBhdG9tID0gbW9sLmF0b21zLmdldChpZHgpO1xyXG5cdHZhciBpO1xyXG5cdHZhciBuZWVkX2JyYWNrZXRzID0gZmFsc2U7XHJcblx0dmFyIGh5ZHJvID0gLTE7XHJcblx0dmFyIGFhbSA9IDA7XHJcblxyXG5cdC8qXHJcbiAgICBpZiAobW9sLmhhdmVRdWVyeUF0b21zKCkpXHJcbiAgICB7XHJcbiAgICAgIHF1ZXJ5X2F0b20gPSAmbW9sLmdldFF1ZXJ5QXRvbShpZHgpO1xyXG5cclxuICAgICAgaWYgKHF1ZXJ5X2F0b20tPnR5cGUgPT0gUVVFUllfQVRPTV9SR1JPVVApXHJcbiAgICAgIHtcclxuICAgICAgICAgaWYgKG1vbC5nZXRSR3JvdXBzKCktPmlzUkdyb3VwQXRvbShpZHgpKVxyXG4gICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnN0IEFycmF5PGludD4gJnJnID0gbW9sLmdldFJHcm91cHMoKS0+Z2V0U2l0ZVJHcm91cHMoaWR4KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChyZy5zaXplKCkgIT0gMSlcclxuICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJyZ3JvdXAgY291bnQgJWRcIiwgcmcuc2l6ZSgpKTtcclxuXHJcbiAgICAgICAgICAgIF9vdXRwdXQucHJpbnRmKFwiWyYlZF1cIiwgcmdbMF0gKyAxKTtcclxuICAgICAgICAgfVxyXG4gICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIF9vdXRwdXQucHJpbnRmKFwiWyYlZF1cIiwgMSk7XHJcblxyXG4gICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgICovXHJcblxyXG5cdGlmIChhdG9tLmxhYmVsID09ICdBJylcclxuXHR7XHJcblx0XHR0aGlzLnNtaWxlcyArPSAnKic7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cclxuXHRpZiAoYXRvbS5sYWJlbCA9PSAnUicgfHwgYXRvbS5sYWJlbCA9PSAnUiMnKVxyXG5cdHtcclxuXHRcdHRoaXMuc21pbGVzICs9ICdbKl0nO1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHJcblx0Ly9LRVRDSEVSLTU5OCAoS2V0Y2hlciBkb2VzIG5vdCBzYXZlIEFBTSBpbnRvIHJlYWN0aW9uIFNNSUxFUylcclxuXHQvL0JFR0lOXHJcbi8vICAgIGlmICh0aGlzLmF0b21fYXRvbV9tYXBwaW5nKVxyXG4vLyAgICAgICAgYWFtID0gYXRvbV9hdG9tX21hcHBpbmdbaWR4XTtcclxuXHRhYW0gPSBhdG9tLmFhbTtcclxuXHQvL0VORFxyXG5cclxuXHRpZiAoYXRvbS5sYWJlbCAhPSAnQycgJiYgYXRvbS5sYWJlbCAhPSAnUCcgJiZcclxuXHRhdG9tLmxhYmVsICE9ICdOJyAmJiBhdG9tLmxhYmVsICE9ICdTJyAmJlxyXG5cdGF0b20ubGFiZWwgIT0gJ08nICYmIGF0b20ubGFiZWwgIT0gJ0NsJyAmJlxyXG5cdGF0b20ubGFiZWwgIT0gJ0YnICYmIGF0b20ubGFiZWwgIT0gJ0JyJyAmJlxyXG5cdGF0b20ubGFiZWwgIT0gJ0InICYmIGF0b20ubGFiZWwgIT0gJ0knKVxyXG5cdFx0bmVlZF9icmFja2V0cyA9IHRydWU7XHJcblxyXG5cdGlmIChhdG9tLmV4cGxpY2l0VmFsZW5jZSA+PSAwIHx8IGF0b20ucmFkaWNhbCAhPSAwIHx8IGNoaXJhbGl0eSA+IDAgfHxcclxuXHRcdChhcm9tYXRpYyAmJiBhdG9tLmxhYmVsICE9ICdDJyAmJiBhdG9tLmxhYmVsICE9ICdPJykgfHxcclxuXHQoYXJvbWF0aWMgJiYgYXRvbS5sYWJlbCA9PSAnQycgJiYgdGhpcy5hdG9tc1tpZHhdLm5laWdoYm91cnMubGVuZ3RoIDwgMyAmJiB0aGlzLmF0b21zW2lkeF0uaF9jb3VudCA9PSAwKSlcclxuXHRcdGh5ZHJvID0gdGhpcy5hdG9tc1tpZHhdLmhfY291bnQ7XHJcblxyXG5cdHZhciBsYWJlbCA9IGF0b20ubGFiZWw7XHJcblx0aWYgKGF0b20uYXRvbUxpc3QgJiYgIWF0b20uYXRvbUxpc3Qubm90TGlzdCkge1xyXG5cdFx0bGFiZWwgPSBhdG9tLmF0b21MaXN0LmxhYmVsKCk7XHJcblx0XHRuZWVkX2JyYWNrZXRzID0gZmFsc2U7IC8vIGF0b20gbGlzdCBsYWJlbCBhbHJlYWR5IGhhcyBicmFja2V0c1xyXG5cdH0gZWxzZSBpZiAoYXRvbS5pc1BzZXVkbygpIHx8IChhdG9tLmF0b21MaXN0ICYmIGF0b20uYXRvbUxpc3Qubm90TGlzdCkpIHtcclxuXHRcdGxhYmVsID0gJyonO1xyXG5cdFx0bmVlZF9icmFja2V0cyA9IHRydWU7XHJcblx0fSBlbHNlIGlmIChjaGlyYWxpdHkgfHwgYXRvbS5jaGFyZ2UgIT0gMCB8fCBhdG9tLmlzb3RvcGUgPiAwIHx8IGh5ZHJvID49IDAgfHwgYWFtID4gMCkge1xyXG5cdFx0bmVlZF9icmFja2V0cyA9IHRydWU7XHJcblx0fVxyXG5cclxuXHRpZiAobmVlZF9icmFja2V0cylcclxuXHR7XHJcblx0XHRpZiAoaHlkcm8gPT0gLTEpXHJcblx0XHRcdGh5ZHJvID0gdGhpcy5hdG9tc1tpZHhdLmhfY291bnQ7XHJcblx0XHR0aGlzLnNtaWxlcyArPSAnWyc7XHJcblx0fVxyXG5cclxuXHRpZiAoYXRvbS5pc290b3BlID4gMClcclxuXHRcdHRoaXMuc21pbGVzICs9IGF0b20uaXNvdG9wZTtcclxuXHJcblx0aWYgKGxvd2VyY2FzZSlcclxuXHRcdHRoaXMuc21pbGVzICs9IGxhYmVsLnRvTG93ZXJDYXNlKCk7XHJcblx0ZWxzZVxyXG5cdFx0dGhpcy5zbWlsZXMgKz0gbGFiZWw7XHJcblxyXG5cdGlmIChjaGlyYWxpdHkgPiAwKVxyXG5cdHtcclxuXHRcdGlmIChjaGlyYWxpdHkgPT0gMSlcclxuXHRcdFx0dGhpcy5zbWlsZXMgKz0gJ0AnO1xyXG5cdFx0ZWxzZSAvLyBjaGlyYWxpdHkgPT0gMlxyXG5cdFx0XHR0aGlzLnNtaWxlcyArPSAnQEAnO1xyXG5cclxuXHRcdGlmIChhdG9tLmltcGxpY2l0SCA+IDEpXHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihhdG9tLmltcGxpY2l0SCArICcgaW1wbGljaXQgSCBuZWFyIHN0ZXJlb2NlbnRlcicpO1xyXG5cdH1cclxuXHJcblx0aWYgKGF0b20ubGFiZWwgIT0gJ0gnKSB7XHJcblx0XHRpZiAoaHlkcm8gPiAxIHx8IChoeWRybyA9PSAwICYmICFuZWVkX2JyYWNrZXRzKSlcclxuXHRcdFx0dGhpcy5zbWlsZXMgKz0gJ0gnICsgaHlkcm87XHJcblx0XHRlbHNlIGlmIChoeWRybyA9PSAxKVxyXG5cdFx0XHR0aGlzLnNtaWxlcyArPSAnSCc7XHJcblx0fVxyXG5cclxuXHRpZiAoYXRvbS5jaGFyZ2UgPiAxKVxyXG5cdFx0dGhpcy5zbWlsZXMgKz0gJysnICsgYXRvbS5jaGFyZ2U7XHJcblx0ZWxzZSBpZiAoYXRvbS5jaGFyZ2UgPCAtMSlcclxuXHRcdHRoaXMuc21pbGVzICs9IGF0b20uY2hhcmdlO1xyXG5cdGVsc2UgaWYgKGF0b20uY2hhcmdlID09IDEpXHJcblx0XHR0aGlzLnNtaWxlcyArPSAnKyc7XHJcblx0ZWxzZSBpZiAoYXRvbS5jaGFyZ2UgPT0gLTEpXHJcblx0XHR0aGlzLnNtaWxlcyArPSAnLSc7XHJcblxyXG5cdGlmIChhYW0gPiAwKVxyXG5cdFx0dGhpcy5zbWlsZXMgKz0gJzonICsgYWFtO1xyXG5cclxuXHRpZiAobmVlZF9icmFja2V0cylcclxuXHRcdHRoaXMuc21pbGVzICs9ICddJztcclxuXHJcblx0LypcclxuICAgIGlmIChtb2wuZ2V0Ukdyb3VwRnJhZ21lbnQoKSAhPSAwKVxyXG4gICAge1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgMjsgaSsrKVxyXG4gICAgICB7XHJcbiAgICAgICAgIGludCBqO1xyXG5cclxuICAgICAgICAgZm9yIChqID0gMDsgbW9sLmdldFJHcm91cEZyYWdtZW50KCktPmdldEF0dGFjaG1lbnRQb2ludChpLCBqKSAhPSAtMTsgaisrKVxyXG4gICAgICAgICAgICBpZiAoaWR4ID09IG1vbC5nZXRSR3JvdXBGcmFnbWVudCgpLT5nZXRBdHRhY2htZW50UG9pbnQoaSwgaikpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgX291dHB1dC5wcmludGYoXCIoWypdKVwiKTtcclxuICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgIGlmIChtb2wuZ2V0Ukdyb3VwRnJhZ21lbnQoKS0+Z2V0QXR0YWNobWVudFBvaW50KGksIGopICE9IC0xKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgKi9cclxufTtcclxuXHJcblNtaWxlcy5wcm90b3R5cGUuX21hcmtDaXNUcmFucyA9IGZ1bmN0aW9uIChtb2wpXHJcbntcclxuXHR0aGlzLmNpc190cmFucyA9IG5ldyBDaXNUcmFucyAobW9sLCBmdW5jdGlvbiAoaWR4KVxyXG5cdHtcclxuXHRcdHJldHVybiB0aGlzLmF0b21zW2lkeF0ubmVpZ2hib3VycztcclxuXHR9LCB0aGlzKTtcclxuXHR0aGlzLmNpc190cmFucy5idWlsZCgpO1xyXG5cdHRoaXMuX2Rib25kcyA9IG5ldyBBcnJheShtb2wuYm9uZHMuY291bnQoKSk7XHJcblxyXG5cdG1vbC5ib25kcy5lYWNoKGZ1bmN0aW9uIChiaWQpXHJcblx0e1xyXG5cdFx0dGhpcy5fZGJvbmRzW2JpZF0gPVxyXG5cdFx0e1xyXG5cdFx0XHRjdGJvbmRfYmVnOiAtMSxcclxuXHRcdFx0Y3Rib25kX2VuZDogLTEsXHJcblx0XHRcdHNhdmVkOiAwXHJcblx0XHR9XHJcblx0fSwgdGhpcyk7XHJcblxyXG5cdHRoaXMuY2lzX3RyYW5zLmVhY2goZnVuY3Rpb24gKGJpZCwgY3QpXHJcblx0e1xyXG5cdFx0dmFyIGJvbmQgPSBtb2wuYm9uZHMuZ2V0KGJpZCk7XHJcblxyXG5cdFx0aWYgKGN0LnBhcml0eSAhPSAwICYmICF0aGlzLmlzQm9uZEluUmluZyhiaWQpKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgbmVpX2JlZyA9IHRoaXMuYXRvbXNbYm9uZC5iZWdpbl0ubmVpZ2hib3VycztcclxuXHRcdFx0dmFyIG5laV9lbmQgPSB0aGlzLmF0b21zW2JvbmQuZW5kXS5uZWlnaGJvdXJzO1xyXG5cdFx0XHR2YXIgYXJvbV9mYWlsX2JlZyA9IHRydWUsIGFyb21fZmFpbF9lbmQgPSB0cnVlO1xyXG5cclxuXHRcdFx0bmVpX2JlZy5lYWNoKGZ1bmN0aW9uIChuZWkpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRpZiAobmVpLmJpZCAhPSBiaWQgJiYgbW9sLmJvbmRzLmdldChuZWkuYmlkKS50eXBlID09IEJvbmQuUEFUVEVSTi5UWVBFLlNJTkdMRSlcclxuXHRcdFx0XHRcdGFyb21fZmFpbF9iZWcgPSBmYWxzZTtcclxuXHRcdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0XHRuZWlfZW5kLmVhY2goZnVuY3Rpb24gKG5laSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGlmIChuZWkuYmlkICE9IGJpZCAmJiBtb2wuYm9uZHMuZ2V0KG5laS5iaWQpLnR5cGUgPT0gQm9uZC5QQVRURVJOLlRZUEUuU0lOR0xFKVxyXG5cdFx0XHRcdFx0YXJvbV9mYWlsX2VuZCA9IGZhbHNlO1xyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHRcdGlmIChhcm9tX2ZhaWxfYmVnIHx8IGFyb21fZmFpbF9lbmQpXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0bmVpX2JlZy5lYWNoKGZ1bmN0aW9uIChuZWkpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRpZiAobmVpLmJpZCAhPSBiaWQpXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0aWYgKG1vbC5ib25kcy5nZXQobmVpLmJpZCkuYmVnaW4gPT0gYm9uZC5iZWdpbilcclxuXHRcdFx0XHRcdFx0dGhpcy5fZGJvbmRzW25laS5iaWRdLmN0Ym9uZF9iZWcgPSBiaWQ7XHJcblx0XHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRcdHRoaXMuX2Rib25kc1tuZWkuYmlkXS5jdGJvbmRfZW5kID0gYmlkO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0XHRuZWlfZW5kLmVhY2goZnVuY3Rpb24gKG5laSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGlmIChuZWkuYmlkICE9IGJpZClcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHRpZiAobW9sLmJvbmRzLmdldChuZWkuYmlkKS5iZWdpbiA9PSBib25kLmVuZClcclxuXHRcdFx0XHRcdFx0dGhpcy5fZGJvbmRzW25laS5iaWRdLmN0Ym9uZF9iZWcgPSBiaWQ7XHJcblx0XHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRcdHRoaXMuX2Rib25kc1tuZWkuYmlkXS5jdGJvbmRfZW5kID0gYmlkO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSwgdGhpcyk7XHJcblx0XHR9XHJcblx0fSwgdGhpcyk7XHJcbn07XHJcblxyXG5TbWlsZXMucHJvdG90eXBlLl91cGRhdGVTaWRlQm9uZHMgPSBmdW5jdGlvbiAobW9sLCBib25kX2lkeClcclxue1xyXG5cdHZhciBib25kID0gbW9sLmJvbmRzLmdldChib25kX2lkeCk7XHJcblx0dmFyIHN1YnN0ID0gdGhpcy5jaXNfdHJhbnMuZ2V0U3Vic3RpdHVlbnRzKGJvbmRfaWR4KTtcclxuXHR2YXIgcGFyaXR5ID0gdGhpcy5jaXNfdHJhbnMuZ2V0UGFyaXR5KGJvbmRfaWR4KTtcclxuXHJcblx0dmFyIHNpZGVib25kcyA9IFstMSwgLTEsIC0xLCAtMV07XHJcblxyXG5cdHNpZGVib25kc1swXSA9IG1vbC5maW5kQm9uZElkKHN1YnN0WzBdLCBib25kLmJlZ2luKTtcclxuXHRpZiAoc3Vic3RbMV0gIT0gLTEpXHJcblx0XHRzaWRlYm9uZHNbMV0gPSBtb2wuZmluZEJvbmRJZChzdWJzdFsxXSwgYm9uZC5iZWdpbik7XHJcblxyXG5cdHNpZGVib25kc1syXSA9IG1vbC5maW5kQm9uZElkKHN1YnN0WzJdLCBib25kLmVuZCk7XHJcblx0aWYgKHN1YnN0WzNdICE9IC0xKVxyXG5cdFx0c2lkZWJvbmRzWzNdID0gbW9sLmZpbmRCb25kSWQoc3Vic3RbM10sIGJvbmQuZW5kKTtcclxuXHJcblx0dmFyIG4xID0gMCwgbjIgPSAwLCBuMyA9IDAsIG40ID0gMDtcclxuXHJcblx0aWYgKHRoaXMuX2Rib25kc1tzaWRlYm9uZHNbMF1dLnNhdmVkICE9IDApXHJcblx0e1xyXG5cdFx0aWYgKCh0aGlzLl9kYm9uZHNbc2lkZWJvbmRzWzBdXS5zYXZlZCA9PSAxICYmIG1vbC5ib25kcy5nZXQoc2lkZWJvbmRzWzBdKS5iZWdpbiA9PSBib25kLmJlZ2luKSB8fFxyXG5cdFx0KHRoaXMuX2Rib25kc1tzaWRlYm9uZHNbMF1dLnNhdmVkID09IDIgJiYgbW9sLmJvbmRzLmdldChzaWRlYm9uZHNbMF0pLmVuZCA9PSBib25kLmJlZ2luKSlcclxuXHRcdFx0bjErKztcclxuXHRcdGVsc2VcclxuXHRcdFx0bjIrKztcclxuXHR9XHJcblx0aWYgKHNpZGVib25kc1sxXSAhPSAtMSAmJiB0aGlzLl9kYm9uZHNbc2lkZWJvbmRzWzFdXS5zYXZlZCAhPSAwKVxyXG5cdHtcclxuXHRcdGlmICgodGhpcy5fZGJvbmRzW3NpZGVib25kc1sxXV0uc2F2ZWQgPT0gMiAmJiBtb2wuYm9uZHMuZ2V0KHNpZGVib25kc1sxXSkuYmVnaW4gPT0gYm9uZC5iZWdpbikgfHxcclxuXHRcdCh0aGlzLl9kYm9uZHNbc2lkZWJvbmRzWzFdXS5zYXZlZCA9PSAxICYmIG1vbC5ib25kcy5nZXQoc2lkZWJvbmRzWzFdKS5lbmQgPT0gYm9uZC5iZWdpbikpXHJcblx0XHRcdG4xKys7XHJcblx0XHRlbHNlXHJcblx0XHRcdG4yKys7XHJcblx0fVxyXG5cdGlmICh0aGlzLl9kYm9uZHNbc2lkZWJvbmRzWzJdXS5zYXZlZCAhPSAwKVxyXG5cdHtcclxuXHRcdGlmICgodGhpcy5fZGJvbmRzW3NpZGVib25kc1syXV0uc2F2ZWQgPT0gMSAmJiBtb2wuYm9uZHMuZ2V0KHNpZGVib25kc1syXSkuYmVnaW4gPT0gYm9uZC5lbmQpIHx8XHJcblx0XHQodGhpcy5fZGJvbmRzW3NpZGVib25kc1syXV0uc2F2ZWQgPT0gMiAmJiBtb2wuYm9uZHMuZ2V0KHNpZGVib25kc1syXSkuZW5kID09IGJvbmQuZW5kKSlcclxuXHRcdFx0bjMrKztcclxuXHRcdGVsc2VcclxuXHRcdFx0bjQrKztcclxuXHR9XHJcblx0aWYgKHNpZGVib25kc1szXSAhPSAtMSAmJiB0aGlzLl9kYm9uZHNbc2lkZWJvbmRzWzNdXS5zYXZlZCAhPSAwKVxyXG5cdHtcclxuXHRcdGlmICgodGhpcy5fZGJvbmRzW3NpZGVib25kc1szXV0uc2F2ZWQgPT0gMiAmJiBtb2wuYm9uZHMuZ2V0KHNpZGVib25kc1szXSkuYmVnaW4gPT0gYm9uZC5lbmQpIHx8XHJcblx0XHQodGhpcy5fZGJvbmRzW3NpZGVib25kc1szXV0uc2F2ZWQgPT0gMSAmJiBtb2wuYm9uZHMuZ2V0KHNpZGVib25kc1szXSkuZW5kID09IGJvbmQuZW5kKSlcclxuXHRcdFx0bjMrKztcclxuXHRcdGVsc2VcclxuXHRcdFx0bjQrKztcclxuXHR9XHJcblxyXG5cdGlmIChwYXJpdHkgPT0gQ2lzVHJhbnMuUEFSSVRZLkNJUylcclxuXHR7XHJcblx0XHRuMSArPSBuMztcclxuXHRcdG4yICs9IG40O1xyXG5cdH1cclxuXHRlbHNlXHJcblx0e1xyXG5cdFx0bjEgKz0gbjQ7XHJcblx0XHRuMiArPSBuMztcclxuXHR9XHJcblxyXG5cdGlmIChuMSA+IDAgJiYgbjIgPiAwKVxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdpbmNvbXBhdGlibGUgY2lzLXRyYW5zIGNvbmZpZ3VyYXRpb24nKTtcclxuXHJcblx0aWYgKG4xID09IDAgJiYgbjIgPT0gMClcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0aWYgKG4xID4gMClcclxuXHR7XHJcblx0XHR0aGlzLl9kYm9uZHNbc2lkZWJvbmRzWzBdXS5zYXZlZCA9XHJcblx0XHRcdChtb2wuYm9uZHMuZ2V0KHNpZGVib25kc1swXSkuYmVnaW4gPT0gYm9uZC5iZWdpbikgPyAxIDogMjtcclxuXHRcdGlmIChzaWRlYm9uZHNbMV0gIT0gLTEpXHJcblx0XHRcdHRoaXMuX2Rib25kc1tzaWRlYm9uZHNbMV1dLnNhdmVkID1cclxuXHRcdFx0XHQobW9sLmJvbmRzLmdldChzaWRlYm9uZHNbMV0pLmJlZ2luID09IGJvbmQuYmVnaW4pID8gMiA6IDE7XHJcblxyXG5cdFx0dGhpcy5fZGJvbmRzW3NpZGVib25kc1syXV0uc2F2ZWQgPVxyXG5cdFx0XHQoKG1vbC5ib25kcy5nZXQoc2lkZWJvbmRzWzJdKS5iZWdpbiA9PSBib25kLmVuZCkgPT0gKHBhcml0eSA9PSBDaXNUcmFucy5QQVJJVFkuQ0lTKSkgPyAxIDogMjtcclxuXHRcdGlmIChzaWRlYm9uZHNbM10gIT0gLTEpXHJcblx0XHRcdHRoaXMuX2Rib25kc1tzaWRlYm9uZHNbM11dLnNhdmVkID1cclxuXHRcdFx0XHQoKG1vbC5ib25kcy5nZXQoc2lkZWJvbmRzWzNdKS5iZWdpbiA9PSBib25kLmVuZCkgPT0gKHBhcml0eSA9PSBDaXNUcmFucy5QQVJJVFkuQ0lTKSkgPyAyIDogMTtcclxuXHR9XHJcblx0aWYgKG4yID4gMClcclxuXHR7XHJcblx0XHR0aGlzLl9kYm9uZHNbc2lkZWJvbmRzWzBdXS5zYXZlZCA9XHJcblx0XHRcdChtb2wuYm9uZHMuZ2V0KHNpZGVib25kc1swXSkuYmVnaW4gPT0gYm9uZC5iZWdpbikgPyAyIDogMTtcclxuXHRcdGlmIChzaWRlYm9uZHNbMV0gIT0gLTEpXHJcblx0XHRcdHRoaXMuX2Rib25kc1tzaWRlYm9uZHNbMV1dLnNhdmVkID1cclxuXHRcdFx0XHQobW9sLmJvbmRzLmdldChzaWRlYm9uZHNbMV0pLmJlZ2luID09IGJvbmQuYmVnaW4pID8gMSA6IDI7XHJcblxyXG5cdFx0dGhpcy5fZGJvbmRzW3NpZGVib25kc1syXV0uc2F2ZWQgPVxyXG5cdFx0XHQoKG1vbC5ib25kcy5nZXQoc2lkZWJvbmRzWzJdKS5iZWdpbiA9PSBib25kLmVuZCkgPT0gKHBhcml0eSA9PSBDaXNUcmFucy5QQVJJVFkuQ0lTKSkgPyAyIDogMTtcclxuXHRcdGlmIChzaWRlYm9uZHNbM10gIT0gLTEpXHJcblx0XHRcdHRoaXMuX2Rib25kc1tzaWRlYm9uZHNbM11dLnNhdmVkID1cclxuXHRcdFx0XHQoKG1vbC5ib25kcy5nZXQoc2lkZWJvbmRzWzNdKS5iZWdpbiA9PSBib25kLmVuZCkgPT0gKHBhcml0eSA9PSBDaXNUcmFucy5QQVJJVFkuQ0lTKSkgPyAxIDogMjtcclxuXHR9XHJcblxyXG5cdHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuU21pbGVzLnByb3RvdHlwZS5fY2FsY0JvbmREaXJlY3Rpb24gPSBmdW5jdGlvbiAobW9sLCBpZHgsIHZwcmV2KVxyXG57XHJcblx0dmFyIG50b3VjaGVkO1xyXG5cclxuXHRpZiAodGhpcy5fZGJvbmRzW2lkeF0uY3Rib25kX2JlZyA9PSAtMSAmJiB0aGlzLl9kYm9uZHNbaWR4XS5jdGJvbmRfZW5kID09IC0xKVxyXG5cdFx0cmV0dXJuIDA7XHJcblxyXG5cdGlmIChtb2wuYm9uZHMuZ2V0KGlkeCkudHlwZSAhPSBCb25kLlBBVFRFUk4uVFlQRS5TSU5HTEUpXHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2ludGVybmFsOiBkaXJlY3RlZCBib25kIHR5cGUgJyArIG1vbC5ib25kcy5nZXQoaWR4KS50eXBlKTtcclxuXHJcblx0d2hpbGUgKHRydWUpXHJcblx0e1xyXG5cdFx0bnRvdWNoZWQgPSAwO1xyXG5cdFx0dGhpcy5jaXNfdHJhbnMuZWFjaChmdW5jdGlvbiAoYmlkLCBjdClcclxuXHRcdHtcclxuXHRcdFx0aWYgKGN0LnBhcml0eSAhPSAwICYmICF0aGlzLmlzQm9uZEluUmluZyhiaWQpKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0aWYgKHRoaXMuX3VwZGF0ZVNpZGVCb25kcyhtb2wsIGJpZCkpXHJcblx0XHRcdFx0XHRudG91Y2hlZCsrO1xyXG5cdFx0XHR9XHJcblx0XHR9LCB0aGlzKTtcclxuXHRcdGlmIChudG91Y2hlZCA9PSB0aGlzLl90b3VjaGVkX2Npc3RyYW5zYm9uZHMpXHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0dGhpcy5fdG91Y2hlZF9jaXN0cmFuc2JvbmRzID0gbnRvdWNoZWQ7XHJcblx0fVxyXG5cclxuXHRpZiAodGhpcy5fZGJvbmRzW2lkeF0uc2F2ZWQgPT0gMClcclxuXHR7XHJcblx0XHRpZiAodnByZXYgPT0gbW9sLmJvbmRzLmdldChpZHgpLmJlZ2luKVxyXG5cdFx0XHR0aGlzLl9kYm9uZHNbaWR4XS5zYXZlZCA9IDE7XHJcblx0XHRlbHNlXHJcblx0XHRcdHRoaXMuX2Rib25kc1tpZHhdLnNhdmVkID0gMjtcclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzLl9kYm9uZHNbaWR4XS5zYXZlZDtcclxufTtcclxuXHJcblNtaWxlcy5wcm90b3R5cGUuX3dyaXRlUmFkaWNhbHMgPSBmdW5jdGlvbiAobW9sKVxyXG57XHJcblx0dmFyIG1hcmtlZCA9IG5ldyBBcnJheSh0aGlzLl93cml0dGVuX2F0b21zLmxlbmd0aCk7XHJcblx0dmFyIGksIGo7XHJcblxyXG5cdGZvciAoaSA9IDA7IGkgPCB0aGlzLl93cml0dGVuX2F0b21zLnNpemUoKTsgaSsrKVxyXG5cdHtcclxuXHRcdGlmIChtYXJrZWRbaV0pXHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cclxuXHRcdHZhciByYWRpY2FsID0gbW9sLmF0b21zLmdldCh0aGlzLl93cml0dGVuX2F0b21zW2ldKS5yYWRpY2FsO1xyXG5cclxuXHRcdGlmIChyYWRpY2FsID09IDApXHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cclxuXHRcdGlmICh0aGlzLmNvbW1hKVxyXG5cdFx0XHR0aGlzLnNtaWxlcyArPSAnLCc7XHJcblx0XHRlbHNlXHJcblx0XHR7XHJcblx0XHRcdHRoaXMuc21pbGVzICs9ICcgfCc7XHJcblx0XHRcdHRoaXMuY29tbWEgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChyYWRpY2FsID09IEF0b20uUEFUVEVSTi5SQURJQ0FMLlNJTkdMRVQpXHJcblx0XHRcdHRoaXMuc21pbGVzICs9ICdeMzonO1xyXG5cdFx0ZWxzZSBpZiAocmFkaWNhbCA9PSBBdG9tLlBBVFRFUk4uUkFESUNBTC5ET1VQTEVUKVxyXG5cdFx0XHR0aGlzLnNtaWxlcyArPSAnXjE6JztcclxuXHRcdGVsc2UgLy8gUkFESUNBTF9UUklQTEVUXHJcblx0XHRcdHRoaXMuc21pbGVzICs9ICdeNDonO1xyXG5cclxuXHRcdHRoaXMuc21pbGVzICs9IGk7XHJcblxyXG5cdFx0Zm9yIChqID0gaSArIDE7IGogPCB0aGlzLl93cml0dGVuX2F0b21zLmxlbmd0aDsgaisrKVxyXG5cdFx0XHRpZiAobW9sLmF0b21zLmdldCh0aGlzLl93cml0dGVuX2F0b21zW2pdKS5yYWRpY2FsID09IHJhZGljYWwpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRtYXJrZWRbal0gPSB0cnVlO1xyXG5cdFx0XHRcdHRoaXMuc21pbGVzICs9ICcsJyArIGo7XHJcblx0XHRcdH1cclxuXHR9XHJcbn07XHJcblxyXG4vKlxyXG52b2lkIFNtaWxlczo6X3dyaXRlU3RlcmVvZ3JvdXBzIChjb25zdCBTdHJ1Y3QgJm1vbCwgY29uc3QgQXJyYXk8X0F0b20+ICZhdG9tcylcclxue1xyXG4gICBNb2xlY3VsZVN0ZXJlb2NlbnRlcnMgJnN0ZXJlb2NlbnRlcnMgPSBtb2wuZ2V0U3RlcmVvY2VudGVycygpO1xyXG4gICBpbnQgaSwgajtcclxuICAgaW50IHNpbmdsZV9hbmRfZ3JvdXAgPSAtMTtcclxuXHJcbiAgIGZvciAoaSA9IHN0ZXJlb2NlbnRlcnMuYmVnaW4oKTsgaSAhPSBzdGVyZW9jZW50ZXJzLmVuZCgpOyBpID0gc3RlcmVvY2VudGVycy5uZXh0KGkpKVxyXG4gICB7XHJcbiAgICAgIGludCBpZHgsIHR5cGUsIGdyb3VwO1xyXG5cclxuICAgICAgc3RlcmVvY2VudGVycy5nZXQoaSwgaWR4LCB0eXBlLCBncm91cCwgMCk7XHJcblxyXG4gICAgICBpZiAodHlwZSA8IE1vbGVjdWxlU3RlcmVvY2VudGVyczo6QVRPTV9BTlkpXHJcbiAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICBpZiAodHlwZSAhPSBNb2xlY3VsZVN0ZXJlb2NlbnRlcnM6OkFUT01fQU5EKVxyXG4gICAgICAgICBicmVhaztcclxuICAgICAgaWYgKHNpbmdsZV9hbmRfZ3JvdXAgPT0gLTEpXHJcbiAgICAgICAgIHNpbmdsZV9hbmRfZ3JvdXAgPSBncm91cDtcclxuICAgICAgZWxzZSBpZiAoc2luZ2xlX2FuZF9ncm91cCAhPSBncm91cClcclxuICAgICAgICAgYnJlYWs7XHJcbiAgIH1cclxuXHJcbiAgIGlmIChpID09IHN0ZXJlb2NlbnRlcnMuZW5kKCkpXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgIGludCBhbmRfZ3JvdXBfaWR4ID0gMTtcclxuICAgaW50IG9yX2dyb3VwX2lkeCA9IDE7XHJcblxyXG4gICBRU19ERUYoQXJyYXk8aW50PiwgbWFya2VkKTtcclxuXHJcbiAgIG1hcmtlZC5jbGVhcl9yZXNpemUoX3dyaXR0ZW5fYXRvbXMuc2l6ZSgpKTtcclxuICAgbWFya2VkLnplcm9maWxsKCk7XHJcblxyXG4gICBmb3IgKGkgPSAwOyBpIDwgX3dyaXR0ZW5fYXRvbXMuc2l6ZSgpOyBpKyspXHJcbiAgIHtcclxuICAgICAgaWYgKG1hcmtlZFtpXSlcclxuICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICBpbnQgdHlwZSA9IHN0ZXJlb2NlbnRlcnMuZ2V0VHlwZShfd3JpdHRlbl9hdG9tc1tpXSk7XHJcblxyXG4gICAgICBpZiAodHlwZSA+IDApXHJcbiAgICAgIHtcclxuICAgICAgICAgaWYgKF9jb21tYSlcclxuICAgICAgICAgICAgX291dHB1dC53cml0ZUNoYXIoJywnKTtcclxuICAgICAgICAgZWxzZVxyXG4gICAgICAgICB7XHJcbiAgICAgICAgICAgIF9vdXRwdXQud3JpdGVTdHJpbmcoXCIgfFwiKTtcclxuICAgICAgICAgICAgX2NvbW1hID0gdHJ1ZTtcclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodHlwZSA9PSBNb2xlY3VsZVN0ZXJlb2NlbnRlcnM6OkFUT01fQU5ZKVxyXG4gICAgICB7XHJcbiAgICAgICAgIF9vdXRwdXQucHJpbnRmKFwidzolZFwiLCBpKTtcclxuXHJcbiAgICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgX3dyaXR0ZW5fYXRvbXMuc2l6ZSgpOyBqKyspXHJcbiAgICAgICAgICAgIGlmIChzdGVyZW9jZW50ZXJzLmdldFR5cGUoX3dyaXR0ZW5fYXRvbXNbal0pID09IE1vbGVjdWxlU3RlcmVvY2VudGVyczo6QVRPTV9BTlkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgbWFya2VkW2pdID0gMTtcclxuICAgICAgICAgICAgICAgX291dHB1dC5wcmludGYoXCIsJWRcIiwgaik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmICh0eXBlID09IE1vbGVjdWxlU3RlcmVvY2VudGVyczo6QVRPTV9BQlMpXHJcbiAgICAgIHtcclxuICAgICAgICAgX291dHB1dC5wcmludGYoXCJhOiVkXCIsIGkpO1xyXG5cclxuICAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBfd3JpdHRlbl9hdG9tcy5zaXplKCk7IGorKylcclxuICAgICAgICAgICAgaWYgKHN0ZXJlb2NlbnRlcnMuZ2V0VHlwZShfd3JpdHRlbl9hdG9tc1tqXSkgPT0gTW9sZWN1bGVTdGVyZW9jZW50ZXJzOjpBVE9NX0FCUylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICBtYXJrZWRbal0gPSAxO1xyXG4gICAgICAgICAgICAgICBfb3V0cHV0LnByaW50ZihcIiwlZFwiLCBqKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKHR5cGUgPT0gTW9sZWN1bGVTdGVyZW9jZW50ZXJzOjpBVE9NX0FORClcclxuICAgICAge1xyXG4gICAgICAgICBpbnQgZ3JvdXAgPSBzdGVyZW9jZW50ZXJzLmdldEdyb3VwKF93cml0dGVuX2F0b21zW2ldKTtcclxuXHJcbiAgICAgICAgIF9vdXRwdXQucHJpbnRmKFwiJiVkOiVkXCIsIGFuZF9ncm91cF9pZHgrKywgaSk7XHJcbiAgICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgX3dyaXR0ZW5fYXRvbXMuc2l6ZSgpOyBqKyspXHJcbiAgICAgICAgICAgIGlmIChzdGVyZW9jZW50ZXJzLmdldFR5cGUoX3dyaXR0ZW5fYXRvbXNbal0pID09IE1vbGVjdWxlU3RlcmVvY2VudGVyczo6QVRPTV9BTkQgJiZcclxuICAgICAgICAgICAgICAgIHN0ZXJlb2NlbnRlcnMuZ2V0R3JvdXAoX3dyaXR0ZW5fYXRvbXNbal0pID09IGdyb3VwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgIG1hcmtlZFtqXSA9IDE7XHJcbiAgICAgICAgICAgICAgIF9vdXRwdXQucHJpbnRmKFwiLCVkXCIsIGopO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAodHlwZSA9PSBNb2xlY3VsZVN0ZXJlb2NlbnRlcnM6OkFUT01fT1IpXHJcbiAgICAgIHtcclxuICAgICAgICAgaW50IGdyb3VwID0gc3RlcmVvY2VudGVycy5nZXRHcm91cChfd3JpdHRlbl9hdG9tc1tpXSk7XHJcblxyXG4gICAgICAgICBfb3V0cHV0LnByaW50ZihcIm8lZDolZFwiLCBvcl9ncm91cF9pZHgrKywgaSk7XHJcbiAgICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgX3dyaXR0ZW5fYXRvbXMuc2l6ZSgpOyBqKyspXHJcbiAgICAgICAgICAgIGlmIChzdGVyZW9jZW50ZXJzLmdldFR5cGUoX3dyaXR0ZW5fYXRvbXNbal0pID09IE1vbGVjdWxlU3RlcmVvY2VudGVyczo6QVRPTV9PUiAmJlxyXG4gICAgICAgICAgICAgICAgc3RlcmVvY2VudGVycy5nZXRHcm91cChfd3JpdHRlbl9hdG9tc1tqXSkgPT0gZ3JvdXApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgbWFya2VkW2pdID0gMTtcclxuICAgICAgICAgICAgICAgX291dHB1dC5wcmludGYoXCIsJWRcIiwgaik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICB9XHJcbn1cclxuKi9cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cdHN0cmluZ2lmeTogZnVuY3Rpb24gKG1vbGVjdWxlLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgb3B0cyA9IG9wdGlvbnMgfHwge307XHJcblx0XHRyZXR1cm4gbmV3IFNtaWxlcygpLnNhdmVNb2xlY3VsZShtb2xlY3VsZSwgb3B0cy5pZ25vcmVFcnJvcnMpO1xyXG5cdH1cclxufTtcclxuIiwidmFyIE1hcCA9IHJlcXVpcmUoJy4uL3V0aWwvbWFwJyk7XHJcbnZhciBTZXQgPSByZXF1aXJlKCcuLi91dGlsL3NldCcpO1xyXG52YXIgVmVjMiA9IHJlcXVpcmUoJy4uL3V0aWwvdmVjMicpO1xyXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcclxudmFyIEJvbmQgPSByZXF1aXJlKCcuL2JvbmQnKTtcclxuXHJcbnZhciBTdGVyZW9jZW50ZXJzID0gZnVuY3Rpb24gKG1vbCwgbmVpZ2hib3JzX2Z1bmMsIGNvbnRleHQpXHJcbntcclxuXHR0aGlzLm1vbGVjdWxlID0gbW9sO1xyXG5cdHRoaXMuYXRvbXMgPSBuZXcgTWFwKCk7XHJcblx0dGhpcy5nZXROZWlnaGJvcnMgPSBuZWlnaGJvcnNfZnVuYztcclxuXHR0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG59O1xyXG5cclxuU3RlcmVvY2VudGVycy5wcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uIChmdW5jLCBjb250ZXh0KVxyXG57XHJcblx0dGhpcy5hdG9tcy5lYWNoKGZ1bmMsIGNvbnRleHQpO1xyXG59O1xyXG5cclxuU3RlcmVvY2VudGVycy5wcm90b3R5cGUuYnVpbGRGcm9tQm9uZHMgPSBmdW5jdGlvbiAoLypjb25zdCBpbnQgKmF0b21fdHlwZXMsIGNvbnN0IGludCAqYXRvbV9ncm91cHMsIGNvbnN0IGludCAqYm9uZF9vcmllbnRhdGlvbnMsICovaWdub3JlX2Vycm9ycylcclxue1xyXG5cdHZhciBhdG9tcyA9IHRoaXMubW9sZWN1bGUuYXRvbXM7XHJcblx0dmFyIGJvbmRzID0gdGhpcy5tb2xlY3VsZS5ib25kcztcclxuXHJcblx0Ly8gdGhpcyBpcyBhIHNldCBvZiBhdG9tcyB0aGF0IGFyZSBsaWtlbHkgdG8gYmVsb25nIHRvIGFsbGVuZSBzdHJ1Y3R1cmVzIGFuZFxyXG5cdC8vICB0aGVyZWZvcmUgc2hvdWxkIG5vdCBiZSBjb25zaWRlcmVkIGFzIHBvdGVudGlhbCBzdGVyZW9jZW50ZXJzIGluIHRoZSBjb2RlIGJlbG93LFxyXG5cdC8vICBhcyBhbGxlbmVzIGNhbm5vdCBiZSBlbmNvZGVkIGluIHRoZSBTTUlMRVMgbm90YXRpb25cclxuXHR2YXIgYWxsZW5lTWFzayA9IFNldC5lbXB0eSgpO1xyXG5cdGF0b21zLmVhY2goZnVuY3Rpb24gKGFpZCwgYXRvbSkge1xyXG5cdFx0dmFyIG5laV9saXN0ID0gdGhpcy5nZXROZWlnaGJvcnMuY2FsbCh0aGlzLmNvbnRleHQsIGFpZCk7XHJcblx0XHRpZiAobmVpX2xpc3QubGVuZ3RoICE9IDIpXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdHZhciBuZWkxID0gbmVpX2xpc3RbMF07XHJcblx0XHR2YXIgbmVpMiA9IG5laV9saXN0WzFdO1xyXG5cdFx0Ly8gY2hlY2sgYXRvbSBsYWJlbHNcclxuXHRcdGlmICh1dGlsLmZpbmRJbmRleChbYWlkLCBuZWkxLmFpZCwgbmVpMi5haWRdLCBmdW5jdGlvbiAoYWlkKSB7XHJcblx0XHRcdHJldHVybiBbJ0MnLCAnU2knXS5pbmRleE9mKGF0b21zLmdldChhaWQpLmxhYmVsKSA8IDA7XHJcblx0XHR9LCB0aGlzKSA+PSAwKVxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0Ly8gY2hlY2sgYWRqYWNlbnQgYm9uZCB0eXBlc1xyXG5cdFx0aWYgKHV0aWwuZmluZEluZGV4KFtuZWkxLmJpZCwgbmVpMi5iaWRdLCBmdW5jdGlvbiAoYmlkKSB7XHJcblx0XHRcdHJldHVybiBib25kcy5nZXQoYmlkKS50eXBlICE9IEJvbmQuUEFUVEVSTi5UWVBFLkRPVUJMRTtcclxuXHRcdH0sIHRoaXMpID49IDApXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHQvLyBnZXQgdGhlIG90aGVyIG5laWdoYm9ycyBvZiB0aGUgdHdvIGFkamFjZW50IGF0b21zIGV4Y2VwdCBmb3IgdGhlIGNlbnRyYWwgYXRvbVxyXG5cdFx0dmFyIG5laTFuZWkgPSB1dGlsLmZpbmRBbGwodGhpcy5nZXROZWlnaGJvcnMuY2FsbCh0aGlzLmNvbnRleHQsIG5laTEuYWlkKSwgZnVuY3Rpb24gKG5laSkge1xyXG5cdFx0XHRyZXR1cm4gbmVpLmFpZCAhPSBhaWQ7XHJcblx0XHR9LCB0aGlzKTtcclxuXHRcdHZhciBuZWkybmVpID0gdXRpbC5maW5kQWxsKHRoaXMuZ2V0TmVpZ2hib3JzLmNhbGwodGhpcy5jb250ZXh0LCBuZWkyLmFpZCksIGZ1bmN0aW9uIChuZWkpIHtcclxuXHRcdFx0cmV0dXJuIG5laS5haWQgIT0gYWlkO1xyXG5cdFx0fSwgdGhpcyk7XHJcblx0XHRpZiAobmVpMW5laS5sZW5ndGggPCAxIHx8IG5laTFuZWkubGVuZ3RoID4gMiB8fCBuZWkybmVpLmxlbmd0aCA8IDEgfHwgbmVpMm5laS5sZW5ndGggPiAyKVxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0aWYgKHV0aWwuZmluZEluZGV4KG5laTFuZWkuY29uY2F0KG5laTJuZWkpLCBmdW5jdGlvbiAobmVpKSB7XHJcblx0XHRcdHJldHVybiBib25kcy5nZXQobmVpLmJpZCkudHlwZSAhPSBCb25kLlBBVFRFUk4uVFlQRS5TSU5HTEU7XHJcblx0XHR9LCB0aGlzKSA+PSAwKVxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0aWYgKHV0aWwuZmluZEluZGV4KG5laTFuZWkuY29uY2F0KG5laTJuZWkpLCBmdW5jdGlvbiAobmVpKSB7XHJcblx0XHRcdHJldHVybiBib25kcy5nZXQobmVpLmJpZCkuc3RlcmVvID09IEJvbmQuUEFUVEVSTi5TVEVSRU8uRUlUSEVSO1xyXG5cdFx0fSwgdGhpcykgPj0gMClcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0U2V0LmFkZChhbGxlbmVNYXNrLCBuZWkxLmFpZCk7XHJcblx0XHRTZXQuYWRkKGFsbGVuZU1hc2ssIG5laTIuYWlkKTtcclxuXHR9LCB0aGlzKTtcclxuXHJcblx0aWYgKFNldC5zaXplKGFsbGVuZU1hc2spID4gMClcclxuXHRcdGFsZXJ0KCdUaGlzIHN0cnVjdHVyZSBtYXkgY29udGFpbiBhbGxlbmVzLCB3aGljaCBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgaW4gdGhlIFNNSUxFUyBub3RhdGlvbi4gUmVsZXZhbnQgc3RlcmVvLWluZm9ybWF0aW9uIHdpbGwgYmUgZGlzY2FyZGVkLicpO1xyXG5cclxuXHRhdG9tcy5lYWNoKGZ1bmN0aW9uIChhaWQpXHJcblx0e1xyXG5cdFx0aWYgKFNldC5jb250YWlucyhhbGxlbmVNYXNrLCBhaWQpKVxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHQvKlxyXG4gICAgICBpZiAoYXRvbV90eXBlc1thdG9tX2lkeF0gPT0gMClcclxuICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICovXHJcblx0XHR2YXIgbmVpX2xpc3QgPSB0aGlzLmdldE5laWdoYm9ycy5jYWxsKHRoaXMuY29udGV4dCwgYWlkKTtcclxuXHRcdHZhciBzdGVyZW9jZW50ZXIgPSBmYWxzZTtcclxuXHJcblx0XHRuZWlfbGlzdC5maW5kKGZ1bmN0aW9uIChuZWkpXHJcblx0XHR7XHJcblx0XHRcdHZhciBib25kID0gdGhpcy5tb2xlY3VsZS5ib25kcy5nZXQobmVpLmJpZCk7XHJcblxyXG5cdFx0XHRpZiAoYm9uZC50eXBlID09IEJvbmQuUEFUVEVSTi5UWVBFLlNJTkdMRSAmJiBib25kLmJlZ2luID09IGFpZClcclxuXHRcdFx0aWYgKGJvbmQuc3RlcmVvID09IEJvbmQuUEFUVEVSTi5TVEVSRU8uVVAgfHwgYm9uZC5zdGVyZW8gPT0gQm9uZC5QQVRURVJOLlNURVJFTy5ET1dOKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0c3RlcmVvY2VudGVyID0gdHJ1ZTtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHRpZiAoIXN0ZXJlb2NlbnRlcilcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdGlmIChpZ25vcmVfZXJyb3JzKVxyXG5cdFx0e1xyXG4vLyAgICAgICAgIHRyeVxyXG4vLyAgICAgICAgIHtcclxuXHRcdFx0dGhpcy5fYnVpbGRPbmVDZW50ZXIoYWlkLyosIGF0b21fZ3JvdXBzW2F0b21faWR4XSwgYXRvbV90eXBlc1thdG9tX2lkeF0sIGJvbmRfb3JpZW50YXRpb25zKi8pO1xyXG4vLyAgICAgICAgIH1cclxuLy8gICAgICAgICBjYXRjaCAoZXIpXHJcbi8vICAgICAgICAge1xyXG4vLyAgICAgICAgIH1cclxuXHRcdH1cclxuXHRcdGVsc2VcclxuXHRcdFx0dGhpcy5fYnVpbGRPbmVDZW50ZXIoYWlkLyosIGF0b21fZ3JvdXBzW2F0b21faWR4XSwgYXRvbV90eXBlc1thdG9tX2lkeF0sIGJvbmRfb3JpZW50YXRpb25zKi8pO1xyXG5cdH0sIHRoaXMpO1xyXG59O1xyXG5cclxuU3RlcmVvY2VudGVycy5hbGxvd2VkX3N0ZXJlb2NlbnRlcnMgPVxyXG5cdFtcclxuXHR7ZWxlbTogJ0MnLCAgY2hhcmdlOiAwLCBkZWdyZWU6IDMsIG5fZG91YmxlX2JvbmRzOiAwLCBpbXBsaWNpdF9kZWdyZWU6IDR9LFxyXG5cdHtlbGVtOiAnQycsICBjaGFyZ2U6IDAsIGRlZ3JlZTogNCwgbl9kb3VibGVfYm9uZHM6IDAsIGltcGxpY2l0X2RlZ3JlZTogNH0sXHJcblx0e2VsZW06ICdTaScsIGNoYXJnZTogMCwgZGVncmVlOiAzLCBuX2RvdWJsZV9ib25kczogMCwgaW1wbGljaXRfZGVncmVlOiA0fSxcclxuXHR7ZWxlbTogJ1NpJywgY2hhcmdlOiAwLCBkZWdyZWU6IDQsIG5fZG91YmxlX2JvbmRzOiAwLCBpbXBsaWNpdF9kZWdyZWU6IDR9LFxyXG5cdHtlbGVtOiAnTicsICBjaGFyZ2U6IDEsIGRlZ3JlZTogMywgbl9kb3VibGVfYm9uZHM6IDAsIGltcGxpY2l0X2RlZ3JlZTogNH0sXHJcblx0e2VsZW06ICdOJywgIGNoYXJnZTogMSwgZGVncmVlOiA0LCBuX2RvdWJsZV9ib25kczogMCwgaW1wbGljaXRfZGVncmVlOiA0fSxcclxuXHR7ZWxlbTogJ04nLCAgY2hhcmdlOiAwLCBkZWdyZWU6IDMsIG5fZG91YmxlX2JvbmRzOiAwLCBpbXBsaWNpdF9kZWdyZWU6IDN9LFxyXG5cdHtlbGVtOiAnUycsICBjaGFyZ2U6IDAsIGRlZ3JlZTogNCwgbl9kb3VibGVfYm9uZHM6IDIsIGltcGxpY2l0X2RlZ3JlZTogNH0sXHJcblx0e2VsZW06ICdTJywgIGNoYXJnZTogMSwgZGVncmVlOiAzLCBuX2RvdWJsZV9ib25kczogMCwgaW1wbGljaXRfZGVncmVlOiAzfSxcclxuXHR7ZWxlbTogJ1MnLCAgY2hhcmdlOiAwLCBkZWdyZWU6IDMsIG5fZG91YmxlX2JvbmRzOiAxLCBpbXBsaWNpdF9kZWdyZWU6IDN9LFxyXG5cdHtlbGVtOiAnUCcsICBjaGFyZ2U6IDAsIGRlZ3JlZTogMywgbl9kb3VibGVfYm9uZHM6IDAsIGltcGxpY2l0X2RlZ3JlZTogM30sXHJcblx0e2VsZW06ICdQJywgIGNoYXJnZTogMSwgZGVncmVlOiA0LCBuX2RvdWJsZV9ib25kczogMCwgaW1wbGljaXRfZGVncmVlOiA0fSxcclxuXHR7ZWxlbTogJ1AnLCAgY2hhcmdlOiAwLCBkZWdyZWU6IDQsIG5fZG91YmxlX2JvbmRzOiAxLCBpbXBsaWNpdF9kZWdyZWU6IDR9XHJcblx0XTtcclxuXHJcblxyXG5TdGVyZW9jZW50ZXJzLnByb3RvdHlwZS5fYnVpbGRPbmVDZW50ZXIgPSBmdW5jdGlvbiAoYXRvbV9pZHgvKiwgaW50IGdyb3VwLCBpbnQgdHlwZSwgY29uc3QgaW50ICpib25kX29yaWVudGF0aW9ucyovKVxyXG57XHJcblx0dmFyIGF0b20gPSB0aGlzLm1vbGVjdWxlLmF0b21zLmdldChhdG9tX2lkeCk7XHJcblxyXG5cdHZhciBuZWlfbGlzdCA9IHRoaXMuZ2V0TmVpZ2hib3JzLmNhbGwodGhpcy5jb250ZXh0LCBhdG9tX2lkeCk7XHJcblx0dmFyIGRlZ3JlZSA9IG5laV9saXN0Lmxlbmd0aDtcclxuXHR2YXIgaW1wbGljaXRfZGVncmVlID0gLTE7XHJcblxyXG5cdHZhciBzdGVyZW9jZW50ZXIgPVxyXG5cdHtcclxuXHRcdGdyb3VwOiAwLCAvLyA9IGdyb3VwO1xyXG5cdFx0dHlwZTogMCwgLy8gPSB0eXBlO1xyXG5cdFx0cHlyYW1pZDogbmV3IEFycmF5KDQpXHJcblx0fTtcclxuXHJcblx0dmFyIG5laV9pZHggPSAwO1xyXG5cdHZhciBlZGdlX2lkcyA9IG5ldyBBcnJheSg0KTtcclxuXHJcblx0dmFyIGxhc3RfYXRvbV9kaXIgPSAwO1xyXG5cdHZhciBuX2RvdWJsZV9ib25kcyA9IDA7XHJcblxyXG5cdHN0ZXJlb2NlbnRlci5weXJhbWlkWzBdID0gLTE7XHJcblx0c3RlcmVvY2VudGVyLnB5cmFtaWRbMV0gPSAtMTtcclxuXHRzdGVyZW9jZW50ZXIucHlyYW1pZFsyXSA9IC0xO1xyXG5cdHN0ZXJlb2NlbnRlci5weXJhbWlkWzNdID0gLTE7XHJcblxyXG5cdHZhciBuX3B1cmVfaHlkcm9nZW5zID0gMDtcclxuXHJcblx0aWYgKGRlZ3JlZSA+IDQpXHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ3N0ZXJlb2NlbnRlciB3aXRoICVkIGJvbmRzIGFyZSBub3Qgc3VwcG9ydGVkJyArIGRlZ3JlZSk7XHJcblxyXG5cdG5laV9saXN0LmVhY2goZnVuY3Rpb24gKG5laSlcclxuXHR7XHJcblx0XHR2YXIgbmVpX2F0b20gPSB0aGlzLm1vbGVjdWxlLmF0b21zLmdldChuZWkuYWlkKTtcclxuXHRcdHZhciBib25kID0gdGhpcy5tb2xlY3VsZS5ib25kcy5nZXQobmVpLmJpZCk7XHJcblxyXG5cdFx0ZWRnZV9pZHNbbmVpX2lkeF0gPVxyXG5cdFx0e1xyXG5cdFx0XHRlZGdlX2lkeDogbmVpLmJpZCxcclxuXHRcdFx0bmVpX2lkeDogbmVpLmFpZCxcclxuXHRcdFx0cmFuazogbmVpLmFpZCxcclxuXHRcdFx0dmVjOiBWZWMyLmRpZmYobmVpX2F0b20ucHAsIGF0b20ucHApLnlDb21wbGVtZW50KClcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKG5laV9hdG9tLnB1cmVIeWRyb2dlbigpKVxyXG5cdFx0e1xyXG5cdFx0XHRuX3B1cmVfaHlkcm9nZW5zKys7XHJcblx0XHRcdGVkZ2VfaWRzW25laV9pZHhdLnJhbmsgPSAxMDAwMDtcclxuXHRcdH0gZWxzZSBpZiAobmVpX2F0b20ubGFiZWwgPT0gJ0gnKVxyXG5cdFx0XHRlZGdlX2lkc1tuZWlfaWR4XS5yYW5rID0gNTAwMDtcclxuXHJcblx0XHRpZiAoIWVkZ2VfaWRzW25laV9pZHhdLnZlYy5ub3JtYWxpemUoKSlcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCd6ZXJvIGJvbmQgbGVuZ3RoJyk7XHJcblxyXG5cdFx0aWYgKGJvbmQudHlwZSA9PSBCb25kLlBBVFRFUk4uVFlQRS5UUklQTEUpXHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignbm9uLXNpbmdsZSBib25kcyBub3QgYWxsb3dlZCBuZWFyIHN0ZXJlb2NlbnRlcicpO1xyXG5cdFx0ZWxzZSBpZiAoYm9uZC50eXBlID09IEJvbmQuUEFUVEVSTi5UWVBFLkFST01BVElDKVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2Fyb21hdGljIGJvbmRzIG5vdCBhbGxvd2VkIG5lYXIgc3RlcmVvY2VudGVyJyk7XHJcblx0XHRlbHNlIGlmIChib25kLnR5cGUgPT0gQm9uZC5QQVRURVJOLlRZUEUuRE9VQkxFKVxyXG5cdFx0XHRuX2RvdWJsZV9ib25kcysrO1xyXG5cclxuXHRcdG5laV9pZHgrKztcclxuXHR9LCB0aGlzKTtcclxuXHJcblx0U3RlcmVvY2VudGVycy5hbGxvd2VkX3N0ZXJlb2NlbnRlcnMuZmluZChmdW5jdGlvbiAoYXMpXHJcblx0e1xyXG5cdFx0aWYgKGFzLmVsZW0gPT0gYXRvbS5sYWJlbCAmJiBhcy5jaGFyZ2UgPT0gYXRvbS5jaGFyZ2UgJiZcclxuXHRcdGFzLmRlZ3JlZSA9PSBkZWdyZWUgJiYgYXMubl9kb3VibGVfYm9uZHMgPT0gbl9kb3VibGVfYm9uZHMpXHJcblx0XHR7XHJcblx0XHRcdGltcGxpY2l0X2RlZ3JlZSA9IGFzLmltcGxpY2l0X2RlZ3JlZTtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fSwgdGhpcyk7XHJcblxyXG5cdGlmIChpbXBsaWNpdF9kZWdyZWUgPT0gLTEpXHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gc3RlcmVvY2VudGVyIGNvbmZpZ3VyYXRpb246ICcgKyBhdG9tLmxhYmVsICsgJywgY2hhcmdlICcgKyBhdG9tLmNoYXJnZSArICcsICcgKyBkZWdyZWUgKyAnIGJvbmRzICgnICsgbl9kb3VibGVfYm9uZHMgKyAnIGRvdWJsZSknKTtcclxuXHJcblx0aWYgKGRlZ3JlZSA9PSA0ICYmIG5fcHVyZV9oeWRyb2dlbnMgPiAxKVxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKG5fcHVyZV9oeWRyb2dlbnMgKyAnIGh5ZHJvZ2VucyBuZWFyIHN0ZXJlb2NlbnRlcicpO1xyXG5cclxuXHRpZiAoZGVncmVlID09IDMgJiYgaW1wbGljaXRfZGVncmVlID09IDQgJiYgbl9wdXJlX2h5ZHJvZ2VucyA+IDApXHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2hhdmUgaHlkcm9nZW4ocykgYmVzaWRlcyBpbXBsaWNpdCBoeWRyb2dlbiBuZWFyIHN0ZXJlb2NlbnRlcicpO1xyXG5cclxuXHQvKlxyXG4gICBpZiAoc3RlcmVvY2VudGVyLnR5cGUgPT0gQVRPTV9BTlkpXHJcbiAgIHtcclxuICAgICAgX3N0ZXJlb2NlbnRlcnMuaW5zZXJ0KGF0b21faWR4LCBzdGVyZW9jZW50ZXIpO1xyXG4gICAgICByZXR1cm47XHJcbiAgIH1cclxuICAgKi9cclxuXHJcblx0aWYgKGRlZ3JlZSA9PSA0KVxyXG5cdHtcclxuXHRcdC8vIHNvcnQgYnkgbmVpZ2hib3IgYXRvbSBpbmRleCAoYXNjZW5kaW5nKVxyXG5cdFx0aWYgKGVkZ2VfaWRzWzBdLnJhbmsgPiBlZGdlX2lkc1sxXS5yYW5rKVxyXG5cdFx0XHRlZGdlX2lkcy5zd2FwKDAsIDEpO1xyXG5cdFx0aWYgKGVkZ2VfaWRzWzFdLnJhbmsgPiBlZGdlX2lkc1syXS5yYW5rKVxyXG5cdFx0XHRlZGdlX2lkcy5zd2FwKDEsIDIpO1xyXG5cdFx0aWYgKGVkZ2VfaWRzWzJdLnJhbmsgPiBlZGdlX2lkc1szXS5yYW5rKVxyXG5cdFx0XHRlZGdlX2lkcy5zd2FwKDIsIDMpO1xyXG5cdFx0aWYgKGVkZ2VfaWRzWzFdLnJhbmsgPiBlZGdlX2lkc1syXS5yYW5rKVxyXG5cdFx0XHRlZGdlX2lkcy5zd2FwKDEsIDIpO1xyXG5cdFx0aWYgKGVkZ2VfaWRzWzBdLnJhbmsgPiBlZGdlX2lkc1sxXS5yYW5rKVxyXG5cdFx0XHRlZGdlX2lkcy5zd2FwKDAsIDEpO1xyXG5cdFx0aWYgKGVkZ2VfaWRzWzFdLnJhbmsgPiBlZGdlX2lkc1syXS5yYW5rKVxyXG5cdFx0XHRlZGdlX2lkcy5zd2FwKDEsIDIpO1xyXG5cclxuXHRcdHZhciBtYWluMSA9IC0xLCBtYWluMiA9IC0xLCBzaWRlMSA9IC0xLCBzaWRlMiA9IC0xO1xyXG5cdFx0dmFyIG1haW5fZGlyID0gMDtcclxuXHJcblx0XHRmb3IgKG5laV9pZHggPSAwOyBuZWlfaWR4IDwgNDsgbmVpX2lkeCsrKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgc3RlcmVvID0gdGhpcy5fZ2V0Qm9uZFN0ZXJlbyhhdG9tX2lkeCwgZWRnZV9pZHNbbmVpX2lkeF0uZWRnZV9pZHgpO1xyXG5cclxuXHRcdFx0aWYgKHN0ZXJlbyA9PSBCb25kLlBBVFRFUk4uU1RFUkVPLlVQIHx8IHN0ZXJlbyA9PSBCb25kLlBBVFRFUk4uU1RFUkVPLkRPV04pXHJcblx0XHRcdHtcclxuXHRcdFx0XHRtYWluMSA9IG5laV9pZHg7XHJcblx0XHRcdFx0bWFpbl9kaXIgPSBzdGVyZW87XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAobWFpbjEgPT0gLTEpXHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignbm9uZSBvZiA0IGJvbmRzIGdvaW5nIGZyb20gc3RlcmVvY2VudGVyIGlzIHN0ZXJlb2JvbmQnKTtcclxuXHJcblx0XHR2YXIgeHl6MSwgeHl6MjtcclxuXHJcblx0XHQvLyBmaW5kIG1haW4yIGFzIG9wcG9zaXRlIHRvIG1haW4xXHJcblx0XHRpZiAobWFpbjIgPT0gLTEpXHJcblx0XHR7XHJcblx0XHRcdHh5ejEgPSBTdGVyZW9jZW50ZXJzLl94eXp6eShlZGdlX2lkc1ttYWluMV0udmVjLCBlZGdlX2lkc1sobWFpbjEgKyAxKSAlIDRdLnZlYywgZWRnZV9pZHNbKG1haW4xICsgMikgJSA0XS52ZWMpO1xyXG5cdFx0XHR4eXoyID0gU3RlcmVvY2VudGVycy5feHl6enkoZWRnZV9pZHNbbWFpbjFdLnZlYywgZWRnZV9pZHNbKG1haW4xICsgMSkgJSA0XS52ZWMsIGVkZ2VfaWRzWyhtYWluMSArIDMpICUgNF0udmVjKTtcclxuXHJcblx0XHRcdGlmICh4eXoxICsgeHl6MiA9PSAzIHx8IHh5ejEgKyB4eXoyID09IDEyKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0bWFpbjIgPSAobWFpbjEgKyAxKSAlIDQ7XHJcblx0XHRcdFx0c2lkZTEgPSAobWFpbjEgKyAyKSAlIDQ7XHJcblx0XHRcdFx0c2lkZTIgPSAobWFpbjEgKyAzKSAlIDQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGlmIChtYWluMiA9PSAtMSlcclxuXHRcdHtcclxuXHRcdFx0eHl6MSA9IFN0ZXJlb2NlbnRlcnMuX3h5enp5KGVkZ2VfaWRzW21haW4xXS52ZWMsIGVkZ2VfaWRzWyhtYWluMSArIDIpICUgNF0udmVjLCBlZGdlX2lkc1sobWFpbjEgKyAxKSAlIDRdLnZlYyk7XHJcblx0XHRcdHh5ejIgPSBTdGVyZW9jZW50ZXJzLl94eXp6eShlZGdlX2lkc1ttYWluMV0udmVjLCBlZGdlX2lkc1sobWFpbjEgKyAyKSAlIDRdLnZlYywgZWRnZV9pZHNbKG1haW4xICsgMykgJSA0XS52ZWMpO1xyXG5cclxuXHRcdFx0aWYgKHh5ejEgKyB4eXoyID09IDMgfHwgeHl6MSArIHh5ejIgPT0gMTIpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRtYWluMiA9IChtYWluMSArIDIpICUgNDtcclxuXHRcdFx0XHRzaWRlMSA9IChtYWluMSArIDEpICUgNDtcclxuXHRcdFx0XHRzaWRlMiA9IChtYWluMSArIDMpICUgNDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKG1haW4yID09IC0xKVxyXG5cdFx0e1xyXG5cdFx0XHR4eXoxID0gU3RlcmVvY2VudGVycy5feHl6enkoZWRnZV9pZHNbbWFpbjFdLnZlYywgZWRnZV9pZHNbKG1haW4xICsgMykgJSA0XS52ZWMsIGVkZ2VfaWRzWyhtYWluMSArIDEpICUgNF0udmVjKTtcclxuXHRcdFx0eHl6MiA9IFN0ZXJlb2NlbnRlcnMuX3h5enp5KGVkZ2VfaWRzW21haW4xXS52ZWMsIGVkZ2VfaWRzWyhtYWluMSArIDMpICUgNF0udmVjLCBlZGdlX2lkc1sobWFpbjEgKyAyKSAlIDRdLnZlYyk7XHJcblxyXG5cdFx0XHRpZiAoeHl6MSArIHh5ejIgPT0gMyB8fCB4eXoxICsgeHl6MiA9PSAxMilcclxuXHRcdFx0e1xyXG5cdFx0XHRcdG1haW4yID0gKG1haW4xICsgMykgJSA0O1xyXG5cdFx0XHRcdHNpZGUxID0gKG1haW4xICsgMikgJSA0O1xyXG5cdFx0XHRcdHNpZGUyID0gKG1haW4xICsgMSkgJSA0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG1haW4yID09IC0xKVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2ludGVybmFsIGVycm9yOiBjYW4gbm90IGZpbmQgb3Bwb3NpdGUgYm9uZCcpO1xyXG5cclxuXHRcdGlmIChtYWluX2RpciA9PSBCb25kLlBBVFRFUk4uU1RFUkVPLlVQICYmIHRoaXMuX2dldEJvbmRTdGVyZW8oYXRvbV9pZHgsIGVkZ2VfaWRzW21haW4yXS5lZGdlX2lkeCkgPT0gQm9uZC5QQVRURVJOLlNURVJFTy5ET1dOKVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ3N0ZXJlbyB0eXBlcyBvZiB0aGUgb3Bwb3NpdGUgYm9uZHMgbWlzbWF0Y2gnKTtcclxuXHRcdGlmIChtYWluX2RpciA9PSBCb25kLlBBVFRFUk4uU1RFUkVPLkRPV04gJiYgdGhpcy5fZ2V0Qm9uZFN0ZXJlbyhhdG9tX2lkeCwgZWRnZV9pZHNbbWFpbjJdLmVkZ2VfaWR4KSA9PSBCb25kLlBBVFRFUk4uU1RFUkVPLlVQKVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ3N0ZXJlbyB0eXBlcyBvZiB0aGUgb3Bwb3NpdGUgYm9uZHMgbWlzbWF0Y2gnKTtcclxuXHJcblx0XHRpZiAobWFpbl9kaXIgPT0gdGhpcy5fZ2V0Qm9uZFN0ZXJlbyhhdG9tX2lkeCwgZWRnZV9pZHNbc2lkZTFdLmVkZ2VfaWR4KSlcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdzdGVyZW8gdHlwZXMgb2Ygbm9uLW9wcG9zaXRlIGJvbmRzIG1hdGNoJyk7XHJcblx0XHRpZiAobWFpbl9kaXIgPT0gdGhpcy5fZ2V0Qm9uZFN0ZXJlbyhhdG9tX2lkeCwgZWRnZV9pZHNbc2lkZTJdLmVkZ2VfaWR4KSlcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdzdGVyZW8gdHlwZXMgb2Ygbm9uLW9wcG9zaXRlIGJvbmRzIG1hdGNoJyk7XHJcblxyXG5cdFx0aWYgKG1haW4xID09IDMgfHwgbWFpbjIgPT0gMylcclxuXHRcdFx0bGFzdF9hdG9tX2RpciA9IG1haW5fZGlyO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRsYXN0X2F0b21fZGlyID0gKG1haW5fZGlyID09IEJvbmQuUEFUVEVSTi5TVEVSRU8uVVAgPyBCb25kLlBBVFRFUk4uU1RFUkVPLkRPV04gOiBCb25kLlBBVFRFUk4uU1RFUkVPLlVQKTtcclxuXHJcblx0XHRzaWduID0gU3RlcmVvY2VudGVycy5fc2lnbihlZGdlX2lkc1swXS52ZWMsIGVkZ2VfaWRzWzFdLnZlYywgZWRnZV9pZHNbMl0udmVjKTtcclxuXHJcblx0XHRpZiAoKGxhc3RfYXRvbV9kaXIgPT0gQm9uZC5QQVRURVJOLlNURVJFTy5VUCAmJiBzaWduID4gMCkgfHxcclxuXHRcdChsYXN0X2F0b21fZGlyID09IEJvbmQuUEFUVEVSTi5TVEVSRU8uRE9XTiAmJiBzaWduIDwgMCkpXHJcblx0XHR7XHJcblx0XHRcdHN0ZXJlb2NlbnRlci5weXJhbWlkWzBdID0gZWRnZV9pZHNbMF0ubmVpX2lkeDtcclxuXHRcdFx0c3RlcmVvY2VudGVyLnB5cmFtaWRbMV0gPSBlZGdlX2lkc1sxXS5uZWlfaWR4O1xyXG5cdFx0XHRzdGVyZW9jZW50ZXIucHlyYW1pZFsyXSA9IGVkZ2VfaWRzWzJdLm5laV9pZHg7XHJcblx0XHR9XHJcblx0XHRlbHNlXHJcblx0XHR7XHJcblx0XHRcdHN0ZXJlb2NlbnRlci5weXJhbWlkWzBdID0gZWRnZV9pZHNbMF0ubmVpX2lkeDtcclxuXHRcdFx0c3RlcmVvY2VudGVyLnB5cmFtaWRbMV0gPSBlZGdlX2lkc1syXS5uZWlfaWR4O1xyXG5cdFx0XHRzdGVyZW9jZW50ZXIucHlyYW1pZFsyXSA9IGVkZ2VfaWRzWzFdLm5laV9pZHg7XHJcblx0XHR9XHJcblxyXG5cdFx0c3RlcmVvY2VudGVyLnB5cmFtaWRbM10gPSBlZGdlX2lkc1szXS5uZWlfaWR4O1xyXG5cdH1cclxuXHRlbHNlIGlmIChkZWdyZWUgPT0gMylcclxuXHR7XHJcblx0XHQvLyBzb3J0IGJ5IG5laWdoYm9yIGF0b20gaW5kZXggKGFzY2VuZGluZylcclxuXHRcdGlmIChlZGdlX2lkc1swXS5yYW5rID4gZWRnZV9pZHNbMV0ucmFuaylcclxuXHRcdFx0ZWRnZV9pZHMuc3dhcCgwLCAxKTtcclxuXHRcdGlmIChlZGdlX2lkc1sxXS5yYW5rID4gZWRnZV9pZHNbMl0ucmFuaylcclxuXHRcdFx0ZWRnZV9pZHMuc3dhcCgxLCAyKTtcclxuXHRcdGlmIChlZGdlX2lkc1swXS5yYW5rID4gZWRnZV9pZHNbMV0ucmFuaylcclxuXHRcdFx0ZWRnZV9pZHMuc3dhcCgwLCAxKTtcclxuXHJcblx0XHR2YXIgc3RlcmVvMCA9IHRoaXMuX2dldEJvbmRTdGVyZW8oYXRvbV9pZHgsIGVkZ2VfaWRzWzBdLmVkZ2VfaWR4KTtcclxuXHRcdHZhciBzdGVyZW8xID0gdGhpcy5fZ2V0Qm9uZFN0ZXJlbyhhdG9tX2lkeCwgZWRnZV9pZHNbMV0uZWRnZV9pZHgpO1xyXG5cdFx0dmFyIHN0ZXJlbzIgPSB0aGlzLl9nZXRCb25kU3RlcmVvKGF0b21faWR4LCBlZGdlX2lkc1syXS5lZGdlX2lkeCk7XHJcblxyXG5cdFx0dmFyIG5fdXAgPSAwLCBuX2Rvd24gPSAwO1xyXG5cclxuXHRcdG5fdXAgKz0gKChzdGVyZW8wID09IEJvbmQuUEFUVEVSTi5TVEVSRU8uVVApID8gMSA6IDApO1xyXG5cdFx0bl91cCArPSAoKHN0ZXJlbzEgPT0gQm9uZC5QQVRURVJOLlNURVJFTy5VUCkgPyAxIDogMCk7XHJcblx0XHRuX3VwICs9ICgoc3RlcmVvMiA9PSBCb25kLlBBVFRFUk4uU1RFUkVPLlVQKSA/IDEgOiAwKTtcclxuXHJcblx0XHRuX2Rvd24gKz0gKChzdGVyZW8wID09IEJvbmQuUEFUVEVSTi5TVEVSRU8uRE9XTikgPyAxIDogMCk7XHJcblx0XHRuX2Rvd24gKz0gKChzdGVyZW8xID09IEJvbmQuUEFUVEVSTi5TVEVSRU8uRE9XTikgPyAxIDogMCk7XHJcblx0XHRuX2Rvd24gKz0gKChzdGVyZW8yID09IEJvbmQuUEFUVEVSTi5TVEVSRU8uRE9XTikgPyAxIDogMCk7XHJcblxyXG5cdFx0aWYgKGltcGxpY2l0X2RlZ3JlZSA9PSA0KSAvLyBoYXZlIGltcGxpY2l0IGh5ZHJvZ2VuXHJcblx0XHR7XHJcblx0XHRcdGlmIChuX3VwID09IDMpXHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdhbGwgMyBib25kcyB1cCBuZWFyIHN0ZXJlb2F0b20nKTtcclxuXHRcdFx0aWYgKG5fZG93biA9PSAzKVxyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignYWxsIDMgYm9uZHMgZG93biBuZWFyIHN0ZXJlb2F0b20nKTtcclxuXHJcblx0XHRcdGlmIChuX3VwID09IDAgJiYgbl9kb3duID09IDApXHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdubyB1cC9kb3duIGJvbmRzIG5lYXIgc3RlcmVvYXRvbSAtLSBpbmRlZmluaXRlIGNhc2UnKTtcclxuXHRcdFx0aWYgKG5fdXAgPT0gMSAmJiBuX2Rvd24gPT0gMSlcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ29uZSBib25kIHVwLCBvbmUgYm9uZCBkb3duIC0tIGluZGVmaW5pdGUgY2FzZScpO1xyXG5cclxuXHRcdFx0bWFpbl9kaXIgPSAwO1xyXG5cclxuXHRcdFx0aWYgKG5fdXAgPT0gMilcclxuXHRcdFx0XHRsYXN0X2F0b21fZGlyID0gQm9uZC5QQVRURVJOLlNURVJFTy5ET1dOO1xyXG5cdFx0XHRlbHNlIGlmIChuX2Rvd24gPT0gMilcclxuXHRcdFx0XHRsYXN0X2F0b21fZGlyID0gQm9uZC5QQVRURVJOLlNURVJFTy5VUDtcclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0bWFpbjEgPSAtMTtcclxuXHRcdFx0XHRzaWRlMSA9IC0xO1xyXG5cdFx0XHRcdHNpZGUyID0gLTE7XHJcblxyXG5cdFx0XHRcdGZvciAobmVpX2lkeCA9IDA7IG5laV9pZHggPCAzOyBuZWlfaWR4KyspXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0ZGlyID0gdGhpcy5fZ2V0Qm9uZFN0ZXJlbyhhdG9tX2lkeCwgZWRnZV9pZHNbbmVpX2lkeF0uZWRnZV9pZHgpO1xyXG5cclxuXHRcdFx0XHRcdGlmIChkaXIgPT0gQm9uZC5QQVRURVJOLlNURVJFTy5VUCB8fCBkaXIgPT0gQm9uZC5QQVRURVJOLlNURVJFTy5ET1dOKVxyXG5cdFx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0XHRtYWluMSA9IG5laV9pZHg7XHJcblx0XHRcdFx0XHRcdG1haW5fZGlyID0gZGlyO1xyXG5cdFx0XHRcdFx0XHRzaWRlMSA9IChuZWlfaWR4ICsgMSkgJSAzO1xyXG5cdFx0XHRcdFx0XHRzaWRlMiA9IChuZWlfaWR4ICsgMikgJSAzO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChtYWluMSA9PSAtMSlcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignaW50ZXJuYWwgZXJyb3I6IGNhbiBub3QgZmluZCB1cCBvciBkb3duIGJvbmQnKTtcclxuXHJcblx0XHRcdFx0dmFyIHh5eiA9IFN0ZXJlb2NlbnRlcnMuX3h5enp5KGVkZ2VfaWRzW3NpZGUxXS52ZWMsIGVkZ2VfaWRzW3NpZGUyXS52ZWMsIGVkZ2VfaWRzW21haW4xXS52ZWMpO1xyXG5cclxuXHRcdFx0XHRpZiAoeHl6ID09IDMgfHwgeHl6ID09IDQpXHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2RlZ2VuZXJhdGUgY2FzZSBmb3IgMyBib25kcyBuZWFyIHN0ZXJlb2F0b20nKTtcclxuXHJcblx0XHRcdFx0aWYgKHh5eiA9PSAxKVxyXG5cdFx0XHRcdFx0bGFzdF9hdG9tX2RpciA9IG1haW5fZGlyO1xyXG5cdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdGxhc3RfYXRvbV9kaXIgPSAobWFpbl9kaXIgPT0gQm9uZC5QQVRURVJOLlNURVJFTy5VUCA/IEJvbmQuUEFUVEVSTi5TVEVSRU8uRE9XTiA6IEJvbmQuUEFUVEVSTi5TVEVSRU8uVVApO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgc2lnbiA9IFN0ZXJlb2NlbnRlcnMuX3NpZ24oZWRnZV9pZHNbMF0udmVjLCBlZGdlX2lkc1sxXS52ZWMsIGVkZ2VfaWRzWzJdLnZlYyk7XHJcblxyXG5cdFx0XHRpZiAoKGxhc3RfYXRvbV9kaXIgPT0gQm9uZC5QQVRURVJOLlNURVJFTy5VUCAmJiBzaWduID4gMCkgfHxcclxuXHRcdFx0KGxhc3RfYXRvbV9kaXIgPT0gQm9uZC5QQVRURVJOLlNURVJFTy5ET1dOICYmIHNpZ24gPCAwKSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHN0ZXJlb2NlbnRlci5weXJhbWlkWzBdID0gZWRnZV9pZHNbMF0ubmVpX2lkeDtcclxuXHRcdFx0XHRzdGVyZW9jZW50ZXIucHlyYW1pZFsxXSA9IGVkZ2VfaWRzWzFdLm5laV9pZHg7XHJcblx0XHRcdFx0c3RlcmVvY2VudGVyLnB5cmFtaWRbMl0gPSBlZGdlX2lkc1syXS5uZWlfaWR4O1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHN0ZXJlb2NlbnRlci5weXJhbWlkWzBdID0gZWRnZV9pZHNbMF0ubmVpX2lkeDtcclxuXHRcdFx0XHRzdGVyZW9jZW50ZXIucHlyYW1pZFsxXSA9IGVkZ2VfaWRzWzJdLm5laV9pZHg7XHJcblx0XHRcdFx0c3RlcmVvY2VudGVyLnB5cmFtaWRbMl0gPSBlZGdlX2lkc1sxXS5uZWlfaWR4O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzdGVyZW9jZW50ZXIucHlyYW1pZFszXSA9IC0xO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSAvLyAzLWNvbm5lY3RlZCBQLCBOIG9yIFM7IG5vIGltcGxpY2l0IGh5ZHJvZ2Vuc1xyXG5cdFx0e1xyXG5cdFx0XHR2YXIgZGlyO1xyXG5cclxuXHRcdFx0aWYgKG5fZG93biA+IDAgJiYgbl91cCA+IDApXHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdvbmUgYm9uZCB1cCwgb25lIGJvbmQgZG93biAtLSBpbmRlZmluaXRlIGNhc2UnKTtcclxuXHRcdFx0ZWxzZSBpZiAobl9kb3duID09IDAgJiYgbl91cCA9PSAwKVxyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignbm8gdXAtZG93biBib25kcyBhdHRhY2hlZCB0byBzdGVyZW9jZW50ZXInKTtcclxuXHRcdFx0ZWxzZSBpZiAobl91cCA+IDApXHJcblx0XHRcdFx0ZGlyID0gMTtcclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdGRpciA9IC0xO1xyXG5cclxuXHRcdFx0aWYgKFN0ZXJlb2NlbnRlcnMuX3h5enp5KGVkZ2VfaWRzWzBdLnZlYywgZWRnZV9pZHNbMV0udmVjLCBlZGdlX2lkc1syXS52ZWMpID09IDEgfHxcclxuXHRcdFx0U3RlcmVvY2VudGVycy5feHl6enkoZWRnZV9pZHNbMF0udmVjLCBlZGdlX2lkc1syXS52ZWMsIGVkZ2VfaWRzWzFdLnZlYykgPT0gMSB8fFxyXG5cdFx0XHRTdGVyZW9jZW50ZXJzLl94eXp6eShlZGdlX2lkc1syXS52ZWMsIGVkZ2VfaWRzWzFdLnZlYywgZWRnZV9pZHNbMF0udmVjKSA9PSAxKVxyXG5cdFx0XHRcdC8vIGFsbCBib25kcyBiZWxvbmcgdG8gdGhlIHNhbWUgaGFsZi1wbGFuZVxyXG5cdFx0XHRcdGRpciA9IC1kaXI7XHJcblxyXG5cdFx0XHRzaWduID0gU3RlcmVvY2VudGVycy5fc2lnbihlZGdlX2lkc1swXS52ZWMsIGVkZ2VfaWRzWzFdLnZlYywgZWRnZV9pZHNbMl0udmVjKTtcclxuXHJcblx0XHRcdGlmIChzaWduID09IGRpcilcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHN0ZXJlb2NlbnRlci5weXJhbWlkWzBdID0gZWRnZV9pZHNbMF0ubmVpX2lkeDtcclxuXHRcdFx0XHRzdGVyZW9jZW50ZXIucHlyYW1pZFsxXSA9IGVkZ2VfaWRzWzJdLm5laV9pZHg7XHJcblx0XHRcdFx0c3RlcmVvY2VudGVyLnB5cmFtaWRbMl0gPSBlZGdlX2lkc1sxXS5uZWlfaWR4O1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHN0ZXJlb2NlbnRlci5weXJhbWlkWzBdID0gZWRnZV9pZHNbMF0ubmVpX2lkeDtcclxuXHRcdFx0XHRzdGVyZW9jZW50ZXIucHlyYW1pZFsxXSA9IGVkZ2VfaWRzWzFdLm5laV9pZHg7XHJcblx0XHRcdFx0c3RlcmVvY2VudGVyLnB5cmFtaWRbMl0gPSBlZGdlX2lkc1syXS5uZWlfaWR4O1xyXG5cdFx0XHR9XHJcblx0XHRcdHN0ZXJlb2NlbnRlci5weXJhbWlkWzNdID0gLTE7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHR0aGlzLmF0b21zLnNldChhdG9tX2lkeCwgc3RlcmVvY2VudGVyKTtcclxufTtcclxuXHJcblN0ZXJlb2NlbnRlcnMucHJvdG90eXBlLl9nZXRCb25kU3RlcmVvID0gZnVuY3Rpb24gKGNlbnRlcl9pZHgsIGVkZ2VfaWR4KVxyXG57XHJcblx0dmFyIGJvbmQgPSB0aGlzLm1vbGVjdWxlLmJvbmRzLmdldChlZGdlX2lkeCk7XHJcblxyXG5cdGlmIChjZW50ZXJfaWR4ICE9IGJvbmQuYmVnaW4pIC8vIFRPRE86IGNoZWNrIHRoaXNcclxuXHRcdHJldHVybiAwO1xyXG5cclxuXHRyZXR1cm4gYm9uZC5zdGVyZW87XHJcbn07XHJcblxyXG4vLyAxIC0tIGluIHRoZSBzbWFsbGVyIGFuZ2xlLCAyIC0tIGluIHRoZSBiaWdnZXIgYW5nbGUsXHJcbi8vIDQgLS0gaW4gdGhlICdwb3NpdGl2ZScgc3RyYWlnaHQgYW5nbGUsIDggLS0gaW4gdGhlICduZWdhdGl2ZScgc3RyYWlnaHQgYW5nbGVcclxuU3RlcmVvY2VudGVycy5feHl6enkgPSBmdW5jdGlvbiAodjEsIHYyLCB1KVxyXG57XHJcblx0dmFyIGVwcyA9IDAuMDAxO1xyXG5cclxuXHR2YXIgc2luZTEgPSBWZWMyLmNyb3NzKHYxLCB2Mik7XHJcblx0dmFyIGNvc2luZTEgPSBWZWMyLmRvdCh2MSwgdjIpO1xyXG5cclxuXHR2YXIgc2luZTIgPSBWZWMyLmNyb3NzKHYxLCB1KTtcclxuXHR2YXIgY29zaW5lMiA9IFZlYzIuZG90KHYxLCB1KTtcclxuXHJcblx0aWYgKE1hdGguYWJzKHNpbmUxKSA8IGVwcylcclxuXHR7XHJcblx0XHRpZiAoTWF0aC5hYnMoc2luZTIpIDwgZXBzKVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2RlZ2VuZXJhdGUgY2FzZSAtLSBib25kcyBvdmVybGFwJyk7XHJcblxyXG5cdFx0cmV0dXJuIChzaW5lMiA+IDApID8gNCA6IDg7XHJcblx0fVxyXG5cclxuXHRpZiAoc2luZTEgKiBzaW5lMiA8IC1lcHMgKiBlcHMpXHJcblx0XHRyZXR1cm4gMjtcclxuXHJcblx0aWYgKGNvc2luZTIgPCBjb3NpbmUxKVxyXG5cdFx0cmV0dXJuIDI7XHJcblxyXG5cdHJldHVybiAxO1xyXG59O1xyXG5cclxuU3RlcmVvY2VudGVycy5fc2lnbiA9IGZ1bmN0aW9uICh2MSwgdjIsIHYzKVxyXG57XHJcblx0dmFyIHJlcyA9ICh2MS54IC0gdjMueCkgKiAodjIueSAtIHYzLnkpIC0gKHYxLnkgLSB2My55KSAqICh2Mi54IC0gdjMueCk7XHJcblx0dmFyIGVwcyA9IDAuMDAxO1xyXG5cclxuXHRpZiAocmVzID4gZXBzKVxyXG5cdFx0cmV0dXJuIDE7XHJcblx0aWYgKHJlcyA8IC1lcHMpXHJcblx0XHRyZXR1cm4gLTE7XHJcblxyXG5cdHRocm93IG5ldyBFcnJvcignZGVnZW5lcmF0ZSB0cmlhbmdsZScpO1xyXG59O1xyXG5cclxuU3RlcmVvY2VudGVycy5pc1B5cmFtaWRNYXBwaW5nUmlnaWQgPSBmdW5jdGlvbiAobWFwcGluZylcclxue1xyXG5cdHZhciBhcnIgPSBtYXBwaW5nLmNsb25lKCk7XHJcblx0dmFyIHJpZ2lkID0gdHJ1ZTtcclxuXHJcblx0aWYgKGFyclswXSA+IGFyclsxXSlcclxuXHRcdGFyci5zd2FwKDAsIDEpLCByaWdpZCA9ICFyaWdpZDtcclxuXHRpZiAoYXJyWzFdID4gYXJyWzJdKVxyXG5cdFx0YXJyLnN3YXAoMSwgMiksIHJpZ2lkID0gIXJpZ2lkO1xyXG5cdGlmIChhcnJbMl0gPiBhcnJbM10pXHJcblx0XHRhcnIuc3dhcCgyLCAzKSwgcmlnaWQgPSAhcmlnaWQ7XHJcblx0aWYgKGFyclsxXSA+IGFyclsyXSlcclxuXHRcdGFyci5zd2FwKDEsIDIpLCByaWdpZCA9ICFyaWdpZDtcclxuXHRpZiAoYXJyWzBdID4gYXJyWzFdKVxyXG5cdFx0YXJyLnN3YXAoMCwgMSksIHJpZ2lkID0gIXJpZ2lkO1xyXG5cdGlmIChhcnJbMV0gPiBhcnJbMl0pXHJcblx0XHRhcnIuc3dhcCgxLCAyKSwgcmlnaWQgPSAhcmlnaWQ7XHJcblxyXG5cdHJldHVybiByaWdpZDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3RlcmVvY2VudGVycztcclxuIiwidmFyIE1hcCA9IHJlcXVpcmUoJy4uL3V0aWwvbWFwJyk7XHJcbnZhciBQb29sID0gcmVxdWlyZSgnLi4vdXRpbC9wb29sJyk7XHJcbnZhciBTZXQgPSByZXF1aXJlKCcuLi91dGlsL3NldCcpO1xyXG52YXIgVmVjMiA9IHJlcXVpcmUoJy4uL3V0aWwvdmVjMicpO1xyXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcclxuXHJcbnZhciBlbGVtZW50ID0gcmVxdWlyZSgnLi9lbGVtZW50Jyk7XHJcbnZhciBCb25kID0gcmVxdWlyZSgnLi9ib25kJyk7XHJcbnZhciBTR3JvdXAgPSByZXF1aXJlKCcuL3Nncm91cCcpO1xyXG52YXIgU0dyb3VwRm9yZXN0ID0gcmVxdWlyZSgnLi9zZ2ZvcmVzdCcpO1xyXG5cclxudmFyIFN0cnVjdCA9IGZ1bmN0aW9uICgpIHtcclxuXHR0aGlzLmF0b21zID0gbmV3IFBvb2woKTtcclxuXHR0aGlzLmJvbmRzID0gbmV3IFBvb2woKTtcclxuXHR0aGlzLnNncm91cHMgPSBuZXcgUG9vbCgpO1xyXG5cdHRoaXMuaGFsZkJvbmRzID0gbmV3IE1hcCgpO1xyXG5cdHRoaXMubG9vcHMgPSBuZXcgUG9vbCgpO1xyXG5cdHRoaXMuaXNDaGlyYWwgPSBmYWxzZTtcclxuXHR0aGlzLmlzUmVhY3Rpb24gPSBmYWxzZTtcclxuXHR0aGlzLnJ4bkFycm93cyA9IG5ldyBQb29sKCk7XHJcblx0dGhpcy5yeG5QbHVzZXMgPSBuZXcgUG9vbCgpO1xyXG5cdHRoaXMuZnJhZ3MgPSBuZXcgUG9vbCgpO1xyXG5cdHRoaXMucmdyb3VwcyA9IG5ldyBNYXAoKTtcclxuXHR0aGlzLm5hbWUgPSAnJztcclxuXHR0aGlzLnNHcm91cEZvcmVzdCA9IG5ldyBTR3JvdXBGb3Jlc3QodGhpcyk7XHJcbn07XHJcblxyXG5TdHJ1Y3QucHJvdG90eXBlLmhhc1J4blByb3BzID0gZnVuY3Rpb24gKCkge1xyXG5cdHJldHVybiB0aGlzLmF0b21zLmZpbmQoZnVuY3Rpb24gKGFpZCwgYXRvbSkge1xyXG5cdFx0cmV0dXJuIGF0b20uaGFzUnhuUHJvcHMoKTtcclxuXHR9LCB0aGlzKSA+PSAwIHx8IHRoaXMuYm9uZHMuZmluZChmdW5jdGlvbiAoYmlkLCBib25kKSB7XHJcblx0XHRyZXR1cm4gYm9uZC5oYXNSeG5Qcm9wcygpO1xyXG5cdH0sIHRoaXMpID49IDA7XHJcbn07XHJcblxyXG5TdHJ1Y3QucHJvdG90eXBlLmhhc1J4bkFycm93ID0gZnVuY3Rpb24gKCkge1xyXG5cdHJldHVybiB0aGlzLnJ4bkFycm93cy5jb3VudCgpID4gMDtcclxufTtcclxuXHJcblN0cnVjdC5wcm90b3R5cGUuYWRkUnhuQXJyb3dJZk5lY2Vzc2FyeSA9IGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgaW1wbGljaXRSZWFjdGlvbiA9ICF0aGlzLmhhc1J4bkFycm93KCkgJiYgdGhpcy5oYXNSeG5Qcm9wcygpO1xyXG5cdGlmIChpbXBsaWNpdFJlYWN0aW9uKSB7XHJcblx0XHR0aGlzLnJ4bkFycm93cy5hZGQobmV3IFN0cnVjdC5SeG5BcnJvdygpKTtcclxuXHR9XHJcblx0cmV0dXJuIGltcGxpY2l0UmVhY3Rpb247XHJcbn07XHJcblxyXG4vLyByZXR1cm5zIGEgbGlzdCBvZiBpZCdzIG9mIHMtZ3JvdXBzLCB3aGljaCBjb250YWluIG9ubHkgYXRvbXMgaW4gdGhlIGdpdmVuIGxpc3RcclxuU3RydWN0LnByb3RvdHlwZS5nZXRTR3JvdXBzSW5BdG9tU2V0ID0gZnVuY3Rpb24gKGF0b21zLypBcnJheSovKSB7XHJcblx0dmFyIHNncm91cENvdW50cyA9IG5ldyBIYXNoKCk7XHJcblxyXG5cdHV0aWwuZWFjaChhdG9tcywgZnVuY3Rpb24gKGFpZCkge1xyXG5cdFx0dmFyIHNnID0gU2V0Lmxpc3QodGhpcy5hdG9tcy5nZXQoYWlkKS5zZ3MpO1xyXG5cclxuXHRcdHNnLmVhY2goZnVuY3Rpb24gKHNpZCkge1xyXG5cdFx0XHR2YXIgbiA9IHNncm91cENvdW50cy5nZXQoc2lkKTtcclxuXHRcdFx0aWYgKE9iamVjdC5pc1VuZGVmaW5lZChuKSkge1xyXG5cdFx0XHRcdG4gPSAxO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG4rKztcclxuXHRcdFx0fVxyXG5cdFx0XHRzZ3JvdXBDb3VudHMuc2V0KHNpZCwgbik7XHJcblx0XHR9LCB0aGlzKTtcclxuXHR9LCB0aGlzKTtcclxuXHJcblx0dmFyIHNncm91cExpc3QgPSBbXTtcclxuXHRzZ3JvdXBDb3VudHMuZWFjaChmdW5jdGlvbiAoc2cpIHtcclxuXHRcdHZhciBzaWQgPSBwYXJzZUludChzZy5rZXksIDEwKTtcclxuXHRcdHZhciBzZ3JvdXAgPSB0aGlzLnNncm91cHMuZ2V0KHNpZCk7XHJcblx0XHR2YXIgc2dBdG9tcyA9IFNHcm91cC5nZXRBdG9tcyh0aGlzLCBzZ3JvdXApO1xyXG5cdFx0aWYgKHNnLnZhbHVlID09IHNnQXRvbXMubGVuZ3RoKSB7XHJcblx0XHRcdHNncm91cExpc3QucHVzaChzaWQpO1xyXG5cdFx0fVxyXG5cdH0sIHRoaXMpO1xyXG5cdHJldHVybiBzZ3JvdXBMaXN0O1xyXG59O1xyXG5cclxuU3RydWN0LnByb3RvdHlwZS5pc0JsYW5rID0gZnVuY3Rpb24gKCkge1xyXG5cdHJldHVybiB0aGlzLmF0b21zLmNvdW50KCkgPT09IDAgJiZcclxuXHR0aGlzLnJ4bkFycm93cy5jb3VudCgpID09PSAwICYmXHJcblx0dGhpcy5yeG5QbHVzZXMuY291bnQoKSA9PT0gMCAmJiAhdGhpcy5pc0NoaXJhbDtcclxufTtcclxuXHJcblN0cnVjdC5wcm90b3R5cGUudG9MaXN0cyA9IGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgYWlkTWFwID0ge307XHJcblx0dmFyIGF0b21MaXN0ID0gW107XHJcblx0dGhpcy5hdG9tcy5lYWNoKGZ1bmN0aW9uIChhaWQsIGF0b20pIHtcclxuXHRcdGFpZE1hcFthaWRdID0gYXRvbUxpc3QubGVuZ3RoO1xyXG5cdFx0YXRvbUxpc3QucHVzaChhdG9tKTtcclxuXHR9KTtcclxuXHJcblx0dmFyIGJvbmRMaXN0ID0gW107XHJcblx0dGhpcy5ib25kcy5lYWNoKGZ1bmN0aW9uIChiaWQsIGJvbmQpIHtcclxuXHRcdHZhciBiID0gbmV3IEJvbmQoYm9uZCk7XHJcblx0XHRiLmJlZ2luID0gYWlkTWFwW2JvbmQuYmVnaW5dO1xyXG5cdFx0Yi5lbmQgPSBhaWRNYXBbYm9uZC5lbmRdO1xyXG5cdFx0Ym9uZExpc3QucHVzaChiKTtcclxuXHR9KTtcclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdCdhdG9tcyc6IGF0b21MaXN0LFxyXG5cdFx0J2JvbmRzJzogYm9uZExpc3RcclxuXHR9O1xyXG59O1xyXG5cclxuU3RydWN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIChhdG9tU2V0LCBib25kU2V0LCBkcm9wUnhuU3ltYm9scywgYWlkTWFwKSB7XHJcblx0dmFyIGNwID0gbmV3IFN0cnVjdCgpO1xyXG5cdHJldHVybiB0aGlzLm1lcmdlSW50byhjcCwgYXRvbVNldCwgYm9uZFNldCwgZHJvcFJ4blN5bWJvbHMsIGZhbHNlLCBhaWRNYXApO1xyXG59O1xyXG5cclxuU3RydWN0LnByb3RvdHlwZS5nZXRTY2FmZm9sZCA9IGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgYXRvbVNldCA9IFNldC5lbXB0eSgpO1xyXG5cdHRoaXMuYXRvbXMuZWFjaChmdW5jdGlvbiAoYWlkKSB7XHJcblx0XHRTZXQuYWRkKGF0b21TZXQsIGFpZCk7XHJcblx0fSwgdGhpcyk7XHJcblx0dGhpcy5yZ3JvdXBzLmVhY2goZnVuY3Rpb24gKHJnaWQsIHJnKSB7XHJcblx0XHRyZy5mcmFncy5lYWNoKGZ1bmN0aW9uIChmbnVtLCBmaWQpIHtcclxuXHRcdFx0dGhpcy5hdG9tcy5lYWNoKGZ1bmN0aW9uIChhaWQsIGF0b20pIHtcclxuXHRcdFx0XHRpZiAoYXRvbS5mcmFnbWVudCA9PSBmaWQpIHtcclxuXHRcdFx0XHRcdFNldC5yZW1vdmUoYXRvbVNldCwgYWlkKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0fSwgdGhpcyk7XHJcblx0fSwgdGhpcyk7XHJcblx0cmV0dXJuIHRoaXMuY2xvbmUoYXRvbVNldCk7XHJcbn07XHJcblxyXG5TdHJ1Y3QucHJvdG90eXBlLmdldEZyYWdtZW50SWRzID0gZnVuY3Rpb24gKGZpZCkge1xyXG5cdHZhciBhdG9tU2V0ID0gU2V0LmVtcHR5KCk7XHJcblx0dGhpcy5hdG9tcy5lYWNoKGZ1bmN0aW9uIChhaWQsIGF0b20pIHtcclxuXHRcdGlmIChhdG9tLmZyYWdtZW50ID09IGZpZCkge1xyXG5cdFx0XHRTZXQuYWRkKGF0b21TZXQsIGFpZCk7XHJcblx0XHR9XHJcblx0fSwgdGhpcyk7XHJcblx0cmV0dXJuIGF0b21TZXQ7XHJcbn07XHJcblxyXG5TdHJ1Y3QucHJvdG90eXBlLmdldEZyYWdtZW50ID0gZnVuY3Rpb24gKGZpZCkge1xyXG5cdHJldHVybiB0aGlzLmNsb25lKHRoaXMuZ2V0RnJhZ21lbnRJZHMoZmlkKSk7XHJcbn07XHJcblxyXG5TdHJ1Y3QucHJvdG90eXBlLm1lcmdlSW50byA9IGZ1bmN0aW9uIChjcCwgYXRvbVNldCwgYm9uZFNldCwgZHJvcFJ4blN5bWJvbHMsIGtlZXBBbGxSR3JvdXBzLCBhaWRNYXApIHtcclxuXHRhdG9tU2V0ID0gYXRvbVNldCB8fCBTZXQua2V5U2V0SW50KHRoaXMuYXRvbXMpO1xyXG5cdGJvbmRTZXQgPSBib25kU2V0IHx8IFNldC5rZXlTZXRJbnQodGhpcy5ib25kcyk7XHJcblx0Ym9uZFNldCA9IFNldC5maWx0ZXIoYm9uZFNldCwgZnVuY3Rpb24gKGJpZCl7XHJcblx0XHR2YXIgYm9uZCA9IHRoaXMuYm9uZHMuZ2V0KGJpZCk7XHJcblx0XHRyZXR1cm4gU2V0LmNvbnRhaW5zKGF0b21TZXQsIGJvbmQuYmVnaW4pICYmIFNldC5jb250YWlucyhhdG9tU2V0LCBib25kLmVuZCk7XHJcblx0fSwgdGhpcyk7XHJcblxyXG5cdHZhciBmaWRNYXNrID0ge307XHJcblx0dGhpcy5hdG9tcy5lYWNoKGZ1bmN0aW9uIChhaWQsIGF0b20pIHtcclxuXHRcdGlmIChTZXQuY29udGFpbnMoYXRvbVNldCwgYWlkKSlcclxuXHRcdFx0ZmlkTWFza1thdG9tLmZyYWdtZW50XSA9IDE7XHJcblx0fSk7XHJcblx0dmFyIGZpZE1hcCA9IHt9O1xyXG5cdHRoaXMuZnJhZ3MuZWFjaChmdW5jdGlvbiAoZmlkLCBmcmFnKSB7XHJcblx0XHRpZiAoZmlkTWFza1tmaWRdKVxyXG5cdFx0XHRmaWRNYXBbZmlkXSA9IGNwLmZyYWdzLmFkZChmcmFnLmNsb25lKCkpO1xyXG5cdH0pO1xyXG5cclxuXHR0aGlzLnJncm91cHMuZWFjaChmdW5jdGlvbiAocmdpZCwgcmdyb3VwKSB7XHJcblx0XHR2YXIga2VlcEdyb3VwID0ga2VlcEFsbFJHcm91cHM7XHJcblx0XHRpZiAoIWtlZXBHcm91cCkge1xyXG5cdFx0XHRyZ3JvdXAuZnJhZ3MuZWFjaChmdW5jdGlvbiAoZm51bSwgZmlkKSB7XHJcblx0XHRcdFx0aWYgKGZpZE1hc2tbZmlkXSlcclxuXHRcdFx0XHRcdGtlZXBHcm91cCA9IHRydWU7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRpZiAoIWtlZXBHcm91cClcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHR2YXIgcmcgPSBjcC5yZ3JvdXBzLmdldChyZ2lkKTtcclxuXHRcdGlmIChyZykge1xyXG5cdFx0XHRyZ3JvdXAuZnJhZ3MuZWFjaChmdW5jdGlvbiAoZm51bSwgZmlkKSB7XHJcblx0XHRcdFx0aWYgKGZpZE1hc2tbZmlkXSlcclxuXHRcdFx0XHRcdHJnLmZyYWdzLmFkZChmaWRNYXBbZmlkXSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y3Aucmdyb3Vwcy5zZXQocmdpZCwgcmdyb3VwLmNsb25lKGZpZE1hcCkpO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHRpZiAodHlwZW9mIGFpZE1hcCA9PT0gJ3VuZGVmaW5lZCcgfHwgYWlkTWFwID09PSBudWxsKVxyXG5cdFx0YWlkTWFwID0ge307XHJcblx0dGhpcy5hdG9tcy5lYWNoKGZ1bmN0aW9uIChhaWQsIGF0b20pIHtcclxuXHRcdGlmIChTZXQuY29udGFpbnMoYXRvbVNldCwgYWlkKSlcclxuXHRcdFx0YWlkTWFwW2FpZF0gPSBjcC5hdG9tcy5hZGQoYXRvbS5jbG9uZShmaWRNYXApKTtcclxuXHR9KTtcclxuXHJcblx0dmFyIGJpZE1hcCA9IHt9O1xyXG5cdHRoaXMuYm9uZHMuZWFjaChmdW5jdGlvbiAoYmlkLCBib25kKSB7XHJcblx0XHRpZiAoU2V0LmNvbnRhaW5zKGJvbmRTZXQsIGJpZCkpXHJcblx0XHRcdGJpZE1hcFtiaWRdID0gY3AuYm9uZHMuYWRkKGJvbmQuY2xvbmUoYWlkTWFwKSk7XHJcblx0fSk7XHJcblxyXG5cdHRoaXMuc2dyb3Vwcy5lYWNoKGZ1bmN0aW9uIChzaWQsIHNnKSB7XHJcblx0XHR2YXIgaTtcclxuXHRcdGZvciAoaSA9IDA7IGkgPCBzZy5hdG9tcy5sZW5ndGg7ICsraSlcclxuXHRcdFx0aWYgKCFTZXQuY29udGFpbnMoYXRvbVNldCwgc2cuYXRvbXNbaV0pKVxyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdHNnID0gU0dyb3VwLmNsb25lKHNnLCBhaWRNYXAsIGJpZE1hcCk7XHJcblx0XHR2YXIgaWQgPSBjcC5zZ3JvdXBzLmFkZChzZyk7XHJcblx0XHRzZy5pZCA9IGlkO1xyXG5cdFx0Zm9yIChpID0gMDsgaSA8IHNnLmF0b21zLmxlbmd0aDsgKytpKSB7XHJcblx0XHRcdFNldC5hZGQoY3AuYXRvbXMuZ2V0KHNnLmF0b21zW2ldKS5zZ3MsIGlkKTtcclxuXHRcdH1cclxuXHRcdGNwLnNHcm91cEZvcmVzdC5pbnNlcnQoc2cuaWQpO1xyXG5cdH0pO1xyXG5cdGNwLmlzQ2hpcmFsID0gdGhpcy5pc0NoaXJhbDtcclxuXHRpZiAoIWRyb3BSeG5TeW1ib2xzKSB7XHJcblx0XHRjcC5pc1JlYWN0aW9uID0gdGhpcy5pc1JlYWN0aW9uO1xyXG5cdFx0dGhpcy5yeG5BcnJvd3MuZWFjaChmdW5jdGlvbiAoaWQsIGl0ZW0pIHtcclxuXHRcdFx0Y3AucnhuQXJyb3dzLmFkZChpdGVtLmNsb25lKCkpO1xyXG5cdFx0fSk7XHJcblx0XHR0aGlzLnJ4blBsdXNlcy5lYWNoKGZ1bmN0aW9uIChpZCwgaXRlbSkge1xyXG5cdFx0XHRjcC5yeG5QbHVzZXMuYWRkKGl0ZW0uY2xvbmUoKSk7XHJcblx0XHR9KTtcclxuXHR9XHJcblx0cmV0dXJuIGNwO1xyXG59O1xyXG5cclxuU3RydWN0LnByb3RvdHlwZS5maW5kQm9uZElkID0gZnVuY3Rpb24gKGJlZ2luLCBlbmQpXHJcbntcclxuXHR2YXIgaWQgPSAtMTtcclxuXHJcblx0dGhpcy5ib25kcy5maW5kKGZ1bmN0aW9uIChiaWQsIGJvbmQpXHJcblx0e1xyXG5cdFx0aWYgKChib25kLmJlZ2luID09IGJlZ2luICYmIGJvbmQuZW5kID09IGVuZCkgfHxcclxuXHRcdChib25kLmJlZ2luID09IGVuZCAmJiBib25kLmVuZCA9PSBiZWdpbikpXHJcblx0XHR7XHJcblx0XHRcdGlkID0gYmlkO1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9LCB0aGlzKTtcclxuXHJcblx0cmV0dXJuIGlkO1xyXG59O1xyXG5cclxudmFyIEhhbGZCb25kID0gZnVuY3Rpb24gKC8qbnVtKi9iZWdpbiwgLypudW0qL2VuZCwgLypudW0qL2JpZClcclxue1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDMpXHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFyYW1ldGVyIG51bWJlciEnKTtcclxuXHJcblx0dGhpcy5iZWdpbiA9IGJlZ2luIC0gMDtcclxuXHR0aGlzLmVuZCA9IGVuZCAtIDA7XHJcblx0dGhpcy5iaWQgPSBiaWQgLSAwO1xyXG5cclxuXHQvLyByZW5kZXJpbmcgcHJvcGVydGllc1xyXG5cdHRoaXMuZGlyID0gbmV3IFZlYzIoKTsgLy8gZGlyZWN0aW9uXHJcblx0dGhpcy5ub3JtID0gbmV3IFZlYzIoKTsgLy8gbGVmdCBub3JtYWxcclxuXHR0aGlzLmFuZyA9IDA7IC8vIGFuZ2xlIHRvICgxLDApLCB1c2VkIGZvciBzb3J0aW5nIHRoZSBib25kc1xyXG5cdHRoaXMucCA9IG5ldyBWZWMyKCk7IC8vIGNvcnJlY3RlZCBvcmlnaW4gcG9zaXRpb25cclxuXHR0aGlzLmxvb3AgPSAtMTsgLy8gbGVmdCBsb29wIGlkIGlmIHRoZSBoYWxmLWJvbmQgaXMgaW4gYSBsb29wLCBvdGhlcndpc2UgLTFcclxuXHR0aGlzLmNvbnRyYSA9IC0xOyAvLyB0aGUgaGFsZiBib25kIGNvbnRyYXJ5IHRvIHRoaXMgb25lXHJcblx0dGhpcy5uZXh0ID0gLTE7IC8vIHRoZSBoYWxmLWJvbmQgbmV4dCBvdCB0aGlzIG9uZSBpbiBDQ1cgb3JkZXJcclxuXHR0aGlzLmxlZnRTaW4gPSAwO1xyXG5cdHRoaXMubGVmdENvcyA9IDA7XHJcblx0dGhpcy5sZWZ0TmVpZ2hib3IgPSAwO1xyXG5cdHRoaXMucmlnaHRTaW4gPSAwO1xyXG5cdHRoaXMucmlnaHRDb3MgPSAwO1xyXG5cdHRoaXMucmlnaHROZWlnaGJvciA9IDA7XHJcbn07XHJcblxyXG5TdHJ1Y3QucHJvdG90eXBlLmluaXROZWlnaGJvcnMgPSBmdW5jdGlvbiAoKVxyXG57XHJcblx0dGhpcy5hdG9tcy5lYWNoKGZ1bmN0aW9uIChhaWQsIGF0b20pe1xyXG5cdFx0YXRvbS5uZWlnaGJvcnMgPSBbXTtcclxuXHR9KTtcclxuXHR0aGlzLmJvbmRzLmVhY2goZnVuY3Rpb24gKGJpZCwgYm9uZCl7XHJcblx0XHR2YXIgYTEgPSB0aGlzLmF0b21zLmdldChib25kLmJlZ2luKTtcclxuXHRcdHZhciBhMiA9IHRoaXMuYXRvbXMuZ2V0KGJvbmQuZW5kKTtcclxuXHRcdGExLm5laWdoYm9ycy5wdXNoKGJvbmQuaGIxKTtcclxuXHRcdGEyLm5laWdoYm9ycy5wdXNoKGJvbmQuaGIyKTtcclxuXHR9LCB0aGlzKTtcclxufTtcclxuXHJcblN0cnVjdC5wcm90b3R5cGUuYm9uZEluaXRIYWxmQm9uZHMgPSBmdW5jdGlvbiAoYmlkLCAvKm9wdCovIGJvbmQpXHJcbntcclxuXHRib25kID0gYm9uZCB8fCB0aGlzLmJvbmRzLmdldChiaWQpO1xyXG5cdGJvbmQuaGIxID0gMiAqIGJpZDtcclxuXHRib25kLmhiMiA9IDIgKiBiaWQgKyAxO1xyXG5cdHRoaXMuaGFsZkJvbmRzLnNldChib25kLmhiMSwgbmV3IEhhbGZCb25kKGJvbmQuYmVnaW4sIGJvbmQuZW5kLCBiaWQpKTtcclxuXHR0aGlzLmhhbGZCb25kcy5zZXQoYm9uZC5oYjIsIG5ldyBIYWxmQm9uZChib25kLmVuZCwgYm9uZC5iZWdpbiwgYmlkKSk7XHJcblx0dmFyIGhiMSA9IHRoaXMuaGFsZkJvbmRzLmdldChib25kLmhiMSk7XHJcblx0dmFyIGhiMiA9IHRoaXMuaGFsZkJvbmRzLmdldChib25kLmhiMik7XHJcblx0aGIxLmNvbnRyYSA9IGJvbmQuaGIyO1xyXG5cdGhiMi5jb250cmEgPSBib25kLmhiMTtcclxufTtcclxuXHJcblN0cnVjdC5wcm90b3R5cGUuaGFsZkJvbmRVcGRhdGUgPSBmdW5jdGlvbiAoaGJpZClcclxue1xyXG5cdHZhciBoYiA9IHRoaXMuaGFsZkJvbmRzLmdldChoYmlkKTtcclxuXHR2YXIgcDEgPSB0aGlzLmF0b21zLmdldChoYi5iZWdpbikucHA7XHJcblx0dmFyIHAyID0gdGhpcy5hdG9tcy5nZXQoaGIuZW5kKS5wcDtcclxuXHR2YXIgZCA9IFZlYzIuZGlmZihwMiwgcDEpLm5vcm1hbGl6ZWQoKTtcclxuXHRoYi5kaXIgPSBWZWMyLmRpc3QocDIsIHAxKSA+IDFlLTQgPyBkIDogbmV3IFZlYzIoMSwgMCk7XHJcblx0aGIubm9ybSA9IGhiLmRpci50dXJuTGVmdCgpO1xyXG5cdGhiLmFuZyA9IGhiLmRpci5veEFuZ2xlKCk7XHJcblx0aWYgKGhiLmxvb3AgPCAwKVxyXG5cdFx0aGIubG9vcCA9IC0xO1xyXG59O1xyXG5cclxuU3RydWN0LnByb3RvdHlwZS5pbml0SGFsZkJvbmRzID0gZnVuY3Rpb24gKClcclxue1xyXG5cdHRoaXMuaGFsZkJvbmRzLmNsZWFyKCk7XHJcblx0dGhpcy5ib25kcy5lYWNoKHRoaXMuYm9uZEluaXRIYWxmQm9uZHMsIHRoaXMpO1xyXG59O1xyXG5cclxuU3RydWN0LnByb3RvdHlwZS5zZXRIYk5leHQgPSBmdW5jdGlvbiAoaGJpZCwgbmV4dClcclxue1xyXG5cdHRoaXMuaGFsZkJvbmRzLmdldCh0aGlzLmhhbGZCb25kcy5nZXQoaGJpZCkuY29udHJhKS5uZXh0ID0gbmV4dDtcclxufTtcclxuXHJcblN0cnVjdC5wcm90b3R5cGUuaGFsZkJvbmRTZXRBbmdsZSA9IGZ1bmN0aW9uIChoYmlkLCBsZWZ0KVxyXG57XHJcblx0dmFyIGhiID0gdGhpcy5oYWxmQm9uZHMuZ2V0KGhiaWQpO1xyXG5cdHZhciBoYmwgPSB0aGlzLmhhbGZCb25kcy5nZXQobGVmdCk7XHJcblx0aGJsLnJpZ2h0Q29zID0gaGIubGVmdENvcyA9IFZlYzIuZG90KGhibC5kaXIsIGhiLmRpcik7XHJcblx0aGJsLnJpZ2h0U2luID0gaGIubGVmdFNpbiA9IFZlYzIuY3Jvc3MoaGJsLmRpciwgaGIuZGlyKTtcclxuXHRoYi5sZWZ0TmVpZ2hib3IgPSBsZWZ0O1xyXG5cdGhibC5yaWdodE5laWdoYm9yID0gaGJpZDtcclxufTtcclxuXHJcblN0cnVjdC5wcm90b3R5cGUuYXRvbUFkZE5laWdoYm9yID0gZnVuY3Rpb24gKGhiaWQpXHJcbntcclxuXHR2YXIgaGIgPSB0aGlzLmhhbGZCb25kcy5nZXQoaGJpZCk7XHJcblx0dmFyIGF0b20gPSB0aGlzLmF0b21zLmdldChoYi5iZWdpbik7XHJcblx0dmFyIGkgPSAwO1xyXG5cdGZvciAoaSA9IDA7IGkgPCBhdG9tLm5laWdoYm9ycy5sZW5ndGg7ICsraSlcclxuXHRcdGlmICh0aGlzLmhhbGZCb25kcy5nZXQoYXRvbS5uZWlnaGJvcnNbaV0pLmFuZyA+IGhiLmFuZylcclxuXHRcdFx0YnJlYWs7XHJcblx0YXRvbS5uZWlnaGJvcnMuc3BsaWNlKGksIDAsIGhiaWQpO1xyXG5cdHZhciBpciA9IGF0b20ubmVpZ2hib3JzWyhpICsgMSkgJSBhdG9tLm5laWdoYm9ycy5sZW5ndGhdO1xyXG5cdHZhciBpbCA9IGF0b20ubmVpZ2hib3JzWyhpICsgYXRvbS5uZWlnaGJvcnMubGVuZ3RoIC0gMSlcclxuXHRcdFx0ICUgYXRvbS5uZWlnaGJvcnMubGVuZ3RoXTtcclxuXHR0aGlzLnNldEhiTmV4dChpbCwgaGJpZCk7XHJcblx0dGhpcy5zZXRIYk5leHQoaGJpZCwgaXIpO1xyXG5cdHRoaXMuaGFsZkJvbmRTZXRBbmdsZShoYmlkLCBpbCk7XHJcblx0dGhpcy5oYWxmQm9uZFNldEFuZ2xlKGlyLCBoYmlkKTtcclxufTtcclxuXHJcblN0cnVjdC5wcm90b3R5cGUuYXRvbVNvcnROZWlnaGJvcnMgPSBmdW5jdGlvbiAoYWlkKSB7XHJcblx0dmFyIGF0b20gPSB0aGlzLmF0b21zLmdldChhaWQpO1xyXG5cdGF0b20ubmVpZ2hib3JzID0gYXRvbS5uZWlnaGJvcnMuc29ydEJ5KGZ1bmN0aW9uIChuZWkpe1xyXG5cdFx0cmV0dXJuIHRoaXMuaGFsZkJvbmRzLmdldChuZWkpLmFuZztcclxuXHR9LCB0aGlzKTtcclxuXHJcblx0dmFyIGk7XHJcblx0Zm9yIChpID0gMDsgaSA8IGF0b20ubmVpZ2hib3JzLmxlbmd0aDsgKytpKVxyXG5cdFx0dGhpcy5oYWxmQm9uZHMuZ2V0KHRoaXMuaGFsZkJvbmRzLmdldChhdG9tLm5laWdoYm9yc1tpXSkuY29udHJhKS5uZXh0ID1cclxuXHRcdFx0YXRvbS5uZWlnaGJvcnNbKGkgKyAxKSAlIGF0b20ubmVpZ2hib3JzLmxlbmd0aF07XHJcblx0Zm9yIChpID0gMDsgaSA8IGF0b20ubmVpZ2hib3JzLmxlbmd0aDsgKytpKVxyXG5cdFx0dGhpcy5oYWxmQm9uZFNldEFuZ2xlKGF0b20ubmVpZ2hib3JzWyhpICsgMSkgJSBhdG9tLm5laWdoYm9ycy5sZW5ndGhdLFxyXG5cdFx0XHRhdG9tLm5laWdoYm9yc1tpXSk7XHJcbn07XHJcblxyXG5TdHJ1Y3QucHJvdG90eXBlLnNvcnROZWlnaGJvcnMgPSBmdW5jdGlvbiAobGlzdCkge1xyXG5cdHZhciBmID0gZnVuY3Rpb24gKGFpZCkgeyB0aGlzLmF0b21Tb3J0TmVpZ2hib3JzKGFpZCk7IH07XHJcblx0aWYgKHV0aWwuaXNOdWxsT3JVbmRlZmluZWQobGlzdCkpXHJcblx0XHR0aGlzLmF0b21zLmVhY2goZiwgdGhpcyk7XHJcblx0ZWxzZVxyXG5cdFx0dXRpbC5lYWNoKGxpc3QsIGYsIHRoaXMpO1xyXG59O1xyXG5cclxuU3RydWN0LnByb3RvdHlwZS5hdG9tVXBkYXRlSGFsZkJvbmRzID0gZnVuY3Rpb24gKGFpZCkge1xyXG5cdHZhciBuZWkgPSB0aGlzLmF0b21zLmdldChhaWQpLm5laWdoYm9ycztcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IG5laS5sZW5ndGg7ICsraSkge1xyXG5cdFx0dmFyIGhiaWQgPSBuZWlbaV07XHJcblx0XHR0aGlzLmhhbGZCb25kVXBkYXRlKGhiaWQpO1xyXG5cdFx0dGhpcy5oYWxmQm9uZFVwZGF0ZSh0aGlzLmhhbGZCb25kcy5nZXQoaGJpZCkuY29udHJhKTtcclxuXHR9XHJcbn07XHJcblxyXG5TdHJ1Y3QucHJvdG90eXBlLnVwZGF0ZUhhbGZCb25kcyA9IGZ1bmN0aW9uIChsaXN0KSB7XHJcblx0dmFyIGYgPSBmdW5jdGlvbiAoYWlkKSB7IHRoaXMuYXRvbVVwZGF0ZUhhbGZCb25kcyhhaWQpOyB9O1xyXG5cdGlmICh1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGxpc3QpKVxyXG5cdFx0dGhpcy5hdG9tcy5lYWNoKGYsIHRoaXMpO1xyXG5cdGVsc2VcclxuXHRcdHV0aWwuZWFjaChsaXN0LCBmLCB0aGlzKTtcclxufTtcclxuXHJcblN0cnVjdC5wcm90b3R5cGUuc0dyb3Vwc1JlY2FsY0Nyb3NzQm9uZHMgPSBmdW5jdGlvbiAoKSB7XHJcblx0dGhpcy5zZ3JvdXBzLmVhY2goZnVuY3Rpb24gKHNnaWQsIHNnKXtcclxuXHRcdHNnLnhCb25kcyA9IFtdO1xyXG5cdFx0c2cubmVpQXRvbXMgPSBbXTtcclxuXHR9LHRoaXMpO1xyXG5cdHRoaXMuYm9uZHMuZWFjaChmdW5jdGlvbiAoYmlkLCBib25kKXtcclxuXHRcdHZhciBhMSA9IHRoaXMuYXRvbXMuZ2V0KGJvbmQuYmVnaW4pO1xyXG5cdFx0dmFyIGEyID0gdGhpcy5hdG9tcy5nZXQoYm9uZC5lbmQpO1xyXG5cdFx0U2V0LmVhY2goYTEuc2dzLCBmdW5jdGlvbiAoc2dpZCl7XHJcblx0XHRcdGlmICghU2V0LmNvbnRhaW5zKGEyLnNncywgc2dpZCkpIHtcclxuXHRcdFx0XHR2YXIgc2cgPSB0aGlzLnNncm91cHMuZ2V0KHNnaWQpO1xyXG5cdFx0XHRcdHNnLnhCb25kcy5wdXNoKGJpZCk7XHJcblx0XHRcdFx0dXRpbC5hcnJheUFkZElmTWlzc2luZyhzZy5uZWlBdG9tcywgYm9uZC5lbmQpO1xyXG5cdFx0XHR9XHJcblx0XHR9LCB0aGlzKTtcclxuXHRcdFNldC5lYWNoKGEyLnNncywgZnVuY3Rpb24gKHNnaWQpe1xyXG5cdFx0XHRpZiAoIVNldC5jb250YWlucyhhMS5zZ3MsIHNnaWQpKSB7XHJcblx0XHRcdFx0dmFyIHNnID0gdGhpcy5zZ3JvdXBzLmdldChzZ2lkKTtcclxuXHRcdFx0XHRzZy54Qm9uZHMucHVzaChiaWQpO1xyXG5cdFx0XHRcdHV0aWwuYXJyYXlBZGRJZk1pc3Npbmcoc2cubmVpQXRvbXMsIGJvbmQuYmVnaW4pO1xyXG5cdFx0XHR9XHJcblx0XHR9LCB0aGlzKTtcclxuXHR9LHRoaXMpO1xyXG59O1xyXG5cclxuU3RydWN0LnByb3RvdHlwZS5zR3JvdXBEZWxldGUgPSBmdW5jdGlvbiAoc2dpZClcclxue1xyXG5cdHZhciBzZyA9IHRoaXMuc2dyb3Vwcy5nZXQoc2dpZCk7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzZy5hdG9tcy5sZW5ndGg7ICsraSkge1xyXG5cdFx0U2V0LnJlbW92ZSh0aGlzLmF0b21zLmdldChzZy5hdG9tc1tpXSkuc2dzLCBzZ2lkKTtcclxuXHR9XHJcblx0dGhpcy5zR3JvdXBGb3Jlc3QucmVtb3ZlKHNnaWQpO1xyXG5cdHRoaXMuc2dyb3Vwcy5yZW1vdmUoc2dpZCk7XHJcbn07XHJcblxyXG5TdHJ1Y3QuaXRlbVNldFBvcyA9IGZ1bmN0aW9uIChpdGVtLCBwcCkgLy8gVE9ETzogcmVtb3ZlXHJcbntcclxuXHRpdGVtLnBwID0gcHA7XHJcbn07XHJcblxyXG5TdHJ1Y3QucHJvdG90eXBlLl9pdGVtU2V0UG9zID0gZnVuY3Rpb24gKG1hcCwgaWQsIHBwLCBzY2FsZUZhY3Rvcilcclxue1xyXG5cdFN0cnVjdC5pdGVtU2V0UG9zKHRoaXNbbWFwXS5nZXQoaWQpLCBwcCwgc2NhbGVGYWN0b3IpO1xyXG59O1xyXG5cclxuU3RydWN0LnByb3RvdHlwZS5fYXRvbVNldFBvcyA9IGZ1bmN0aW9uIChpZCwgcHAsIHNjYWxlRmFjdG9yKVxyXG57XHJcblx0dGhpcy5faXRlbVNldFBvcygnYXRvbXMnLCBpZCwgcHAsIHNjYWxlRmFjdG9yKTtcclxufTtcclxuXHJcblN0cnVjdC5wcm90b3R5cGUuX3J4blBsdXNTZXRQb3MgPSBmdW5jdGlvbiAoaWQsIHBwLCBzY2FsZUZhY3Rvcilcclxue1xyXG5cdHRoaXMuX2l0ZW1TZXRQb3MoJ3J4blBsdXNlcycsIGlkLCBwcCwgc2NhbGVGYWN0b3IpO1xyXG59O1xyXG5cclxuU3RydWN0LnByb3RvdHlwZS5fcnhuQXJyb3dTZXRQb3MgPSBmdW5jdGlvbiAoaWQsIHBwLCBzY2FsZUZhY3Rvcilcclxue1xyXG5cdHRoaXMuX2l0ZW1TZXRQb3MoJ3J4bkFycm93cycsIGlkLCBwcCwgc2NhbGVGYWN0b3IpO1xyXG59O1xyXG5cclxuU3RydWN0LnByb3RvdHlwZS5nZXRDb29yZEJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKGF0b21TZXQpXHJcbntcclxuXHR2YXIgYmIgPSBudWxsO1xyXG5cdHZhciBleHRlbmQgPSBmdW5jdGlvbiAocHApIHtcclxuXHRcdGlmICghYmIpXHJcblx0XHRcdGJiID0ge1xyXG5cdFx0XHRcdG1pbjogcHAsXHJcblx0XHRcdFx0bWF4OiBwcFxyXG5cdFx0XHR9O1xyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdGJiLm1pbiA9IFZlYzIubWluKGJiLm1pbiwgcHApO1xyXG5cdFx0XHRiYi5tYXggPSBWZWMyLm1heChiYi5tYXgsIHBwKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHR2YXIgZ2xvYmFsID0gdHlwZW9mKGF0b21TZXQpID09ICd1bmRlZmluZWQnO1xyXG5cclxuXHR0aGlzLmF0b21zLmVhY2goZnVuY3Rpb24gKGFpZCwgYXRvbSkge1xyXG5cdFx0aWYgKGdsb2JhbCB8fCBTZXQuY29udGFpbnMoYXRvbVNldCwgYWlkKSlcclxuXHRcdFx0ZXh0ZW5kKGF0b20ucHApO1xyXG5cdH0pO1xyXG5cdGlmIChnbG9iYWwpIHtcclxuXHRcdHRoaXMucnhuUGx1c2VzLmVhY2goZnVuY3Rpb24gKGlkLCBpdGVtKSB7XHJcblx0XHRcdGV4dGVuZChpdGVtLnBwKTtcclxuXHRcdH0pO1xyXG5cdFx0dGhpcy5yeG5BcnJvd3MuZWFjaChmdW5jdGlvbiAoaWQsIGl0ZW0pIHtcclxuXHRcdFx0ZXh0ZW5kKGl0ZW0ucHApO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cdGlmICghYmIgJiYgZ2xvYmFsKVxyXG5cdFx0YmIgPSB7XHJcblx0XHRcdG1pbjogbmV3IFZlYzIoMCwgMCksXHJcblx0XHRcdG1heDogbmV3IFZlYzIoMSwgMSlcclxuXHRcdH07XHJcblx0cmV0dXJuIGJiO1xyXG59O1xyXG5cclxuU3RydWN0LnByb3RvdHlwZS5nZXRDb29yZEJvdW5kaW5nQm94T2JqID0gZnVuY3Rpb24gKClcclxue1xyXG5cdHZhciBiYiA9IG51bGw7XHJcblx0dmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChwcCkge1xyXG5cdFx0aWYgKCFiYilcclxuXHRcdFx0YmIgPSB7XHJcblx0XHRcdFx0bWluOiBuZXcgVmVjMihwcCksXHJcblx0XHRcdFx0bWF4OiBuZXcgVmVjMihwcClcclxuXHRcdFx0fTtcclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRiYi5taW4gPSBWZWMyLm1pbihiYi5taW4sIHBwKTtcclxuXHRcdFx0YmIubWF4ID0gVmVjMi5tYXgoYmIubWF4LCBwcCk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0dGhpcy5hdG9tcy5lYWNoKGZ1bmN0aW9uIChhaWQsIGF0b20pIHtcclxuXHRcdGV4dGVuZChhdG9tLnBwKTtcclxuXHR9KTtcclxuXHRyZXR1cm4gYmI7XHJcbn07XHJcblxyXG5TdHJ1Y3QucHJvdG90eXBlLmdldEJvbmRMZW5ndGhEYXRhID0gZnVuY3Rpb24gKClcclxue1xyXG5cdHZhciB0b3RhbExlbmd0aCA9IDA7XHJcblx0dmFyIGNudCA9IDA7XHJcblx0dGhpcy5ib25kcy5lYWNoKGZ1bmN0aW9uIChiaWQsIGJvbmQpe1xyXG5cdFx0dG90YWxMZW5ndGggKz0gVmVjMi5kaXN0KFxyXG5cdFx0XHR0aGlzLmF0b21zLmdldChib25kLmJlZ2luKS5wcCxcclxuXHRcdFx0dGhpcy5hdG9tcy5nZXQoYm9uZC5lbmQpLnBwKTtcclxuXHRcdGNudCsrO1xyXG5cdH0sIHRoaXMpO1xyXG5cdHJldHVybiB7Y250OmNudCwgdG90YWxMZW5ndGg6dG90YWxMZW5ndGh9O1xyXG59O1xyXG5cclxuU3RydWN0LnByb3RvdHlwZS5nZXRBdmdCb25kTGVuZ3RoID0gZnVuY3Rpb24gKClcclxue1xyXG5cdHZhciBibGQgPSB0aGlzLmdldEJvbmRMZW5ndGhEYXRhKCk7XHJcblx0cmV0dXJuIGJsZC5jbnQgPiAwID8gYmxkLnRvdGFsTGVuZ3RoIC8gYmxkLmNudCA6IC0xO1xyXG59O1xyXG5cclxuU3RydWN0LnByb3RvdHlwZS5nZXRBdmdDbG9zZXN0QXRvbURpc3RhbmNlID0gZnVuY3Rpb24gKClcclxue1xyXG5cdHZhciB0b3RhbERpc3QgPSAwLCBtaW5EaXN0LCBkaXN0ID0gMDtcclxuXHR2YXIga2V5cyA9IHRoaXMuYXRvbXMua2V5cygpLCBrLCBqO1xyXG5cdGZvciAoayA9IDA7IGsgPCBrZXlzLmxlbmd0aDsgKytrKSB7XHJcblx0XHRtaW5EaXN0ID0gLTE7XHJcblx0XHRmb3IgKGogPSAwOyBqIDwga2V5cy5sZW5ndGg7ICsraikge1xyXG5cdFx0XHRpZiAoaiA9PSBrKVxyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRkaXN0ID0gVmVjMi5kaXN0KHRoaXMuYXRvbXMuZ2V0KGtleXNbal0pLnBwLCB0aGlzLmF0b21zLmdldChrZXlzW2tdKS5wcCk7XHJcblx0XHRcdGlmIChtaW5EaXN0IDwgMCB8fCBtaW5EaXN0ID4gZGlzdClcclxuXHRcdFx0XHRtaW5EaXN0ID0gZGlzdDtcclxuXHRcdH1cclxuXHRcdHRvdGFsRGlzdCArPSBtaW5EaXN0O1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGtleXMubGVuZ3RoID4gMCA/IHRvdGFsRGlzdCAvIGtleXMubGVuZ3RoIDogLTE7XHJcbn07XHJcblxyXG5TdHJ1Y3QucHJvdG90eXBlLmNoZWNrQm9uZEV4aXN0cyA9IGZ1bmN0aW9uIChiZWdpbiwgZW5kKVxyXG57XHJcblx0dmFyIGJvbmRFeGlzdHMgPSBmYWxzZTtcclxuXHR0aGlzLmJvbmRzLmVhY2goZnVuY3Rpb24gKGJpZCwgYm9uZCl7XHJcblx0XHRpZiAoKGJvbmQuYmVnaW4gPT0gYmVnaW4gJiYgYm9uZC5lbmQgPT0gZW5kKSB8fFxyXG5cdFx0KGJvbmQuZW5kID09IGJlZ2luICYmIGJvbmQuYmVnaW4gPT0gZW5kKSlcclxuXHRcdFx0Ym9uZEV4aXN0cyA9IHRydWU7XHJcblx0fSwgdGhpcyk7XHJcblx0cmV0dXJuIGJvbmRFeGlzdHM7XHJcbn07XHJcblxyXG52YXIgTG9vcCA9IGZ1bmN0aW9uICgvKkFycmF5IG9mIG51bSovaGJzLCAvKlN0cnVjdCovc3RydWN0LCAvKmJvb2wqL2NvbnZleClcclxue1xyXG5cdHRoaXMuaGJzID0gaGJzOyAvLyBzZXQgb2YgaGFsZi1ib25kcyBpbnZvbHZlZFxyXG5cdHRoaXMuZGJsQm9uZHMgPSAwOyAvLyBudW1iZXIgb2YgZG91YmxlIGJvbmRzIGluIHRoZSBsb29wXHJcblx0dGhpcy5hcm9tYXRpYyA9IHRydWU7XHJcblx0dGhpcy5jb252ZXggPSBjb252ZXggfHwgZmFsc2U7XHJcblxyXG5cdGhicy5lYWNoKGZ1bmN0aW9uIChoYil7XHJcblx0XHR2YXIgYm9uZCA9IHN0cnVjdC5ib25kcy5nZXQoc3RydWN0LmhhbGZCb25kcy5nZXQoaGIpLmJpZCk7XHJcblx0XHRpZiAoYm9uZC50eXBlICE9IEJvbmQuUEFUVEVSTi5UWVBFLkFST01BVElDKVxyXG5cdFx0XHR0aGlzLmFyb21hdGljID0gZmFsc2U7XHJcblx0XHRpZiAoYm9uZC50eXBlID09IEJvbmQuUEFUVEVSTi5UWVBFLkRPVUJMRSlcclxuXHRcdFx0dGhpcy5kYmxCb25kcysrO1xyXG5cdH0sIHRoaXMpO1xyXG59O1xyXG5cclxuU3RydWN0LlJ4blBsdXMgPSBmdW5jdGlvbiAocGFyYW1zKVxyXG57XHJcblx0cGFyYW1zID0gcGFyYW1zIHx8IHt9O1xyXG5cdHRoaXMucHAgPSBwYXJhbXMucHAgPyBuZXcgVmVjMihwYXJhbXMucHApIDogbmV3IFZlYzIoKTtcclxufTtcclxuXHJcblN0cnVjdC5SeG5QbHVzLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpXHJcbntcclxuXHRyZXR1cm4gbmV3IFN0cnVjdC5SeG5QbHVzKHRoaXMpO1xyXG59O1xyXG5cclxuU3RydWN0LlJ4bkFycm93ID0gZnVuY3Rpb24gKHBhcmFtcylcclxue1xyXG5cdHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcclxuXHR0aGlzLnBwID0gcGFyYW1zLnBwID8gbmV3IFZlYzIocGFyYW1zLnBwKSA6IG5ldyBWZWMyKCk7XHJcbn07XHJcblxyXG5TdHJ1Y3QuUnhuQXJyb3cucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKClcclxue1xyXG5cdHJldHVybiBuZXcgU3RydWN0LlJ4bkFycm93KHRoaXMpO1xyXG59O1xyXG5cclxuU3RydWN0LnByb3RvdHlwZS5maW5kQ29ubmVjdGVkQ29tcG9uZW50ID0gZnVuY3Rpb24gKGFpZCkge1xyXG5cdHZhciBtYXAgPSB7fTtcclxuXHR2YXIgbGlzdCA9IFthaWRdO1xyXG5cdHZhciBpZHMgPSBTZXQuZW1wdHkoKTtcclxuXHR3aGlsZSAobGlzdC5sZW5ndGggPiAwKSB7XHJcblx0XHQoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR2YXIgYWlkID0gbGlzdC5wb3AoKTtcclxuXHRcdFx0bWFwW2FpZF0gPSAxO1xyXG5cdFx0XHRTZXQuYWRkKGlkcywgYWlkKTtcclxuXHRcdFx0dmFyIGF0b20gPSB0aGlzLmF0b21zLmdldChhaWQpO1xyXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGF0b20ubmVpZ2hib3JzLmxlbmd0aDsgKytpKSB7XHJcblx0XHRcdFx0dmFyIG5laUlkID0gdGhpcy5oYWxmQm9uZHMuZ2V0KGF0b20ubmVpZ2hib3JzW2ldKS5lbmQ7XHJcblx0XHRcdFx0aWYgKCFTZXQuY29udGFpbnMoaWRzLCBuZWlJZCkpXHJcblx0XHRcdFx0XHRsaXN0LnB1c2gobmVpSWQpO1xyXG5cdFx0XHR9XHJcblx0XHR9KS5hcHBseSh0aGlzKTtcclxuXHR9XHJcblx0cmV0dXJuIGlkcztcclxufTtcclxuXHJcblN0cnVjdC5wcm90b3R5cGUuZmluZENvbm5lY3RlZENvbXBvbmVudHMgPSBmdW5jdGlvbiAoZGlzY2FyZEV4aXN0aW5nRnJhZ21lbnRzKSB7XHJcblx0Ly8gTkI6IHRoaXMgaXMgYSBoYWNrXHJcblx0Ly8gVE9ETzogbmVlZCB0byBtYWludGFpbiBoYWxmLWJvbmQgYW5kIG5laWdoYm9yIHN0cnVjdHVyZSBwZXJtYW5lbnRseVxyXG5cdGlmICghdGhpcy5oYWxmQm9uZHMuY291bnQoKSkge1xyXG5cdFx0dGhpcy5pbml0SGFsZkJvbmRzKCk7XHJcblx0XHR0aGlzLmluaXROZWlnaGJvcnMoKTtcclxuXHRcdHRoaXMudXBkYXRlSGFsZkJvbmRzKHRoaXMuYXRvbXMua2V5cygpKTtcclxuXHRcdHRoaXMuc29ydE5laWdoYm9ycyh0aGlzLmF0b21zLmtleXMoKSk7XHJcblx0fVxyXG5cclxuXHR2YXIgbWFwID0ge307XHJcblx0dGhpcy5hdG9tcy5lYWNoKGZ1bmN0aW9uIChhaWQpIHtcclxuXHRcdG1hcFthaWRdID0gLTE7XHJcblx0fSwgdGhpcyk7XHJcblx0dmFyIGNvbXBvbmVudHMgPSBbXTtcclxuXHR0aGlzLmF0b21zLmVhY2goZnVuY3Rpb24gKGFpZCxhdG9tKXtcclxuXHRcdGlmICgoZGlzY2FyZEV4aXN0aW5nRnJhZ21lbnRzIHx8IGF0b20uZnJhZ21lbnQgPCAwKSAmJiBtYXBbYWlkXSA8IDApIHtcclxuXHRcdFx0dmFyIGNvbXBvbmVudCA9IHRoaXMuZmluZENvbm5lY3RlZENvbXBvbmVudChhaWQpO1xyXG5cdFx0XHRjb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcclxuXHRcdFx0U2V0LmVhY2goY29tcG9uZW50LCBmdW5jdGlvbiAoYWlkKXtcclxuXHRcdFx0XHRtYXBbYWlkXSA9IDE7XHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sIHRoaXMpO1xyXG5cdHJldHVybiBjb21wb25lbnRzO1xyXG59O1xyXG5cclxuU3RydWN0LnByb3RvdHlwZS5tYXJrRnJhZ21lbnQgPSBmdW5jdGlvbiAoaWRzKSB7XHJcblx0dmFyIGZpZCA9IHRoaXMuZnJhZ3MuYWRkKG5ldyBTdHJ1Y3QuRnJhZ21lbnQoKSk7XHJcblx0U2V0LmVhY2goaWRzLCBmdW5jdGlvbiAoYWlkKXtcclxuXHRcdHRoaXMuYXRvbXMuZ2V0KGFpZCkuZnJhZ21lbnQgPSBmaWQ7XHJcblx0fSwgdGhpcyk7XHJcbn07XHJcblxyXG5TdHJ1Y3QucHJvdG90eXBlLm1hcmtGcmFnbWVudEJ5QXRvbUlkID0gZnVuY3Rpb24gKGFpZCkge1xyXG5cdHRoaXMubWFya0ZyYWdtZW50KHRoaXMuZmluZENvbm5lY3RlZENvbXBvbmVudChhaWQpKTtcclxufTtcclxuXHJcblN0cnVjdC5wcm90b3R5cGUubWFya0ZyYWdtZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgY29tcG9uZW50cyA9IHRoaXMuZmluZENvbm5lY3RlZENvbXBvbmVudHMoKTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyArK2kpIHtcclxuXHRcdHRoaXMubWFya0ZyYWdtZW50KGNvbXBvbmVudHNbaV0pO1xyXG5cdH1cclxufTtcclxuXHJcblN0cnVjdC5GcmFnbWVudCA9IGZ1bmN0aW9uICgpIHtcclxufTtcclxuU3RydWN0LkZyYWdtZW50LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHRyZXR1cm4gT2JqZWN0LmNsb25lKHRoaXMpO1xyXG59O1xyXG5cclxuU3RydWN0LkZyYWdtZW50LmdldEF0b21zID0gZnVuY3Rpb24gKHN0cnVjdCwgZnJpZCkge1xyXG5cdHZhciBhdG9tcyA9IFtdO1xyXG5cdHN0cnVjdC5hdG9tcy5lYWNoKGZ1bmN0aW9uIChhaWQsIGF0b20pIHtcclxuXHRcdGlmIChhdG9tLmZyYWdtZW50ID09IGZyaWQpXHJcblx0XHRcdGF0b21zLnB1c2goYWlkKTtcclxuXHR9LCB0aGlzKTtcclxuXHRyZXR1cm4gYXRvbXM7XHJcbn1cclxuXHJcblN0cnVjdC5SR3JvdXAgPSBmdW5jdGlvbiAobG9naWMpIHtcclxuXHRsb2dpYyA9IGxvZ2ljIHx8IHt9O1xyXG5cdHRoaXMuZnJhZ3MgPSBuZXcgUG9vbCgpO1xyXG5cdHRoaXMucmVzdGggPSBsb2dpYy5yZXN0aCB8fCBmYWxzZTtcclxuXHR0aGlzLnJhbmdlID0gbG9naWMucmFuZ2UgfHwgJyc7XHJcblx0dGhpcy5pZnRoZW4gPSBsb2dpYy5pZnRoZW4gfHwgMDtcclxufTtcclxuXHJcblN0cnVjdC5SR3JvdXAucHJvdG90eXBlLmdldEF0dHJzID0gZnVuY3Rpb24gKCkge1xyXG5cdHJldHVybiB7XHJcblx0XHRyZXN0aDogdGhpcy5yZXN0aCxcclxuXHRcdHJhbmdlOiB0aGlzLnJhbmdlLFxyXG5cdFx0aWZ0aGVuOiB0aGlzLmlmdGhlblxyXG5cdH07XHJcbn07XHJcblxyXG5TdHJ1Y3QuUkdyb3VwLmZpbmRSR3JvdXBCeUZyYWdtZW50ID0gZnVuY3Rpb24gKHJncm91cHMsIGZyaWQpIHtcclxuXHR2YXIgcmV0O1xyXG5cdHJncm91cHMuZWFjaChmdW5jdGlvbiAocmdpZCwgcmdyb3VwKSB7XHJcblx0XHRpZiAoIU9iamVjdC5pc1VuZGVmaW5lZChyZ3JvdXAuZnJhZ3Mua2V5T2YoZnJpZCkpKSByZXQgPSByZ2lkO1xyXG5cdH0pO1xyXG5cdHJldHVybiByZXQ7XHJcbn07XHJcblN0cnVjdC5SR3JvdXAucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKGZpZE1hcCkge1xyXG5cdHZhciByZXQgPSBuZXcgU3RydWN0LlJHcm91cCh0aGlzKTtcclxuXHR0aGlzLmZyYWdzLmVhY2goZnVuY3Rpb24gKGZudW0sIGZpZCkge1xyXG5cdFx0cmV0LmZyYWdzLmFkZChmaWRNYXAgPyBmaWRNYXBbZmlkXSA6IGZpZCk7XHJcblx0fSk7XHJcblx0cmV0dXJuIHJldDtcclxufTtcclxuXHJcblN0cnVjdC5wcm90b3R5cGUuc2NhbGUgPSBmdW5jdGlvbiAoc2NhbGUpXHJcbntcclxuXHRpZiAoc2NhbGUgIT0gMSkge1xyXG5cdFx0dGhpcy5hdG9tcy5lYWNoKGZ1bmN0aW9uIChhaWQsIGF0b20pe1xyXG5cdFx0XHRhdG9tLnBwID0gYXRvbS5wcC5zY2FsZWQoc2NhbGUpO1xyXG5cdFx0fSwgdGhpcyk7XHJcblx0XHR0aGlzLnJ4blBsdXNlcy5lYWNoKGZ1bmN0aW9uIChpZCwgaXRlbSl7XHJcblx0XHRcdGl0ZW0ucHAgPSBpdGVtLnBwLnNjYWxlZChzY2FsZSk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHRcdHRoaXMucnhuQXJyb3dzLmVhY2goZnVuY3Rpb24gKGlkLCBpdGVtKXtcclxuXHRcdFx0aXRlbS5wcCA9IGl0ZW0ucHAuc2NhbGVkKHNjYWxlKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdFx0dGhpcy5zZ3JvdXBzLmVhY2goZnVuY3Rpb24gKGlkLCBpdGVtKXtcclxuXHRcdFx0aXRlbS5wcCA9IGl0ZW0ucHAgPyBpdGVtLnBwLnNjYWxlZChzY2FsZSkgOiBudWxsO1xyXG5cdFx0fSwgdGhpcyk7XHJcblx0fVxyXG59O1xyXG5cclxuU3RydWN0LnByb3RvdHlwZS5yZXNjYWxlID0gZnVuY3Rpb24gKClcclxue1xyXG5cdHZhciBhdmcgPSB0aGlzLmdldEF2Z0JvbmRMZW5ndGgoKTtcclxuXHRpZiAoYXZnIDwgMCAmJiAhdGhpcy5pc1JlYWN0aW9uKSAvLyBUT0RPIFtNS10gdGhpcyBkb2Vzbid0IHdvcmsgd2VsbCBmb3IgcmVhY3Rpb25zIGFzIHRoZSBkaXN0YW5jZXMgYmV0d2VlblxyXG5cdFx0Ly8gdGhlIGF0b21zIGluIGRpZmZlcmVudCBjb21wb25lbnRzIGFyZSBnZW5lcmFsbHkgbGFyZ2VyIHRoYW4gdGhvc2UgYmV0d2VlbiBhdG9tcyBvZiBhIHNpbmdsZSBjb21wb25lbnRcclxuXHRcdC8vIChLRVRDSEVSLTM0MSlcclxuXHRcdGF2ZyA9IHRoaXMuZ2V0QXZnQ2xvc2VzdEF0b21EaXN0YW5jZSgpO1xyXG5cdGlmIChhdmcgPCAxZS0zKVxyXG5cdFx0YXZnID0gMTtcclxuXHR2YXIgc2NhbGUgPSAxIC8gYXZnO1xyXG5cdHRoaXMuc2NhbGUoc2NhbGUpO1xyXG59O1xyXG5cclxuU3RydWN0LnByb3RvdHlwZS5sb29wSGFzU2VsZkludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiAoaGJzKVxyXG57XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBoYnMubGVuZ3RoOyArK2kpIHtcclxuXHRcdHZhciBoYmkgPSB0aGlzLmhhbGZCb25kcy5nZXQoaGJzW2ldKTtcclxuXHRcdHZhciBhaSA9IHRoaXMuYXRvbXMuZ2V0KGhiaS5iZWdpbikucHA7XHJcblx0XHR2YXIgYmkgPSB0aGlzLmF0b21zLmdldChoYmkuZW5kKS5wcDtcclxuXHRcdHZhciBzZXQgPSBTZXQuZnJvbUxpc3QoW2hiaS5iZWdpbiwgaGJpLmVuZF0pO1xyXG5cdFx0Zm9yICh2YXIgaiA9IGkgKyAyOyBqIDwgaGJzLmxlbmd0aDsgKytqKSB7XHJcblx0XHRcdHZhciBoYmogPSB0aGlzLmhhbGZCb25kcy5nZXQoaGJzW2pdKTtcclxuXHRcdFx0aWYgKFNldC5jb250YWlucyhzZXQsIGhiai5iZWdpbikgfHwgU2V0LmNvbnRhaW5zKHNldCwgaGJqLmVuZCkpXHJcblx0XHRcdFx0Y29udGludWU7IC8vIHNraXAgZWRnZXMgc2hhcmluZyBhbiBhdG9tXHJcblx0XHRcdHZhciBhaiA9IHRoaXMuYXRvbXMuZ2V0KGhiai5iZWdpbikucHA7XHJcblx0XHRcdHZhciBiaiA9IHRoaXMuYXRvbXMuZ2V0KGhiai5lbmQpLnBwO1xyXG5cdFx0XHRpZiAoVmVjMi5zZWdtZW50SW50ZXJzZWN0aW9uKGFpLCBiaSwgYWosIGJqKSkge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuLy8gcGFydGl0aW9uIGEgY3ljbGUgaW50byBzaW1wbGUgY3ljbGVzXHJcbi8vIFRPRE86IFtNS10gcmV3cml0ZSB0aGUgZGV0ZWN0aW9uIGFsZ29yaXRobSB0byBvbmx5IGZpbmQgc2ltcGxlIG9uZXMgcmlnaHQgYXdheT9cclxuU3RydWN0LnByb3RvdHlwZS5wYXJ0aXRpb25Mb29wID0gZnVuY3Rpb24gKGxvb3ApIHtcclxuXHR2YXIgc3VibG9vcHMgPSBbXTtcclxuXHR2YXIgY29udGludWVGbGFnID0gdHJ1ZTtcclxuXHRzZWFyY2g6IHdoaWxlIChjb250aW51ZUZsYWcpIHtcclxuXHRcdFx0dmFyIGF0b21Ub0hhbGZCb25kID0ge307IC8vIG1hcCBmcm9tIGV2ZXJ5IGF0b20gaW4gdGhlIGxvb3AgdG8gdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBoYWxmLWJvbmQgc3RhcnRpbmcgZnJvbSB0aGF0IGF0b20gaW4gdGhlIHVuaXFIYiBhcnJheVxyXG5cdFx0XHRmb3IgKHZhciBsID0gMDsgbCA8IGxvb3AubGVuZ3RoOyArK2wpIHtcclxuXHRcdFx0XHR2YXIgaGJpZCA9IGxvb3BbbF07XHJcblx0XHRcdFx0dmFyIGFpZDEgPSB0aGlzLmhhbGZCb25kcy5nZXQoaGJpZCkuYmVnaW47XHJcblx0XHRcdFx0dmFyIGFpZDIgPSB0aGlzLmhhbGZCb25kcy5nZXQoaGJpZCkuZW5kO1xyXG5cdFx0XHRcdGlmIChhaWQyIGluIGF0b21Ub0hhbGZCb25kKSB7IC8vIHN1Ymxvb3AgZm91bmRcclxuXHRcdFx0XHRcdHZhciBzID0gYXRvbVRvSGFsZkJvbmRbYWlkMl07IC8vIHdoZXJlIHRoZSBzdWJsb29wIGJlZ2luc1xyXG5cdFx0XHRcdFx0dmFyIHN1Ymxvb3AgPSBsb29wLnNsaWNlKHMsIGwgKyAxKTtcclxuXHRcdFx0XHRcdHN1Ymxvb3BzLnB1c2goc3VibG9vcCk7XHJcblx0XHRcdFx0XHRpZiAobCA8IGxvb3AubGVuZ3RoKSAvLyByZW1vdmUgaGFsZi1ib25kcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBzdWJsb29wXHJcblx0XHRcdFx0XHRcdGxvb3Auc3BsaWNlKHMsIGwgLSBzICsgMSk7XHJcblx0XHRcdFx0XHRjb250aW51ZSBzZWFyY2g7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGF0b21Ub0hhbGZCb25kW2FpZDFdID0gbDtcclxuXHRcdFx0fVxyXG5cdFx0XHRjb250aW51ZUZsYWcgPSBmYWxzZTsgLy8gd2UncmUgZG9uZSwgbm8gbW9yZSBzdWJsb29wcyBmb3VuZFxyXG5cdFx0XHRzdWJsb29wcy5wdXNoKGxvb3ApO1xyXG5cdFx0fVxyXG5cdHJldHVybiBzdWJsb29wcztcclxufVxyXG5cclxuU3RydWN0LnByb3RvdHlwZS5oYWxmQm9uZEFuZ2xlID0gZnVuY3Rpb24gKGhiaWQxLCBoYmlkMikge1xyXG5cdHZhciBoYmEgPSB0aGlzLmhhbGZCb25kcy5nZXQoaGJpZDEpO1xyXG5cdHZhciBoYmIgPSB0aGlzLmhhbGZCb25kcy5nZXQoaGJpZDIpO1xyXG5cdHJldHVybiBNYXRoLmF0YW4yKFxyXG5cdFZlYzIuY3Jvc3MoaGJhLmRpciwgaGJiLmRpciksXHJcblx0VmVjMi5kb3QoaGJhLmRpciwgaGJiLmRpcikpO1xyXG59XHJcblxyXG5TdHJ1Y3QucHJvdG90eXBlLmxvb3BJc0NvbnZleCA9IGZ1bmN0aW9uIChsb29wKSB7XHJcblx0Zm9yICh2YXIgayA9IDA7IGsgPCBsb29wLmxlbmd0aDsgKytrKSB7XHJcblx0XHR2YXIgYW5nbGUgPSB0aGlzLmhhbGZCb25kQW5nbGUobG9vcFtrXSwgbG9vcFsoayArIDEpICUgbG9vcC5sZW5ndGhdKTtcclxuXHRcdGlmIChhbmdsZSA+IDApXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblx0cmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbi8vIGNoZWNrIHdoZXRoZXIgYSBsb29wIGlzIG9uIHRoZSBpbm5lciBvciBvdXRlciBzaWRlIG9mIHRoZSBwb2x5Z29uXHJcbi8vICBieSBtZWFzdXJpbmcgdGhlIHRvdGFsIGFuZ2xlIGJldHdlZW4gYm9uZHNcclxuU3RydWN0LnByb3RvdHlwZS5sb29wSXNJbm5lciA9IGZ1bmN0aW9uIChsb29wKSB7XHJcblx0dmFyIHRvdGFsQW5nbGUgPSAyICogTWF0aC5QSTtcclxuXHRmb3IgKHZhciBrID0gMDsgayA8IGxvb3AubGVuZ3RoOyArK2spIHtcclxuXHRcdHZhciBoYmlkYSA9IGxvb3Bba107XHJcblx0XHR2YXIgaGJpZGIgPSBsb29wWyhrICsgMSkgJSBsb29wLmxlbmd0aF07XHJcblx0XHR2YXIgaGJiID0gdGhpcy5oYWxmQm9uZHMuZ2V0KGhiaWRiKTtcclxuXHRcdHZhciBhbmdsZSA9IHRoaXMuaGFsZkJvbmRBbmdsZShoYmlkYSwgaGJpZGIpO1xyXG5cdFx0aWYgKGhiYi5jb250cmEgPT0gbG9vcFtrXSkgLy8gYmFjayBhbmQgZm9ydGggYWxvbmcgdGhlIHNhbWUgZWRnZVxyXG5cdFx0XHR0b3RhbEFuZ2xlICs9IE1hdGguUEk7XHJcblx0XHRlbHNlXHJcblx0XHRcdHRvdGFsQW5nbGUgKz0gYW5nbGU7XHJcblx0fVxyXG5cdHJldHVybiBNYXRoLmFicyh0b3RhbEFuZ2xlKSA8IE1hdGguUEk7XHJcbn1cclxuXHJcblN0cnVjdC5wcm90b3R5cGUuZmluZExvb3BzID0gZnVuY3Rpb24gKClcclxue1xyXG5cdHZhciBuZXdMb29wcyA9IFtdO1xyXG5cdHZhciBib25kc1RvTWFyayA9IFNldC5lbXB0eSgpO1xyXG5cclxuXHQvLyBTdGFydGluZyBmcm9tIGVhY2ggaGFsZi1ib25kIG5vdCBrbm93biB0byBiZSBpbiBhIGxvb3AgeWV0LFxyXG5cdC8vICBmb2xsb3cgdGhlICduZXh0JyBsaW5rcyB1bnRpbCB0aGUgaW5pdGlhbCBoYWxmLWJvbmQgaXMgcmVhY2hlZCBvclxyXG5cdC8vICB0aGUgbGVuZ3RoIG9mIHRoZSBzZXF1ZW5jZSBleGNlZWRzIHRoZSBudW1iZXIgb2YgaGFsZi1ib25kcyBhdmFpbGFibGUuXHJcblx0Ly8gSW4gYSBwbGFuYXIgZ3JhcGgsIGFzIGxvbmcgYXMgZXZlcnkgYm9uZCBpcyBhIHBhcnQgb2Ygc29tZSBcImxvb3BcIiAtXHJcblx0Ly8gIGVpdGhlciBhbiBvdXRlciBvciBhbiBpbm5lciBvbmUgLSBldmVyeSBpdGVyYXRpb24gZWl0aGVyIHlpZWxkcyBhIGxvb3BcclxuXHQvLyAgb3IgZG9lc24ndCBzdGFydCBhdCBhbGwuIFRodXMgdGhpcyBoYXMgbGluZWFyIGNvbXBsZXhpdHkgaW4gdGhlIG51bWJlclxyXG5cdC8vICBvZiBib25kcyBmb3IgcGxhbmFyIGdyYXBocy5cclxuXHR2YXIgaiwgYywgbG9vcCwgbG9vcElkO1xyXG5cdHRoaXMuaGFsZkJvbmRzLmVhY2goZnVuY3Rpb24gKGksIGhiKSB7XHJcblx0XHRpZiAoaGIubG9vcCA9PSAtMSkge1xyXG5cdFx0XHRmb3IgKGogPSBpLCBjID0gMCwgbG9vcCA9IFtdO1xyXG5cdFx0XHRcdGMgPD0gdGhpcy5oYWxmQm9uZHMuY291bnQoKTtcclxuXHRcdFx0XHRqID0gdGhpcy5oYWxmQm9uZHMuZ2V0KGopLm5leHQsICsrYykge1xyXG5cdFx0XHRcdGlmIChjID4gMCAmJiBqID09IGkpIHsgLy8gbG9vcCBmb3VuZFxyXG5cdFx0XHRcdFx0dmFyIHN1Ymxvb3BzID0gdGhpcy5wYXJ0aXRpb25Mb29wKGxvb3ApO1xyXG5cdFx0XHRcdFx0dXRpbC5lYWNoKHN1Ymxvb3BzLCBmdW5jdGlvbiAobG9vcCkge1xyXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5sb29wSXNJbm5lcihsb29wKSAmJiAhdGhpcy5sb29wSGFzU2VsZkludGVyc2VjdGlvbnMobG9vcCkpIHsgLy8gbG9vcCBpcyBpbnRlcm5hbFxyXG5cdFx0XHRcdFx0XHRcdC8vIHVzZSBsb3dlc3QgaGFsZi1ib25kIGlkIGluIHRoZSBsb29wIGFzIHRoZSBsb29wIGlkXHJcblx0XHRcdFx0XHRcdFx0Ly8gdGhpcyBlbnN1cmVzIHRoYXQgdGhlIGxvb3AgZ2V0cyB0aGUgc2FtZSBpZCBpZiBpdCBpcyBkaXNjYXJkZWQgYW5kIHRoZW4gcmVjcmVhdGVkLFxyXG5cdFx0XHRcdFx0XHRcdC8vIHdoaWNoIGluIHR1cm4gaXMgcmVxdWlyZWQgdG8gZW5hYmxlIHJlZHJhd2luZyB3aGlsZSBkcmFnZ2luZywgYXMgYWN0aW9ucyBzdG9yZSBpdGVtIGlkJ3NcclxuXHRcdFx0XHRcdFx0XHRsb29wSWQgPSB1dGlsLmFycmF5TWluKGxvb3ApO1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMubG9vcHMuc2V0KGxvb3BJZCwgbmV3IExvb3AobG9vcCwgdGhpcywgdGhpcy5sb29wSXNDb252ZXgobG9vcCkpKTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRsb29wSWQgPSAtMjtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRsb29wLmVhY2goZnVuY3Rpb24gKGhiaWQpe1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuaGFsZkJvbmRzLmdldChoYmlkKS5sb29wID0gbG9vcElkO1xyXG5cdFx0XHRcdFx0XHRcdFNldC5hZGQoYm9uZHNUb01hcmssIHRoaXMuaGFsZkJvbmRzLmdldChoYmlkKS5iaWQpO1xyXG5cdFx0XHRcdFx0XHR9LCB0aGlzKTtcclxuXHRcdFx0XHRcdFx0aWYgKGxvb3BJZCA+PSAwKSB7XHJcblx0XHRcdFx0XHRcdFx0bmV3TG9vcHMucHVzaChsb29wSWQpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9LCB0aGlzKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRsb29wLnB1c2goaik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSwgdGhpcyk7XHJcblx0cmV0dXJuIHtcclxuXHRcdG5ld0xvb3BzOiBuZXdMb29wcyxcclxuXHRcdGJvbmRzVG9NYXJrOiBTZXQubGlzdChib25kc1RvTWFyaylcclxuXHR9O1xyXG59O1xyXG5cclxuLy8gTkI6IHRoaXMgdXBkYXRlcyB0aGUgc3RydWN0dXJlIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBjb3JyZXNwb25kaW5nIFJlU3RydWN0LlxyXG4vLyAgVG8gYmUgYXBwbGllZCB0byBzdGFuZGFsb25lIHN0cnVjdHVyZXMgb25seS5cclxuU3RydWN0LnByb3RvdHlwZS5wcmVwYXJlTG9vcFN0cnVjdHVyZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuaW5pdEhhbGZCb25kcygpO1xyXG4gICAgdGhpcy5pbml0TmVpZ2hib3JzKCk7XHJcbiAgICB0aGlzLnVwZGF0ZUhhbGZCb25kcyh0aGlzLmF0b21zLmtleXMoKSk7XHJcbiAgICB0aGlzLnNvcnROZWlnaGJvcnModGhpcy5hdG9tcy5rZXlzKCkpO1xyXG4gICAgdGhpcy5maW5kTG9vcHMoKTtcclxufTtcclxuXHJcblN0cnVjdC5wcm90b3R5cGUuYXRvbUFkZFRvU0dyb3VwID0gZnVuY3Rpb24gKHNnaWQsIGFpZCkge1xyXG4gICAgLy8gVE9ETzogW01LXSBtYWtlIHN1cmUgdGhlIGFkZGl0aW9uIGRvZXMgbm90IGJyZWFrIHRoZSBoaWVyYXJjaHk/XHJcbiAgICBTR3JvdXAuYWRkQXRvbSh0aGlzLnNncm91cHMuZ2V0KHNnaWQpLCBhaWQpO1xyXG4gICAgU2V0LmFkZCh0aGlzLmF0b21zLmdldChhaWQpLnNncywgc2dpZCk7XHJcbn07XHJcblxyXG5TdHJ1Y3QucHJvdG90eXBlLmNhbGNDb25uID0gZnVuY3Rpb24gKGFpZCkge1xyXG4gICAgdmFyIGNvbm4gPSAwO1xyXG4gICAgdmFyIGF0b20gPSB0aGlzLmF0b21zLmdldChhaWQpO1xyXG4gICAgdmFyIGhhc0Fyb21hdGljID0gZmFsc2U7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0b20ubmVpZ2hib3JzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgdmFyIGhiID0gdGhpcy5oYWxmQm9uZHMuZ2V0KGF0b20ubmVpZ2hib3JzW2ldKTtcclxuICAgICAgICB2YXIgYm9uZCA9IHRoaXMuYm9uZHMuZ2V0KGhiLmJpZCk7XHJcbiAgICAgICAgc3dpdGNoIChib25kLnR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBCb25kLlBBVFRFUk4uVFlQRS5TSU5HTEU6XHJcbiAgICAgICAgICAgICAgICBjb25uICs9IDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBCb25kLlBBVFRFUk4uVFlQRS5ET1VCTEU6XHJcbiAgICAgICAgICAgICAgICBjb25uICs9IDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBCb25kLlBBVFRFUk4uVFlQRS5UUklQTEU6XHJcbiAgICAgICAgICAgICAgICBjb25uICs9IDM7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBCb25kLlBBVFRFUk4uVFlQRS5BUk9NQVRJQzpcclxuICAgICAgICAgICAgICAgIGNvbm4gKz0gMTtcclxuICAgICAgICAgICAgICAgIGhhc0Fyb21hdGljID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChoYXNBcm9tYXRpYylcclxuICAgICAgICBjb25uICs9IDE7XHJcbiAgICByZXR1cm4gY29ubjtcclxufTtcclxuXHJcblN0cnVjdC5wcm90b3R5cGUuY2FsY0ltcGxpY2l0SHlkcm9nZW4gPSBmdW5jdGlvbiAoYWlkKSB7XHJcbiAgICB2YXIgY29ubiA9IHRoaXMuY2FsY0Nvbm4oYWlkKTtcclxuICAgIHZhciBhdG9tID0gdGhpcy5hdG9tcy5nZXQoYWlkKTtcclxuICAgIGF0b20uYmFkQ29ubiA9IGZhbHNlO1xyXG4gICAgaWYgKGNvbm4gPCAwIHx8IGF0b20uaXNRdWVyeSgpKSB7XHJcbiAgICAgICAgYXRvbS5pbXBsaWNpdEggPSAwO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChhdG9tLmV4cGxpY2l0VmFsZW5jZSA+PSAwKSB7XHJcbiAgICAgICAgdmFyIGVsZW0gPSBlbGVtZW50LmdldEVsZW1lbnRCeUxhYmVsKGF0b20ubGFiZWwpO1xyXG4gICAgICAgIGF0b20uaW1wbGljaXRIID0gMDtcclxuICAgICAgICBpZiAoZWxlbSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGF0b20uaW1wbGljaXRIID0gYXRvbS5leHBsaWNpdFZhbGVuY2UgLSBhdG9tLmNhbGNWYWxlbmNlTWludXNIeWQoY29ubik7XHJcbiAgICAgICAgICAgIGlmIChhdG9tLmltcGxpY2l0SCA8IDApIHtcclxuICAgICAgICAgICAgICAgIGF0b20uaW1wbGljaXRIID0gMDtcclxuICAgICAgICAgICAgICAgIGF0b20uYmFkQ29ubiA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGF0b20uY2FsY1ZhbGVuY2UoY29ubik7XHJcbiAgICB9XHJcbn07XHJcblxyXG5TdHJ1Y3QucHJvdG90eXBlLnNldEltcGxpY2l0SHlkcm9nZW4gPSBmdW5jdGlvbiAobGlzdCkge1xyXG4gICAgdmFyIGYgPSBmdW5jdGlvbiAoYWlkKSB7IHRoaXMuY2FsY0ltcGxpY2l0SHlkcm9nZW4oYWlkKTsgfTtcclxuICAgIGlmICh1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGxpc3QpKVxyXG4gICAgICAgIHRoaXMuYXRvbXMuZWFjaChmLCB0aGlzKTtcclxuICAgIGVsc2VcclxuICAgICAgICB1dGlsLmVhY2gobGlzdCwgZiwgdGhpcyk7XHJcbn07XHJcblxyXG5TdHJ1Y3QucHJvdG90eXBlLmdldENvbXBvbmVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAvKiBzYXZlciAqL1xyXG4gICAgdmFyIGNjcyA9IHRoaXMuZmluZENvbm5lY3RlZENvbXBvbmVudHModHJ1ZSk7XHJcbiAgICB2YXIgc3VibW9scyA9IFtdO1xyXG4gICAgdmFyIGJhcnJpZXJzID0gW107XHJcbiAgICB2YXIgYXJyb3dQb3MgPSBudWxsO1xyXG4gICAgdGhpcy5yeG5BcnJvd3MuZWFjaChmdW5jdGlvbiAoaWQsIGl0ZW0pIHsgLy8gdGhlcmUncyBqdXN0IG9uZSBhcnJvd1xyXG4gICAgICAgIGFycm93UG9zID0gaXRlbS5wcC54O1xyXG4gICAgfSk7XHJcbiAgICB0aGlzLnJ4blBsdXNlcy5lYWNoKGZ1bmN0aW9uIChpZCwgaXRlbSkge1xyXG4gICAgICAgIGJhcnJpZXJzLnB1c2goaXRlbS5wcC54KTtcclxuICAgIH0pO1xyXG4gICAgaWYgKGFycm93UG9zICE9IG51bGwpXHJcbiAgICAgICAgYmFycmllcnMucHVzaChhcnJvd1Bvcyk7XHJcbiAgICBiYXJyaWVycy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIC0gYjsgfSk7XHJcbiAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xyXG5cclxuICAgIHZhciBpO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGNjcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIHZhciBiYiA9IHRoaXMuZ2V0Q29vcmRCb3VuZGluZ0JveChjY3NbaV0pO1xyXG4gICAgICAgIHZhciBjID0gVmVjMi5sYzIoYmIubWluLCAwLjUsIGJiLm1heCwgMC41KTtcclxuICAgICAgICB2YXIgaiA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGMueCA+IGJhcnJpZXJzW2pdKVxyXG4gICAgICAgICAgICArK2o7XHJcbiAgICAgICAgY29tcG9uZW50c1tqXSA9IGNvbXBvbmVudHNbal0gfHwge307XHJcbiAgICAgICAgU2V0Lm1lcmdlSW4oY29tcG9uZW50c1tqXSwgY2NzW2ldKTtcclxuICAgIH1cclxuICAgIHZhciBzdWJtb2xUZXh0cyA9IFtdO1xyXG4gICAgdmFyIHJlYWN0YW50cyA9IFtdLCBwcm9kdWN0cyA9IFtdO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBpZiAoIWNvbXBvbmVudHNbaV0pIHtcclxuICAgICAgICAgICAgc3VibW9sVGV4dHMucHVzaCgnJyk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBiYiA9IHRoaXMuZ2V0Q29vcmRCb3VuZGluZ0JveChjb21wb25lbnRzW2ldKTtcclxuICAgICAgICBjID0gVmVjMi5sYzIoYmIubWluLCAwLjUsIGJiLm1heCwgMC41KTtcclxuICAgICAgICBpZiAoYy54IDwgYXJyb3dQb3MpXHJcbiAgICAgICAgICAgIHJlYWN0YW50cy5wdXNoKGNvbXBvbmVudHNbaV0pO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcHJvZHVjdHMucHVzaChjb21wb25lbnRzW2ldKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgICdyZWFjdGFudHMnOiByZWFjdGFudHMsXHJcbiAgICAgICAgJ3Byb2R1Y3RzJzogcHJvZHVjdHNcclxuICAgIH07XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN0cnVjdDtcclxuIiwidmFyIHF1ZXJ5U3RyaW5nID0gcmVxdWlyZSgncXVlcnktc3RyaW5nJyk7XHJcblxyXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xyXG52YXIgYXBpID0gcmVxdWlyZSgnLi9hcGkuanMnKTtcclxuXHJcbnJlcXVpcmUoJy4vdWknKTtcclxudmFyIG1vbGZpbGUgPSByZXF1aXJlKCcuL2NoZW0vbW9sZmlsZScpO1xyXG52YXIgc21pbGVzID0gcmVxdWlyZSgnLi9jaGVtL3NtaWxlcycpO1xyXG5cclxucmVxdWlyZSgnLi9ybmQnKTtcclxuXHJcbnZhciB1aSA9IGdsb2JhbC51aTtcclxudmFyIHJuZCA9IGdsb2JhbC5ybmQ7XHJcblxyXG5mdW5jdGlvbiBnZXRTbWlsZXMoKSB7XHJcblx0cmV0dXJuIHNtaWxlcy5zdHJpbmdpZnkodWkuY3RhYiwgeyBpZ25vcmVFcnJvcnM6IHRydWUgfSk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBnZXRNb2xmaWxlKCkge1xyXG5cdHJldHVybiBtb2xmaWxlLnN0cmluZ2lmeSh1aS5jdGFiLCB7IGlnbm9yZUVycm9yczogdHJ1ZSB9KTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIHNldE1vbGVjdWxlKG1vbFN0cmluZykge1xyXG5cdGlmICghT2JqZWN0LmlzU3RyaW5nKG1vbFN0cmluZykpIHtcclxuXHRcdHJldHVybjtcclxuXHR9XHJcblx0dWkubG9hZE1vbGVjdWxlKG1vbFN0cmluZyk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBhZGRGcmFnbWVudChtb2xTdHJpbmcpIHtcclxuXHRpZiAoIU9iamVjdC5pc1N0cmluZyhtb2xTdHJpbmcpKSB7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cdHVpLmxvYWRGcmFnbWVudChtb2xTdHJpbmcpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gc2hvd01vbGZpbGUoY2xpZW50QXJlYSwgbW9sU3RyaW5nLCBvcHRpb25zKSB7XHJcblx0dmFyIG9wdHMgPSB1dGlsLmV4dGVuZCh7XHJcblx0XHRib25kTGVuZ3RoOiA3NSxcclxuXHRcdHNob3dTZWxlY3Rpb25SZWdpb25zOiBmYWxzZSxcclxuXHRcdHNob3dCb25kSWRzOiBmYWxzZSxcclxuXHRcdHNob3dIYWxmQm9uZElkczogZmFsc2UsXHJcblx0XHRzaG93TG9vcElkczogZmFsc2UsXHJcblx0XHRzaG93QXRvbUlkczogZmFsc2UsXHJcblx0XHRhdXRvU2NhbGU6IGZhbHNlLFxyXG5cdFx0YXV0b1NjYWxlTWFyZ2luOiA0LFxyXG5cdFx0aGlkZUltcGxpY2l0SHlkcm9nZW46IGZhbHNlXHJcblx0fSwgb3B0aW9ucyk7XHJcblx0dmFyIHJlbmRlciA9IG5ldyBybmQuUmVuZGVyKGNsaWVudEFyZWEsIG9wdHMuYm9uZExlbmd0aCwgb3B0cyk7XHJcblx0aWYgKG1vbFN0cmluZykge1xyXG5cdFx0dmFyIG1vbCA9IG1vbGZpbGUucGFyc2UobW9sU3RyaW5nKTtcclxuXHRcdHJlbmRlci5zZXRNb2xlY3VsZShtb2wpO1xyXG5cdH1cclxuXHRyZW5kZXIudXBkYXRlKCk7XHJcblx0Ly8gbm90IHN1cmUgd2UgbmVlZCB0byBleHBvc2UgZ3V0c1xyXG5cdHJldHVybiByZW5kZXI7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBvblN0cnVjdENoYW5nZShoYW5kbGVyKSB7XHJcblx0dXRpbC5hc3NlcnQoaGFuZGxlcik7XHJcblx0dWkucmVuZGVyLmFkZFN0cnVjdENoYW5nZUhhbmRsZXIoaGFuZGxlcik7XHJcbn07XHJcblxyXG4vLyBUT0RPOiByZXBsYWNlIHdpbmRvdy5vbmxvYWQgd2l0aCBzb21ldGhpbmcgbGlrZSA8aHR0cHM6Ly9naXRodWIuY29tL2RlZC9kb21yZWFkeT5cclxuLy8gdG8gc3RhcnQgZWFybHlcclxud2luZG93Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgcGFyYW1zID0gcXVlcnlTdHJpbmcucGFyc2UoZG9jdW1lbnQubG9jYXRpb24uc2VhcmNoKTtcclxuXHRpZiAocGFyYW1zLmFwaV9wYXRoKVxyXG5cdFx0a2V0Y2hlci5hcGlfcGF0aCA9IHBhcmFtcy5hcGlfcGF0aDtcclxuXHRrZXRjaGVyLnNlcnZlciA9IGFwaShrZXRjaGVyLmFwaV9wYXRoKTtcclxuXHR1aS5pbml0KHV0aWwuZXh0ZW5kKHt9LCBwYXJhbXMpLCBrZXRjaGVyLnNlcnZlcik7XHJcbn07XHJcblxyXG52YXIga2V0Y2hlciA9IG1vZHVsZS5leHBvcnRzID0ge1xyXG5cdHZlcnNpb246ICcyLjAuMC1hbHBoYS4zK3IyNycsXHJcblx0YXBpX3BhdGg6ICcnLFxyXG5cdGJ1aWxkX2RhdGU6ICcyMDE1LTEyLTA4IDA5LTE0LTMzJyxcclxuXHRidWlsZF9udW1iZXI6ICcnIHx8IG51bGwsXHJcblx0YnVpbGRfb3B0aW9uczogJ19fQlVJTERfT1BUSU9OU19fJyxcclxuXHJcblx0Z2V0U21pbGVzOiBnZXRTbWlsZXMsXHJcblx0Z2V0TW9sZmlsZTogZ2V0TW9sZmlsZSxcclxuXHRzZXRNb2xlY3VsZTogc2V0TW9sZWN1bGUsXHJcblx0YWRkRnJhZ21lbnQ6IGFkZEZyYWdtZW50LFxyXG5cdHNob3dNb2xmaWxlOiBzaG93TW9sZmlsZSxcclxuXHRvblN0cnVjdENoYW5nZTogb25TdHJ1Y3RDaGFuZ2VcclxufTtcclxuIiwiLy8gU2luZ2xlIGVudHJ5IHBvaW50IHRvIFJhcGhhw6tsIGxpYnJhcnlcclxuXHJcbnZhciBSYXBoYWVsID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ1JhcGhhZWwnXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ1JhcGhhZWwnXSA6IG51bGwpO1xyXG52YXIgVmVjMiA9IHJlcXVpcmUoJy4vdXRpbC92ZWMyJyk7XHJcblxyXG4vLyBUT0RPOiByZWZhY3RvciB1Z2x5IHByb3RvdHlwZSBleHRlbnNpb25zIHRvIHBsYWluIG9sZCBmdW5jdGlvbnNcclxuUmFwaGFlbC5lbC50cmFuc2xhdGVBYnMgPSBmdW5jdGlvbiAoeCx5KSB7XHJcblx0dGhpcy5kZWx0YSA9IHRoaXMuZGVsdGEgfHwgbmV3IFZlYzIoKTtcclxuXHR0aGlzLmRlbHRhLnggKz0geCAtIDA7XHJcblx0dGhpcy5kZWx0YS55ICs9IHkgLSAwO1xyXG5cdHRoaXMudHJhbnNmb3JtKCd0JyArIHRoaXMuZGVsdGEueC50b1N0cmluZygpICsgJywnICsgdGhpcy5kZWx0YS55LnRvU3RyaW5nKCkpO1xyXG59O1xyXG5cclxuUmFwaGFlbC5zdC50cmFuc2xhdGVBYnMgPSBmdW5jdGlvbiAoeCx5KSB7XHJcblx0dGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xyXG5cdFx0ZWwudHJhbnNsYXRlQWJzKHgseSk7XHJcblx0fSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJhcGhhZWw7XHJcbiIsInZhciBTZXQgPSByZXF1aXJlKCcuLi91dGlsL3NldCcpO1xyXG52YXIgVmVjMiA9IHJlcXVpcmUoJy4uL3V0aWwvdmVjMicpO1xyXG52YXIgQWN0aW9uID0gcmVxdWlyZSgnLi4vdWkvYWN0aW9uJyk7XHJcblxyXG52YXIgZWxlbWVudCA9IHJlcXVpcmUoJy4uL2NoZW0vZWxlbWVudCcpO1xyXG52YXIgU3RydWN0ID0gcmVxdWlyZSgnLi4vY2hlbS9zdHJ1Y3QnKTtcclxudmFyIEF0b20gPSByZXF1aXJlKCcuLi9jaGVtL2F0b20nKTtcclxudmFyIEJvbmQgPSByZXF1aXJlKCcuLi9jaGVtL2JvbmQnKTtcclxudmFyIG1vbGZpbGUgPSByZXF1aXJlKCcuLi9jaGVtL21vbGZpbGUnKTtcclxudmFyIFNHcm91cCA9IHJlcXVpcmUoJy4uL2NoZW0vc2dyb3VwJyk7XHJcblxyXG5yZXF1aXJlKCcuL3Jlc3RydWN0Jyk7XHJcblxyXG52YXIgcm5kID0gZ2xvYmFsLnJuZCA9IGdsb2JhbC5ybmQgfHwge307IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG52YXIgdWkgPSBnbG9iYWwudWk7XHJcblxyXG52YXIgRWRpdG9yID0gZnVuY3Rpb24gKHJlbmRlcilcclxue1xyXG5cdHRoaXMucmVuZGVyID0gcmVuZGVyO1xyXG5cdHRoaXMuX3NlbGVjdGlvbkhlbHBlciA9IG5ldyBFZGl0b3IuU2VsZWN0aW9uSGVscGVyKHRoaXMpO1xyXG59O1xyXG5cclxuRWRpdG9yLnByb3RvdHlwZS5zZWxlY3RBbGwgPSBmdW5jdGlvbiAoKSB7XHJcblx0dmFyIHNlbGVjdGlvbiA9IHt9O1xyXG5cdGZvciAodmFyIG1hcCBpbiBybmQuUmVTdHJ1Y3QubWFwcykge1xyXG5cdFx0c2VsZWN0aW9uW21hcF0gPSB1aS5yZW5kZXIuY3RhYlttYXBdLmlrZXlzKCk7XHJcblx0fVxyXG5cdHRoaXMuX3NlbGVjdGlvbkhlbHBlci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcclxufTtcclxuRWRpdG9yLnByb3RvdHlwZS5kZXNlbGVjdEFsbCA9IGZ1bmN0aW9uICgpIHtcclxuXHR0aGlzLl9zZWxlY3Rpb25IZWxwZXIuc2V0U2VsZWN0aW9uKCk7XHJcbn07XHJcbkVkaXRvci5wcm90b3R5cGUuaGFzU2VsZWN0aW9uID0gZnVuY3Rpb24gKGNvcHlhYmxlKSB7XHJcblx0aWYgKCdzZWxlY3Rpb24nIGluIHRoaXMuX3NlbGVjdGlvbkhlbHBlcilcclxuXHRcdGZvciAodmFyIG1hcCBpbiB0aGlzLl9zZWxlY3Rpb25IZWxwZXIuc2VsZWN0aW9uKVxyXG5cdFx0XHRpZiAodGhpcy5fc2VsZWN0aW9uSGVscGVyLnNlbGVjdGlvblttYXBdLmxlbmd0aCA+IDApXHJcblx0XHRcdGlmICghY29weWFibGUgfHwgbWFwICE9PSAnc2dyb3VwRGF0YScpXHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0cmV0dXJuIGZhbHNlO1xyXG59O1xyXG5FZGl0b3IucHJvdG90eXBlLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uIChleHBsaWNpdCkge1xyXG5cdHZhciBzZWxlY3Rpb24gPSB7fTtcclxuXHRpZiAoJ3NlbGVjdGlvbicgaW4gdGhpcy5fc2VsZWN0aW9uSGVscGVyKSB7XHJcblx0XHRmb3IgKHZhciBtYXAgaW4gdGhpcy5fc2VsZWN0aW9uSGVscGVyLnNlbGVjdGlvbikge1xyXG5cdFx0XHRzZWxlY3Rpb25bbWFwXSA9IHRoaXMuX3NlbGVjdGlvbkhlbHBlci5zZWxlY3Rpb25bbWFwXS5zbGljZSgwKTtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKGV4cGxpY2l0KSB7XHJcblx0XHR2YXIgc3RydWN0ID0gdGhpcy5yZW5kZXIuY3RhYi5tb2xlY3VsZTtcclxuXHRcdC8vIFwiYXV0by1zZWxlY3RcIiB0aGUgYXRvbXMgZm9yIHRoZSBib25kcyBpbiBzZWxlY3Rpb25cclxuXHRcdGlmICgnYm9uZHMnIGluIHNlbGVjdGlvbikge1xyXG5cdFx0XHRzZWxlY3Rpb24uYm9uZHMuZWFjaChcclxuXHRcdFx0ZnVuY3Rpb24gKGJpZCkge1xyXG5cdFx0XHRcdHZhciBib25kID0gc3RydWN0LmJvbmRzLmdldChiaWQpO1xyXG5cdFx0XHRcdHNlbGVjdGlvbi5hdG9tcyA9IHNlbGVjdGlvbi5hdG9tcyB8fCBbXTtcclxuXHRcdFx0XHRpZiAoc2VsZWN0aW9uLmF0b21zLmluZGV4T2YoYm9uZC5iZWdpbikgPCAwKSBzZWxlY3Rpb24uYXRvbXMucHVzaChib25kLmJlZ2luKTtcclxuXHRcdFx0XHRpZiAoc2VsZWN0aW9uLmF0b21zLmluZGV4T2YoYm9uZC5lbmQpIDwgMCkgc2VsZWN0aW9uLmF0b21zLnB1c2goYm9uZC5lbmQpO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcdHRoaXNcclxuXHRcdFx0KTtcclxuXHRcdH1cclxuXHRcdC8vIFwiYXV0by1zZWxlY3RcIiB0aGUgYm9uZHMgd2l0aCBib3RoIGF0b21zIHNlbGVjdGVkXHJcblx0XHRpZiAoJ2F0b21zJyBpbiBzZWxlY3Rpb24gJiYgJ2JvbmRzJyBpbiBzZWxlY3Rpb24pIHtcclxuXHRcdFx0c3RydWN0LmJvbmRzLmVhY2goXHJcblx0XHRcdGZ1bmN0aW9uIChiaWQpIHtcclxuXHRcdFx0XHRpZiAoISgnYm9uZHMnIGluIHNlbGVjdGlvbikgfHwgc2VsZWN0aW9uLmJvbmRzLmluZGV4T2YoYmlkKSA8IDApIHtcclxuXHRcdFx0XHRcdHZhciBib25kID0gc3RydWN0LmJvbmRzLmdldChiaWQpO1xyXG5cdFx0XHRcdFx0aWYgKHNlbGVjdGlvbi5hdG9tcy5pbmRleE9mKGJvbmQuYmVnaW4pID49IDAgJiYgc2VsZWN0aW9uLmF0b21zLmluZGV4T2YoYm9uZC5lbmQpID49IDApIHtcclxuXHRcdFx0XHRcdFx0c2VsZWN0aW9uLmJvbmRzID0gc2VsZWN0aW9uLmJvbmRzIHx8IFtdO1xyXG5cdFx0XHRcdFx0XHRzZWxlY3Rpb24uYm9uZHMucHVzaChiaWQpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHRcdFx0XHR0aGlzXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBzZWxlY3Rpb247XHJcbn07XHJcblxyXG5FZGl0b3IucHJvdG90eXBlLmdldFNlbGVjdGlvblN0cnVjdCA9IGZ1bmN0aW9uICgpIHtcclxuXHRjb25zb2xlLmFzc2VydCh1aS5jdGFiID09IHRoaXMucmVuZGVyLmN0YWIubW9sZWN1bGUsXHJcblx0ICAgICAgICAgICAgICAgJ0Fub3RoZXIgY3RhYicpO1xyXG5cdHZhciBzcmMgPSB1aS5jdGFiO1xyXG5cdHZhciBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbih0cnVlKTtcclxuXHR2YXIgZHN0ID0gc3JjLmNsb25lKFNldC5mcm9tTGlzdChzZWxlY3Rpb24uYXRvbXMpLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgU2V0LmZyb21MaXN0KHNlbGVjdGlvbi5ib25kcyksIHRydWUpO1xyXG5cclxuXHQvLyBDb3B5IGJ5IGl0cyBvd24gYXMgU3RydWN0LmNsb25lIGRvZXNuJ3Qgc3VwcG9ydFxyXG5cdC8vIGFycm93cy9wbHVzZXMgaWQgc2V0c1xyXG5cdHNyYy5yeG5BcnJvd3MuZWFjaChmdW5jdGlvbiAoaWQsIGl0ZW0pIHtcclxuXHRcdGlmIChzZWxlY3Rpb24ucnhuQXJyb3dzLmluZGV4T2YoaWQpICE9IC0xKVxyXG5cdFx0XHRkc3QucnhuQXJyb3dzLmFkZChpdGVtLmNsb25lKCkpO1xyXG5cdH0pO1xyXG5cdHNyYy5yeG5QbHVzZXMuZWFjaChmdW5jdGlvbiAoaWQsIGl0ZW0pIHtcclxuXHRcdGlmIChzZWxlY3Rpb24ucnhuUGx1c2VzLmluZGV4T2YoaWQpICE9IC0xKVxyXG5cdFx0XHRkc3QucnhuUGx1c2VzLmFkZChpdGVtLmNsb25lKCkpO1xyXG5cdH0pO1xyXG5cclxuXHQvLyBUT0RPOiBzaG91bGQgYmUgcmVhY3Rpb24gb25seSBpZiBhcnJ3b3M/IGNoZWNrIHRoaXMgbG9naWNcclxuXHRkc3QuaXNSZWFjdGlvbiA9IHNyYy5pc1JlYWN0aW9uICYmXHJcblx0XHQoZHN0LnJ4bkFycm93cy5jb3VudCgpIHx8IGRzdC5yeG5QbHVzZXMuY291bnQoKSk7XHJcblxyXG5cdHJldHVybiBkc3Q7XHJcbn07XHJcblxyXG5FZGl0b3IuU2VsZWN0aW9uSGVscGVyID0gZnVuY3Rpb24gKGVkaXRvcikge1xyXG5cdHRoaXMuZWRpdG9yID0gZWRpdG9yO1xyXG59O1xyXG5FZGl0b3IuU2VsZWN0aW9uSGVscGVyLnByb3RvdHlwZS5zZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoc2VsZWN0aW9uLCBhZGQpIHtcclxuXHRpZiAoISgnc2VsZWN0aW9uJyBpbiB0aGlzKSB8fCAhYWRkKSB7XHJcblx0XHR0aGlzLnNlbGVjdGlvbiA9IHt9O1xyXG5cdFx0Zm9yICh2YXIgbWFwMSBpbiBybmQuUmVTdHJ1Y3QubWFwcykgdGhpcy5zZWxlY3Rpb25bbWFwMV0gPSBbXTsgLy8gVE9ETyBpdCBzaG91bGQgTk9UIGJlIG1hbmRhdG9yeVxyXG5cdH1cclxuXHRpZiAoc2VsZWN0aW9uICYmICdpZCcgaW4gc2VsZWN0aW9uICYmICdtYXAnIGluIHNlbGVjdGlvbikge1xyXG5cdFx0KHNlbGVjdGlvbltzZWxlY3Rpb24ubWFwXSA9IHNlbGVjdGlvbltzZWxlY3Rpb24ubWFwXSB8fCBbXSkucHVzaChzZWxlY3Rpb24uaWQpO1xyXG5cdH1cclxuXHRpZiAoc2VsZWN0aW9uKSB7XHJcblx0XHRmb3IgKHZhciBtYXAyIGluIHRoaXMuc2VsZWN0aW9uKSB7XHJcblx0XHRcdGlmIChtYXAyIGluIHNlbGVjdGlvbikge1xyXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0aW9uW21hcDJdLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRpZiAodGhpcy5zZWxlY3Rpb25bbWFwMl0uaW5kZXhPZihzZWxlY3Rpb25bbWFwMl1baV0pIDwgMCkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLnNlbGVjdGlvblttYXAyXS5wdXNoKHNlbGVjdGlvblttYXAyXVtpXSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdHRoaXMuZWRpdG9yLnJlbmRlci5zZXRTZWxlY3Rpb24odGhpcy5zZWxlY3Rpb24pO1xyXG5cdHRoaXMuZWRpdG9yLnJlbmRlci51cGRhdGUoKTtcclxuXHJcblx0dWkudXBkYXRlQ2xpcGJvYXJkQnV0dG9ucygpOyAvLyBUT0RPIG5vdGlmeSB1aSBhYm91dCBzZWxlY3Rpb25cclxufTtcclxuRWRpdG9yLlNlbGVjdGlvbkhlbHBlci5wcm90b3R5cGUuaXNTZWxlY3RlZCA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcblx0dmFyIHJlbmRlciA9IHRoaXMuZWRpdG9yLnJlbmRlcjtcclxuXHR2YXIgY3RhYiA9IHJlbmRlci5jdGFiO1xyXG5cdGlmIChpdGVtLm1hcCA9PSAnZnJhZ3MnIHx8IGl0ZW0ubWFwID09ICdyZ3JvdXBzJykge1xyXG5cdFx0dmFyIGF0b21zID0gaXRlbS5tYXAgPT0gJ2ZyYWdzJyA/XHJcblx0XHRcdGN0YWIuZnJhZ3MuZ2V0KGl0ZW0uaWQpLmZyYWdHZXRBdG9tcyhyZW5kZXIsIGl0ZW0uaWQpIDpcclxuXHRcdFx0Y3RhYi5yZ3JvdXBzLmdldChpdGVtLmlkKS5nZXRBdG9tcyhyZW5kZXIpO1xyXG5cdFx0cmV0dXJuICFPYmplY3QuaXNVbmRlZmluZWQodGhpcy5zZWxlY3Rpb25bJ2F0b21zJ10pXHJcblx0XHRcdCAmJiBTZXQuc3Vic2V0KFNldC5mcm9tTGlzdChhdG9tcyksIFNldC5mcm9tTGlzdCh0aGlzLnNlbGVjdGlvblsnYXRvbXMnXSkpO1xyXG5cdH1cclxuXHRyZXR1cm4gJ3NlbGVjdGlvbicgaW4gdGhpcyAmJiAhT2JqZWN0LmlzVW5kZWZpbmVkKHRoaXMuc2VsZWN0aW9uW2l0ZW0ubWFwXSkgJiZcclxuXHR0aGlzLnNlbGVjdGlvbltpdGVtLm1hcF0uaW5kZXhPZihpdGVtLmlkKSA+IC0xO1xyXG59O1xyXG5cclxuXHJcbkVkaXRvci5FZGl0b3JUb29sID0gZnVuY3Rpb24gKGVkaXRvcikge1xyXG5cdHRoaXMuZWRpdG9yID0gZWRpdG9yO1xyXG59O1xyXG5FZGl0b3IuRWRpdG9yVG9vbC5wcm90b3R5cGUucHJvY2Vzc0V2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGV2ZW50LCBhY3Rpb24pIHtcclxuXHRpZiAoISgndG91Y2hlcycgaW4gZXZlbnQpIHx8IGV2ZW50LnRvdWNoZXMubGVuZ3RoID09IDEpIHtcclxuXHRcdGlmIChuYW1lICsgJzAnIGluIHRoaXMpXHJcblx0XHRcdHJldHVybiB0aGlzW25hbWUgKyAnMCddKGV2ZW50LCBhY3Rpb24pO1xyXG5cdFx0ZWxzZSBpZiAobmFtZSBpbiB0aGlzKVxyXG5cdFx0XHRyZXR1cm4gdGhpc1tuYW1lXShldmVudCwgYWN0aW9uKTtcclxuXHRcdGNvbnNvbGUubG9nKCdFZGl0b3JUb29sLmRpc3BhdGNoRXZlbnQ6IGV2ZW50IFxcJycgKyBuYW1lICsgJ1xcJyBpcyBub3QgaGFuZGxlZC4nKTtcclxuXHR9IGVsc2UgaWYgKCdsYXN0RXZlbnQnIGluIHRoaXMuT25Nb3VzZURvd24wKSB7XHJcblx0XHQvLyBoZXJlIHdlIGZpbmlzaCBwcmV2aW91cyBNb3VzZURvd24gYW5kIE1vdXNlTW92ZXMgd2l0aCBzaW11bGF0ZWQgTW91c2VVcFxyXG5cdFx0Ly8gYmVmb3JlIGdlc3R1cmUgKGNhbnZhcyB6b29tLCBzY3JvbGwsIHJvdGF0ZSkgc3RhcnRlZFxyXG5cdFx0cmV0dXJuIHRoaXMuT25Nb3VzZVVwMChldmVudCwgYWN0aW9uKTtcclxuXHR9XHJcbn07XHJcbkVkaXRvci5FZGl0b3JUb29sLnByb3RvdHlwZS5Pbk1vdXNlRG93biA9IGZ1bmN0aW9uICgpIHt9O1xyXG5FZGl0b3IuRWRpdG9yVG9vbC5wcm90b3R5cGUuT25Nb3VzZU1vdmUgPSBmdW5jdGlvbiAoKSB7fTtcclxuRWRpdG9yLkVkaXRvclRvb2wucHJvdG90eXBlLk9uTW91c2VVcCA9IGZ1bmN0aW9uICgpIHt9O1xyXG5FZGl0b3IuRWRpdG9yVG9vbC5wcm90b3R5cGUuT25DbGljayA9IGZ1bmN0aW9uICgpIHt9O1xyXG5FZGl0b3IuRWRpdG9yVG9vbC5wcm90b3R5cGUuT25EYmxDbGljayA9IGZ1bmN0aW9uICgpIHt9O1xyXG5FZGl0b3IuRWRpdG9yVG9vbC5wcm90b3R5cGUuT25Nb3VzZUxlYXZlID0gZnVuY3Rpb24gKCkgeyB0aGlzLk9uQ2FuY2VsKCk7fTtcclxuRWRpdG9yLkVkaXRvclRvb2wucHJvdG90eXBlLk9uS2V5UHJlc3MgPSBmdW5jdGlvbiAoKSB7fTtcclxuRWRpdG9yLkVkaXRvclRvb2wucHJvdG90eXBlLk9uQ2FuY2VsID0gZnVuY3Rpb24gKCkge307IC8vIGNhbGxlZCB3aGVuIHdlIGFiYW5kb24gdGhlIHRvb2xcclxuRWRpdG9yLkVkaXRvclRvb2wucHJvdG90eXBlLk9uTW91c2VEb3duMCA9IGZ1bmN0aW9uIChldmVudCkge1xyXG5cdGlmICh1aS5oaWRlQmx1cnJlZENvbnRyb2xzKCkpIHJldHVybiB0cnVlOyAvLyBUT0RPIHJldmlldyAoZG9uJ3Qgc3RvcCBwcm9wYWdhdGlvbiB0byBoYW5kbGUgZHJvcGRvd24gY2xvc2luZylcclxuXHJcblx0dGhpcy5Pbk1vdXNlRG93bjAubGFzdEV2ZW50ID0gZXZlbnQ7XHJcblx0dGhpcy5Pbk1vdXNlTW92ZTAubGFzdEV2ZW50ID0gZXZlbnQ7XHJcblxyXG5cdGlmICgnT25Nb3VzZURvd24nIGluIHRoaXMpIHJldHVybiB0aGlzLk9uTW91c2VEb3duKGV2ZW50KTtcclxufTtcclxuRWRpdG9yLkVkaXRvclRvb2wucHJvdG90eXBlLk9uTW91c2VNb3ZlMCA9IGZ1bmN0aW9uIChldmVudCkge1xyXG5cdHRoaXMuT25Nb3VzZU1vdmUwLmxhc3RFdmVudCA9IGV2ZW50O1xyXG5cclxuXHRpZiAoJ09uTW91c2VNb3ZlJyBpbiB0aGlzKSByZXR1cm4gdGhpcy5Pbk1vdXNlTW92ZShldmVudCk7XHJcbn07XHJcbkVkaXRvci5FZGl0b3JUb29sLnByb3RvdHlwZS5Pbk1vdXNlVXAwID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0Ly8gaGVyZSB3ZSBzdXBwcmVzcyBldmVudCB3ZSBnb3Qgd2hlbiBzZWNvbmQgdG91Y2ggcmVsZWFzZWQgaW4gZ3Vlc3R1cmVcclxuXHRpZiAoISgnbGFzdEV2ZW50JyBpbiB0aGlzLk9uTW91c2VEb3duMCkpIHJldHVybiB0cnVlO1xyXG5cclxuXHRpZiAoJ2xhc3RFdmVudCcgaW4gdGhpcy5Pbk1vdXNlTW92ZTApIHtcclxuXHRcdC8vIHRoaXMgZGF0YSBpcyBtaXNzaW5nIGZvciAndG91Y2hlbmQnIGV2ZW50IHdoZW4gbGFzdCBmaW5nZXIgaXMgb3V0XHJcblx0XHRldmVudCA9IE9iamVjdC5jbG9uZShldmVudCk7IC8vIHBhZ2VYICYgcGFnZVkgcHJvcGVydGllcyBhcmUgcmVhZG9ubHkgaW4gT3BlcmFcclxuXHRcdGV2ZW50LnBhZ2VYID0gdGhpcy5Pbk1vdXNlTW92ZTAubGFzdEV2ZW50LnBhZ2VYO1xyXG5cdFx0ZXZlbnQucGFnZVkgPSB0aGlzLk9uTW91c2VNb3ZlMC5sYXN0RXZlbnQucGFnZVk7XHJcblx0fVxyXG5cclxuXHR0cnkge1xyXG5cdFx0aWYgKCdPbk1vdXNlVXAnIGluIHRoaXMpIHJldHVybiB0aGlzLk9uTW91c2VVcChldmVudCk7XHJcblx0fSBmaW5hbGx5IHtcclxuXHRcdGRlbGV0ZSB0aGlzLk9uTW91c2VEb3duMC5sYXN0RXZlbnQ7XHJcblx0fVxyXG59O1xyXG5cclxuRWRpdG9yLkVkaXRvclRvb2wuYXRvbV9sYWJlbF9tYXAgPSB7XHJcblx0YXRvbV90b29sX2FueTogJ0EnLFxyXG5cdGF0b21fdG9vbF9oOiAnSCcsXHJcblx0YXRvbV90b29sX2M6ICdDJyxcclxuXHRhdG9tX3Rvb2xfbjogJ04nLFxyXG5cdGF0b21fdG9vbF9vOiAnTycsXHJcblx0YXRvbV90b29sX3M6ICdTJyxcclxuXHRhdG9tX3Rvb2xfcDogJ1AnLFxyXG5cdGF0b21fdG9vbF9mOiAnRicsXHJcblx0YXRvbV90b29sX2JyOiAnQnInLFxyXG5cdGF0b21fdG9vbF9jbDogJ0NsJyxcclxuXHRhdG9tX3Rvb2xfaTogJ0knXHJcbn07XHJcblxyXG5FZGl0b3IuRWRpdG9yVG9vbC5wcm90b3R5cGUuT25LZXlQcmVzczAgPSBmdW5jdGlvbiAoZXZlbnQsIGFjdGlvbikge1xyXG5cdGlmIChhY3Rpb24gPT09ICdyZ3JvdXBfdG9vbF9sYWJlbCcgJiYgJ2xhc3RFdmVudCcgaW4gdGhpcy5Pbk1vdXNlTW92ZTApIHtcclxuXHRcdHJldHVybiBFZGl0b3IuUkdyb3VwQXRvbVRvb2wucHJvdG90eXBlLk9uTW91c2VVcC5jYWxsKHRoaXMsXHJcblx0XHRcdHRoaXMuT25Nb3VzZU1vdmUwLmxhc3RFdmVudCk7XHJcblx0fSBlbHNlIGlmIChhY3Rpb24gaW4gRWRpdG9yLkVkaXRvclRvb2wuYXRvbV9sYWJlbF9tYXApIHtcclxuXHRcdHZhciBsYWJlbCA9IEVkaXRvci5FZGl0b3JUb29sLmF0b21fbGFiZWxfbWFwW2FjdGlvbl07XHJcblx0XHR2YXIgc2VsZWN0aW9uID0gdGhpcy5lZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XHJcblx0XHRpZiAoc2VsZWN0aW9uICYmICdhdG9tcycgaW4gc2VsZWN0aW9uICYmIHNlbGVjdGlvbi5hdG9tcy5sZW5ndGggPiAwKSB7XHJcblx0XHRcdHVpLmFkZFVuZG9BY3Rpb24oQWN0aW9uLmZyb21BdG9tc0F0dHJzKFxyXG5cdFx0XHRcdHNlbGVjdGlvbi5hdG9tcywge2xhYmVsOiBsYWJlbH0sIHRydWUpLCB0cnVlKTtcclxuXHRcdFx0dWkucmVuZGVyLnVwZGF0ZSgpO1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZhciBjaSA9IHRoaXMuZWRpdG9yLnJlbmRlci5maW5kSXRlbSh0aGlzLk9uTW91c2VNb3ZlMC5sYXN0RXZlbnQpO1xyXG5cdFx0XHRpZiAoY2kpIHtcclxuXHRcdFx0XHRjaS5sYWJlbCA9IHtsYWJlbDogbGFiZWx9O1xyXG5cdFx0XHRcdGlmIChjaS5tYXAgPT09ICdhdG9tcycpIHtcclxuXHRcdFx0XHRcdHVpLmFkZFVuZG9BY3Rpb24oQWN0aW9uLmZyb21BdG9tc0F0dHJzKFxyXG5cdFx0XHRcdFx0XHRjaS5pZCwgY2kubGFiZWwsIHRydWUpLCB0cnVlKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKGNpLmlkID09IC0xKSB7XHJcblx0XHRcdFx0XHR1aS5hZGRVbmRvQWN0aW9uKFxyXG5cdFx0XHRcdFx0QWN0aW9uLmZyb21BdG9tQWRkaXRpb24oXHJcblx0XHRcdFx0XHR1aS5wYWdlMm9iaihcclxuXHRcdFx0XHRcdFx0dGhpcy5Pbk1vdXNlTW92ZTAubGFzdEV2ZW50KSwgY2kubGFiZWwpLCB0cnVlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dWkucmVuZGVyLnVwZGF0ZSgpO1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmICgnT25LZXlQcmVzcycgaW4gdGhpcylcclxuXHRcdHJldHVybiB0aGlzLk9uS2V5UHJlc3MoZXZlbnQpO1xyXG5cdHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbkVkaXRvci5FZGl0b3JUb29sLnByb3RvdHlwZS5fY2FsY0FuZ2xlID0gZnVuY3Rpb24gKHBvczAsIHBvczEpIHtcclxuXHR2YXIgdiA9IFZlYzIuZGlmZihwb3MxLCBwb3MwKTtcclxuXHR2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKHYueSwgdi54KTtcclxuXHR2YXIgc2lnbiA9IGFuZ2xlIDwgMCA/IC0xIDogMTtcclxuXHR2YXIgZmxvb3IgPSBNYXRoLmZsb29yKE1hdGguYWJzKGFuZ2xlKSAvIChNYXRoLlBJIC8gMTIpKSAqIChNYXRoLlBJIC8gMTIpO1xyXG5cdGFuZ2xlID0gc2lnbiAqIChmbG9vciArICgoTWF0aC5hYnMoYW5nbGUpIC0gZmxvb3IgPCBNYXRoLlBJIC8gMjQpID8gMCA6IE1hdGguUEkgLyAxMikpO1xyXG5cdHJldHVybiBhbmdsZTtcclxufTtcclxuRWRpdG9yLkVkaXRvclRvb2wucHJvdG90eXBlLl9jYWxjTmV3QXRvbVBvcyA9IGZ1bmN0aW9uIChwb3MwLCBwb3MxKSB7XHJcblx0dmFyIHYgPSBuZXcgVmVjMigxLCAwKS5yb3RhdGUodGhpcy5fY2FsY0FuZ2xlKHBvczAsIHBvczEpKTtcclxuXHR2LmFkZF8ocG9zMCk7XHJcblx0cmV0dXJuIHY7XHJcbn07XHJcblxyXG5cclxuRWRpdG9yLkVkaXRvclRvb2wuSG92ZXJIZWxwZXIgPSBmdW5jdGlvbiAoZWRpdG9yVG9vbCkge1xyXG5cdHRoaXMuZWRpdG9yVG9vbCA9IGVkaXRvclRvb2w7XHJcbn07XHJcbkVkaXRvci5FZGl0b3JUb29sLkhvdmVySGVscGVyLnByb3RvdHlwZS5ob3ZlciA9IGZ1bmN0aW9uIChjaSkge1xyXG5cdGlmIChjaSAmJiBjaS50eXBlID09ICdDYW52YXMnKVxyXG5cdFx0Y2kgPSBudWxsO1xyXG5cdC8vIFRPRE8gYWRkIGN1c3RvbSBoaWdobGlnaHQgc3R5bGUgcGFyYW1ldGVyLCB0byBiZSB1c2VkIHdoZW4gZnVzaW5nIGF0b21zLCBzZ3JvdXAgY2hpbGRyZW4gaGlnaGxpZ2h0aW5nLCBldGNcclxuXHRpZiAoJ2NpJyBpbiB0aGlzICYmICghY2kgfHwgdGhpcy5jaS50eXBlICE9IGNpLnR5cGUgfHwgdGhpcy5jaS5pZCAhPSBjaS5pZCkpIHtcclxuXHRcdHRoaXMuZWRpdG9yVG9vbC5lZGl0b3IucmVuZGVyLmhpZ2hsaWdodE9iamVjdCh0aGlzLmNpLCBmYWxzZSk7XHJcblx0XHRkZWxldGUgdGhpcy5jaTtcclxuXHR9XHJcblx0aWYgKGNpICYmIHRoaXMuZWRpdG9yVG9vbC5lZGl0b3IucmVuZGVyLmhpZ2hsaWdodE9iamVjdChjaSwgdHJ1ZSkpIHtcclxuXHRcdHRoaXMuY2kgPSBjaTtcclxuXHR9XHJcbn07XHJcblxyXG5FZGl0b3IuTGFzc29Ub29sID0gZnVuY3Rpb24gKGVkaXRvciwgbW9kZSwgZnJhZ21lbnQpIHtcclxuXHR0aGlzLmVkaXRvciA9IGVkaXRvcjtcclxuXHJcblx0dGhpcy5faG92ZXJIZWxwZXIgPSBuZXcgRWRpdG9yLkVkaXRvclRvb2wuSG92ZXJIZWxwZXIodGhpcyk7XHJcblx0dGhpcy5fbGFzc29IZWxwZXIgPSBuZXcgRWRpdG9yLkxhc3NvVG9vbC5MYXNzb0hlbHBlcihtb2RlIHx8IDAsIGVkaXRvciwgZnJhZ21lbnQpO1xyXG5cdHRoaXMuX3NHcm91cEhlbHBlciA9IG5ldyBFZGl0b3IuU0dyb3VwVG9vbC5TR3JvdXBIZWxwZXIoZWRpdG9yKTtcclxufTtcclxuRWRpdG9yLkxhc3NvVG9vbC5wcm90b3R5cGUgPSBuZXcgRWRpdG9yLkVkaXRvclRvb2woKTtcclxuRWRpdG9yLkxhc3NvVG9vbC5wcm90b3R5cGUuT25Nb3VzZURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuXHR2YXIgcmVuZGVyID0gdGhpcy5lZGl0b3IucmVuZGVyO1xyXG5cdHZhciBjdGFiID0gcmVuZGVyLmN0YWIsIG1vbCA9IGN0YWIubW9sZWN1bGU7XHJcblx0dGhpcy5faG92ZXJIZWxwZXIuaG92ZXIobnVsbCk7IC8vIFRPRE8gcmV2aWV3IGhvdmVyaW5nIGZvciB0b3VjaCBkZXZpY2VzXHJcblx0dmFyIHNlbGVjdEZyYWdtZW50ID0gKHRoaXMuX2xhc3NvSGVscGVyLmZyYWdtZW50IHx8IGV2ZW50LmN0cmxLZXkpO1xyXG5cdHZhciBjaSA9IHRoaXMuZWRpdG9yLnJlbmRlci5maW5kSXRlbShcclxuXHRcdGV2ZW50LFxyXG5cdFx0c2VsZWN0RnJhZ21lbnQgP1xyXG5cdFx0XHRbJ2ZyYWdzJywgJ3Nncm91cHMnLCAnc2dyb3VwRGF0YScsICdyZ3JvdXBzJywgJ3J4bkFycm93cycsICdyeG5QbHVzZXMnLCAnY2hpcmFsRmxhZ3MnXSA6XHJcblx0XHRcdFsnYXRvbXMnLCAnYm9uZHMnLCAnc2dyb3VwcycsICdzZ3JvdXBEYXRhJywgJ3Jncm91cHMnLCAncnhuQXJyb3dzJywgJ3J4blBsdXNlcycsICdjaGlyYWxGbGFncyddXHJcblx0KTtcclxuXHRpZiAoIWNpIHx8IGNpLnR5cGUgPT0gJ0NhbnZhcycpIHtcclxuXHRcdGlmICghdGhpcy5fbGFzc29IZWxwZXIuZnJhZ21lbnQpXHJcblx0XHRcdHRoaXMuX2xhc3NvSGVscGVyLmJlZ2luKGV2ZW50KTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhpcy5faG92ZXJIZWxwZXIuaG92ZXIobnVsbCk7XHJcblx0XHRpZiAoJ29uU2hvd0xvdXBlJyBpbiB0aGlzLmVkaXRvci5yZW5kZXIpXHJcblx0XHRcdHRoaXMuZWRpdG9yLnJlbmRlci5vblNob3dMb3VwZSh0cnVlKTtcclxuXHRcdGlmICghdGhpcy5lZGl0b3IuX3NlbGVjdGlvbkhlbHBlci5pc1NlbGVjdGVkKGNpKSkge1xyXG5cdFx0XHRpZiAoY2kubWFwID09ICdmcmFncycpIHtcclxuXHRcdFx0XHR2YXIgZnJhZyA9IGN0YWIuZnJhZ3MuZ2V0KGNpLmlkKTtcclxuXHRcdFx0XHR0aGlzLmVkaXRvci5fc2VsZWN0aW9uSGVscGVyLnNldFNlbGVjdGlvbihcclxuXHRcdFx0XHR7ICdhdG9tcyc6IGZyYWcuZnJhZ0dldEF0b21zKHJlbmRlciwgY2kuaWQpLCAnYm9uZHMnOiBmcmFnLmZyYWdHZXRCb25kcyhyZW5kZXIsIGNpLmlkKSB9LFxyXG5cdFx0XHRcdFx0ZXZlbnQuc2hpZnRLZXlcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGNpLm1hcCA9PSAnc2dyb3VwcycpIHtcclxuXHRcdFx0XHR2YXIgc2dyb3VwID0gY3RhYi5zZ3JvdXBzLmdldChjaS5pZCkuaXRlbTtcclxuXHRcdFx0XHR0aGlzLmVkaXRvci5fc2VsZWN0aW9uSGVscGVyLnNldFNlbGVjdGlvbihcclxuXHRcdFx0XHR7ICdhdG9tcyc6IFNHcm91cC5nZXRBdG9tcyhtb2wsIHNncm91cCksICdib25kcyc6IFNHcm91cC5nZXRCb25kcyhtb2wsIHNncm91cCkgfSxcclxuXHRcdFx0XHRcdGV2ZW50LnNoaWZ0S2V5XHJcblx0XHRcdFx0KTtcclxuXHRcdFx0fSBlbHNlIGlmIChjaS5tYXAgPT0gJ3Jncm91cHMnKSB7XHJcblx0XHRcdFx0dmFyIHJncm91cCA9IGN0YWIucmdyb3Vwcy5nZXQoY2kuaWQpO1xyXG5cdFx0XHRcdHRoaXMuZWRpdG9yLl9zZWxlY3Rpb25IZWxwZXIuc2V0U2VsZWN0aW9uKFxyXG5cdFx0XHRcdHsgJ2F0b21zJzogcmdyb3VwLmdldEF0b21zKHJlbmRlciksICdib25kcyc6IHJncm91cC5nZXRCb25kcyhyZW5kZXIpIH0sXHJcblx0XHRcdFx0XHRldmVudC5zaGlmdEtleVxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5lZGl0b3IuX3NlbGVjdGlvbkhlbHBlci5zZXRTZWxlY3Rpb24oY2ksIGV2ZW50LnNoaWZ0S2V5KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0dGhpcy5kcmFnQ3R4ID0ge1xyXG5cdFx0XHRpdGVtOiBjaSxcclxuXHRcdFx0eHkwOiB1aS5wYWdlMm9iaihldmVudClcclxuXHRcdH07XHJcblx0XHRpZiAoY2kubWFwID09ICdhdG9tcycgJiYgIXVpLmlzX3RvdWNoKSB7XHJcblx0XHRcdHZhciBzZWxmID0gdGhpcztcclxuXHRcdFx0dGhpcy5kcmFnQ3R4LnRpbWVvdXQgPSBzZXRUaW1lb3V0KFxyXG5cdFx0XHRmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0ZGVsZXRlIHNlbGYuZHJhZ0N0eDtcclxuXHRcdFx0XHRzZWxmLmVkaXRvci5fc2VsZWN0aW9uSGVscGVyLnNldFNlbGVjdGlvbihudWxsKTtcclxuXHRcdFx0XHR1aS5zaG93TGFiZWxFZGl0b3IoY2kuaWQpO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcdDc1MFxyXG5cdFx0XHQpO1xyXG5cdFx0XHR0aGlzLmRyYWdDdHguc3RvcFRhcHBpbmcgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0aWYgKCd0aW1lb3V0JyBpbiBzZWxmLmRyYWdDdHgpIHtcclxuXHRcdFx0XHRcdGNsZWFyVGltZW91dChzZWxmLmRyYWdDdHgudGltZW91dCk7XHJcblx0XHRcdFx0XHRkZWxldGUgc2VsZi5kcmFnQ3R4LnRpbWVvdXQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbkVkaXRvci5MYXNzb1Rvb2wucHJvdG90eXBlLk9uTW91c2VNb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0aWYgKCdkcmFnQ3R4JyBpbiB0aGlzKSB7XHJcblx0XHRpZiAoJ3N0b3BUYXBwaW5nJyBpbiB0aGlzLmRyYWdDdHgpIHRoaXMuZHJhZ0N0eC5zdG9wVGFwcGluZygpO1xyXG5cdFx0Ly8gbW92aW5nIHNlbGVjdGVkIG9iamVjdHNcclxuXHRcdGlmICh0aGlzLmRyYWdDdHguYWN0aW9uKSB7XHJcblx0XHRcdHRoaXMuZHJhZ0N0eC5hY3Rpb24ucGVyZm9ybSgpO1xyXG5cdFx0XHR0aGlzLmVkaXRvci5yZW5kZXIudXBkYXRlKCk7IC8vIHJlZHJhdyB0aGUgZWxlbWVudHMgaW4gdW5zaGlmdGVkIHBvc2l0aW9uLCBsZXN0IHRoZSBoYXZlIGRpZmZlcmVudCBvZmZzZXRcclxuXHRcdH1cclxuXHRcdHRoaXMuZHJhZ0N0eC5hY3Rpb24gPSBBY3Rpb24uZnJvbU11bHRpcGxlTW92ZShcclxuXHRcdHRoaXMuZWRpdG9yLmdldFNlbGVjdGlvbih0cnVlKSxcclxuXHRcdHVpLnBhZ2Uyb2JqKGV2ZW50KS5zdWIodGhpcy5kcmFnQ3R4Lnh5MCkpO1xyXG5cdFx0Ly8gZmluZGluZyAmIGhpZ2hsaWdodGluZyBvYmplY3QgdG8gc3RpY2sgdG9cclxuXHRcdGlmIChbJ2F0b21zJy8qLCAnYm9uZHMnKi9dLmluZGV4T2YodGhpcy5kcmFnQ3R4Lml0ZW0ubWFwKSA+PSAwKSB7XHJcblx0XHRcdC8vIFRPRE8gYWRkIGJvbmQtdG8tYm9uZCBmdXNpbmdcclxuXHRcdFx0dmFyIGNpID0gdGhpcy5lZGl0b3IucmVuZGVyLmZpbmRJdGVtKGV2ZW50LCBbdGhpcy5kcmFnQ3R4Lml0ZW0ubWFwXSwgdGhpcy5kcmFnQ3R4Lml0ZW0pO1xyXG5cdFx0XHR0aGlzLl9ob3ZlckhlbHBlci5ob3ZlcihjaS5tYXAgPT0gdGhpcy5kcmFnQ3R4Lml0ZW0ubWFwID8gY2kgOiBudWxsKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuZWRpdG9yLnJlbmRlci51cGRhdGUoKTtcclxuXHR9IGVsc2UgaWYgKHRoaXMuX2xhc3NvSGVscGVyLnJ1bm5pbmcoKSkge1xyXG5cdFx0dGhpcy5lZGl0b3IuX3NlbGVjdGlvbkhlbHBlci5zZXRTZWxlY3Rpb24odGhpcy5fbGFzc29IZWxwZXIuYWRkUG9pbnQoZXZlbnQpLCBldmVudC5zaGlmdEtleSk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRoaXMuX2hvdmVySGVscGVyLmhvdmVyKFxyXG5cdFx0dGhpcy5lZGl0b3IucmVuZGVyLmZpbmRJdGVtKFxyXG5cdFx0XHRldmVudCxcclxuXHRcdFx0KHRoaXMuX2xhc3NvSGVscGVyLmZyYWdtZW50IHx8IGV2ZW50LmN0cmxLZXkpID9cclxuXHRcdFx0XHRbJ2ZyYWdzJywgJ3Nncm91cHMnLCAnc2dyb3VwRGF0YScsICdyZ3JvdXBzJywgJ3J4bkFycm93cycsICdyeG5QbHVzZXMnLCAnY2hpcmFsRmxhZ3MnXSA6XHJcblx0XHRcdFx0WydhdG9tcycsICdib25kcycsICdzZ3JvdXBzJywgJ3Nncm91cERhdGEnLCAncmdyb3VwcycsICdyeG5BcnJvd3MnLCAncnhuUGx1c2VzJywgJ2NoaXJhbEZsYWdzJ11cclxuXHRcdClcclxuXHRcdCk7XHJcblx0fVxyXG5cdHJldHVybiB0cnVlO1xyXG59O1xyXG5FZGl0b3IuTGFzc29Ub29sLnByb3RvdHlwZS5Pbk1vdXNlVXAgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuXHRpZiAoJ2RyYWdDdHgnIGluIHRoaXMpIHtcclxuXHRcdGlmICgnc3RvcFRhcHBpbmcnIGluIHRoaXMuZHJhZ0N0eCkgdGhpcy5kcmFnQ3R4LnN0b3BUYXBwaW5nKCk7XHJcblx0XHRpZiAoWydhdG9tcycvKiwgJ2JvbmRzJyovXS5pbmRleE9mKHRoaXMuZHJhZ0N0eC5pdGVtLm1hcCkgPj0gMCkge1xyXG5cdFx0XHQvLyBUT0RPIGFkZCBib25kLXRvLWJvbmQgZnVzaW5nXHJcblx0XHRcdHZhciBjaSA9IHRoaXMuZWRpdG9yLnJlbmRlci5maW5kSXRlbShldmVudCwgW3RoaXMuZHJhZ0N0eC5pdGVtLm1hcF0sIHRoaXMuZHJhZ0N0eC5pdGVtKTtcclxuXHRcdFx0aWYgKGNpLm1hcCA9PSB0aGlzLmRyYWdDdHguaXRlbS5tYXApIHtcclxuXHRcdFx0XHR0aGlzLl9ob3ZlckhlbHBlci5ob3ZlcihudWxsKTtcclxuXHRcdFx0XHR0aGlzLmVkaXRvci5fc2VsZWN0aW9uSGVscGVyLnNldFNlbGVjdGlvbigpO1xyXG5cdFx0XHRcdHRoaXMuZHJhZ0N0eC5hY3Rpb24gPSB0aGlzLmRyYWdDdHguYWN0aW9uXHJcblx0XHRcdFx0XHRcdCA/IEFjdGlvbi5mcm9tQXRvbU1lcmdlKHRoaXMuZHJhZ0N0eC5pdGVtLmlkLCBjaS5pZCkubWVyZ2VXaXRoKHRoaXMuZHJhZ0N0eC5hY3Rpb24pXHJcblx0XHRcdFx0XHRcdCA6IEFjdGlvbi5mcm9tQXRvbU1lcmdlKHRoaXMuZHJhZ0N0eC5pdGVtLmlkLCBjaS5pZCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHVpLmFkZFVuZG9BY3Rpb24odGhpcy5kcmFnQ3R4LmFjdGlvbiwgdHJ1ZSk7XHJcblx0XHR0aGlzLmVkaXRvci5yZW5kZXIudXBkYXRlKCk7XHJcblx0XHRkZWxldGUgdGhpcy5kcmFnQ3R4O1xyXG5cdH0gZWxzZSB7XHJcblx0XHRpZiAodGhpcy5fbGFzc29IZWxwZXIucnVubmluZygpKSB7IC8vIFRPRE8gaXQgY2F0Y2hlcyBtb3JlIGV2ZW50cyB0aGFuIG5lZWRlZCwgdG8gYmUgcmUtZmFjdG9yZWRcclxuXHRcdFx0dGhpcy5lZGl0b3IuX3NlbGVjdGlvbkhlbHBlci5zZXRTZWxlY3Rpb24odGhpcy5fbGFzc29IZWxwZXIuZW5kKCksIGV2ZW50LnNoaWZ0S2V5KTtcclxuXHRcdH0gZWxzZSBpZiAodGhpcy5fbGFzc29IZWxwZXIuZnJhZ21lbnQpIHtcclxuXHRcdFx0dGhpcy5lZGl0b3IuX3NlbGVjdGlvbkhlbHBlci5zZXRTZWxlY3Rpb24oKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIHRydWU7XHJcbn07XHJcbkVkaXRvci5MYXNzb1Rvb2wucHJvdG90eXBlLk9uRGJsQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuXHR2YXIgY2kgPSB0aGlzLmVkaXRvci5yZW5kZXIuZmluZEl0ZW0oZXZlbnQpO1xyXG5cdGlmIChjaS5tYXAgPT0gJ2F0b21zJykge1xyXG5cdFx0dGhpcy5lZGl0b3IuX3NlbGVjdGlvbkhlbHBlci5zZXRTZWxlY3Rpb24oY2kpO1xyXG5cdFx0Ly8gVE9ETyBbUkJdIHJlLWZhY3RvcmluZyBuZWVkZWQuIHdlIHByb2JhYmx5IG5lZWQgdG8gaW50b2R1Y2UgXCJjdXN0b21cIiBlbGVtZW50IHNldHMsIHNvbWUgb2YgdGhlbSBtaWdodCBiZSBcInNwZWNpYWxcIiAobGlzdHMsIHItZ3JvdXBzKSwgc29tZSBvZiB0aGVtIG1pZ2h0IGJlIFwicGx1Z2dhYmxlXCIgKHJlYXh5cyBnZW5lcmljcylcclxuXHRcdHZhciBhdG9tID0gdWkuY3RhYi5hdG9tcy5nZXQoY2kuaWQpO1xyXG5cdFx0aWYgKGF0b20ubGFiZWwgPT0gJ1IjJykge1xyXG5cdFx0XHRFZGl0b3IuUkdyb3VwQXRvbVRvb2wucHJvdG90eXBlLk9uTW91c2VVcC5jYWxsKHRoaXMsIGV2ZW50KTtcclxuXHRcdH0gZWxzZSBpZiAoYXRvbS5sYWJlbCA9PSAnTCMnKSB7XHJcblx0XHRcdHVpLnNob3dFbGVtVGFibGUoe1xyXG5cdFx0XHRcdHNlbGVjdGlvbjogYXRvbSxcclxuXHRcdFx0XHRvbk9rOiBmdW5jdGlvbiAoYXR0cnMpIHtcclxuXHRcdFx0XHRcdGlmIChhdG9tLmxhYmVsICE9IGF0dHJzLmxhYmVsIHx8ICFhdG9tLmF0b21MaXN0LmVxdWFscyhhdHRycy5hdG9tTGlzdCkpIHtcclxuXHRcdFx0XHRcdFx0dWkuYWRkVW5kb0FjdGlvbihBY3Rpb24uZnJvbUF0b21zQXR0cnMoY2kuaWQsIGF0dHJzKSk7XHJcblx0XHRcdFx0XHRcdHVpLnJlbmRlci51cGRhdGUoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdH0uYmluZCh0aGlzKVxyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSBpZiAoKGVsZW1lbnQuZ2V0RWxlbWVudEJ5TGFiZWwoYXRvbS5sYWJlbCkgfHwgMTIxKSA8IDEyMCkge1xyXG5cdFx0XHR1aS5zaG93QXRvbVByb3BlcnRpZXMoY2kuaWQpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dWkuc2hvd1JlYUdlbmVyaWNzVGFibGUoe1xyXG5cdFx0XHRcdHZhbHVlczogW2F0b20ubGFiZWxdLFxyXG5cdFx0XHRcdG9uT2s6IGZ1bmN0aW9uIChyZXMpIHtcclxuXHRcdFx0XHRcdHZhciBsYWJlbCA9IHJlcy52YWx1ZXNbMF07XHJcblx0XHRcdFx0XHRpZiAoYXRvbS5sYWJlbCAhPSBsYWJlbCkge1xyXG5cdFx0XHRcdFx0XHR1aS5hZGRVbmRvQWN0aW9uKEFjdGlvbi5mcm9tQXRvbXNBdHRycyhjaS5pZCwge2xhYmVsOiBsYWJlbH0pKTtcclxuXHRcdFx0XHRcdFx0dWkucmVuZGVyLnVwZGF0ZSgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0fS5iaW5kKHRoaXMpXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSBpZiAoY2kubWFwID09ICdib25kcycpIHtcclxuXHRcdHRoaXMuZWRpdG9yLl9zZWxlY3Rpb25IZWxwZXIuc2V0U2VsZWN0aW9uKGNpKTtcclxuXHRcdHVpLnNob3dCb25kUHJvcGVydGllcyhjaS5pZCk7XHJcblx0fSBlbHNlIGlmIChjaS5tYXAgPT0gJ3Nncm91cHMnKSB7XHJcblx0XHR0aGlzLmVkaXRvci5fc2VsZWN0aW9uSGVscGVyLnNldFNlbGVjdGlvbihjaSk7XHJcblx0XHR0aGlzLl9zR3JvdXBIZWxwZXIuc2hvd1Byb3BlcnRpZXNEaWFsb2coY2kuaWQpO1xyXG4vLyAgICB9IGVsc2UgaWYgKGNpLm1hcCA9PSAnc2dyb3VwRGF0YScpIHtcclxuLy8gICAgICAgIHRoaXMuX3NHcm91cEhlbHBlci5zaG93UHJvcGVydGllc0RpYWxvZyhjaS5zZ2lkKTtcclxuXHR9XHJcblx0cmV0dXJuIHRydWU7XHJcbn07XHJcbkVkaXRvci5MYXNzb1Rvb2wucHJvdG90eXBlLk9uQ2FuY2VsID0gZnVuY3Rpb24gKCkge1xyXG5cdGlmICgnZHJhZ0N0eCcgaW4gdGhpcykge1xyXG5cdFx0aWYgKCdzdG9wVGFwcGluZycgaW4gdGhpcy5kcmFnQ3R4KSB0aGlzLmRyYWdDdHguc3RvcFRhcHBpbmcoKTtcclxuXHRcdHVpLmFkZFVuZG9BY3Rpb24odGhpcy5kcmFnQ3R4LmFjdGlvbiwgdHJ1ZSk7XHJcblx0XHR0aGlzLmVkaXRvci5yZW5kZXIudXBkYXRlKCk7XHJcblx0XHRkZWxldGUgdGhpcy5kcmFnQ3R4O1xyXG5cdH0gZWxzZSBpZiAodGhpcy5fbGFzc29IZWxwZXIucnVubmluZygpKSB7XHJcblx0XHR0aGlzLmVkaXRvci5fc2VsZWN0aW9uSGVscGVyLnNldFNlbGVjdGlvbih0aGlzLl9sYXNzb0hlbHBlci5lbmQoKSk7XHJcblx0fVxyXG5cdHRoaXMuX2hvdmVySGVscGVyLmhvdmVyKG51bGwpO1xyXG59O1xyXG5cclxuXHJcbkVkaXRvci5MYXNzb1Rvb2wuTGFzc29IZWxwZXIgPSBmdW5jdGlvbiAobW9kZSwgZWRpdG9yLCBmcmFnbWVudCkge1xyXG5cdHRoaXMubW9kZSA9IG1vZGU7XHJcblx0dGhpcy5mcmFnbWVudCA9IGZyYWdtZW50O1xyXG5cdHRoaXMuZWRpdG9yID0gZWRpdG9yO1xyXG59O1xyXG5FZGl0b3IuTGFzc29Ub29sLkxhc3NvSGVscGVyLnByb3RvdHlwZS5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0aWYgKHRoaXMubW9kZSA9PSAwKSB7XHJcblx0XHRyZXR1cm4gdWkucmVuZGVyLmdldEVsZW1lbnRzSW5Qb2x5Z29uKHRoaXMucG9pbnRzKTtcclxuXHR9IGVsc2UgaWYgKHRoaXMubW9kZSA9PSAxKSB7XHJcblx0XHRyZXR1cm4gdWkucmVuZGVyLmdldEVsZW1lbnRzSW5SZWN0YW5nbGUodGhpcy5wb2ludHNbMF0sIHRoaXMucG9pbnRzWzFdKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdTZWxlY3RvciBtb2RlIHVua25vd24nKTtcclxuXHR9XHJcbn07XHJcbkVkaXRvci5MYXNzb1Rvb2wuTGFzc29IZWxwZXIucHJvdG90eXBlLmJlZ2luID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0dGhpcy5wb2ludHMgPSBbIHVpLnBhZ2Uyb2JqKGV2ZW50KSBdO1xyXG5cdGlmICh0aGlzLm1vZGUgPT0gMSkge1xyXG5cdFx0dGhpcy5wb2ludHMucHVzaCh0aGlzLnBvaW50c1swXSk7XHJcblx0fVxyXG59O1xyXG5FZGl0b3IuTGFzc29Ub29sLkxhc3NvSGVscGVyLnByb3RvdHlwZS5ydW5uaW5nID0gZnVuY3Rpb24gKCkge1xyXG5cdHJldHVybiAncG9pbnRzJyBpbiB0aGlzO1xyXG59O1xyXG5FZGl0b3IuTGFzc29Ub29sLkxhc3NvSGVscGVyLnByb3RvdHlwZS5hZGRQb2ludCA9IGZ1bmN0aW9uIChldmVudCkge1xyXG5cdGlmICghdGhpcy5ydW5uaW5nKCkpIHJldHVybiBmYWxzZTtcclxuXHRpZiAodGhpcy5tb2RlID09IDApIHtcclxuXHRcdHRoaXMucG9pbnRzLnB1c2godWkucGFnZTJvYmooZXZlbnQpKTtcclxuXHRcdHRoaXMuZWRpdG9yLnJlbmRlci5kcmF3U2VsZWN0aW9uUG9seWdvbih0aGlzLnBvaW50cyk7XHJcblx0fSBlbHNlIGlmICh0aGlzLm1vZGUgPT0gMSkge1xyXG5cdFx0dGhpcy5wb2ludHMgPSBbIHRoaXMucG9pbnRzWzBdLCB1aS5wYWdlMm9iaihldmVudCkgXTtcclxuXHRcdHRoaXMuZWRpdG9yLnJlbmRlci5kcmF3U2VsZWN0aW9uUmVjdGFuZ2xlKHRoaXMucG9pbnRzWzBdLCB0aGlzLnBvaW50c1sxXSk7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzLmdldFNlbGVjdGlvbigpO1xyXG59O1xyXG5FZGl0b3IuTGFzc29Ub29sLkxhc3NvSGVscGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKSB7XHJcblx0dmFyIHJldCA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XHJcblx0aWYgKCdwb2ludHMnIGluIHRoaXMpIHtcclxuXHRcdHRoaXMuZWRpdG9yLnJlbmRlci5kcmF3U2VsZWN0aW9uUG9seWdvbihudWxsKTtcclxuXHRcdGRlbGV0ZSB0aGlzLnBvaW50cztcclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufTtcclxuXHJcblxyXG5FZGl0b3IuRXJhc2VyVG9vbCA9IGZ1bmN0aW9uIChlZGl0b3IsIG1vZGUpIHtcclxuXHR0aGlzLmVkaXRvciA9IGVkaXRvcjtcclxuXHJcblx0dGhpcy5tYXBzID0gWydhdG9tcycsICdib25kcycsICdyeG5BcnJvd3MnLCAncnhuUGx1c2VzJywgJ3Nncm91cHMnLCAnc2dyb3VwRGF0YScsICdjaGlyYWxGbGFncyddO1xyXG5cdHRoaXMuX2hvdmVySGVscGVyID0gbmV3IEVkaXRvci5FZGl0b3JUb29sLkhvdmVySGVscGVyKHRoaXMpO1xyXG5cdHRoaXMuX2xhc3NvSGVscGVyID0gbmV3IEVkaXRvci5MYXNzb1Rvb2wuTGFzc29IZWxwZXIobW9kZSB8fCAwLCBlZGl0b3IpO1xyXG59O1xyXG5FZGl0b3IuRXJhc2VyVG9vbC5wcm90b3R5cGUgPSBuZXcgRWRpdG9yLkVkaXRvclRvb2woKTtcclxuRWRpdG9yLkVyYXNlclRvb2wucHJvdG90eXBlLk9uTW91c2VEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0dmFyIGNpID0gdGhpcy5lZGl0b3IucmVuZGVyLmZpbmRJdGVtKGV2ZW50LCB0aGlzLm1hcHMpO1xyXG5cdGlmICghY2kgfHwgY2kudHlwZSA9PSAnQ2FudmFzJykge1xyXG5cdFx0dGhpcy5fbGFzc29IZWxwZXIuYmVnaW4oZXZlbnQpO1xyXG5cdH1cclxufTtcclxuRWRpdG9yLkVyYXNlclRvb2wucHJvdG90eXBlLk9uTW91c2VNb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0aWYgKHRoaXMuX2xhc3NvSGVscGVyLnJ1bm5pbmcoKSkge1xyXG5cdFx0dGhpcy5lZGl0b3IuX3NlbGVjdGlvbkhlbHBlci5zZXRTZWxlY3Rpb24oXHJcblx0XHR0aGlzLl9sYXNzb0hlbHBlci5hZGRQb2ludChldmVudClcclxuXHRcdCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRoaXMuX2hvdmVySGVscGVyLmhvdmVyKHRoaXMuZWRpdG9yLnJlbmRlci5maW5kSXRlbShldmVudCwgdGhpcy5tYXBzKSk7XHJcblx0fVxyXG59O1xyXG5FZGl0b3IuRXJhc2VyVG9vbC5wcm90b3R5cGUuT25Nb3VzZVVwID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0aWYgKHRoaXMuX2xhc3NvSGVscGVyLnJ1bm5pbmcoKSkgeyAvLyBUT0RPIGl0IGNhdGNoZXMgbW9yZSBldmVudHMgdGhhbiBuZWVkZWQsIHRvIGJlIHJlLWZhY3RvcmVkXHJcblx0XHR1aS5hZGRVbmRvQWN0aW9uKEFjdGlvbi5mcm9tRnJhZ21lbnREZWxldGlvbih0aGlzLl9sYXNzb0hlbHBlci5lbmQoZXZlbnQpKSk7XHJcblx0XHR0aGlzLmVkaXRvci5kZXNlbGVjdEFsbCgpO1xyXG5cdFx0dWkucmVuZGVyLnVwZGF0ZSgpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR2YXIgY2kgPSB0aGlzLmVkaXRvci5yZW5kZXIuZmluZEl0ZW0oZXZlbnQsIHRoaXMubWFwcyk7XHJcblx0XHRpZiAoY2kgJiYgY2kudHlwZSAhPSAnQ2FudmFzJykge1xyXG5cdFx0XHR0aGlzLl9ob3ZlckhlbHBlci5ob3ZlcihudWxsKTtcclxuXHRcdFx0aWYgKGNpLm1hcCA9PSAnYXRvbXMnKSB7XHJcblx0XHRcdFx0dWkuYWRkVW5kb0FjdGlvbihBY3Rpb24uZnJvbUF0b21EZWxldGlvbihjaS5pZCkpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGNpLm1hcCA9PSAnYm9uZHMnKSB7XHJcblx0XHRcdFx0dWkuYWRkVW5kb0FjdGlvbihBY3Rpb24uZnJvbUJvbmREZWxldGlvbihjaS5pZCkpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGNpLm1hcCA9PSAnc2dyb3VwcycgfHwgY2kubWFwID09ICdzZ3JvdXBEYXRhJykge1xyXG5cdFx0XHRcdHVpLmFkZFVuZG9BY3Rpb24oQWN0aW9uLmZyb21TZ3JvdXBEZWxldGlvbihjaS5pZCkpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGNpLm1hcCA9PSAncnhuQXJyb3dzJykge1xyXG5cdFx0XHRcdHVpLmFkZFVuZG9BY3Rpb24oQWN0aW9uLmZyb21BcnJvd0RlbGV0aW9uKGNpLmlkKSk7XHJcblx0XHRcdH0gZWxzZSBpZiAoY2kubWFwID09ICdyeG5QbHVzZXMnKSB7XHJcblx0XHRcdFx0dWkuYWRkVW5kb0FjdGlvbihBY3Rpb24uZnJvbVBsdXNEZWxldGlvbihjaS5pZCkpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGNpLm1hcCA9PSAnY2hpcmFsRmxhZ3MnKSB7XHJcblx0XHRcdFx0dWkuYWRkVW5kb0FjdGlvbihBY3Rpb24uZnJvbUNoaXJhbEZsYWdEZWxldGlvbigpKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyBUT0RPIHJlLWZhY3RvcmluZyBuZWVkZWQgLSBzaG91bGQgYmUgXCJtYXAtaW5kZXBlbmRlbnRcIlxyXG5cdFx0XHRcdGNvbnNvbGUubG9nKCdFcmFzZXJUb29sOiB1bmFibGUgdG8gZGVsZXRlIHRoZSBvYmplY3QgJyArIGNpLm1hcCArICdbJyArIGNpLmlkICsgJ10nKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5lZGl0b3IuZGVzZWxlY3RBbGwoKTtcclxuXHRcdFx0dWkucmVuZGVyLnVwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcblxyXG5FZGl0b3IuQXRvbVRvb2wgPSBmdW5jdGlvbiAoZWRpdG9yLCBhdG9tUHJvcHMpIHtcclxuXHR0aGlzLmVkaXRvciA9IGVkaXRvcjtcclxuXHR0aGlzLmF0b21Qcm9wcyA9IGF0b21Qcm9wcztcclxuXHR0aGlzLmJvbmRQcm9wcyA9IHsgdHlwZTogMSwgc3RlcmVvOiBCb25kLlBBVFRFUk4uU1RFUkVPLk5PTkUgfTtcclxuXHJcblx0dGhpcy5faG92ZXJIZWxwZXIgPSBuZXcgRWRpdG9yLkVkaXRvclRvb2wuSG92ZXJIZWxwZXIodGhpcyk7XHJcbn07XHJcbkVkaXRvci5BdG9tVG9vbC5wcm90b3R5cGUgPSBuZXcgRWRpdG9yLkVkaXRvclRvb2woKTtcclxuRWRpdG9yLkF0b21Ub29sLnByb3RvdHlwZS5Pbk1vdXNlRG93biA9IGZ1bmN0aW9uIChldmVudCkge1xyXG5cdHRoaXMuX2hvdmVySGVscGVyLmhvdmVyKG51bGwpO1xyXG5cdHZhciBjaSA9IHRoaXMuZWRpdG9yLnJlbmRlci5maW5kSXRlbShldmVudCwgWydhdG9tcyddKTtcclxuXHRpZiAoIWNpIHx8IGNpLnR5cGUgPT0gJ0NhbnZhcycpIHtcclxuXHRcdHRoaXMuZHJhZ0N0eCA9IHtcclxuXHRcdFx0eHkwOiB1aS5wYWdlMm9iaihldmVudClcclxuXHRcdH07XHJcblx0fSBlbHNlIGlmIChjaS5tYXAgPT0gJ2F0b21zJykge1xyXG5cdFx0dGhpcy5kcmFnQ3R4ID0ge1xyXG5cdFx0XHRpdGVtOiBjaSxcclxuXHRcdFx0eHkwOiB1aS5wYWdlMm9iaihldmVudClcclxuXHRcdH07XHJcblx0fVxyXG59O1xyXG5FZGl0b3IuQXRvbVRvb2wucHJvdG90eXBlLk9uTW91c2VNb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0dmFyIF9FXyA9IHRoaXMuZWRpdG9yLCBfUl8gPSBfRV8ucmVuZGVyO1xyXG5cdGlmICgnZHJhZ0N0eCcgaW4gdGhpcyAmJiAnaXRlbScgaW4gdGhpcy5kcmFnQ3R4KSB7XHJcblx0XHR2YXIgX0RDXyA9IHRoaXMuZHJhZ0N0eDtcclxuXHRcdHZhciBuZXdBdG9tUG9zID0gdGhpcy5fY2FsY05ld0F0b21Qb3MoXHJcblx0XHRfUl8uYXRvbUdldFBvcyhfRENfLml0ZW0uaWQpLCB1aS5wYWdlMm9iaihldmVudClcclxuXHRcdCk7XHJcblx0XHRpZiAoJ2FjdGlvbicgaW4gX0RDXykge1xyXG5cdFx0XHRfRENfLmFjdGlvbi5wZXJmb3JtKCk7XHJcblx0XHR9XHJcblx0XHQvLyBUT0RPIFtSQl0ga2x1ZGdlIGZpeCBmb3IgS0VUQ0hFUi01NjAuIG5lZWQgdG8gcmV2aWV3XHJcblx0XHQvL0JFR0lOXHJcblx0XHQvKlxyXG4gICAgICAgICB2YXIgYWN0aW9uX3JldCA9IEFjdGlvbi5mcm9tQm9uZEFkZGl0aW9uKFxyXG4gICAgICAgICB0aGlzLmJvbmRQcm9wcywgX0RDXy5pdGVtLmlkLCB0aGlzLmF0b21Qcm9wcywgbmV3QXRvbVBvcywgbmV3QXRvbVBvc1xyXG4gICAgICAgICApO1xyXG4gICAgICAgICAqL1xyXG5cdFx0dmFyIGFjdGlvbl9yZXQgPSBBY3Rpb24uZnJvbUJvbmRBZGRpdGlvbihcclxuXHRcdFx0dGhpcy5ib25kUHJvcHMsIF9EQ18uaXRlbS5pZCwgT2JqZWN0LmNsb25lKHRoaXMuYXRvbVByb3BzKSwgbmV3QXRvbVBvcywgbmV3QXRvbVBvc1xyXG5cdFx0KTtcclxuXHRcdC8vRU5EXHJcblx0XHRfRENfLmFjdGlvbiA9IGFjdGlvbl9yZXRbMF07XHJcblx0XHRfRENfLmFpZDIgPSBhY3Rpb25fcmV0WzJdO1xyXG5cdFx0X1JfLnVwZGF0ZSgpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aGlzLl9ob3ZlckhlbHBlci5ob3ZlcihfUl8uZmluZEl0ZW0oZXZlbnQsIFsnYXRvbXMnXSkpO1xyXG5cdH1cclxufTtcclxuRWRpdG9yLkF0b21Ub29sLnByb3RvdHlwZS5Pbk1vdXNlVXAgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuXHRpZiAoJ2RyYWdDdHgnIGluIHRoaXMpIHtcclxuXHRcdHZhciBfRENfID0gdGhpcy5kcmFnQ3R4O1xyXG5cdFx0dWkuYWRkVW5kb0FjdGlvbihcclxuXHRcdFx0XHQnYWN0aW9uJyBpbiBfRENfXHJcblx0XHRcdFx0ID8gX0RDXy5hY3Rpb25cclxuXHRcdFx0XHQgOiAnaXRlbScgaW4gX0RDX1xyXG5cdFx0XHRcdFx0ID8gQWN0aW9uLmZyb21BdG9tc0F0dHJzKF9EQ18uaXRlbS5pZCwgdGhpcy5hdG9tUHJvcHMsIHRydWUpXHJcblx0XHRcdFx0XHQgOiBBY3Rpb24uZnJvbUF0b21BZGRpdGlvbih1aS5wYWdlMm9iaihldmVudCksIHRoaXMuYXRvbVByb3BzKSxcclxuXHRcdFx0dHJ1ZVxyXG5cdFx0KTtcclxuXHRcdHRoaXMuZWRpdG9yLnJlbmRlci51cGRhdGUoKTtcclxuXHRcdGRlbGV0ZSB0aGlzLmRyYWdDdHg7XHJcblx0fVxyXG59O1xyXG5cclxuXHJcbkVkaXRvci5Cb25kVG9vbCA9IGZ1bmN0aW9uIChlZGl0b3IsIGJvbmRQcm9wcykge1xyXG5cdHRoaXMuZWRpdG9yID0gZWRpdG9yO1xyXG5cdHRoaXMuYXRvbVByb3BzID0geyBsYWJlbDogJ0MnIH07XHJcblx0dGhpcy5ib25kUHJvcHMgPSBib25kUHJvcHM7XHJcblx0dGhpcy5wbGFpbkJvbmRUeXBlcyA9IFtcclxuXHRcdFx0Qm9uZC5QQVRURVJOLlRZUEUuU0lOR0xFLFxyXG5cdFx0XHRCb25kLlBBVFRFUk4uVFlQRS5ET1VCTEUsXHJcblx0XHRcdEJvbmQuUEFUVEVSTi5UWVBFLlRSSVBMRV07XHJcblxyXG5cdHRoaXMuX2hvdmVySGVscGVyID0gbmV3IEVkaXRvci5FZGl0b3JUb29sLkhvdmVySGVscGVyKHRoaXMpO1xyXG59O1xyXG5FZGl0b3IuQm9uZFRvb2wucHJvdG90eXBlID0gbmV3IEVkaXRvci5FZGl0b3JUb29sKCk7XHJcblxyXG5FZGl0b3IuQm9uZFRvb2wucHJvdG90eXBlLk9uTW91c2VEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0dGhpcy5faG92ZXJIZWxwZXIuaG92ZXIobnVsbCk7XHJcblx0dGhpcy5kcmFnQ3R4ID0ge1xyXG5cdFx0eHkwOiB1aS5wYWdlMm9iaihldmVudCksXHJcblx0XHRpdGVtOiB0aGlzLmVkaXRvci5yZW5kZXIuZmluZEl0ZW0oZXZlbnQsIFsnYXRvbXMnLCAnYm9uZHMnXSlcclxuXHR9O1xyXG5cdGlmICghdGhpcy5kcmFnQ3R4Lml0ZW0gfHwgdGhpcy5kcmFnQ3R4Lml0ZW0udHlwZSA9PSAnQ2FudmFzJykgZGVsZXRlIHRoaXMuZHJhZ0N0eC5pdGVtO1xyXG5cdHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuRWRpdG9yLkJvbmRUb29sLnByb3RvdHlwZS5Pbk1vdXNlTW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xyXG5cdHZhciBfRV8gPSB0aGlzLmVkaXRvciwgX1JfID0gX0VfLnJlbmRlcjtcclxuXHRpZiAoJ2RyYWdDdHgnIGluIHRoaXMpIHtcclxuXHRcdHZhciBfRENfID0gdGhpcy5kcmFnQ3R4O1xyXG5cdFx0aWYgKCEoJ2l0ZW0nIGluIF9EQ18pIHx8IF9EQ18uaXRlbS5tYXAgPT0gJ2F0b21zJykge1xyXG5cdFx0XHRpZiAoJ2FjdGlvbicgaW4gX0RDXykgX0RDXy5hY3Rpb24ucGVyZm9ybSgpO1xyXG5cdFx0XHR2YXIgaTEsIGkyLCBwMSwgcDI7XHJcblx0XHRcdGlmICgoJ2l0ZW0nIGluIF9EQ18gJiYgX0RDXy5pdGVtLm1hcCA9PSAnYXRvbXMnKSkge1xyXG5cdFx0XHRcdGkxID0gX0RDXy5pdGVtLmlkO1xyXG5cdFx0XHRcdGkyID0gX1JfLmZpbmRJdGVtKGV2ZW50LCBbJ2F0b21zJ10sIF9EQ18uaXRlbSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aTEgPSB0aGlzLmF0b21Qcm9wcztcclxuXHRcdFx0XHRwMSA9IF9EQ18ueHkwO1xyXG5cdFx0XHRcdGkyID0gX1JfLmZpbmRJdGVtKGV2ZW50LCBbJ2F0b21zJ10pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBkaXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuXHRcdFx0aWYgKGkyICYmIGkyLm1hcCA9PSAnYXRvbXMnKSB7XHJcblx0XHRcdFx0aTIgPSBpMi5pZDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpMiA9IHRoaXMuYXRvbVByb3BzO1xyXG5cdFx0XHRcdHZhciB4eTEgPSB1aS5wYWdlMm9iaihldmVudCk7XHJcblx0XHRcdFx0ZGlzdCA9IFZlYzIuZGlzdChfRENfLnh5MCwgeHkxKTtcclxuXHRcdFx0XHRpZiAocDEpIHtcclxuXHRcdFx0XHRcdHAyID0gdGhpcy5fY2FsY05ld0F0b21Qb3MocDEsIHh5MSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHAxID0gdGhpcy5fY2FsY05ld0F0b21Qb3MoX1JfLmF0b21HZXRQb3MoaTEpLCB4eTEpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBkb24ndCByb3RhdGUgdGhlIGJvbmQgaWYgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgcG9pbnQgaXMgdG9vIHNtYWxsXHJcblx0XHRcdGlmIChkaXN0ID4gMC4zKSB7XHJcblx0XHRcdFx0X0RDXy5hY3Rpb24gPSBBY3Rpb24uZnJvbUJvbmRBZGRpdGlvbih0aGlzLmJvbmRQcm9wcywgaTEsIGkyLCBwMSwgcDIpWzBdO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGRlbGV0ZSBfRENfLmFjdGlvbjtcclxuXHRcdFx0fVxyXG5cdFx0XHRfUl8udXBkYXRlKCk7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHR0aGlzLl9ob3ZlckhlbHBlci5ob3ZlcihfUl8uZmluZEl0ZW0oZXZlbnQsIFsnYXRvbXMnLCAnYm9uZHMnXSkpO1xyXG5cdHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuRWRpdG9yLkJvbmRUb29sLnByb3RvdHlwZS5Pbk1vdXNlVXAgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuXHRpZiAoJ2RyYWdDdHgnIGluIHRoaXMpIHtcclxuXHRcdHZhciBfRENfID0gdGhpcy5kcmFnQ3R4O1xyXG5cdFx0aWYgKCdhY3Rpb24nIGluIF9EQ18pIHtcclxuXHRcdFx0dWkuYWRkVW5kb0FjdGlvbihfRENfLmFjdGlvbik7XHJcblx0XHR9IGVsc2UgaWYgKCEoJ2l0ZW0nIGluIF9EQ18pKSB7XHJcblx0XHRcdHZhciB4eSA9IHVpLnBhZ2Uyb2JqKGV2ZW50KTtcclxuXHRcdFx0dmFyIHYgPSBuZXcgVmVjMigxLjAgLyAyLCAwKS5yb3RhdGUoXHJcblx0XHRcdFx0dGhpcy5ib25kUHJvcHMudHlwZSA9PSBCb25kLlBBVFRFUk4uVFlQRS5TSU5HTEUgPyAtTWF0aC5QSSAvIDYgOiAwXHJcblx0XHRcdCk7XHJcblx0XHRcdHZhciBib25kQWRkaXRpb24gPSBBY3Rpb24uZnJvbUJvbmRBZGRpdGlvbihcclxuXHRcdFx0XHR0aGlzLmJvbmRQcm9wcyxcclxuXHRcdFx0eyBsYWJlbDogJ0MnIH0sXHJcblx0XHRcdHsgbGFiZWw6ICdDJyB9LFxyXG5cdFx0XHR7IHg6IHh5LnggLSB2LngsIHk6IHh5LnkgLSB2Lnl9LFxyXG5cdFx0XHR7IHg6IHh5LnggKyB2LngsIHk6IHh5LnkgKyB2Lnl9XHJcblx0XHRcdCk7XHJcblx0XHRcdHVpLmFkZFVuZG9BY3Rpb24oYm9uZEFkZGl0aW9uWzBdKTtcclxuXHRcdH0gZWxzZSBpZiAoX0RDXy5pdGVtLm1hcCA9PSAnYXRvbXMnKSB7XHJcblx0XHRcdHVpLmFkZFVuZG9BY3Rpb24oQWN0aW9uLmZyb21Cb25kQWRkaXRpb24odGhpcy5ib25kUHJvcHMsIF9EQ18uaXRlbS5pZClbMF0pO1xyXG5cdFx0fSBlbHNlIGlmIChfRENfLml0ZW0ubWFwID09ICdib25kcycpIHtcclxuXHRcdFx0dmFyIGJvbmRQcm9wcyA9IE9iamVjdC5jbG9uZSh0aGlzLmJvbmRQcm9wcyk7XHJcblx0XHRcdHZhciBib25kID0gdWkuY3RhYi5ib25kcy5nZXQoX0RDXy5pdGVtLmlkKTtcclxuXHJcblx0XHRcdGlmIChcclxuXHRcdFx0Ym9uZFByb3BzLnN0ZXJlbyAhPSBCb25kLlBBVFRFUk4uU1RFUkVPLk5PTkUgJiZcclxuXHRcdFx0Ym9uZC50eXBlID09IEJvbmQuUEFUVEVSTi5UWVBFLlNJTkdMRSAmJlxyXG5cdFx0XHRib25kUHJvcHMudHlwZSA9PSBCb25kLlBBVFRFUk4uVFlQRS5TSU5HTEUgJiZcclxuXHRcdFx0Ym9uZC5zdGVyZW8gPT0gYm9uZFByb3BzLnN0ZXJlb1xyXG5cdFx0XHQpIHtcclxuXHRcdFx0XHR1aS5hZGRVbmRvQWN0aW9uKEFjdGlvbi5mcm9tQm9uZEZsaXBwaW5nKF9EQ18uaXRlbS5pZCkpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmIChcclxuXHRcdFx0XHRib25kUHJvcHMudHlwZSA9PT0gQm9uZC5QQVRURVJOLlRZUEUuU0lOR0xFICYmXHJcblx0XHRcdFx0Ym9uZC5zdGVyZW8gPT09IEJvbmQuUEFUVEVSTi5TVEVSRU8uTk9ORSAmJlxyXG5cdFx0XHRcdGJvbmRQcm9wcy5zdGVyZW8gPT09IEJvbmQuUEFUVEVSTi5TVEVSRU8uTk9ORVxyXG5cdFx0XHRcdCkge1xyXG5cdFx0XHRcdFx0dmFyIGxvb3AgPSB0aGlzLnBsYWluQm9uZFR5cGVzLmluZGV4T2YoYm9uZFByb3BzLnR5cGUpID49IDAgPyB0aGlzLnBsYWluQm9uZFR5cGVzIDogbnVsbDtcclxuXHRcdFx0XHRcdGlmIChsb29wKSB7XHJcblx0XHRcdFx0XHRcdGJvbmRQcm9wcy50eXBlID0gbG9vcFsobG9vcC5pbmRleE9mKGJvbmQudHlwZSkgKyAxKSAlIGxvb3AubGVuZ3RoXTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dWkuYWRkVW5kb0FjdGlvbihcclxuXHRcdFx0XHRBY3Rpb24uZnJvbUJvbmRBdHRycyhfRENfLml0ZW0uaWQsIGJvbmRQcm9wcywgYm9uZEZsaXBSZXF1aXJlZChib25kLCBib25kUHJvcHMpKSxcclxuXHRcdFx0XHRcdHRydWVcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHR0aGlzLmVkaXRvci5yZW5kZXIudXBkYXRlKCk7XHJcblx0XHRkZWxldGUgdGhpcy5kcmFnQ3R4O1xyXG5cdH1cclxuXHRyZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbkVkaXRvci5DaGFpblRvb2wgPSBmdW5jdGlvbiAoZWRpdG9yKSB7XHJcblx0dGhpcy5lZGl0b3IgPSBlZGl0b3I7XHJcblxyXG5cdHRoaXMuX2hvdmVySGVscGVyID0gbmV3IEVkaXRvci5FZGl0b3JUb29sLkhvdmVySGVscGVyKHRoaXMpO1xyXG59O1xyXG5FZGl0b3IuQ2hhaW5Ub29sLnByb3RvdHlwZSA9IG5ldyBFZGl0b3IuRWRpdG9yVG9vbCgpO1xyXG5FZGl0b3IuQ2hhaW5Ub29sLnByb3RvdHlwZS5Pbk1vdXNlRG93biA9IGZ1bmN0aW9uIChldmVudCkge1xyXG5cdHRoaXMuX2hvdmVySGVscGVyLmhvdmVyKG51bGwpO1xyXG5cdHRoaXMuZHJhZ0N0eCA9IHtcclxuXHRcdHh5MDogdWkucGFnZTJvYmooZXZlbnQpLFxyXG5cdFx0aXRlbTogdGhpcy5lZGl0b3IucmVuZGVyLmZpbmRJdGVtKGV2ZW50LCBbJ2F0b21zJ10pXHJcblx0fTtcclxuXHRpZiAoIXRoaXMuZHJhZ0N0eC5pdGVtIHx8IHRoaXMuZHJhZ0N0eC5pdGVtLnR5cGUgPT0gJ0NhbnZhcycpIGRlbGV0ZSB0aGlzLmRyYWdDdHguaXRlbTtcclxuXHRyZXR1cm4gdHJ1ZTtcclxufTtcclxuRWRpdG9yLkNoYWluVG9vbC5wcm90b3R5cGUuT25Nb3VzZU1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuXHR2YXIgX0VfID0gdGhpcy5lZGl0b3IsIF9SXyA9IF9FXy5yZW5kZXI7XHJcblx0aWYgKCdkcmFnQ3R4JyBpbiB0aGlzKSB7XHJcblx0XHR2YXIgX0RDXyA9IHRoaXMuZHJhZ0N0eDtcclxuXHRcdGlmICgnYWN0aW9uJyBpbiBfRENfKSBfRENfLmFjdGlvbi5wZXJmb3JtKCk7XHJcblx0XHR2YXIgcG9zMCA9ICdpdGVtJyBpbiBfRENfID8gX1JfLmF0b21HZXRQb3MoX0RDXy5pdGVtLmlkKSA6IF9EQ18ueHkwO1xyXG5cdFx0dmFyIHBvczEgPSB1aS5wYWdlMm9iaihldmVudCk7XHJcblx0XHRfRENfLmFjdGlvbiA9IEFjdGlvbi5mcm9tQ2hhaW4oXHJcblx0XHRcdHBvczAsXHJcblx0XHR0aGlzLl9jYWxjQW5nbGUocG9zMCwgcG9zMSksXHJcblx0XHRNYXRoLmNlaWwoVmVjMi5kaWZmKHBvczEsIHBvczApLmxlbmd0aCgpKSxcclxuXHRcdFx0XHQnaXRlbScgaW4gX0RDXyA/IF9EQ18uaXRlbS5pZCA6IG51bGxcclxuXHRcdCk7XHJcblx0XHRfUl8udXBkYXRlKCk7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblx0dGhpcy5faG92ZXJIZWxwZXIuaG92ZXIoX1JfLmZpbmRJdGVtKGV2ZW50LCBbJ2F0b21zJ10pKTtcclxuXHRyZXR1cm4gdHJ1ZTtcclxufTtcclxuRWRpdG9yLkNoYWluVG9vbC5wcm90b3R5cGUuT25Nb3VzZVVwID0gZnVuY3Rpb24gKCkge1xyXG5cdGlmICgnZHJhZ0N0eCcgaW4gdGhpcykge1xyXG5cdFx0aWYgKCdhY3Rpb24nIGluIHRoaXMuZHJhZ0N0eCkge1xyXG5cdFx0XHR1aS5hZGRVbmRvQWN0aW9uKHRoaXMuZHJhZ0N0eC5hY3Rpb24pO1xyXG5cdFx0fVxyXG5cdFx0ZGVsZXRlIHRoaXMuZHJhZ0N0eDtcclxuXHR9XHJcblx0cmV0dXJuIHRydWU7XHJcbn07XHJcbkVkaXRvci5DaGFpblRvb2wucHJvdG90eXBlLk9uQ2FuY2VsID0gZnVuY3Rpb24gKCkge1xyXG5cdHRoaXMuT25Nb3VzZVVwKCk7XHJcbn07XHJcblxyXG5cclxuRWRpdG9yLlRlbXBsYXRlVG9vbCA9IGZ1bmN0aW9uIChlZGl0b3IsIHRlbXBsYXRlKSB7XHJcblx0dGhpcy5lZGl0b3IgPSBlZGl0b3I7XHJcblx0dGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xyXG5cclxuXHQvLyBsb2FkIHRlbXBsYXRlIG1vbGZpbGUgaW4gYWR2YW5jZVxyXG5cdGlmICghdGhpcy50ZW1wbGF0ZS5tb2xlY3VsZSkge1xyXG5cdFx0dmFyIGZyYWcgPSBtb2xmaWxlLnBhcnNlKHRoaXMudGVtcGxhdGUubW9sZmlsZSk7XHJcblx0XHRmcmFnLnJlc2NhbGUoKTtcclxuXHJcblx0XHR2YXIgeHkwID0gbmV3IFZlYzIoKTtcclxuXHJcblx0XHRmcmFnLmF0b21zLmVhY2goZnVuY3Rpb24gKGFpZCwgYXRvbSkge1xyXG5cdFx0XHR4eTAuYWRkXyhhdG9tLnBwKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHRoaXMudGVtcGxhdGUubW9sZWN1bGUgPSBmcmFnOyAvLyBwcmVsb2FkZWQgc3RydWN0XHJcblx0XHR0aGlzLnRlbXBsYXRlLnh5MCA9IHh5MC5zY2FsZWQoMSAvIGZyYWcuYXRvbXMuY291bnQoKSk7IC8vIHRlbXBsYXRlIGNlbnRlclxyXG5cdFx0dGhpcy50ZW1wbGF0ZS5hbmdsZTAgPSB0aGlzLl9jYWxjQW5nbGUoZnJhZy5hdG9tcy5nZXQodGhpcy50ZW1wbGF0ZS5haWQpLnBwLCB0aGlzLnRlbXBsYXRlLnh5MCk7IC8vIGNlbnRlciB0aWx0XHJcblxyXG5cdFx0dmFyIGJvbmQgPSBmcmFnLmJvbmRzLmdldCh0aGlzLnRlbXBsYXRlLmJpZCk7XHJcblx0XHR0aGlzLnRlbXBsYXRlLnNpZ24gPSB0aGlzLl9nZXRTaWduKGZyYWcsIGJvbmQsIHRoaXMudGVtcGxhdGUueHkwKTsgLy8gdGVtcGxhdGUgbG9jYXRpb24gc2lnbiBhZ2FpbnN0IGF0dGFjaG1lbnQgYm9uZFxyXG5cdH1cclxuXHJcblx0dGhpcy5faG92ZXJIZWxwZXIgPSBuZXcgRWRpdG9yLkVkaXRvclRvb2wuSG92ZXJIZWxwZXIodGhpcyk7XHJcbn07XHJcbkVkaXRvci5UZW1wbGF0ZVRvb2wucHJvdG90eXBlID0gbmV3IEVkaXRvci5FZGl0b3JUb29sKCk7XHJcbkVkaXRvci5UZW1wbGF0ZVRvb2wucHJvdG90eXBlLl9nZXRTaWduID0gZnVuY3Rpb24gKG1vbGVjdWxlLCBib25kLCB2KSB7XHJcblx0dmFyIGJlZ2luID0gbW9sZWN1bGUuYXRvbXMuZ2V0KGJvbmQuYmVnaW4pLnBwO1xyXG5cdHZhciBlbmQgPSBtb2xlY3VsZS5hdG9tcy5nZXQoYm9uZC5lbmQpLnBwO1xyXG5cclxuXHR2YXIgc2lnbiA9IFZlYzIuY3Jvc3MoVmVjMi5kaWZmKGJlZ2luLCBlbmQpLCBWZWMyLmRpZmYodiwgZW5kKSk7XHJcblxyXG5cdGlmIChzaWduID4gMCkgcmV0dXJuIDE7XHJcblx0aWYgKHNpZ24gPCAwKSByZXR1cm4gLTE7XHJcblx0cmV0dXJuIDA7XHJcbn07XHJcbkVkaXRvci5UZW1wbGF0ZVRvb2wucHJvdG90eXBlLk9uTW91c2VEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0dmFyIF9FXyA9IHRoaXMuZWRpdG9yLCBfUl8gPSBfRV8ucmVuZGVyO1xyXG5cdHRoaXMuX2hvdmVySGVscGVyLmhvdmVyKG51bGwpO1xyXG5cdHRoaXMuZHJhZ0N0eCA9IHtcclxuXHRcdHh5MDogdWkucGFnZTJvYmooZXZlbnQpLFxyXG5cdFx0aXRlbTogX1JfLmZpbmRJdGVtKGV2ZW50LCBbJ2F0b21zJywgJ2JvbmRzJ10pXHJcblx0fTtcclxuXHR2YXIgX0RDXyA9IHRoaXMuZHJhZ0N0eDtcclxuXHR2YXIgY2kgPSBfRENfLml0ZW07XHJcblx0aWYgKCFjaSB8fCBjaS50eXBlID09ICdDYW52YXMnKSB7XHJcblx0XHRkZWxldGUgX0RDXy5pdGVtO1xyXG5cdH0gZWxzZSBpZiAoY2kubWFwID09ICdib25kcycpIHtcclxuXHRcdC8vIGNhbGN1bGF0ZSBmcmFnbWVudCBjZW50ZXJcclxuXHRcdHZhciBtb2xlY3VsZSA9IF9SXy5jdGFiLm1vbGVjdWxlO1xyXG5cdFx0dmFyIHh5MCA9IG5ldyBWZWMyKCk7XHJcblx0XHR2YXIgYm9uZCA9IG1vbGVjdWxlLmJvbmRzLmdldChjaS5pZCk7XHJcblx0XHR2YXIgZnJpZCA9IF9SXy5hdG9tR2V0QXR0cihib25kLmJlZ2luLCAnZnJhZ21lbnQnKTtcclxuXHRcdHZhciBmcl9pZHMgPSBtb2xlY3VsZS5nZXRGcmFnbWVudElkcyhmcmlkKTtcclxuXHRcdHZhciBjb3VudCA9IDA7XHJcblxyXG5cdFx0dmFyIGxvb3AgPSBtb2xlY3VsZS5oYWxmQm9uZHMuZ2V0KGJvbmQuaGIxKS5sb29wO1xyXG5cclxuXHRcdGlmIChsb29wIDwgMCkge1xyXG5cdFx0XHRsb29wID0gbW9sZWN1bGUuaGFsZkJvbmRzLmdldChib25kLmhiMikubG9vcDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobG9vcCA+PSAwKSB7XHJcblx0XHRcdHZhciBsb29wX2hicyA9IG1vbGVjdWxlLmxvb3BzLmdldChsb29wKS5oYnM7XHJcblx0XHRcdGxvb3BfaGJzLmVhY2goZnVuY3Rpb24gKGhiKSB7XHJcblx0XHRcdFx0eHkwLmFkZF8obW9sZWN1bGUuYXRvbXMuZ2V0KG1vbGVjdWxlLmhhbGZCb25kcy5nZXQoaGIpLmJlZ2luKS5wcCk7XHJcblx0XHRcdFx0Y291bnQrKztcclxuXHRcdFx0fSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRTZXQuZWFjaChmcl9pZHMsIGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0XHRcdHh5MC5hZGRfKG1vbGVjdWxlLmF0b21zLmdldChpZCkucHApO1xyXG5cdFx0XHRcdGNvdW50Kys7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdF9EQ18udjAgPSB4eTAuc2NhbGVkKDEgLyBjb3VudCk7XHJcblxyXG5cdFx0dmFyIHNpZ24gPSB0aGlzLl9nZXRTaWduKG1vbGVjdWxlLCBib25kLCBfRENfLnYwKTtcclxuXHJcblx0XHQvLyBjYWxjdWxhdGUgZGVmYXVsdCB0ZW1wbGF0ZSBmbGlwXHJcblx0XHRfRENfLnNpZ24xID0gc2lnbiB8fCAxO1xyXG5cdFx0X0RDXy5zaWduMiA9IHRoaXMudGVtcGxhdGUuc2lnbjtcclxuXHR9XHJcblx0cmV0dXJuIHRydWU7XHJcbn07XHJcbkVkaXRvci5UZW1wbGF0ZVRvb2wucHJvdG90eXBlLk9uTW91c2VNb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0dmFyIF9FXyA9IHRoaXMuZWRpdG9yLCBfUl8gPSBfRV8ucmVuZGVyO1xyXG5cdGlmICgnZHJhZ0N0eCcgaW4gdGhpcykge1xyXG5cdFx0dmFyIF9EQ18gPSB0aGlzLmRyYWdDdHg7XHJcblx0XHR2YXIgY2kgPSBfRENfLml0ZW07XHJcblx0XHR2YXIgcG9zMDtcclxuXHRcdHZhciBwb3MxID0gdWkucGFnZTJvYmooZXZlbnQpO1xyXG5cdFx0dmFyIGFuZ2xlLCBleHRyYV9ib25kO1xyXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuXHRcdF9EQ18ubW91c2VfbW92ZWQgPSB0cnVlO1xyXG5cclxuXHRcdC8vIGNhbGMgaW5pdGlhbCBwb3MgYW5kIGlzIGV4dHJhIGJvbmQgbmVlZGVkXHJcblx0XHRpZiAoIWNpIHx8IGNpLnR5cGUgPT0gJ0NhbnZhcycpIHtcclxuXHRcdFx0cG9zMCA9IF9EQ18ueHkwO1xyXG5cdFx0fSBlbHNlIGlmIChjaS5tYXAgPT0gJ2F0b21zJykge1xyXG5cdFx0XHRwb3MwID0gX1JfLmF0b21HZXRQb3MoY2kuaWQpO1xyXG5cdFx0XHRleHRyYV9ib25kID0gVmVjMi5kaXN0KHBvczAsIHBvczEpID4gMTtcclxuXHRcdH0gZWxzZSBpZiAoY2kubWFwID09ICdib25kcycpIHtcclxuXHRcdFx0dmFyIG1vbGVjdWxlID0gX1JfLmN0YWIubW9sZWN1bGU7XHJcblx0XHRcdHZhciBib25kID0gbW9sZWN1bGUuYm9uZHMuZ2V0KGNpLmlkKTtcclxuXHRcdFx0dmFyIHNpZ24gPSB0aGlzLl9nZXRTaWduKG1vbGVjdWxlLCBib25kLCBwb3MxKTtcclxuXHJcblx0XHRcdGlmIChfRENfLnNpZ24xICogdGhpcy50ZW1wbGF0ZS5zaWduID4gMCkge1xyXG5cdFx0XHRcdHNpZ24gPSAtc2lnbjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHNpZ24gIT0gX0RDXy5zaWduMiB8fCAhX0RDXy5hY3Rpb24pIHtcclxuXHRcdFx0XHQvLyB1bmRvIHByZXZpb3VzIGFjdGlvblxyXG5cdFx0XHRcdGlmICgnYWN0aW9uJyBpbiBfRENfKSBfRENfLmFjdGlvbi5wZXJmb3JtKCk7XHJcblx0XHRcdFx0X0RDXy5zaWduMiA9IHNpZ247XHJcblx0XHRcdFx0X0RDXy5hY3Rpb24gPSBBY3Rpb24uZnJvbVRlbXBsYXRlT25Cb25kKGNpLmlkLCB0aGlzLnRlbXBsYXRlLCB0aGlzLl9jYWxjQW5nbGUsIF9EQ18uc2lnbjEgKiBfRENfLnNpZ24yID4gMCk7XHJcblx0XHRcdFx0X1JfLnVwZGF0ZSgpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRhbmdsZSA9IHRoaXMuX2NhbGNBbmdsZShwb3MwLCBwb3MxKTtcclxuXHRcdHZhciBkZWdyZWVzID0gTWF0aC5yb3VuZCgxODAgLyBNYXRoLlBJICogYW5nbGUpO1xyXG5cdFx0Ly8gY2hlY2sgaWYgYW55dGhpbmcgY2hhbmdlZCBzaW5jZSBsYXN0IHRpbWVcclxuXHRcdGlmICgnYW5nbGUnIGluIF9EQ18gJiYgX0RDXy5hbmdsZSA9PSBkZWdyZWVzKSB7XHJcblx0XHRcdGlmICgnZXh0cmFfYm9uZCcgaW4gX0RDXykge1xyXG5cdFx0XHRcdGlmIChfRENfLmV4dHJhX2JvbmQgPT0gZXh0cmFfYm9uZClcclxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHQvLyB1bmRvIHByZXZpb3VzIGFjdGlvblxyXG5cdFx0aWYgKCdhY3Rpb24nIGluIF9EQ18pIF9EQ18uYWN0aW9uLnBlcmZvcm0oKTtcclxuXHRcdC8vIGNyZWF0ZSBuZXcgYWN0aW9uXHJcblx0XHRfRENfLmFuZ2xlID0gZGVncmVlcztcclxuXHRcdGlmICghY2kgfHwgY2kudHlwZSA9PSAnQ2FudmFzJykge1xyXG5cdFx0XHRfRENfLmFjdGlvbiA9IEFjdGlvbi5mcm9tVGVtcGxhdGVPbkNhbnZhcyhcclxuXHRcdFx0XHRwb3MwLFxyXG5cdFx0XHRcdGFuZ2xlLFxyXG5cdFx0XHRcdHRoaXMudGVtcGxhdGVcclxuXHRcdFx0KTtcclxuXHRcdH0gZWxzZSBpZiAoY2kubWFwID09ICdhdG9tcycpIHtcclxuXHRcdFx0X0RDXy5hY3Rpb24gPSBBY3Rpb24uZnJvbVRlbXBsYXRlT25BdG9tKFxyXG5cdFx0XHRcdGNpLmlkLFxyXG5cdFx0XHRcdGFuZ2xlLFxyXG5cdFx0XHRcdGV4dHJhX2JvbmQsXHJcblx0XHRcdFx0dGhpcy50ZW1wbGF0ZSxcclxuXHRcdFx0XHR0aGlzLl9jYWxjQW5nbGVcclxuXHRcdFx0KTtcclxuXHRcdFx0X0RDXy5leHRyYV9ib25kID0gZXh0cmFfYm9uZDtcclxuXHRcdH1cclxuXHRcdF9SXy51cGRhdGUoKTtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHR0aGlzLl9ob3ZlckhlbHBlci5ob3ZlcihfUl8uZmluZEl0ZW0oZXZlbnQsIFsnYXRvbXMnLCAnYm9uZHMnXSkpO1xyXG5cdHJldHVybiB0cnVlO1xyXG59O1xyXG5FZGl0b3IuVGVtcGxhdGVUb29sLnByb3RvdHlwZS5Pbk1vdXNlVXAgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuXHR2YXIgX0VfID0gdGhpcy5lZGl0b3IsIF9SXyA9IF9FXy5yZW5kZXI7XHJcblx0aWYgKCdkcmFnQ3R4JyBpbiB0aGlzKSB7XHJcblx0XHR2YXIgX0RDXyA9IHRoaXMuZHJhZ0N0eDtcclxuXHRcdHZhciBjaSA9IF9EQ18uaXRlbTtcclxuXHJcblx0XHRpZiAoIV9EQ18uYWN0aW9uKSB7XHJcblx0XHRcdGlmICghY2kgfHwgY2kudHlwZSA9PSAnQ2FudmFzJykge1xyXG5cdFx0XHRcdF9EQ18uYWN0aW9uID0gQWN0aW9uLmZyb21UZW1wbGF0ZU9uQ2FudmFzKF9EQ18ueHkwLCAwLCB0aGlzLnRlbXBsYXRlKTtcclxuXHRcdFx0fSBlbHNlIGlmIChjaS5tYXAgPT0gJ2F0b21zJykge1xyXG5cdFx0XHRcdHZhciBkZWdyZWUgPSBfUl8uYXRvbUdldERlZ3JlZShjaS5pZCk7XHJcblxyXG5cdFx0XHRcdGlmIChkZWdyZWUgPiAxKSB7IC8vIGNvbW1vbiBjYXNlXHJcblx0XHRcdFx0XHRfRENfLmFjdGlvbiA9IEFjdGlvbi5mcm9tVGVtcGxhdGVPbkF0b20oXHJcblx0XHRcdFx0XHRcdGNpLmlkLFxyXG5cdFx0XHRcdFx0XHRudWxsLFxyXG5cdFx0XHRcdFx0XHR0cnVlLFxyXG5cdFx0XHRcdFx0XHR0aGlzLnRlbXBsYXRlLFxyXG5cdFx0XHRcdFx0XHR0aGlzLl9jYWxjQW5nbGVcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChkZWdyZWUgPT0gMSkgeyAvLyBvbiBjaGFpbiBlbmRcclxuXHRcdFx0XHRcdHZhciBtb2xlY3VsZSA9IF9SXy5jdGFiLm1vbGVjdWxlO1xyXG5cdFx0XHRcdFx0dmFyIG5laV9pZCA9IG1vbGVjdWxlLmhhbGZCb25kcy5nZXQobW9sZWN1bGUuYXRvbXMuZ2V0KGNpLmlkKS5uZWlnaGJvcnNbMF0pLmVuZDtcclxuXHRcdFx0XHRcdHZhciBhdG9tID0gbW9sZWN1bGUuYXRvbXMuZ2V0KGNpLmlkKTtcclxuXHRcdFx0XHRcdHZhciBuZWkgPSBtb2xlY3VsZS5hdG9tcy5nZXQobmVpX2lkKTtcclxuXHJcblx0XHRcdFx0XHRfRENfLmFjdGlvbiA9IEFjdGlvbi5mcm9tVGVtcGxhdGVPbkF0b20oXHJcblx0XHRcdFx0XHRcdGNpLmlkLFxyXG5cdFx0XHRcdFx0dGhpcy5fY2FsY0FuZ2xlKG5laS5wcCwgYXRvbS5wcCksXHJcblx0XHRcdFx0XHRcdGZhbHNlLFxyXG5cdFx0XHRcdFx0XHR0aGlzLnRlbXBsYXRlLFxyXG5cdFx0XHRcdFx0XHR0aGlzLl9jYWxjQW5nbGVcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0fSBlbHNlIHsgLy8gb24gc2luZ2xlIGF0b21cclxuXHRcdFx0XHRcdF9EQ18uYWN0aW9uID0gQWN0aW9uLmZyb21UZW1wbGF0ZU9uQXRvbShcclxuXHRcdFx0XHRcdFx0Y2kuaWQsXHJcblx0XHRcdFx0XHRcdDAsXHJcblx0XHRcdFx0XHRcdGZhbHNlLFxyXG5cdFx0XHRcdFx0XHR0aGlzLnRlbXBsYXRlLFxyXG5cdFx0XHRcdFx0XHR0aGlzLl9jYWxjQW5nbGVcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2UgaWYgKGNpLm1hcCA9PSAnYm9uZHMnKSB7XHJcblx0XHRcdFx0X0RDXy5hY3Rpb24gPSBBY3Rpb24uZnJvbVRlbXBsYXRlT25Cb25kKGNpLmlkLCB0aGlzLnRlbXBsYXRlLCB0aGlzLl9jYWxjQW5nbGUsIF9EQ18uc2lnbjEgKiBfRENfLnNpZ24yID4gMCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF9SXy51cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoJ2FjdGlvbicgaW4gdGhpcy5kcmFnQ3R4KSB7XHJcblx0XHRcdGlmICghdGhpcy5kcmFnQ3R4LmFjdGlvbi5pc0R1bW15KCkpXHJcblx0XHRcdFx0dWkuYWRkVW5kb0FjdGlvbih0aGlzLmRyYWdDdHguYWN0aW9uKTtcclxuXHRcdH1cclxuXHRcdGRlbGV0ZSB0aGlzLmRyYWdDdHg7XHJcblx0fVxyXG59O1xyXG5FZGl0b3IuVGVtcGxhdGVUb29sLnByb3RvdHlwZS5PbkNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcclxuXHR0aGlzLk9uTW91c2VVcCgpO1xyXG59O1xyXG5cclxuRWRpdG9yLkNoYXJnZVRvb2wgPSBmdW5jdGlvbiAoZWRpdG9yLCBjaGFyZ2UpIHsgLy8gVE9ETyBbUkJdIHNob3VsZCBiZSBcInBsdWdnYWJsZVwiXHJcblx0dGhpcy5lZGl0b3IgPSBlZGl0b3I7XHJcblx0dGhpcy5jaGFyZ2UgPSBjaGFyZ2U7XHJcblxyXG5cdHRoaXMuX2hvdmVySGVscGVyID0gbmV3IEVkaXRvci5FZGl0b3JUb29sLkhvdmVySGVscGVyKHRoaXMpO1xyXG59O1xyXG5FZGl0b3IuQ2hhcmdlVG9vbC5wcm90b3R5cGUgPSBuZXcgRWRpdG9yLkVkaXRvclRvb2woKTtcclxuRWRpdG9yLkNoYXJnZVRvb2wucHJvdG90eXBlLk9uTW91c2VNb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0dmFyIGNpID0gdGhpcy5lZGl0b3IucmVuZGVyLmZpbmRJdGVtKGV2ZW50LCBbJ2F0b21zJ10pO1xyXG5cdGlmIChjaSAmJiBjaS5tYXAgPT0gJ2F0b21zJyAmJiBlbGVtZW50LmdldEVsZW1lbnRCeUxhYmVsKHVpLmN0YWIuYXRvbXMuZ2V0KGNpLmlkKS5sYWJlbCkgIT0gbnVsbCkge1xyXG5cdFx0dGhpcy5faG92ZXJIZWxwZXIuaG92ZXIoY2kpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aGlzLl9ob3ZlckhlbHBlci5ob3ZlcihudWxsKTtcclxuXHR9XHJcblx0cmV0dXJuIHRydWU7XHJcbn07XHJcbkVkaXRvci5DaGFyZ2VUb29sLnByb3RvdHlwZS5Pbk1vdXNlVXAgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuXHR2YXIgX0VfID0gdGhpcy5lZGl0b3IsIF9SXyA9IF9FXy5yZW5kZXI7XHJcblx0dmFyIGNpID0gX1JfLmZpbmRJdGVtKGV2ZW50LCBbJ2F0b21zJ10pO1xyXG5cdGlmIChjaSAmJiBjaS5tYXAgPT0gJ2F0b21zJyAmJiBlbGVtZW50LmdldEVsZW1lbnRCeUxhYmVsKHVpLmN0YWIuYXRvbXMuZ2V0KGNpLmlkKS5sYWJlbCkgIT0gbnVsbCkge1xyXG5cdFx0dGhpcy5faG92ZXJIZWxwZXIuaG92ZXIobnVsbCk7XHJcblx0XHR1aS5hZGRVbmRvQWN0aW9uKFxyXG5cdFx0QWN0aW9uLmZyb21BdG9tc0F0dHJzKGNpLmlkLCB7IGNoYXJnZTogX1JfLmN0YWIubW9sZWN1bGUuYXRvbXMuZ2V0KGNpLmlkKS5jaGFyZ2UgKyB0aGlzLmNoYXJnZSB9KVxyXG5cdFx0KTtcclxuXHRcdF9SXy51cGRhdGUoKTtcclxuXHR9XHJcblx0cmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG5cclxuRWRpdG9yLlJHcm91cEF0b21Ub29sID0gZnVuY3Rpb24gKGVkaXRvcikge1xyXG5cdHRoaXMuZWRpdG9yID0gZWRpdG9yO1xyXG5cclxuXHR0aGlzLl9ob3ZlckhlbHBlciA9IG5ldyBFZGl0b3IuRWRpdG9yVG9vbC5Ib3ZlckhlbHBlcih0aGlzKTtcclxufTtcclxuRWRpdG9yLlJHcm91cEF0b21Ub29sLnByb3RvdHlwZSA9IG5ldyBFZGl0b3IuRWRpdG9yVG9vbCgpO1xyXG5FZGl0b3IuUkdyb3VwQXRvbVRvb2wucHJvdG90eXBlLk9uTW91c2VNb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0dGhpcy5faG92ZXJIZWxwZXIuaG92ZXIodGhpcy5lZGl0b3IucmVuZGVyLmZpbmRJdGVtKGV2ZW50LCBbJ2F0b21zJ10pKTtcclxufTtcclxuRWRpdG9yLlJHcm91cEF0b21Ub29sLnByb3RvdHlwZS5Pbk1vdXNlVXAgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuXHRmdW5jdGlvbiBzZWwyVmFsdWVzKHJnKSB7XHJcblx0XHR2YXIgcmVzID0gW107XHJcblx0XHRmb3IgKHZhciByZ2kgPSAwOyByZ2kgPCAzMjsgcmdpKyspXHJcblx0XHRcdGlmIChyZyAmICgxIDw8IHJnaSkpIHtcclxuXHRcdFx0XHR2YXIgdmFsID0gJ1InICsgKHJnaSArIDEpO1xyXG5cdFx0XHRcdHJlcy5wdXNoKHZhbCk7IC8vIHB1c2ggdGhlIHN0cmluZ1xyXG5cdFx0XHR9XHJcblx0XHRyZXR1cm4gcmVzO1xyXG5cdH1cclxuXHRmdW5jdGlvbiB2YWx1ZXMyU2VsKHZhbHMpIHtcclxuXHRcdHZhciByZXMgPSAwO1xyXG5cdFx0dmFscy52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsKSB7XHJcblx0XHRcdHZhciByZ2kgPSB2YWwuc3Vic3RyKDEpIC0gMTtcclxuXHRcdFx0cmVzIHw9IDEgPDwgcmdpO1xyXG5cdFx0fSk7XHJcblx0XHRyZXR1cm4gcmVzO1xyXG5cdH1cclxuXHR2YXIgY2kgPSB0aGlzLmVkaXRvci5yZW5kZXIuZmluZEl0ZW0oZXZlbnQsIFsnYXRvbXMnXSk7XHJcblx0aWYgKCFjaSB8fCBjaS50eXBlID09ICdDYW52YXMnKSB7XHJcblx0XHR0aGlzLl9ob3ZlckhlbHBlci5ob3ZlcihudWxsKTtcclxuXHRcdHVpLnNob3dSR3JvdXBUYWJsZSh7XHJcblx0XHRcdG1vZGU6ICdtdWx0aXBsZScsXHJcblx0XHRcdG9uT2s6IGZ1bmN0aW9uIChyZ05ldykge1xyXG5cdFx0XHRcdHJnTmV3ID0gdmFsdWVzMlNlbChyZ05ldyk7XHJcblx0XHRcdFx0aWYgKHJnTmV3KSB7XHJcblx0XHRcdFx0XHR1aS5hZGRVbmRvQWN0aW9uKFxyXG5cdFx0XHRcdFx0QWN0aW9uLmZyb21BdG9tQWRkaXRpb24oXHJcblx0XHRcdFx0XHR1aS5wYWdlMm9iaih0aGlzLk9uTW91c2VNb3ZlMC5sYXN0RXZlbnQpLFxyXG5cdFx0XHRcdFx0eyBsYWJlbDogJ1IjJywgcmdsYWJlbDogcmdOZXd9XHJcblx0XHRcdFx0XHQpLFxyXG5cdFx0XHRcdFx0XHR0cnVlXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdFx0dWkucmVuZGVyLnVwZGF0ZSgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fS5iaW5kKHRoaXMpXHJcblx0XHR9KTtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH0gZWxzZSBpZiAoY2kgJiYgY2kubWFwID09ICdhdG9tcycpIHtcclxuXHRcdHRoaXMuX2hvdmVySGVscGVyLmhvdmVyKG51bGwpO1xyXG5cdFx0dmFyIGF0b20gPSB0aGlzLmVkaXRvci5yZW5kZXIuY3RhYi5tb2xlY3VsZS5hdG9tcy5nZXQoY2kuaWQpO1xyXG5cdFx0dmFyIGxiT2xkID0gYXRvbS5sYWJlbDtcclxuXHRcdHZhciByZ09sZCA9IGF0b20ucmdsYWJlbDtcclxuXHRcdHVpLnNob3dSR3JvdXBUYWJsZSh7XHJcblx0XHRcdG1vZGU6ICdtdWx0aXBsZScsXHJcblx0XHRcdHZhbHVlczogc2VsMlZhbHVlcyhyZ09sZCksXHJcblx0XHRcdG9uT2s6IGZ1bmN0aW9uIChyZ05ldykge1xyXG5cdFx0XHRcdHJnTmV3ID0gdmFsdWVzMlNlbChyZ05ldyk7XHJcblx0XHRcdFx0aWYgKHJnT2xkICE9IHJnTmV3IHx8IGxiT2xkICE9ICdSIycpIHtcclxuXHRcdFx0XHRcdHZhciBuZXdQcm9wcyA9IE9iamVjdC5jbG9uZShBdG9tLmF0dHJsaXN0KTsgLy8gVE9ETyByZXZpZXc6IHVzaW5nIEF0b20uYXR0cmxpc3QgYXMgYSBzb3VyY2Ugb2YgZGVmYXVsdCBwcm9wZXJ0eSB2YWx1ZXNcclxuXHRcdFx0XHRcdGlmIChyZ05ldykge1xyXG5cdFx0XHRcdFx0XHRuZXdQcm9wcy5sYWJlbCA9ICdSIyc7XHJcblx0XHRcdFx0XHRcdG5ld1Byb3BzLnJnbGFiZWwgPSByZ05ldztcclxuXHRcdFx0XHRcdFx0bmV3UHJvcHMuYWFtID0gYXRvbS5hYW07XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRuZXdQcm9wcy5sYWJlbCA9ICdDJztcclxuXHRcdFx0XHRcdFx0bmV3UHJvcHMuYWFtID0gYXRvbS5hYW07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR1aS5hZGRVbmRvQWN0aW9uKEFjdGlvbi5mcm9tQXRvbXNBdHRycyhjaS5pZCwgbmV3UHJvcHMpLCB0cnVlKTtcclxuXHRcdFx0XHRcdHVpLnJlbmRlci51cGRhdGUoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0uYmluZCh0aGlzKVxyXG5cdFx0fSk7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuRWRpdG9yLlJHcm91cEZyYWdtZW50VG9vbCA9IGZ1bmN0aW9uIChlZGl0b3IpIHtcclxuXHR0aGlzLmVkaXRvciA9IGVkaXRvcjtcclxuXHJcblx0dGhpcy5faG92ZXJIZWxwZXIgPSBuZXcgRWRpdG9yLkVkaXRvclRvb2wuSG92ZXJIZWxwZXIodGhpcyk7XHJcbn07XHJcblxyXG5FZGl0b3IuUkdyb3VwRnJhZ21lbnRUb29sLnByb3RvdHlwZSA9IG5ldyBFZGl0b3IuRWRpdG9yVG9vbCgpO1xyXG5FZGl0b3IuUkdyb3VwRnJhZ21lbnRUb29sLnByb3RvdHlwZS5Pbk1vdXNlTW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xyXG5cdHRoaXMuX2hvdmVySGVscGVyLmhvdmVyKHRoaXMuZWRpdG9yLnJlbmRlci5maW5kSXRlbShldmVudCwgWydmcmFncycsICdyZ3JvdXBzJ10pKTtcclxufTtcclxuXHJcbkVkaXRvci5SR3JvdXBGcmFnbWVudFRvb2wucHJvdG90eXBlLk9uTW91c2VVcCA9IGZ1bmN0aW9uIChldmVudCkge1xyXG5cdHZhciBjaSA9IHRoaXMuZWRpdG9yLnJlbmRlci5maW5kSXRlbShldmVudCwgWydmcmFncycsICdyZ3JvdXBzJ10pO1xyXG5cdGlmIChjaSAmJiBjaS5tYXAgPT0gJ2ZyYWdzJykge1xyXG5cdFx0dGhpcy5faG92ZXJIZWxwZXIuaG92ZXIobnVsbCk7XHJcblx0XHR2YXIgcmdPbGQgPSBTdHJ1Y3QuUkdyb3VwLmZpbmRSR3JvdXBCeUZyYWdtZW50KHRoaXMuZWRpdG9yLnJlbmRlci5jdGFiLm1vbGVjdWxlLnJncm91cHMsIGNpLmlkKTtcclxuXHRcdHVpLnNob3dSR3JvdXBUYWJsZSh7XHJcblx0XHRcdHZhbHVlczogcmdPbGQgJiYgWydSJyArIHJnT2xkXSxcclxuXHRcdFx0b25PazogZnVuY3Rpb24gKHJnTmV3KSB7XHJcblx0XHRcdFx0Y29uc29sZS5hc3NlcnQocmdOZXcudmFsdWVzLmxlbmd0aCA8PSAxLCAnVG9vIG11Y2ggZWxlbWVudHMnKTtcclxuXHRcdFx0XHRyZ05ldyA9IHJnTmV3LnZhbHVlcy5sZW5ndGggPyByZ05ldy52YWx1ZXNbMF0uc3Vic3RyKDEpIC0gMCA6IDA7XHJcblx0XHRcdFx0aWYgKHJnT2xkICE9IHJnTmV3KSB7XHJcblx0XHRcdFx0XHR1aS5hZGRVbmRvQWN0aW9uKFxyXG5cdFx0XHRcdFx0QWN0aW9uLmZyb21SR3JvdXBGcmFnbWVudChyZ05ldywgY2kuaWQpLFxyXG5cdFx0XHRcdFx0XHR0cnVlXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdFx0dWkucmVuZGVyLnVwZGF0ZSgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fS5iaW5kKHRoaXMpXHJcblx0XHR9KTtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHRlbHNlIGlmIChjaSAmJiBjaS5tYXAgPT0gJ3Jncm91cHMnKSB7XHJcblx0XHR0aGlzLl9ob3ZlckhlbHBlci5ob3ZlcihudWxsKTtcclxuXHRcdHZhciByZyA9IHRoaXMuZWRpdG9yLnJlbmRlci5jdGFiLm1vbGVjdWxlLnJncm91cHMuZ2V0KGNpLmlkKTtcclxuXHRcdHZhciByZ21hc2sgPSAwOyB0aGlzLmVkaXRvci5yZW5kZXIuY3RhYi5tb2xlY3VsZS5yZ3JvdXBzLmVhY2goZnVuY3Rpb24gKHJnaWQpIHsgcmdtYXNrIHw9ICgxIDw8IChyZ2lkIC0gMSkpOyB9KTtcclxuXHRcdHZhciBvbGRMb2dpYyA9IHtcclxuXHRcdFx0b2NjdXJyZW5jZTogcmcucmFuZ2UsXHJcblx0XHRcdHJlc3RoOiByZy5yZXN0aCxcclxuXHRcdFx0aWZ0aGVuOiByZy5pZnRoZW5cclxuXHRcdH07XHJcblx0XHR1aS5zaG93UkxvZ2ljVGFibGUoe1xyXG5cdFx0XHRyZ2lkOiBjaS5pZCxcclxuXHRcdFx0cmxvZ2ljOiBvbGRMb2dpYyxcclxuXHRcdFx0cmdtYXNrOiByZ21hc2ssXHJcblx0XHRcdG9uT2s6IGZ1bmN0aW9uIChuZXdMb2dpYykge1xyXG5cdFx0XHRcdHZhciBwcm9wcyA9IHt9O1xyXG5cdFx0XHRcdGlmIChvbGRMb2dpYy5vY2N1cnJlbmNlICE9IG5ld0xvZ2ljLm9jY3VycmVuY2UpIHtcclxuXHRcdFx0XHRcdHZhciBpc1ZhbGlkID0gbmV3TG9naWMub2NjdXJyZW5jZS5zcGxpdCgnLCcpLmFsbChmdW5jdGlvbiAocyl7XHJcblx0XHRcdFx0XHRcdHJldHVybiBzLm1hdGNoKC9eWz4sPCw9XT9bMC05XSskL2cpIHx8IHMubWF0Y2goL15bMC05XStcXC1bMC05XSskL2cpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHRpZiAoIWlzVmFsaWQpIHtcclxuXHRcdFx0XHRcdFx0YWxlcnQoJ0JhZCBvY2N1cnJlbmNlIHZhbHVlJyk7XHJcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHByb3BzLnJhbmdlID0gbmV3TG9naWMub2NjdXJyZW5jZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKG9sZExvZ2ljLnJlc3RoICE9IG5ld0xvZ2ljLnJlc3RoKSBwcm9wcy5yZXN0aCA9IG5ld0xvZ2ljLnJlc3RoO1xyXG5cdFx0XHRcdGlmIChvbGRMb2dpYy5pZnRoZW4gIT0gbmV3TG9naWMuaWZ0aGVuKSBwcm9wcy5pZnRoZW4gPSBuZXdMb2dpYy5pZnRoZW47XHJcblx0XHRcdFx0aWYgKCdyYW5nZScgaW4gcHJvcHMgfHwgJ3Jlc3RoJyBpbiBwcm9wcyB8fCAnaWZ0aGVuJyBpbiBwcm9wcykge1xyXG5cdFx0XHRcdFx0dWkuYWRkVW5kb0FjdGlvbihBY3Rpb24uZnJvbVJHcm91cEF0dHJzKGNpLmlkLCBwcm9wcykpO1xyXG5cdFx0XHRcdFx0dGhpcy5lZGl0b3IucmVuZGVyLnVwZGF0ZSgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fS5iaW5kKHRoaXMpXHJcblx0XHR9KTtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxufTtcclxuXHJcbkVkaXRvci5BUG9pbnRUb29sID0gZnVuY3Rpb24gKGVkaXRvcikge1xyXG5cdHRoaXMuZWRpdG9yID0gZWRpdG9yO1xyXG5cclxuXHR0aGlzLl9ob3ZlckhlbHBlciA9IG5ldyBFZGl0b3IuRWRpdG9yVG9vbC5Ib3ZlckhlbHBlcih0aGlzKTtcclxufTtcclxuRWRpdG9yLkFQb2ludFRvb2wucHJvdG90eXBlID0gbmV3IEVkaXRvci5FZGl0b3JUb29sKCk7XHJcbkVkaXRvci5BUG9pbnRUb29sLnByb3RvdHlwZS5Pbk1vdXNlTW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xyXG5cdHRoaXMuX2hvdmVySGVscGVyLmhvdmVyKHRoaXMuZWRpdG9yLnJlbmRlci5maW5kSXRlbShldmVudCwgWydhdG9tcyddKSk7XHJcbn07XHJcbkVkaXRvci5BUG9pbnRUb29sLnByb3RvdHlwZS5Pbk1vdXNlVXAgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuXHR2YXIgY2kgPSB0aGlzLmVkaXRvci5yZW5kZXIuZmluZEl0ZW0oZXZlbnQsIFsnYXRvbXMnXSk7XHJcblx0aWYgKGNpICYmIGNpLm1hcCA9PSAnYXRvbXMnKSB7XHJcblx0XHR0aGlzLl9ob3ZlckhlbHBlci5ob3ZlcihudWxsKTtcclxuXHRcdHZhciBhcE9sZCA9IHRoaXMuZWRpdG9yLnJlbmRlci5jdGFiLm1vbGVjdWxlLmF0b21zLmdldChjaS5pZCkuYXR0cG50O1xyXG5cdFx0dWkuc2hvd0F0b21BdHRhY2htZW50UG9pbnRzKHtcclxuXHRcdFx0c2VsZWN0aW9uOiBhcE9sZCxcclxuXHRcdFx0b25PazogZnVuY3Rpb24gKGFwTmV3KSB7XHJcblx0XHRcdFx0aWYgKGFwT2xkICE9IGFwTmV3KSB7XHJcblx0XHRcdFx0XHR1aS5hZGRVbmRvQWN0aW9uKEFjdGlvbi5mcm9tQXRvbXNBdHRycyhjaS5pZCwgeyBhdHRwbnQ6IGFwTmV3IH0pLCB0cnVlKTtcclxuXHRcdFx0XHRcdHVpLnJlbmRlci51cGRhdGUoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0uYmluZCh0aGlzKVxyXG5cdFx0fSk7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuRWRpdG9yLlJlYWN0aW9uQXJyb3dUb29sID0gZnVuY3Rpb24gKGVkaXRvcikge1xyXG5cdHRoaXMuZWRpdG9yID0gZWRpdG9yO1xyXG5cclxuXHR0aGlzLl9ob3ZlckhlbHBlciA9IG5ldyBFZGl0b3IuRWRpdG9yVG9vbC5Ib3ZlckhlbHBlcih0aGlzKTtcclxufTtcclxuRWRpdG9yLlJlYWN0aW9uQXJyb3dUb29sLnByb3RvdHlwZSA9IG5ldyBFZGl0b3IuRWRpdG9yVG9vbCgpO1xyXG5FZGl0b3IuUmVhY3Rpb25BcnJvd1Rvb2wucHJvdG90eXBlLk9uTW91c2VEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0dmFyIGNpID0gdGhpcy5lZGl0b3IucmVuZGVyLmZpbmRJdGVtKGV2ZW50LCBbJ3J4bkFycm93cyddKTtcclxuXHRpZiAoY2kgJiYgY2kubWFwID09ICdyeG5BcnJvd3MnKSB7XHJcblx0XHR0aGlzLl9ob3ZlckhlbHBlci5ob3ZlcihudWxsKTtcclxuXHRcdHRoaXMuZWRpdG9yLl9zZWxlY3Rpb25IZWxwZXIuc2V0U2VsZWN0aW9uKGNpKTtcclxuXHRcdHRoaXMuZHJhZ0N0eCA9IHtcclxuXHRcdFx0eHkwOiB1aS5wYWdlMm9iaihldmVudClcclxuXHRcdH07XHJcblx0fVxyXG59O1xyXG5FZGl0b3IuUmVhY3Rpb25BcnJvd1Rvb2wucHJvdG90eXBlLk9uTW91c2VNb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0aWYgKCdkcmFnQ3R4JyBpbiB0aGlzKSB7XHJcblx0XHRpZiAodGhpcy5kcmFnQ3R4LmFjdGlvbilcclxuXHRcdFx0dGhpcy5kcmFnQ3R4LmFjdGlvbi5wZXJmb3JtKCk7XHJcblx0XHR0aGlzLmRyYWdDdHguYWN0aW9uID0gQWN0aW9uLmZyb21NdWx0aXBsZU1vdmUoXHJcblx0XHRcdHRoaXMuZWRpdG9yLl9zZWxlY3Rpb25IZWxwZXIuc2VsZWN0aW9uLFxyXG5cdFx0dWkucGFnZTJvYmooZXZlbnQpLnN1Yih0aGlzLmRyYWdDdHgueHkwKVxyXG5cdFx0KTtcclxuXHRcdHVpLnJlbmRlci51cGRhdGUoKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhpcy5faG92ZXJIZWxwZXIuaG92ZXIodGhpcy5lZGl0b3IucmVuZGVyLmZpbmRJdGVtKGV2ZW50LCBbJ3J4bkFycm93cyddKSk7XHJcblx0fVxyXG59O1xyXG5FZGl0b3IuUmVhY3Rpb25BcnJvd1Rvb2wucHJvdG90eXBlLk9uTW91c2VVcCA9IGZ1bmN0aW9uIChldmVudCkge1xyXG5cdGlmICgnZHJhZ0N0eCcgaW4gdGhpcykge1xyXG5cdFx0dWkuYWRkVW5kb0FjdGlvbih0aGlzLmRyYWdDdHguYWN0aW9uLCBmYWxzZSk7IC8vIFRPRE8gaW52ZXN0aWdhdGUsIHN1YnNlcXVlbnQgdW5kby9yZWRvIGZhaWxzXHJcblx0XHR0aGlzLmVkaXRvci5yZW5kZXIudXBkYXRlKCk7XHJcblx0XHRkZWxldGUgdGhpcy5kcmFnQ3R4O1xyXG5cdH0gZWxzZSBpZiAodGhpcy5lZGl0b3IucmVuZGVyLmN0YWIubW9sZWN1bGUucnhuQXJyb3dzLmNvdW50KCkgPCAxKSB7XHJcblx0XHR1aS5hZGRVbmRvQWN0aW9uKEFjdGlvbi5mcm9tQXJyb3dBZGRpdGlvbih1aS5wYWdlMm9iaihldmVudCkpKTtcclxuXHRcdHRoaXMuZWRpdG9yLnJlbmRlci51cGRhdGUoKTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuRWRpdG9yLlJlYWN0aW9uUGx1c1Rvb2wgPSBmdW5jdGlvbiAoZWRpdG9yKSB7XHJcblx0dGhpcy5lZGl0b3IgPSBlZGl0b3I7XHJcblxyXG5cdHRoaXMuX2hvdmVySGVscGVyID0gbmV3IEVkaXRvci5FZGl0b3JUb29sLkhvdmVySGVscGVyKHRoaXMpO1xyXG59O1xyXG5FZGl0b3IuUmVhY3Rpb25QbHVzVG9vbC5wcm90b3R5cGUgPSBuZXcgRWRpdG9yLkVkaXRvclRvb2woKTtcclxuRWRpdG9yLlJlYWN0aW9uUGx1c1Rvb2wucHJvdG90eXBlLk9uTW91c2VEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0dmFyIGNpID0gdGhpcy5lZGl0b3IucmVuZGVyLmZpbmRJdGVtKGV2ZW50LCBbJ3J4blBsdXNlcyddKTtcclxuXHRpZiAoY2kgJiYgY2kubWFwID09ICdyeG5QbHVzZXMnKSB7XHJcblx0XHR0aGlzLl9ob3ZlckhlbHBlci5ob3ZlcihudWxsKTtcclxuXHRcdHRoaXMuZWRpdG9yLl9zZWxlY3Rpb25IZWxwZXIuc2V0U2VsZWN0aW9uKGNpKTtcclxuXHRcdHRoaXMuZHJhZ0N0eCA9IHtcclxuXHRcdFx0eHkwOiB1aS5wYWdlMm9iaihldmVudClcclxuXHRcdH07XHJcblx0fVxyXG59O1xyXG5FZGl0b3IuUmVhY3Rpb25QbHVzVG9vbC5wcm90b3R5cGUuT25Nb3VzZU1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuXHRpZiAoJ2RyYWdDdHgnIGluIHRoaXMpIHtcclxuXHRcdGlmICh0aGlzLmRyYWdDdHguYWN0aW9uKVxyXG5cdFx0XHR0aGlzLmRyYWdDdHguYWN0aW9uLnBlcmZvcm0oKTtcclxuXHRcdHRoaXMuZHJhZ0N0eC5hY3Rpb24gPSBBY3Rpb24uZnJvbU11bHRpcGxlTW92ZShcclxuXHRcdFx0dGhpcy5lZGl0b3IuX3NlbGVjdGlvbkhlbHBlci5zZWxlY3Rpb24sXHJcblx0XHR1aS5wYWdlMm9iaihldmVudCkuc3ViKHRoaXMuZHJhZ0N0eC54eTApXHJcblx0XHQpO1xyXG5cdFx0dWkucmVuZGVyLnVwZGF0ZSgpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aGlzLl9ob3ZlckhlbHBlci5ob3Zlcih0aGlzLmVkaXRvci5yZW5kZXIuZmluZEl0ZW0oZXZlbnQsIFsncnhuUGx1c2VzJ10pKTtcclxuXHR9XHJcbn07XHJcbkVkaXRvci5SZWFjdGlvblBsdXNUb29sLnByb3RvdHlwZS5Pbk1vdXNlVXAgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuXHRpZiAoJ2RyYWdDdHgnIGluIHRoaXMpIHtcclxuXHRcdHVpLmFkZFVuZG9BY3Rpb24odGhpcy5kcmFnQ3R4LmFjdGlvbiwgZmFsc2UpOyAvLyBUT0RPIGludmVzdGlnYXRlLCBzdWJzZXF1ZW50IHVuZG8vcmVkbyBmYWlsc1xyXG5cdFx0dGhpcy5lZGl0b3IucmVuZGVyLnVwZGF0ZSgpO1xyXG5cdFx0ZGVsZXRlIHRoaXMuZHJhZ0N0eDtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dWkuYWRkVW5kb0FjdGlvbihBY3Rpb24uZnJvbVBsdXNBZGRpdGlvbih1aS5wYWdlMm9iaihldmVudCkpKTtcclxuXHRcdHRoaXMuZWRpdG9yLnJlbmRlci51cGRhdGUoKTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuRWRpdG9yLlJlYWN0aW9uTWFwVG9vbCA9IGZ1bmN0aW9uIChlZGl0b3IpIHtcclxuXHR0aGlzLmVkaXRvciA9IGVkaXRvcjtcclxuXHJcblx0dGhpcy5faG92ZXJIZWxwZXIgPSBuZXcgRWRpdG9yLkVkaXRvclRvb2wuSG92ZXJIZWxwZXIodGhpcyk7XHJcblxyXG5cdHRoaXMuZWRpdG9yLl9zZWxlY3Rpb25IZWxwZXIuc2V0U2VsZWN0aW9uKG51bGwpO1xyXG5cclxuXHR0aGlzLnJjcyA9IHRoaXMuZWRpdG9yLnJlbmRlci5jdGFiLm1vbGVjdWxlLmdldENvbXBvbmVudHMoKTtcclxufTtcclxuRWRpdG9yLlJlYWN0aW9uTWFwVG9vbC5wcm90b3R5cGUgPSBuZXcgRWRpdG9yLkVkaXRvclRvb2woKTtcclxuRWRpdG9yLlJlYWN0aW9uTWFwVG9vbC5wcm90b3R5cGUuT25Nb3VzZURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuXHR2YXIgY2kgPSB0aGlzLmVkaXRvci5yZW5kZXIuZmluZEl0ZW0oZXZlbnQsIFsnYXRvbXMnXSk7XHJcblx0aWYgKGNpICYmIGNpLm1hcCA9PSAnYXRvbXMnKSB7XHJcblx0XHR0aGlzLl9ob3ZlckhlbHBlci5ob3ZlcihudWxsKTtcclxuXHRcdHRoaXMuZHJhZ0N0eCA9IHtcclxuXHRcdFx0aXRlbTogY2ksXHJcblx0XHRcdHh5MDogdWkucGFnZTJvYmooZXZlbnQpXHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5FZGl0b3IuUmVhY3Rpb25NYXBUb29sLnByb3RvdHlwZS5Pbk1vdXNlTW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xyXG5cdHZhciBybmQgPSB0aGlzLmVkaXRvci5yZW5kZXI7XHJcblx0aWYgKCdkcmFnQ3R4JyBpbiB0aGlzKSB7XHJcblx0XHR2YXIgY2kgPSBybmQuZmluZEl0ZW0oZXZlbnQsIFsnYXRvbXMnXSwgdGhpcy5kcmFnQ3R4Lml0ZW0pO1xyXG5cdFx0aWYgKGNpICYmIGNpLm1hcCA9PSAnYXRvbXMnICYmIHRoaXMuX2lzVmFsaWRNYXAodGhpcy5kcmFnQ3R4Lml0ZW0uaWQsIGNpLmlkKSkge1xyXG5cdFx0XHR0aGlzLl9ob3ZlckhlbHBlci5ob3ZlcihjaSk7XHJcblx0XHRcdHJuZC5kcmF3U2VsZWN0aW9uTGluZShybmQuYXRvbUdldFBvcyh0aGlzLmRyYWdDdHguaXRlbS5pZCksIHJuZC5hdG9tR2V0UG9zKGNpLmlkKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9ob3ZlckhlbHBlci5ob3ZlcihudWxsKTtcclxuXHRcdFx0cm5kLmRyYXdTZWxlY3Rpb25MaW5lKHJuZC5hdG9tR2V0UG9zKHRoaXMuZHJhZ0N0eC5pdGVtLmlkKSwgdWkucGFnZTJvYmooZXZlbnQpKTtcclxuXHRcdH1cclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhpcy5faG92ZXJIZWxwZXIuaG92ZXIocm5kLmZpbmRJdGVtKGV2ZW50LCBbJ2F0b21zJ10pKTtcclxuXHR9XHJcbn07XHJcbkVkaXRvci5SZWFjdGlvbk1hcFRvb2wucHJvdG90eXBlLk9uTW91c2VVcCA9IGZ1bmN0aW9uIChldmVudCkge1xyXG5cdGlmICgnZHJhZ0N0eCcgaW4gdGhpcykge1xyXG5cdFx0dmFyIHJuZCA9IHRoaXMuZWRpdG9yLnJlbmRlcjtcclxuXHRcdHZhciBjaSA9IHJuZC5maW5kSXRlbShldmVudCwgWydhdG9tcyddLCB0aGlzLmRyYWdDdHguaXRlbSk7XHJcblx0XHRpZiAoY2kgJiYgY2kubWFwID09ICdhdG9tcycgJiYgdGhpcy5faXNWYWxpZE1hcCh0aGlzLmRyYWdDdHguaXRlbS5pZCwgY2kuaWQpKSB7XHJcblx0XHRcdHZhciBhY3Rpb24gPSBuZXcgQWN0aW9uKCk7XHJcblx0XHRcdHZhciBhdG9tcyA9IHJuZC5jdGFiLm1vbGVjdWxlLmF0b21zO1xyXG5cdFx0XHR2YXIgYXRvbTEgPSBhdG9tcy5nZXQodGhpcy5kcmFnQ3R4Lml0ZW0uaWQpLCBhdG9tMiA9IGF0b21zLmdldChjaS5pZCk7XHJcblx0XHRcdHZhciBhYW0xID0gYXRvbTEuYWFtLCBhYW0yID0gYXRvbTIuYWFtO1xyXG5cdFx0XHRpZiAoIWFhbTEgfHwgYWFtMSAhPSBhYW0yKSB7XHJcblx0XHRcdFx0aWYgKGFhbTEgJiYgYWFtMSAhPSBhYW0yIHx8ICFhYW0xICYmIGFhbTIpIHtcclxuXHRcdFx0XHRcdGF0b21zLmVhY2goXHJcblx0XHRcdFx0XHRmdW5jdGlvbiAoYWlkLCBhdG9tKSB7XHJcblx0XHRcdFx0XHRcdGlmIChhaWQgIT0gdGhpcy5kcmFnQ3R4Lml0ZW0uaWQgJiYgKGFhbTEgJiYgYXRvbS5hYW0gPT0gYWFtMSB8fCBhYW0yICYmIGF0b20uYWFtID09IGFhbTIpKSB7XHJcblx0XHRcdFx0XHRcdFx0YWN0aW9uLm1lcmdlV2l0aChBY3Rpb24uZnJvbUF0b21zQXR0cnMoYWlkLCB7IGFhbTogMCB9KSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHRcdHRoaXNcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChhYW0xKSB7XHJcblx0XHRcdFx0XHRhY3Rpb24ubWVyZ2VXaXRoKEFjdGlvbi5mcm9tQXRvbXNBdHRycyhjaS5pZCwgeyBhYW06IGFhbTEgfSkpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR2YXIgYWFtID0gMDsgYXRvbXMuZWFjaChmdW5jdGlvbiAoYWlkLCBhdG9tKSB7IGFhbSA9IE1hdGgubWF4KGFhbSwgYXRvbS5hYW0gfHwgMCk7IH0pO1xyXG5cdFx0XHRcdFx0YWN0aW9uLm1lcmdlV2l0aChBY3Rpb24uZnJvbUF0b21zQXR0cnModGhpcy5kcmFnQ3R4Lml0ZW0uaWQsIHsgYWFtOiBhYW0gKyAxIH0pKTtcclxuXHRcdFx0XHRcdGFjdGlvbi5tZXJnZVdpdGgoQWN0aW9uLmZyb21BdG9tc0F0dHJzKGNpLmlkLCB7IGFhbTogYWFtICsgMSB9KSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHVpLmFkZFVuZG9BY3Rpb24oYWN0aW9uLCB0cnVlKTtcclxuXHRcdFx0XHRybmQudXBkYXRlKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJuZC5kcmF3U2VsZWN0aW9uTGluZShudWxsKTtcclxuXHRcdGRlbGV0ZSB0aGlzLmRyYWdDdHg7XHJcblx0fVxyXG5cdHRoaXMuX2hvdmVySGVscGVyLmhvdmVyKG51bGwpO1xyXG59O1xyXG5cclxuRWRpdG9yLlJlYWN0aW9uTWFwVG9vbC5wcm90b3R5cGUuX2lzVmFsaWRNYXAgPSBmdW5jdGlvbiAoYWlkMSwgYWlkMikge1xyXG5cdHZhciB0MSwgdDI7XHJcblx0Zm9yICh2YXIgcmkgPSAwOyAoIXQxIHx8ICF0MikgJiYgcmkgPCB0aGlzLnJjcy5yZWFjdGFudHMubGVuZ3RoOyByaSsrKSB7XHJcblx0XHR2YXIgcm8gPSBTZXQubGlzdCh0aGlzLnJjcy5yZWFjdGFudHNbcmldKTtcclxuXHRcdGlmICghdDEgJiYgcm8uaW5kZXhPZihhaWQxKSA+PSAwKSB0MSA9ICdyJztcclxuXHRcdGlmICghdDIgJiYgcm8uaW5kZXhPZihhaWQyKSA+PSAwKSB0MiA9ICdyJztcclxuXHR9XHJcblx0Zm9yICh2YXIgcGkgPSAwOyAoIXQxIHx8ICF0MikgJiYgcGkgPCB0aGlzLnJjcy5wcm9kdWN0cy5sZW5ndGg7IHBpKyspIHtcclxuXHRcdHZhciBwbyA9IFNldC5saXN0KHRoaXMucmNzLnByb2R1Y3RzW3BpXSk7XHJcblx0XHRpZiAoIXQxICYmIHBvLmluZGV4T2YoYWlkMSkgPj0gMCkgdDEgPSAncCc7XHJcblx0XHRpZiAoIXQyICYmIHBvLmluZGV4T2YoYWlkMikgPj0gMCkgdDIgPSAncCc7XHJcblx0fVxyXG5cdHJldHVybiB0MSAmJiB0MiAmJiB0MSAhPSB0MjtcclxufTtcclxuXHJcblxyXG5FZGl0b3IuUmVhY3Rpb25Vbm1hcFRvb2wgPSBmdW5jdGlvbiAoZWRpdG9yKSB7XHJcblx0dGhpcy5lZGl0b3IgPSBlZGl0b3I7XHJcblxyXG5cdHRoaXMuX2hvdmVySGVscGVyID0gbmV3IEVkaXRvci5FZGl0b3JUb29sLkhvdmVySGVscGVyKHRoaXMpO1xyXG5cclxuXHR0aGlzLmVkaXRvci5fc2VsZWN0aW9uSGVscGVyLnNldFNlbGVjdGlvbihudWxsKTtcclxufTtcclxuRWRpdG9yLlJlYWN0aW9uVW5tYXBUb29sLnByb3RvdHlwZSA9IG5ldyBFZGl0b3IuRWRpdG9yVG9vbCgpO1xyXG5FZGl0b3IuUmVhY3Rpb25Vbm1hcFRvb2wucHJvdG90eXBlLk9uTW91c2VNb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0dmFyIGNpID0gdGhpcy5lZGl0b3IucmVuZGVyLmZpbmRJdGVtKGV2ZW50LCBbJ2F0b21zJ10pO1xyXG5cdGlmIChjaSAmJiBjaS5tYXAgPT0gJ2F0b21zJykge1xyXG5cdFx0dGhpcy5faG92ZXJIZWxwZXIuaG92ZXIodGhpcy5lZGl0b3IucmVuZGVyLmN0YWIubW9sZWN1bGUuYXRvbXMuZ2V0KGNpLmlkKS5hYW0gPyBjaSA6IG51bGwpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aGlzLl9ob3ZlckhlbHBlci5ob3ZlcihudWxsKTtcclxuXHR9XHJcbn07XHJcbkVkaXRvci5SZWFjdGlvblVubWFwVG9vbC5wcm90b3R5cGUuT25Nb3VzZVVwID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0dmFyIGNpID0gdGhpcy5lZGl0b3IucmVuZGVyLmZpbmRJdGVtKGV2ZW50LCBbJ2F0b21zJ10pO1xyXG5cdHZhciBhdG9tcyA9IHRoaXMuZWRpdG9yLnJlbmRlci5jdGFiLm1vbGVjdWxlLmF0b21zO1xyXG5cdGlmIChjaSAmJiBjaS5tYXAgPT0gJ2F0b21zJyAmJiBhdG9tcy5nZXQoY2kuaWQpLmFhbSkge1xyXG5cdFx0dmFyIGFjdGlvbiA9IG5ldyBBY3Rpb24oKTtcclxuXHRcdHZhciBhYW0gPSBhdG9tcy5nZXQoY2kuaWQpLmFhbTtcclxuXHRcdGF0b21zLmVhY2goXHJcblx0XHRmdW5jdGlvbiAoYWlkLCBhdG9tKSB7XHJcblx0XHRcdGlmIChhdG9tLmFhbSA9PSBhYW0pIHtcclxuXHRcdFx0XHRhY3Rpb24ubWVyZ2VXaXRoKEFjdGlvbi5mcm9tQXRvbXNBdHRycyhhaWQsIHsgYWFtOiAwIH0pKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFx0dGhpc1xyXG5cdFx0KTtcclxuXHRcdHVpLmFkZFVuZG9BY3Rpb24oYWN0aW9uLCB0cnVlKTtcclxuXHRcdHRoaXMuZWRpdG9yLnJlbmRlci51cGRhdGUoKTtcclxuXHR9XHJcblx0dGhpcy5faG92ZXJIZWxwZXIuaG92ZXIobnVsbCk7XHJcbn07XHJcblxyXG5FZGl0b3IuU0dyb3VwVG9vbCA9IGZ1bmN0aW9uIChlZGl0b3IpIHtcclxuXHR0aGlzLmVkaXRvciA9IGVkaXRvcjtcclxuXHJcblx0dGhpcy5tYXBzID0gWydhdG9tcycsICdib25kcycsICdzZ3JvdXBzJywgJ3Nncm91cERhdGEnXTtcclxuXHR0aGlzLl9ob3ZlckhlbHBlciA9IG5ldyBFZGl0b3IuRWRpdG9yVG9vbC5Ib3ZlckhlbHBlcih0aGlzKTtcclxuXHR0aGlzLl9sYXNzb0hlbHBlciA9IG5ldyBFZGl0b3IuTGFzc29Ub29sLkxhc3NvSGVscGVyKDEsIGVkaXRvcik7XHJcblx0dGhpcy5fc0dyb3VwSGVscGVyID0gbmV3IEVkaXRvci5TR3JvdXBUb29sLlNHcm91cEhlbHBlcihlZGl0b3IpO1xyXG5cclxuXHR2YXIgc2VsZWN0aW9uID0gdGhpcy5lZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XHJcblx0aWYgKHNlbGVjdGlvbi5hdG9tcyAmJiBzZWxlY3Rpb24uYXRvbXMubGVuZ3RoID4gMCkge1xyXG5cdFx0Ly8gaWYgdGhlIHNlbGVjdGlvbiBjb250YWlucyBhdG9tcywgY3JlYXRlIGFuIHMtZ3JvdXAgb3V0IG9mIHRob3NlXHJcblx0XHR0aGlzLl9zR3JvdXBIZWxwZXIuc2hvd1Byb3BlcnRpZXNEaWFsb2cobnVsbCwgc2VsZWN0aW9uKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Ly8gb3RoZXJ3aXNlLCBjbGVhciBzZWxlY3Rpb25cclxuXHRcdHRoaXMuZWRpdG9yLmRlc2VsZWN0QWxsKCk7XHJcblx0fVxyXG59O1xyXG5FZGl0b3IuU0dyb3VwVG9vbC5wcm90b3R5cGUgPSBuZXcgRWRpdG9yLkVkaXRvclRvb2woKTtcclxuRWRpdG9yLlNHcm91cFRvb2wucHJvdG90eXBlLk9uTW91c2VEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0dmFyIGNpID0gdGhpcy5lZGl0b3IucmVuZGVyLmZpbmRJdGVtKGV2ZW50LCB0aGlzLm1hcHMpO1xyXG5cdGlmICghY2kgfHwgY2kudHlwZSA9PSAnQ2FudmFzJykge1xyXG5cdFx0dGhpcy5fbGFzc29IZWxwZXIuYmVnaW4oZXZlbnQpO1xyXG5cdH1cclxufTtcclxuRWRpdG9yLlNHcm91cFRvb2wucHJvdG90eXBlLk9uTW91c2VNb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0aWYgKHRoaXMuX2xhc3NvSGVscGVyLnJ1bm5pbmcoKSkge1xyXG5cdFx0dGhpcy5lZGl0b3IuX3NlbGVjdGlvbkhlbHBlci5zZXRTZWxlY3Rpb24oXHJcblx0XHR0aGlzLl9sYXNzb0hlbHBlci5hZGRQb2ludChldmVudClcclxuXHRcdCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRoaXMuX2hvdmVySGVscGVyLmhvdmVyKHRoaXMuZWRpdG9yLnJlbmRlci5maW5kSXRlbShldmVudCwgdGhpcy5tYXBzKSk7XHJcblx0fVxyXG59O1xyXG5cclxuRWRpdG9yLlNHcm91cFRvb2wuU0dyb3VwSGVscGVyID0gZnVuY3Rpb24gKGVkaXRvcikge1xyXG5cdHRoaXMuZWRpdG9yID0gZWRpdG9yO1xyXG5cdHRoaXMuc2VsZWN0aW9uID0gbnVsbDtcclxufTtcclxuXHJcbkVkaXRvci5TR3JvdXBUb29sLlNHcm91cEhlbHBlci5wcm90b3R5cGUuc2hvd1Byb3BlcnRpZXNEaWFsb2cgPSBmdW5jdGlvbiAoaWQsIHNlbGVjdGlvbikge1xyXG5cdHRoaXMuc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xyXG5cclxuXHR2YXIgcmVuZGVyID0gdGhpcy5lZGl0b3IucmVuZGVyO1xyXG5cdC8vIGNoZWNrIHMtZ3JvdXAgb3ZlcmxhcHBpbmdzXHJcblx0aWYgKGlkID09IG51bGwpXHJcblx0e1xyXG5cdFx0dmFyIHZlcmlmaWVkID0ge307XHJcblx0XHR2YXIgYXRvbXNfaGFzaCA9IHt9O1xyXG5cclxuXHRcdHNlbGVjdGlvbi5hdG9tcy5lYWNoKGZ1bmN0aW9uIChpZClcclxuXHRcdHtcclxuXHRcdFx0YXRvbXNfaGFzaFtpZF0gPSB0cnVlO1xyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKCFPYmplY3QuaXNVbmRlZmluZWQoc2VsZWN0aW9uLmF0b21zLmRldGVjdChmdW5jdGlvbiAoaWQpXHJcblx0XHR7XHJcblx0XHRcdHZhciBzZ3JvdXBzID0gcmVuZGVyLmF0b21HZXRTR3JvdXBzKGlkKTtcclxuXHJcblx0XHRcdHJldHVybiAhT2JqZWN0LmlzVW5kZWZpbmVkKHNncm91cHMuZGV0ZWN0KGZ1bmN0aW9uIChzaWQpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRpZiAoc2lkIGluIHZlcmlmaWVkKVxyXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdFx0XHR2YXIgc2dfYXRvbXMgPSByZW5kZXIuc0dyb3VwR2V0QXRvbXMoc2lkKTtcclxuXHJcblx0XHRcdFx0aWYgKHNnX2F0b21zLmxlbmd0aCA8IHNlbGVjdGlvbi5hdG9tcy5sZW5ndGgpXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0aWYgKCFPYmplY3QuaXNVbmRlZmluZWQoc2dfYXRvbXMuZGV0ZWN0KGZ1bmN0aW9uIChhaWQpXHJcblx0XHRcdFx0XHR7XHJcblx0XHRcdFx0XHRcdHJldHVybiAhKGFpZCBpbiBhdG9tc19oYXNoKTtcclxuXHRcdFx0XHRcdH0sIHRoaXMpKSlcclxuXHRcdFx0XHRcdHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBlbHNlIGlmICghT2JqZWN0LmlzVW5kZWZpbmVkKHNlbGVjdGlvbi5hdG9tcy5kZXRlY3QoZnVuY3Rpb24gKGFpZClcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHRyZXR1cm4gKHNnX2F0b21zLmluZGV4T2YoYWlkKSA9PSAtMSk7XHJcblx0XHRcdFx0fSwgdGhpcykpKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9LCB0aGlzKSk7XHJcblx0XHR9LCB0aGlzKSkpXHJcblx0XHR7XHJcblx0XHRcdGFsZXJ0KCdQYXJ0aWFsIFMtZ3JvdXAgb3ZlcmxhcHBpbmcgaXMgbm90IGFsbG93ZWQuJyk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHVpLnNob3dTR3JvdXBQcm9wZXJ0aWVzKHtcclxuXHRcdHR5cGU6IGlkICE9PSBudWxsID8gdWkucmVuZGVyLnNHcm91cEdldFR5cGUoaWQpIDogbnVsbCxcclxuXHRcdGF0dHJzOiBpZCAhPT0gbnVsbCA/IHVpLnJlbmRlci5zR3JvdXBHZXRBdHRycyhpZCkgOiB7fSxcclxuXHRcdG9uQ2FuY2VsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXMuZWRpdG9yLmRlc2VsZWN0QWxsKCk7XHJcblx0XHR9LmJpbmQodGhpcyksXHJcblx0XHRvbk9rOiBmdW5jdGlvbiAocGFyYW1zKSB7XHJcblx0XHRcdGlmIChpZCA9PSBudWxsKSB7XHJcblx0XHRcdFx0aWQgPSB1aS5yZW5kZXIuY3RhYi5tb2xlY3VsZS5zZ3JvdXBzLm5ld0lkKCk7XHJcblx0XHRcdFx0dWkuYWRkVW5kb0FjdGlvbihBY3Rpb24uZnJvbVNncm91cEFkZGl0aW9uKHBhcmFtcy50eXBlLCB0aGlzLnNlbGVjdGlvbi5hdG9tcyxcclxuXHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmF0dHJzLCBpZCksIHRydWUpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHVpLmFkZFVuZG9BY3Rpb24oQWN0aW9uLmZyb21TZ3JvdXBUeXBlKGlkLCBwYXJhbXMudHlwZSlcclxuXHRcdFx0XHQgICAgICAgICAgICAgICAgIC5tZXJnZVdpdGgoQWN0aW9uLmZyb21TZ3JvdXBBdHRycyhpZCwgcGFyYW1zLmF0dHJzKSksIHRydWUpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuZWRpdG9yLmRlc2VsZWN0QWxsKCk7XHJcblx0XHRcdHRoaXMuZWRpdG9yLnJlbmRlci51cGRhdGUoKTtcclxuXHJcblx0XHR9LmJpbmQodGhpcylcclxuXHR9KTtcclxufTtcclxuXHJcbkVkaXRvci5TR3JvdXBUb29sLnByb3RvdHlwZS5Pbk1vdXNlVXAgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuXHR2YXIgaWQgPSBudWxsOyAvLyBpZCBvZiBhbiBleGlzdGluZyBncm91cCwgaWYgd2UncmUgZWRpdGluZyBvbmVcclxuXHR2YXIgc2VsZWN0aW9uID0gbnVsbDsgLy8gYXRvbXMgdG8gaW5jbHVkZSBpbiBhIG5ld2x5IGNyZWF0ZWQgZ3JvdXBcclxuXHRpZiAodGhpcy5fbGFzc29IZWxwZXIucnVubmluZygpKSB7IC8vIFRPRE8gaXQgY2F0Y2hlcyBtb3JlIGV2ZW50cyB0aGFuIG5lZWRlZCwgdG8gYmUgcmUtZmFjdG9yZWRcclxuXHRcdHNlbGVjdGlvbiA9IHRoaXMuX2xhc3NvSGVscGVyLmVuZChldmVudCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHZhciBjaSA9IHRoaXMuZWRpdG9yLnJlbmRlci5maW5kSXRlbShldmVudCwgdGhpcy5tYXBzKTtcclxuXHRcdGlmICghY2kgfHwgY2kudHlwZSA9PSAnQ2FudmFzJylcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0dGhpcy5faG92ZXJIZWxwZXIuaG92ZXIobnVsbCk7XHJcblxyXG5cdFx0aWYgKGNpLm1hcCA9PSAnYXRvbXMnKSB7XHJcblx0XHRcdC8vIGlmIHdlIGNsaWNrIHRoZSBTR3JvdXAgdG9vbCBvbiBhIHNpbmdsZSBhdG9tIG9yIGJvbmQsIG1ha2UgYSBncm91cCBvdXQgb2YgdGhvc2VcclxuXHRcdFx0c2VsZWN0aW9uID0geydhdG9tcyc6IFtjaS5pZF19O1xyXG5cdFx0fSBlbHNlIGlmIChjaS5tYXAgPT0gJ2JvbmRzJykge1xyXG5cdFx0XHR2YXIgYm9uZCA9IHRoaXMuZWRpdG9yLnJlbmRlci5jdGFiLmJvbmRzLmdldChjaS5pZCk7XHJcblx0XHRcdHNlbGVjdGlvbiA9IHsnYXRvbXMnOiBbYm9uZC5iLmJlZ2luLCBib25kLmIuZW5kXX07XHJcblx0XHR9IGVsc2UgaWYgKGNpLm1hcCA9PSAnc2dyb3VwcycpIHtcclxuXHRcdFx0aWQgPSBjaS5pZDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHR9XHJcblx0Ly8gVE9ETzogaGFuZGxlIGNsaWNrIG9uIGFuIGV4aXN0aW5nIGdyb3VwP1xyXG5cdGlmIChpZCAhPSBudWxsIHx8IChzZWxlY3Rpb24gJiYgc2VsZWN0aW9uLmF0b21zICYmIHNlbGVjdGlvbi5hdG9tcy5sZW5ndGggPiAwKSlcclxuXHRcdHRoaXMuX3NHcm91cEhlbHBlci5zaG93UHJvcGVydGllc0RpYWxvZyhpZCwgc2VsZWN0aW9uKTtcclxufTtcclxuXHJcbkVkaXRvci5QYXN0ZVRvb2wgPSBmdW5jdGlvbiAoZWRpdG9yLCBzdHJ1Y3QpIHtcclxuXHR0aGlzLmVkaXRvciA9IGVkaXRvcjtcclxuXHR0aGlzLnN0cnVjdCA9IHN0cnVjdDtcclxuXHR0aGlzLmFjdGlvbiA9IEFjdGlvbi5mcm9tUGFzdGUoXHJcblx0XHR0aGlzLnN0cnVjdCwgJ2xhc3RFdmVudCcgaW4gdGhpcy5Pbk1vdXNlTW92ZTAgP1xyXG5cdFx0XHR1aS5wYWdlMm9iaih0aGlzLk9uTW91c2VNb3ZlMC5sYXN0RXZlbnQpIDogdW5kZWZpbmVkKTtcclxuXHR0aGlzLmVkaXRvci5yZW5kZXIudXBkYXRlKCk7XHJcbn07XHJcbkVkaXRvci5QYXN0ZVRvb2wucHJvdG90eXBlID0gbmV3IEVkaXRvci5FZGl0b3JUb29sKCk7XHJcbkVkaXRvci5QYXN0ZVRvb2wucHJvdG90eXBlLk9uTW91c2VNb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0aWYgKCdhY3Rpb24nIGluIHRoaXMpIHtcclxuXHRcdHRoaXMuYWN0aW9uLnBlcmZvcm0odGhpcy5lZGl0b3IpO1xyXG5cdH1cclxuXHR0aGlzLmFjdGlvbiA9IEFjdGlvbi5mcm9tUGFzdGUodGhpcy5zdHJ1Y3QsIHVpLnBhZ2Uyb2JqKGV2ZW50KSk7XHJcblx0dGhpcy5lZGl0b3IucmVuZGVyLnVwZGF0ZSgpO1xyXG59O1xyXG5FZGl0b3IuUGFzdGVUb29sLnByb3RvdHlwZS5Pbk1vdXNlVXAgPSBmdW5jdGlvbiAoKSB7XHJcblx0dWkuYWRkVW5kb0FjdGlvbih0aGlzLmFjdGlvbik7XHJcblx0ZGVsZXRlIHRoaXMuYWN0aW9uO1xyXG5cdHVpLnNlbGVjdEFjdGlvbihudWxsKTtcclxufTtcclxuRWRpdG9yLlBhc3RlVG9vbC5wcm90b3R5cGUuT25DYW5jZWwgPSBmdW5jdGlvbiAoKSB7XHJcblx0aWYgKCdhY3Rpb24nIGluIHRoaXMpIHtcclxuXHRcdHRoaXMuYWN0aW9uLnBlcmZvcm0odGhpcy5lZGl0b3IpO1xyXG5cdFx0ZGVsZXRlIHRoaXMuYWN0aW9uO1xyXG5cdH1cclxufTtcclxuXHJcbkVkaXRvci5Sb3RhdGVUb29sID0gZnVuY3Rpb24gKGVkaXRvcikge1xyXG5cdHRoaXMuZWRpdG9yID0gZWRpdG9yO1xyXG5cdHRoaXMuX2xhc3NvSGVscGVyID0gbmV3IEVkaXRvci5MYXNzb1Rvb2wuTGFzc29IZWxwZXIoMSwgZWRpdG9yKTtcclxuXHJcblx0dmFyIHNlbGVjdGlvbiA9IHRoaXMuZWRpdG9yLl9zZWxlY3Rpb25IZWxwZXIuc2VsZWN0aW9uO1xyXG5cdGlmICghc2VsZWN0aW9uLmF0b21zIHx8ICFzZWxlY3Rpb24uYXRvbXMubGVuZ3RoKSB7XHJcblx0XHQvLyBvdGhlcndpc2UsIGNsZWFyIHNlbGVjdGlvblxyXG5cdFx0dGhpcy5lZGl0b3IuX3NlbGVjdGlvbkhlbHBlci5zZXRTZWxlY3Rpb24obnVsbCk7XHJcblx0fVxyXG59O1xyXG5FZGl0b3IuUm90YXRlVG9vbC5wcm90b3R5cGUgPSBuZXcgRWRpdG9yLkVkaXRvclRvb2woKTtcclxuXHJcbkVkaXRvci5Sb3RhdGVUb29sLnByb3RvdHlwZS5Pbk1vdXNlRG93biA9IGZ1bmN0aW9uIChldmVudCkge1xyXG5cclxuXHR2YXIgc2VsZWN0aW9uID0gdGhpcy5lZGl0b3IuX3NlbGVjdGlvbkhlbHBlci5zZWxlY3Rpb247XHJcblx0aWYgKHNlbGVjdGlvbi5hdG9tcyAmJiBzZWxlY3Rpb24uYXRvbXMubGVuZ3RoKSB7XHJcblx0XHR2YXIgbW9sZWN1bGUgPSB0aGlzLmVkaXRvci5yZW5kZXIuY3RhYi5tb2xlY3VsZTtcclxuXHRcdHZhciB4eTAgPSBuZXcgVmVjMigpO1xyXG5cclxuXHRcdGlmICghc2VsZWN0aW9uLmF0b21zIHx8ICFzZWxlY3Rpb24uYXRvbXMubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciByb3RfaWQgPSBudWxsLCByb3RfYWxsID0gZmFsc2U7XHJcblxyXG5cdFx0c2VsZWN0aW9uLmF0b21zLmVhY2goZnVuY3Rpb24gKGFpZCkge1xyXG5cdFx0XHR2YXIgYXRvbSA9IG1vbGVjdWxlLmF0b21zLmdldChhaWQpO1xyXG5cclxuXHRcdFx0eHkwLmFkZF8oYXRvbS5wcCk7XHJcblxyXG5cdFx0XHRpZiAocm90X2FsbCkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YXRvbS5uZWlnaGJvcnMuZmluZChmdW5jdGlvbiAobmVpKSB7XHJcblx0XHRcdFx0dmFyIGhiID0gbW9sZWN1bGUuaGFsZkJvbmRzLmdldChuZWkpO1xyXG5cclxuXHRcdFx0XHRpZiAoc2VsZWN0aW9uLmF0b21zLmluZGV4T2YoaGIuZW5kKSA9PSAtMSkge1xyXG5cdFx0XHRcdFx0aWYgKGhiLmxvb3AgPj0gMCkge1xyXG5cdFx0XHRcdFx0XHR2YXIgbmVpX2F0b20gPSBtb2xlY3VsZS5hdG9tcy5nZXQoYWlkKTtcclxuXHRcdFx0XHRcdFx0aWYgKCFPYmplY3QuaXNVbmRlZmluZWQobmVpX2F0b20ubmVpZ2hib3JzLmZpbmQoZnVuY3Rpb24gKG5laV9uZWkpIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgbmVpX2hiID0gbW9sZWN1bGUuaGFsZkJvbmRzLmdldChuZWlfbmVpKTtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbmVpX2hiLmxvb3AgPj0gMCAmJiBzZWxlY3Rpb24uYXRvbXMuaW5kZXhPZihuZWlfaGIuZW5kKSAhPSAtMTtcclxuXHRcdFx0XHRcdFx0fSkpKSB7XHJcblx0XHRcdFx0XHRcdFx0cm90X2FsbCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmIChyb3RfaWQgPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRyb3RfaWQgPSBhaWQ7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHJvdF9pZCAhPSBhaWQpIHtcclxuXHRcdFx0XHRcdFx0cm90X2FsbCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKCFyb3RfYWxsICYmIHJvdF9pZCAhPSBudWxsKSB7XHJcblx0XHRcdHh5MCA9IG1vbGVjdWxlLmF0b21zLmdldChyb3RfaWQpLnBwO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0eHkwID0geHkwLnNjYWxlZCgxIC8gc2VsZWN0aW9uLmF0b21zLmxlbmd0aCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5kcmFnQ3R4ID0ge1xyXG5cdFx0XHR4eTA6IHh5MCxcclxuXHRcdFx0YW5nbGUxOiB0aGlzLl9jYWxjQW5nbGUoeHkwLCB1aS5wYWdlMm9iaihldmVudCkpLFxyXG5cdFx0XHRhbGw6IHJvdF9hbGxcclxuXHRcdH07XHJcblx0fSBlbHNlIHtcclxuXHRcdHRoaXMuX2xhc3NvSGVscGVyLmJlZ2luKGV2ZW50KTtcclxuXHR9XHJcblx0cmV0dXJuIHRydWU7XHJcbn07XHJcbkVkaXRvci5Sb3RhdGVUb29sLnByb3RvdHlwZS5Pbk1vdXNlTW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xyXG5cdGlmICh0aGlzLl9sYXNzb0hlbHBlci5ydW5uaW5nKCkpIHtcclxuXHRcdHRoaXMuZWRpdG9yLl9zZWxlY3Rpb25IZWxwZXIuc2V0U2VsZWN0aW9uKFxyXG5cdFx0dGhpcy5fbGFzc29IZWxwZXIuYWRkUG9pbnQoZXZlbnQpXHJcblx0XHQpO1xyXG5cdH0gZWxzZSBpZiAoJ2RyYWdDdHgnIGluIHRoaXMpIHtcclxuXHRcdHZhciBfRV8gPSB0aGlzLmVkaXRvciwgX1JfID0gX0VfLnJlbmRlcjtcclxuXHRcdHZhciBfRENfID0gdGhpcy5kcmFnQ3R4O1xyXG5cclxuXHRcdHZhciBwb3MgPSB1aS5wYWdlMm9iaihldmVudCk7XHJcblx0XHR2YXIgYW5nbGUgPSB0aGlzLl9jYWxjQW5nbGUoX0RDXy54eTAsIHBvcykgLSBfRENfLmFuZ2xlMTtcclxuXHJcblx0XHR2YXIgZGVncmVlcyA9IE1hdGgucm91bmQoYW5nbGUgLyBNYXRoLlBJICogMTgwKTtcclxuXHJcblx0XHRpZiAoZGVncmVlcyA+IDE4MCkge1xyXG5cdFx0XHRkZWdyZWVzIC09IDM2MDtcclxuXHRcdH0gZWxzZSBpZiAoZGVncmVlcyA8PSAtMTgwKSB7XHJcblx0XHRcdGRlZ3JlZXMgKz0gMzYwO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICgnYW5nbGUnIGluIF9EQ18gJiYgX0RDXy5hbmdsZSA9PSBkZWdyZWVzKSByZXR1cm4gdHJ1ZTtcclxuXHRcdGlmICgnYWN0aW9uJyBpbiBfRENfKSBfRENfLmFjdGlvbi5wZXJmb3JtKCk7XHJcblxyXG5cdFx0X0RDXy5hbmdsZSA9IGRlZ3JlZXM7XHJcblx0XHRfRENfLmFjdGlvbiA9IEFjdGlvbi5mcm9tUm90YXRlKFxyXG5cdFx0XHRfRENfLmFsbCA/IF9SXy5jdGFiLm1vbGVjdWxlIDogdGhpcy5lZGl0b3IuZ2V0U2VsZWN0aW9uKCksXHJcblx0XHRcdF9EQ18ueHkwLFxyXG5cdFx0XHRhbmdsZVxyXG5cdFx0KTtcclxuXHJcblx0XHQkKCd0b29sVGV4dCcpLnVwZGF0ZShkZWdyZWVzICsgJ8K6Jyk7XHJcblxyXG5cdFx0X1JfLnVwZGF0ZSgpO1xyXG5cdH1cclxuXHRyZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbkVkaXRvci5Sb3RhdGVUb29sLnByb3RvdHlwZS5Pbk1vdXNlVXAgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuXHR2YXIgaWQgPSBudWxsOyAvLyBpZCBvZiBhbiBleGlzdGluZyBncm91cCwgaWYgd2UncmUgZWRpdGluZyBvbmVcclxuXHR2YXIgc2VsZWN0aW9uID0gbnVsbDsgLy8gYXRvbXMgdG8gaW5jbHVkZSBpbiBhIG5ld2x5IGNyZWF0ZWQgZ3JvdXBcclxuXHRpZiAodGhpcy5fbGFzc29IZWxwZXIucnVubmluZygpKSB7IC8vIFRPRE8gaXQgY2F0Y2hlcyBtb3JlIGV2ZW50cyB0aGFuIG5lZWRlZCwgdG8gYmUgcmUtZmFjdG9yZWRcclxuXHRcdHNlbGVjdGlvbiA9IHRoaXMuX2xhc3NvSGVscGVyLmVuZChldmVudCk7XHJcblx0fSBlbHNlIGlmICgnZHJhZ0N0eCcgaW4gdGhpcykge1xyXG5cdFx0aWYgKCdhY3Rpb24nIGluIHRoaXMuZHJhZ0N0eCkge1xyXG5cdFx0XHR1aS5hZGRVbmRvQWN0aW9uKHRoaXMuZHJhZ0N0eC5hY3Rpb24sIHRydWUpO1xyXG5cdFx0XHQkKCd0b29sVGV4dCcpLnVwZGF0ZSgnJyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLmVkaXRvci5fc2VsZWN0aW9uSGVscGVyLnNldFNlbGVjdGlvbigpO1xyXG5cdFx0fVxyXG5cdFx0ZGVsZXRlIHRoaXMuZHJhZ0N0eDtcclxuXHR9XHJcblx0cmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG5FZGl0b3IuUm90YXRlVG9vbC5wcm90b3R5cGUuT25DYW5jZWwgPSBmdW5jdGlvbiAoKSB7XHJcblx0aWYgKCdkcmFnQ3R4JyBpbiB0aGlzKSB7XHJcblx0XHRpZiAoJ2FjdGlvbicgaW4gdGhpcy5kcmFnQ3R4KSB7XHJcblx0XHRcdHVpLmFkZFVuZG9BY3Rpb24odGhpcy5kcmFnQ3R4LmFjdGlvbiwgdHJ1ZSk7XHJcblx0XHRcdCQoJ3Rvb2xUZXh0JykudXBkYXRlKCcnKTtcclxuXHRcdH1cclxuXHRcdGRlbGV0ZSB0aGlzLmRyYWdDdHg7XHJcblx0fVxyXG5cclxuXHQvLyBkb24ndCByZXNldCB0aGUgc2VsZWN0aW9uIHdoZW4gbGVhdmluZyB0aGUgY2FudmFzLCBzZWUgS0VUQ0hFUi02MzJcclxuXHQvLyB0aGlzLmVkaXRvci5fc2VsZWN0aW9uSGVscGVyLnNldFNlbGVjdGlvbigpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gYm9uZEZsaXBSZXF1aXJlZCAoYm9uZCwgYXR0cnMpIHtcclxuXHRyZXR1cm4gYXR0cnMudHlwZSA9PSBCb25kLlBBVFRFUk4uVFlQRS5TSU5HTEUgJiZcclxuXHQgICAgICAgYm9uZC5zdGVyZW8gPT0gQm9uZC5QQVRURVJOLlNURVJFTy5OT05FICYmXHJcblx0ICAgICAgIGF0dHJzLnN0ZXJlbyAhPSBCb25kLlBBVFRFUk4uU1RFUkVPLk5PTkUgJiZcclxuXHQgICAgICAgdWkuY3RhYi5hdG9tcy5nZXQoYm9uZC5iZWdpbikubmVpZ2hib3JzLmxlbmd0aCA8XHJcblx0ICAgICAgIHVpLmN0YWIuYXRvbXMuZ2V0KGJvbmQuZW5kKS5uZWlnaGJvcnMubGVuZ3RoO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEVkaXRvcjtcclxuIiwicmVxdWlyZSgnLi9yZXN0cnVjdCcpO1xyXG5yZXF1aXJlKCcuL3JlbmRlcicpO1xyXG5yZXF1aXJlKCcuL3Jlc3RydWN0X3JlbmRlcmluZycpO1xyXG5cclxuZ2xvYmFsLnJuZCA9IGdsb2JhbC5ybmQgfHwge307XHJcbiIsInZhciBSYXBoYWVsID0gcmVxdWlyZSgnLi4vcmFwaGFlbC1leHQuanMnKTtcclxudmFyIEJveDJBYnMgPSByZXF1aXJlKCcuLi91dGlsL2JveDJhYnMnKTtcclxudmFyIFNldCA9IHJlcXVpcmUoJy4uL3V0aWwvc2V0Jyk7XHJcbnZhciBWZWMyID0gcmVxdWlyZSgnLi4vdXRpbC92ZWMyJyk7XHJcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xyXG5cclxudmFyIFN0cnVjdCA9IHJlcXVpcmUoJy4uL2NoZW0vc3RydWN0Jyk7XHJcbnZhciBTR3JvdXAgPSByZXF1aXJlKCcuLi9jaGVtL3Nncm91cCcpO1xyXG5cclxucmVxdWlyZSgnLi9yZXN0cnVjdCcpO1xyXG5yZXF1aXJlKCcuL3Jlc3RydWN0X3JlbmRlcmluZycpO1xyXG5cclxudmFyIHJuZCA9IGdsb2JhbC5ybmQgPSBnbG9iYWwucm5kIHx8IHt9OyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxudmFyIHVpID0gZ2xvYmFsLnVpO1xyXG52YXIgdGZ4ID0gdXRpbC50Zng7XHJcblxyXG5ybmQuREVCVUcgPSBmYWxzZTtcclxuXHJcbnJuZC5sb2djbnQgPSAwO1xyXG5ybmQubG9nbW91c2UgPSBmYWxzZTtcclxucm5kLmhsID0gZmFsc2U7XHJcblxyXG52YXIgRXZlbnRNYXAgPSB7XHJcblx0bW91c2Vtb3ZlOiAnbW91c2Vtb3ZlJyxcclxuXHRtb3VzZWRvd246ICdtb3VzZWRvd24nLFxyXG5cdG1vdXNldXA6ICdtb3VzZXVwJ1xyXG59O1xyXG5cclxucm5kLmxvZ01ldGhvZCA9IGZ1bmN0aW9uICgpIHsgfTtcclxuLy9ybmQubG9nTWV0aG9kID0gZnVuY3Rpb24gKG1ldGhvZCkge2NvbnNvbGUubG9nKFwiTUVUSE9EOiBcIiArIG1ldGhvZCk7fVxyXG5cclxucm5kLlJlbmRlck9wdGlvbnMgPSBmdW5jdGlvbiAob3B0KVxyXG57XHJcblx0b3B0ID0gb3B0IHx8IHt9O1xyXG5cclxuXHQvLyBmbGFncyBmb3IgZGVidWdnaW5nXHJcblx0dGhpcy5zaG93U2VsZWN0aW9uUmVnaW9ucyA9IG9wdC5zaG93U2VsZWN0aW9uUmVnaW9ucyB8fCBmYWxzZTtcclxuXHR0aGlzLnNob3dBdG9tSWRzID0gb3B0LnNob3dBdG9tSWRzIHx8IGZhbHNlO1xyXG5cdHRoaXMuc2hvd0JvbmRJZHMgPSBvcHQuc2hvd0JvbmRJZHMgfHwgZmFsc2U7XHJcblx0dGhpcy5zaG93SGFsZkJvbmRJZHMgPSBvcHQuc2hvd0hhbGZCb25kSWRzIHx8IGZhbHNlO1xyXG5cdHRoaXMuc2hvd0xvb3BJZHMgPSBvcHQuc2hvd0xvb3BJZHMgfHwgZmFsc2U7XHJcblx0dGhpcy5oaWRlQ2hpcmFsRmxhZyA9IG9wdC5oaWRlQ2hpcmFsRmxhZyB8fCBmYWxzZTtcclxuXHJcblx0Ly8gcmVuZGVyaW5nIGN1c3RvbWl6YXRpb24gZmxhZ3NcclxuXHR0aGlzLnNob3dWYWxlbmNlV2FybmluZ3MgPSAhT2JqZWN0LmlzVW5kZWZpbmVkKG9wdC5zaG93VmFsZW5jZVdhcm5pbmdzKSA/IG9wdC5zaG93VmFsZW5jZVdhcm5pbmdzIDogdHJ1ZTtcclxuXHR0aGlzLmF1dG9TY2FsZSA9IG9wdC5hdXRvU2NhbGUgfHwgZmFsc2U7IC8vIHNjYWxlIHN0cnVjdHVyZSB0byBmaXQgaW50byB0aGUgZ2l2ZW4gdmlldyBib3gsIHVzZWQgaW4gdmlldyBtb2RlXHJcblx0dGhpcy5hdXRvU2NhbGVNYXJnaW4gPSBvcHQuYXV0b1NjYWxlTWFyZ2luIHx8IDA7XHJcblx0dGhpcy5tYXhCb25kTGVuZ3RoID0gb3B0Lm1heEJvbmRMZW5ndGggfHwgMDsgLy8gMCBzdGFuZHMgZm9yIFwibm90IHNwZWNpZmllZFwiXHJcblx0dGhpcy5hdG9tQ29sb3JpbmcgPSBvcHQuYXRvbUNvbG9yaW5nIHx8IDA7XHJcblx0dGhpcy5oaWRlSW1wbGljaXRIeWRyb2dlbiA9IG9wdC5oaWRlSW1wbGljaXRIeWRyb2dlbiB8fCBmYWxzZTtcclxuXHR0aGlzLmhpZGVUZXJtaW5hbExhYmVscyA9IG9wdC5oaWRlVGVybWluYWxMYWJlbHMgfHwgZmFsc2U7XHJcblx0dGhpcy5pZ25vcmVNb3VzZUV2ZW50cyA9IG9wdC5pZ25vcmVNb3VzZUV2ZW50cyB8fCBmYWxzZTsgLy8gZm9yIHZpZXcgbW9kZVxyXG5cdHRoaXMuc2VsZWN0aW9uRGlzdGFuY2VDb2VmZmljaWVudCA9IChvcHQuc2VsZWN0aW9uRGlzdGFuY2VDb2VmZmljaWVudCB8fCAwLjQpIC0gMDtcclxufTtcclxuXHJcbnJuZC5SZW5kZXIgPSBmdW5jdGlvbiAoY2xpZW50QXJlYSwgc2NhbGUsIG9wdCwgdmlld1N6KVxyXG57XHJcblx0dGhpcy5vcHQgPSBuZXcgcm5kLlJlbmRlck9wdGlvbnMob3B0KTtcclxuXHJcblx0dGhpcy51c2VPbGRab29tID0gUHJvdG90eXBlLkJyb3dzZXIuSUU7XHJcblx0dGhpcy5zY2FsZSA9IHNjYWxlIHx8IDEwMDtcclxuXHR0aGlzLmJhc2VTY2FsZSA9IHRoaXMuc2NhbGU7XHJcblx0dGhpcy5vZmZzZXQgPSBuZXcgVmVjMigpO1xyXG5cdHRoaXMuY2xpZW50QXJlYSA9IGNsaWVudEFyZWEgPSAkKGNsaWVudEFyZWEpO1xyXG5cdGNsaWVudEFyZWEuaW5uZXJIVE1MID0gJyc7XHJcblx0dGhpcy5wYXBlciA9IG5ldyBSYXBoYWVsKGNsaWVudEFyZWEpO1xyXG5cdHRoaXMuc2l6ZSA9IG5ldyBWZWMyKCk7XHJcblx0dGhpcy52aWV3U3ogPSB2aWV3U3ogfHwgbmV3IFZlYzIoY2xpZW50QXJlYVsnY2xpZW50V2lkdGgnXSB8fCAxMDAsIGNsaWVudEFyZWFbJ2NsaWVudEhlaWdodCddIHx8IDEwMCk7XHJcblx0dGhpcy5iYiA9IG5ldyBCb3gyQWJzKG5ldyBWZWMyKCksIHRoaXMudmlld1N6KTtcclxuXHR0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuXHR0aGlzLnNlbGVjdGlvblJlY3QgPSBudWxsO1xyXG5cdHRoaXMucnhuQXJyb3cgPSBudWxsO1xyXG5cdHRoaXMucnhuTW9kZSA9IGZhbHNlO1xyXG5cdHRoaXMuem9vbSA9IDEuMDtcclxuXHR0aGlzLnN0cnVjdENoYW5nZUhhbmRsZXJzID0gW107XHJcblxyXG5cdHZhciByZW5kZXIgPSB0aGlzO1xyXG5cdHZhciB2YWx1ZVQgPSAwLCB2YWx1ZUwgPSAwO1xyXG5cdHZhciBlbGVtZW50ID0gY2xpZW50QXJlYTtcclxuXHRkbyB7XHJcblx0XHR2YWx1ZVQgKz0gZWxlbWVudC5vZmZzZXRUb3AgIHx8IDA7XHJcblx0XHR2YWx1ZUwgKz0gZWxlbWVudC5vZmZzZXRMZWZ0IHx8IDA7XHJcblx0XHRlbGVtZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XHJcblx0fSB3aGlsZSAoZWxlbWVudCk7XHJcblxyXG5cdHRoaXMuY2xpZW50QXJlYVBvcyA9IG5ldyBWZWMyKHZhbHVlTCwgdmFsdWVUKTtcclxuXHJcblx0Ly8gcmJhbGFiYW5vdjogdHdvLWZpbmdlcnMgc2Nyb2xsaW5nICYgem9vbWluZyBmb3IgaVBhZFxyXG5cdC8vIFRPRE8gc2hvdWxkIGJlIG1vdmVkIHRvIHRvdWNoLmpzIG1vZHVsZSwgcmUtZmFjdG9yaW5nIG5lZWRlZFxyXG5cdC8vQkVHSU5cclxuXHR2YXIgc2VsZiA9IHRoaXM7XHJcblx0c2VsZi5sb25nVGFwRmxhZyA9IGZhbHNlO1xyXG5cdHNlbGYubG9uZ1RhcFRpbWVvdXQgPSBudWxsO1xyXG5cdHNlbGYubG9uZ1RhcFRvdWNoc3RhcnQgPSBudWxsO1xyXG5cclxuXHRzZWxmLnNldExvbmdUYXBUaW1lb3V0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0XHRzZWxmLmxvbmdUYXBGbGFnID0gZmFsc2U7XHJcblx0XHRzZWxmLmxvbmdUYXBUb3VjaHN0YXJ0ID0gZXZlbnQ7XHJcblx0XHRzZWxmLmxvbmdUYXBUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHNlbGYubG9uZ1RhcEZsYWcgPSB0cnVlO1xyXG5cdFx0XHRzZWxmLmxvbmdUYXBUaW1lb3V0ID0gbnVsbDtcclxuXHRcdH0sIDUwMCk7XHJcblx0fTtcclxuXHJcblx0c2VsZi5yZXNldExvbmdUYXBUaW1lb3V0ID0gZnVuY3Rpb24gKHJlc2V0RmxhZykge1xyXG5cdFx0Y2xlYXJUaW1lb3V0KHNlbGYubG9uZ1RhcFRpbWVvdXQpO1xyXG5cdFx0c2VsZi5sb25nVGFwVGltZW91dCA9IG51bGw7XHJcblx0XHRpZiAocmVzZXRGbGFnKSB7XHJcblx0XHRcdHNlbGYubG9uZ1RhcFRvdWNoc3RhcnQgPSBudWxsO1xyXG5cdFx0XHRzZWxmLmxvbmdUYXBGbGFnID0gZmFsc2U7XHJcblx0XHR9XHJcblx0fTtcclxuXHQvL0VORFxyXG5cclxuXHQvLyByYmFsYWJhbm92OiBoZXJlIGlzIHRlbXBvcmFyeSBmaXggZm9yIFwiZHJhZyBpc3N1ZVwiIG9uIGlQYWRcclxuXHQvL0JFR0lOXHJcblx0aWYgKCdoaWRkZW5QYXRocycgaW4gcm5kLlJlU3RydWN0LnByb3RvdHlwZSkge1xyXG5cdFx0Y2xpZW50QXJlYS5vYnNlcnZlKCd0b3VjaGVuZCcsIGZ1bmN0aW9uIChldmVudCkge1xyXG5cdFx0XHRpZiAoZXZlbnQudG91Y2hlcy5sZW5ndGggPT0gMCkge1xyXG5cdFx0XHRcdHdoaWxlIChybmQuUmVTdHJ1Y3QucHJvdG90eXBlLmhpZGRlblBhdGhzLmxlbmd0aCA+IDApIHJuZC5SZVN0cnVjdC5wcm90b3R5cGUuaGlkZGVuUGF0aHMucG9wKCkucmVtb3ZlKCk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxuXHQvL0VORFxyXG5cclxuXHRpZiAoIXRoaXMub3B0Lmlnbm9yZU1vdXNlRXZlbnRzKSB7XHJcblx0XHQvLyBbUkJdIEtFVENIRVItMzk2IChNYWluIHRvb2xiYXIgaXMgZ3JheWVkIGFmdGVyIHRoZSBTaGlmdC1zZWxlY3Rpb24gb2Ygc29tZSBhdG9tcy9ib25kcylcclxuXHRcdC8vIGhlcmUgd2UgcHJldmVudCB0aGF0IGZyZWFraW5nIFwiYWNjZWxlcmF0b3JzIG1lbnVcIiBvbiBJRThcclxuXHRcdC8vQkVHSU5cclxuXHRcdGNsaWVudEFyZWEub2JzZXJ2ZSgnc2VsZWN0c3RhcnQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuXHRcdFx0dXRpbC5zdG9wRXZlbnRQcm9wYWdhdGlvbihldmVudCk7XHJcblx0XHRcdHJldHVybiB1dGlsLnByZXZlbnREZWZhdWx0KGV2ZW50KTtcclxuXHRcdH0pO1xyXG5cdFx0Ly9FTkRcclxuXHJcblx0XHRjbGllbnRBcmVhLm9ic2VydmUoJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuXHRcdFx0c2VsZi5yZXNldExvbmdUYXBUaW1lb3V0KHRydWUpO1xyXG5cdFx0XHRpZiAoZXZlbnQudG91Y2hlcy5sZW5ndGggPT0gMikge1xyXG5cdFx0XHRcdHRoaXMuX3R1aSA9IHRoaXMuX3R1aSB8fCB7fTtcclxuXHRcdFx0XHR0aGlzLl90dWkuY2VudGVyID0ge1xyXG5cdFx0XHRcdFx0cGFnZVg6IChldmVudC50b3VjaGVzWzBdLnBhZ2VYICsgZXZlbnQudG91Y2hlc1sxXS5wYWdlWCkgLyAyLFxyXG5cdFx0XHRcdFx0cGFnZVk6IChldmVudC50b3VjaGVzWzBdLnBhZ2VZICsgZXZlbnQudG91Y2hlc1sxXS5wYWdlWSkgLyAyXHJcblx0XHRcdFx0fTtcclxuXHRcdFx0XHR1aS5zZXRab29tU3RhdGljUG9pbnRJbml0KHVpLnBhZ2Uyb2JqKHRoaXMuX3R1aS5jZW50ZXIpKTtcclxuXHRcdFx0fSBlbHNlIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCA9PSAxKSB7XHJcblx0XHRcdFx0c2VsZi5zZXRMb25nVGFwVGltZW91dChldmVudCk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0Y2xpZW50QXJlYS5vYnNlcnZlKCd0b3VjaG1vdmUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuXHRcdFx0c2VsZi5yZXNldExvbmdUYXBUaW1lb3V0KHRydWUpO1xyXG5cdFx0XHRpZiAoJ190dWknIGluIHRoaXMgJiYgZXZlbnQudG91Y2hlcy5sZW5ndGggPT0gMikge1xyXG5cdFx0XHRcdHRoaXMuX3R1aS5jZW50ZXIgPSB7XHJcblx0XHRcdFx0XHRwYWdlWDogKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggKyBldmVudC50b3VjaGVzWzFdLnBhZ2VYKSAvIDIsXHJcblx0XHRcdFx0XHRwYWdlWTogKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgKyBldmVudC50b3VjaGVzWzFdLnBhZ2VZKSAvIDJcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdGNsaWVudEFyZWEub2JzZXJ2ZSgnZ2VzdHVyZXN0YXJ0JywgZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0XHRcdHRoaXMuX3R1aSA9IHRoaXMuX3R1aSB8fCB7fTtcclxuXHRcdFx0dGhpcy5fdHVpLnNjYWxlMCA9IHVpLnJlbmRlci56b29tO1xyXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0fSk7XHJcblx0XHRjbGllbnRBcmVhLm9ic2VydmUoJ2dlc3R1cmVjaGFuZ2UnLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuXHRcdFx0dWkuc2V0Wm9vbVN0YXRpY1BvaW50KHRoaXMuX3R1aS5zY2FsZTAgKiBldmVudC5zY2FsZSwgdWkucGFnZTJjYW52YXMyKHRoaXMuX3R1aS5jZW50ZXIpKTtcclxuXHRcdFx0dWkucmVuZGVyLnVwZGF0ZSgpO1xyXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0fSk7XHJcblx0XHRjbGllbnRBcmVhLm9ic2VydmUoJ2dlc3R1cmVlbmQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX3R1aTtcclxuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHRcdH0pO1xyXG5cdFx0Ly9FTkRcclxuXHJcblx0XHRjbGllbnRBcmVhLm9ic2VydmUoJ29ucmVzaXplJywgZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0XHRcdHJlbmRlci5vblJlc2l6ZSgpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gYXNzaWduIGNhbnZhcyBldmVudHMgaGFuZGxlcnNcclxuXHRcdFsnQ2xpY2snLCAnRGJsQ2xpY2snLCAnTW91c2VEb3duJywgJ01vdXNlTW92ZScsICdNb3VzZVVwJywgJ01vdXNlTGVhdmUnXS5lYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpe1xyXG5cdFx0XHR2YXIgYmluZEV2ZW50TmFtZSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xyXG5cdFx0XHRiaW5kRXZlbnROYW1lID0gRXZlbnRNYXBbYmluZEV2ZW50TmFtZV0gfHwgYmluZEV2ZW50TmFtZTtcclxuXHRcdFx0Y2xpZW50QXJlYS5vYnNlcnZlKGJpbmRFdmVudE5hbWUsIGZ1bmN0aW9uIChldmVudCkge1xyXG5cdFx0XHRcdGlmIChldmVudE5hbWUgIT0gJ01vdXNlTGVhdmUnKSBpZiAoIXVpIHx8ICF1aS5pc190b3VjaCkge1xyXG5cdFx0XHRcdFx0Ly8gVE9ETzoga2FydWxpbjogZml4IHRoaXMgb24gdG91Y2ggZGV2aWNlcyBpZiBuZWVkZWRcclxuXHRcdFx0XHRcdHZhciBjbyA9IGNsaWVudEFyZWEuY3VtdWxhdGl2ZU9mZnNldCgpO1xyXG5cdFx0XHRcdFx0Y28gPSBuZXcgVmVjMihjb1swXSwgY29bMV0pO1xyXG5cdFx0XHRcdFx0dmFyIHZwID0gbmV3IFZlYzIoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSkuc3ViKGNvKTtcclxuXHRcdFx0XHRcdHZhciBzeiA9IG5ldyBWZWMyKGNsaWVudEFyZWEuY2xpZW50V2lkdGgsIGNsaWVudEFyZWEuY2xpZW50SGVpZ2h0KTtcclxuXHRcdFx0XHRcdGlmICghKHZwLnggPiAwICYmIHZwLnkgPiAwICYmIHZwLnggPCBzei54ICYmIHZwLnkgPCBzei55KSkgey8vIGlnbm9yZSBldmVudHMgb24gdGhlIGhpZGRlbiBwYXJ0IG9mIHRoZSBjYW52YXNcclxuXHRcdFx0XHRcdFx0aWYgKGV2ZW50TmFtZSA9PSAnTW91c2VNb3ZlJykge1xyXG5cdFx0XHRcdFx0XHRcdC8vIFtSQl0gaGVyZSB3ZSBhbHNlIGVtdWxhdGUgbW91c2VsZWF2ZSB3aGVuIHVzZXIgZHJhZ3MgbW91c2Ugb3ZlciB0b29sYmFyIChzZWUgS0VUQ0hFUi00MzMpXHJcblx0XHRcdFx0XHRcdFx0dWkucmVuZGVyLmN1cnJlbnRfdG9vbC5wcm9jZXNzRXZlbnQoJ09uTW91c2VMZWF2ZScsIGV2ZW50KTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gdXRpbC5wcmV2ZW50RGVmYXVsdChldmVudCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR1aS5yZW5kZXIuY3VycmVudF90b29sLnByb2Nlc3NFdmVudCgnT24nICsgZXZlbnROYW1lLCBldmVudCk7XHJcblx0XHRcdFx0aWYgKGV2ZW50TmFtZSAhPSAnTW91c2VVcCcpIHtcclxuXHRcdFx0XHRcdC8vIFtOS10gZG8gbm90IHN0b3AgbW91c2V1cCBwcm9wYWdhdGlvblxyXG5cdFx0XHRcdFx0Ly8gdG8gbWFpbnRhaW4gY2xpcGFyZWEgZm9jdXMuXHJcblx0XHRcdFx0XHQvLyBEbyB3ZSByZWFsbHkgbmVlZCB0b3RhbCBzdG9wIGhlcmU/XHJcblx0XHRcdFx0XHR1dGlsLnN0b3BFdmVudFByb3BhZ2F0aW9uKGV2ZW50KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKGJpbmRFdmVudE5hbWUgIT0gJ3RvdWNoc3RhcnQnICYmIChiaW5kRXZlbnROYW1lICE9ICd0b3VjaG1vdmUnIHx8IGV2ZW50LnRvdWNoZXMubGVuZ3RoICE9IDIpKVxyXG5cdFx0XHRcdFx0cmV0dXJuIHV0aWwucHJldmVudERlZmF1bHQoZXZlbnQpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdH1cclxuXHJcblx0dGhpcy5jdGFiID0gbmV3IHJuZC5SZVN0cnVjdChuZXcgU3RydWN0KCksIHRoaXMpO1xyXG5cdHRoaXMuc2V0dGluZ3MgPSBudWxsO1xyXG5cdHRoaXMuc3R5bGVzID0gbnVsbDtcclxuXHJcblx0dGhpcy5vbkNhbnZhc09mZnNldENoYW5nZWQgPSBudWxsOyAvL2Z1bmN0aW9uKG5ld09mZnNldCwgb2xkT2Zmc2V0KXt9O1xyXG5cdHRoaXMub25DYW52YXNTaXplQ2hhbmdlZCA9IG51bGw7IC8vZnVuY3Rpb24obmV3U2l6ZSwgb2xkU2l6ZSl7fTtcclxufTtcclxuXHJcbnJuZC5SZW5kZXIucHJvdG90eXBlLmFkZFN0cnVjdENoYW5nZUhhbmRsZXIgPSBmdW5jdGlvbiAoaGFuZGxlcilcclxue1xyXG5cdGlmIChoYW5kbGVyIGluIHRoaXMuc3RydWN0Q2hhbmdlSGFuZGxlcnMpXHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2hhbmRsZXIgYWxyZWFkeSBwcmVzZW50Jyk7XHJcblx0dGhpcy5zdHJ1Y3RDaGFuZ2VIYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xyXG59O1xyXG5cclxucm5kLlJlbmRlci5wcm90b3R5cGUudmlldzJzY2FsZWQgPSBmdW5jdGlvbiAocCwgaXNSZWxhdGl2ZSkge1xyXG5cdHZhciBzY3JvbGwgPSB1aS5zY3JvbGxQb3MoKTtcclxuXHRpZiAoIXRoaXMudXNlT2xkWm9vbSkge1xyXG5cdFx0cCA9IHAuc2NhbGVkKDEgLyB0aGlzLnpvb20pO1xyXG5cdFx0c2Nyb2xsID0gc2Nyb2xsLnNjYWxlZCgxIC8gdGhpcy56b29tKTtcclxuXHR9XHJcblx0cCA9IGlzUmVsYXRpdmUgPyBwIDogcC5hZGQoc2Nyb2xsKS5zdWIodGhpcy5vZmZzZXQpO1xyXG5cdHJldHVybiBwO1xyXG59O1xyXG5cclxucm5kLlJlbmRlci5wcm90b3R5cGUuc2NhbGVkMnZpZXcgPSBmdW5jdGlvbiAocCwgaXNSZWxhdGl2ZSkge1xyXG5cdHAgPSBpc1JlbGF0aXZlID8gcCA6IHAuYWRkKHRoaXMub2Zmc2V0KS5zdWIodWkuc2Nyb2xsUG9zKCkuc2NhbGVkKDEgLyB0aGlzLnpvb20pKTtcclxuXHRpZiAoIXRoaXMudXNlT2xkWm9vbSlcclxuXHRcdHAgPSBwLnNjYWxlZCh0aGlzLnpvb20pO1xyXG5cdHJldHVybiBwO1xyXG59O1xyXG5cclxucm5kLlJlbmRlci5wcm90b3R5cGUuc2NhbGVkMm9iaiA9IGZ1bmN0aW9uICh2KSB7XHJcblx0cmV0dXJuIHYuc2NhbGVkKDEgLyB0aGlzLnNldHRpbmdzLnNjYWxlRmFjdG9yKTtcclxufTtcclxuXHJcbnJuZC5SZW5kZXIucHJvdG90eXBlLm9iajJzY2FsZWQgPSBmdW5jdGlvbiAodikge1xyXG5cdHJldHVybiB2LnNjYWxlZCh0aGlzLnNldHRpbmdzLnNjYWxlRmFjdG9yKTtcclxufTtcclxuXHJcbnJuZC5SZW5kZXIucHJvdG90eXBlLnZpZXcyb2JqID0gZnVuY3Rpb24gKHYsIGlzUmVsYXRpdmUpIHtcclxuXHRyZXR1cm4gdGhpcy5zY2FsZWQyb2JqKHRoaXMudmlldzJzY2FsZWQodiwgaXNSZWxhdGl2ZSkpO1xyXG59O1xyXG5cclxucm5kLlJlbmRlci5wcm90b3R5cGUub2JqMnZpZXcgPSBmdW5jdGlvbiAodiwgaXNSZWxhdGl2ZSkge1xyXG5cdHJldHVybiB0aGlzLnNjYWxlZDJ2aWV3KHRoaXMub2JqMnNjYWxlZCh2LCBpc1JlbGF0aXZlKSk7XHJcbn07XHJcblxyXG5ybmQuUmVuZGVyLnByb3RvdHlwZS5maW5kSXRlbSA9IGZ1bmN0aW9uIChldmVudCwgbWFwcywgc2tpcCkge1xyXG5cdHZhciBjaSA9IHRoaXMuZmluZENsb3Nlc3RJdGVtKFxyXG5cdFx0XHQndWknIGluIHdpbmRvdyAmJiAncGFnZTJvYmonIGluIHVpID8gbmV3IFZlYzIodWkucGFnZTJvYmooZXZlbnQpKSA6XHJcblx0XHRuZXcgVmVjMihldmVudC5wYWdlWCwgZXZlbnQucGFnZVkpLnN1Yih0aGlzLmNsaWVudEFyZWFQb3MpLFxyXG5cdFx0bWFwcyxcclxuXHRcdHNraXBcclxuXHQpO1xyXG5cdC8vcmJhbGFiYW5vdjogbGV0IGl0IGJlIHRoaXMgd2F5IGF0IHRoZSBtb21lbnRcclxuXHRpZiAoY2kudHlwZSA9PSAnQXRvbScpIGNpLm1hcCA9ICdhdG9tcyc7XHJcblx0ZWxzZSBpZiAoY2kudHlwZSA9PSAnQm9uZCcpIGNpLm1hcCA9ICdib25kcyc7XHJcblx0ZWxzZSBpZiAoY2kudHlwZSA9PSAnU0dyb3VwJykgY2kubWFwID0gJ3Nncm91cHMnO1xyXG5cdGVsc2UgaWYgKGNpLnR5cGUgPT0gJ0RhdGFTR3JvdXBEYXRhJykgY2kubWFwID0gJ3Nncm91cERhdGEnO1xyXG5cdGVsc2UgaWYgKGNpLnR5cGUgPT0gJ1J4bkFycm93JykgY2kubWFwID0gJ3J4bkFycm93cyc7XHJcblx0ZWxzZSBpZiAoY2kudHlwZSA9PSAnUnhuUGx1cycpIGNpLm1hcCA9ICdyeG5QbHVzZXMnO1xyXG5cdGVsc2UgaWYgKGNpLnR5cGUgPT0gJ0ZyYWdtZW50JykgY2kubWFwID0gJ2ZyYWdzJztcclxuXHRlbHNlIGlmIChjaS50eXBlID09ICdSR3JvdXAnKSBjaS5tYXAgPSAncmdyb3Vwcyc7XHJcblx0ZWxzZSBpZiAoY2kudHlwZSA9PSAnQ2hpcmFsRmxhZycpIGNpLm1hcCA9ICdjaGlyYWxGbGFncyc7XHJcblx0cmV0dXJuIGNpO1xyXG59O1xyXG5cclxucm5kLlJlbmRlci5wcm90b3R5cGUuY2xpZW50Mk9iaiA9IGZ1bmN0aW9uIChjbGllbnRQb3MpIHtcclxuXHRyZXR1cm4gbmV3IFZlYzIoY2xpZW50UG9zKS5zdWIodGhpcy5vZmZzZXQpO1xyXG59O1xyXG5cclxucm5kLlJlbmRlci5wcm90b3R5cGUuc2V0TW9sZWN1bGUgPSBmdW5jdGlvbiAoY3RhYiwgbm9yZXNjYWxlKVxyXG57XHJcblx0cm5kLmxvZ01ldGhvZCgnc2V0TW9sZWN1bGUnKTtcclxuXHR0aGlzLnBhcGVyLmNsZWFyKCk7XHJcblx0dGhpcy5jdGFiID0gbmV3IHJuZC5SZVN0cnVjdChjdGFiLCB0aGlzLCBub3Jlc2NhbGUpO1xyXG5cdHRoaXMub2Zmc2V0ID0gbnVsbDtcclxuXHR0aGlzLnNpemUgPSBudWxsO1xyXG5cdHRoaXMuYmIgPSBudWxsO1xyXG5cdHRoaXMucnhuTW9kZSA9IGN0YWIuaXNSZWFjdGlvbjtcclxufTtcclxuXHJcbi8vIG1vbGVjdWxlIG1hbmlwdWxhdGlvbiBpbnRlcmZhY2Vcclxucm5kLlJlbmRlci5wcm90b3R5cGUuYXRvbUdldEF0dHIgPSBmdW5jdGlvbiAoYWlkLCBuYW1lKVxyXG57XHJcblx0cm5kLmxvZ01ldGhvZCgnYXRvbUdldEF0dHInKTtcclxuXHQvLyBUT0RPOiBjaGVjayBhdHRyaWJ1dGUgbmFtZXNcclxuXHRyZXR1cm4gdGhpcy5jdGFiLm1vbGVjdWxlLmF0b21zLmdldChhaWQpW25hbWVdO1xyXG59O1xyXG5cclxucm5kLlJlbmRlci5wcm90b3R5cGUuaW52YWxpZGF0ZUF0b20gPSBmdW5jdGlvbiAoYWlkLCBsZXZlbClcclxue1xyXG5cdHZhciBhdG9tID0gdGhpcy5jdGFiLmF0b21zLmdldChhaWQpO1xyXG5cdHRoaXMuY3RhYi5tYXJrQXRvbShhaWQsIGxldmVsID8gMSA6IDApO1xyXG5cdHZhciBoYnMgPSB0aGlzLmN0YWIubW9sZWN1bGUuaGFsZkJvbmRzO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXRvbS5hLm5laWdoYm9ycy5sZW5ndGg7ICsraSkge1xyXG5cdFx0dmFyIGhiaWQgPSBhdG9tLmEubmVpZ2hib3JzW2ldO1xyXG5cdFx0aWYgKGhicy5oYXMoaGJpZCkpIHtcclxuXHRcdFx0dmFyIGhiID0gaGJzLmdldChoYmlkKTtcclxuXHRcdFx0dGhpcy5jdGFiLm1hcmtCb25kKGhiLmJpZCwgMSk7XHJcblx0XHRcdHRoaXMuY3RhYi5tYXJrQXRvbShoYi5lbmQsIDApO1xyXG5cdFx0XHRpZiAobGV2ZWwpXHJcblx0XHRcdFx0dGhpcy5pbnZhbGlkYXRlTG9vcChoYi5iaWQpO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbnJuZC5SZW5kZXIucHJvdG90eXBlLmludmFsaWRhdGVMb29wID0gZnVuY3Rpb24gKGJpZClcclxue1xyXG5cdHZhciBib25kID0gdGhpcy5jdGFiLmJvbmRzLmdldChiaWQpO1xyXG5cdHZhciBsaWQxID0gdGhpcy5jdGFiLm1vbGVjdWxlLmhhbGZCb25kcy5nZXQoYm9uZC5iLmhiMSkubG9vcDtcclxuXHR2YXIgbGlkMiA9IHRoaXMuY3RhYi5tb2xlY3VsZS5oYWxmQm9uZHMuZ2V0KGJvbmQuYi5oYjIpLmxvb3A7XHJcblx0aWYgKGxpZDEgPj0gMClcclxuXHRcdHRoaXMuY3RhYi5sb29wUmVtb3ZlKGxpZDEpO1xyXG5cdGlmIChsaWQyID49IDApXHJcblx0XHR0aGlzLmN0YWIubG9vcFJlbW92ZShsaWQyKTtcclxufTtcclxuXHJcbnJuZC5SZW5kZXIucHJvdG90eXBlLmludmFsaWRhdGVCb25kID0gZnVuY3Rpb24gKGJpZClcclxue1xyXG5cdHZhciBib25kID0gdGhpcy5jdGFiLmJvbmRzLmdldChiaWQpO1xyXG5cdHRoaXMuaW52YWxpZGF0ZUxvb3AoYmlkKTtcclxuXHR0aGlzLmludmFsaWRhdGVBdG9tKGJvbmQuYi5iZWdpbiwgMCk7XHJcblx0dGhpcy5pbnZhbGlkYXRlQXRvbShib25kLmIuZW5kLCAwKTtcclxufTtcclxuXHJcbnJuZC5SZW5kZXIucHJvdG90eXBlLmludmFsaWRhdGVJdGVtID0gZnVuY3Rpb24gKG1hcCwgaWQsIGxldmVsKVxyXG57XHJcblx0aWYgKG1hcCA9PSAnYXRvbXMnKSB7XHJcblx0XHR0aGlzLmludmFsaWRhdGVBdG9tKGlkLCBsZXZlbCk7XHJcblx0fSBlbHNlIGlmIChtYXAgPT0gJ2JvbmRzJykge1xyXG5cdFx0dGhpcy5pbnZhbGlkYXRlQm9uZChpZCk7XHJcblx0XHRpZiAobGV2ZWwgPiAwKVxyXG5cdFx0XHR0aGlzLmludmFsaWRhdGVMb29wKGlkKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhpcy5jdGFiLm1hcmtJdGVtKG1hcCwgaWQsIGxldmVsKTtcclxuXHR9XHJcbn07XHJcblxyXG5ybmQuUmVuZGVyLnByb3RvdHlwZS5hdG9tR2V0RGVncmVlID0gZnVuY3Rpb24gKGFpZClcclxue1xyXG5cdHJuZC5sb2dNZXRob2QoJ2F0b21HZXREZWdyZWUnKTtcclxuXHRyZXR1cm4gdGhpcy5jdGFiLmF0b21zLmdldChhaWQpLmEubmVpZ2hib3JzLmxlbmd0aDtcclxufTtcclxuXHJcbnJuZC5SZW5kZXIucHJvdG90eXBlLmlzQm9uZEluUmluZyA9IGZ1bmN0aW9uIChiaWQpIHtcclxuXHR2YXIgYm9uZCA9IHRoaXMuY3RhYi5ib25kcy5nZXQoYmlkKTtcclxuXHRyZXR1cm4gdGhpcy5jdGFiLm1vbGVjdWxlLmhhbGZCb25kcy5nZXQoYm9uZC5iLmhiMSkubG9vcCA+PSAwIHx8XHJcblx0dGhpcy5jdGFiLm1vbGVjdWxlLmhhbGZCb25kcy5nZXQoYm9uZC5iLmhiMikubG9vcCA+PSAwO1xyXG59O1xyXG5cclxucm5kLlJlbmRlci5wcm90b3R5cGUuYXRvbUdldE5laWdoYm9ycyA9IGZ1bmN0aW9uIChhaWQpXHJcbntcclxuXHR2YXIgYXRvbSA9IHRoaXMuY3RhYi5hdG9tcy5nZXQoYWlkKTtcclxuXHR2YXIgbmVpQXRvbXMgPSBbXTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGF0b20uYS5uZWlnaGJvcnMubGVuZ3RoOyArK2kpIHtcclxuXHRcdHZhciBoYiA9IHRoaXMuY3RhYi5tb2xlY3VsZS5oYWxmQm9uZHMuZ2V0KGF0b20uYS5uZWlnaGJvcnNbaV0pO1xyXG5cdFx0bmVpQXRvbXMucHVzaCh7XHJcblx0XHRcdCdhaWQnOiBoYi5lbmQgLSAwLFxyXG5cdFx0XHQnYmlkJzogaGIuYmlkIC0gMFxyXG5cdFx0fSk7XHJcblx0fVxyXG5cdHJldHVybiBuZWlBdG9tcztcclxufTtcclxuXHJcbi8vIHJldHVybnMgYW4gYXJyYXkgb2Ygcy1ncm91cCBpZCdzXHJcbnJuZC5SZW5kZXIucHJvdG90eXBlLmF0b21HZXRTR3JvdXBzID0gZnVuY3Rpb24gKGFpZClcclxue1xyXG5cdHJuZC5sb2dNZXRob2QoJ2F0b21HZXRTR3JvdXBzJyk7XHJcblx0dmFyIGF0b20gPSB0aGlzLmN0YWIuYXRvbXMuZ2V0KGFpZCk7XHJcblx0cmV0dXJuIFNldC5saXN0KGF0b20uYS5zZ3MpO1xyXG59O1xyXG5cclxucm5kLlJlbmRlci5wcm90b3R5cGUuc0dyb3VwR2V0QXR0ciA9IGZ1bmN0aW9uIChzZ2lkLCBuYW1lKVxyXG57XHJcblx0cm5kLmxvZ01ldGhvZCgnc0dyb3VwR2V0QXR0cicpO1xyXG5cdHJldHVybiB0aGlzLmN0YWIuc2dyb3Vwcy5nZXQoc2dpZCkuaXRlbS5nZXRBdHRyKG5hbWUpO1xyXG59O1xyXG5cclxucm5kLlJlbmRlci5wcm90b3R5cGUuc0dyb3VwR2V0QXR0cnMgPSBmdW5jdGlvbiAoc2dpZClcclxue1xyXG5cdHJuZC5sb2dNZXRob2QoJ3NHcm91cEdldEF0dHJzJyk7XHJcblx0cmV0dXJuIHRoaXMuY3RhYi5zZ3JvdXBzLmdldChzZ2lkKS5pdGVtLmdldEF0dHJzKCk7XHJcbn07XHJcblxyXG4vLyBUT0RPOiBtb3ZlIHRvIFNHcm91cFxyXG5ybmQuUmVuZGVyLnByb3RvdHlwZS5zR3JvdXBHZXRBdG9tcyA9IGZ1bmN0aW9uIChzZ2lkKVxyXG57XHJcblx0cm5kLmxvZ01ldGhvZCgnc0dyb3VwR2V0QXRvbXMnKTtcclxuXHR2YXIgc2cgPSB0aGlzLmN0YWIuc2dyb3Vwcy5nZXQoc2dpZCkuaXRlbTtcclxuXHRyZXR1cm4gU0dyb3VwLmdldEF0b21zKHRoaXMuY3RhYi5tb2xlY3VsZSwgc2cpO1xyXG59O1xyXG5cclxucm5kLlJlbmRlci5wcm90b3R5cGUuc0dyb3VwR2V0VHlwZSA9IGZ1bmN0aW9uIChzZ2lkKVxyXG57XHJcblx0cm5kLmxvZ01ldGhvZCgnc0dyb3VwR2V0VHlwZScpO1xyXG5cdHZhciBzZyA9IHRoaXMuY3RhYi5zZ3JvdXBzLmdldChzZ2lkKS5pdGVtO1xyXG5cdHJldHVybiBzZy50eXBlO1xyXG59O1xyXG5cclxucm5kLlJlbmRlci5wcm90b3R5cGUuc0dyb3Vwc0ZpbmRDcm9zc0JvbmRzID0gZnVuY3Rpb24gKClcclxue1xyXG5cdHJuZC5sb2dNZXRob2QoJ3NHcm91cHNGaW5kQ3Jvc3NCb25kcycpO1xyXG5cdHRoaXMuY3RhYi5tb2xlY3VsZS5zR3JvdXBzUmVjYWxjQ3Jvc3NCb25kcygpO1xyXG59O1xyXG5cclxuLy8gVE9ETzogbW92ZSB0byBSZVN0cnVjdFxyXG5ybmQuUmVuZGVyLnByb3RvdHlwZS5zR3JvdXBHZXROZWlnaGJvckF0b21zID0gZnVuY3Rpb24gKHNnaWQpXHJcbntcclxuXHRybmQubG9nTWV0aG9kKCdzR3JvdXBHZXROZWlnaGJvckF0b21zJyk7XHJcblx0dmFyIHNnID0gdGhpcy5jdGFiLnNncm91cHMuZ2V0KHNnaWQpLml0ZW07XHJcblx0cmV0dXJuIHNnLm5laUF0b21zO1xyXG59O1xyXG5cclxuLy8gVE9ETzogbW92ZSB0byBSZVN0cnVjdFxyXG5ybmQuUmVuZGVyLnByb3RvdHlwZS5hdG9tSXNQbGFpbkNhcmJvbiA9IGZ1bmN0aW9uIChhaWQpXHJcbntcclxuXHRybmQubG9nTWV0aG9kKCdhdG9tSXNQbGFpbkNhcmJvbicpO1xyXG5cdHJldHVybiB0aGlzLmN0YWIuYXRvbXMuZ2V0KGFpZCkuYS5pc1BsYWluQ2FyYm9uKCk7XHJcbn07XHJcblxyXG5ybmQuUmVuZGVyLnByb3RvdHlwZS5oaWdobGlnaHRPYmplY3QgPSBmdW5jdGlvbiAob2JqLCB2aXNpYmxlKSB7XHJcblx0aWYgKFsnYXRvbXMnLCAnYm9uZHMnLCAncnhuQXJyb3dzJywgJ3J4blBsdXNlcycsICdjaGlyYWxGbGFncycsICdmcmFncycsICdyZ3JvdXBzJywgJ3Nncm91cHMnLCAnc2dyb3VwRGF0YSddLmluZGV4T2Yob2JqLm1hcCkgPiAtMSkge1xyXG5cdFx0dmFyIGl0ZW0gPSB0aGlzLmN0YWJbb2JqLm1hcF0uZ2V0KG9iai5pZCk7XHJcblx0XHRpZiAoaXRlbSA9PSBudWxsKVxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTsgLy8gVE9ETzogZml4LCBhdHRlbXB0IHRvIGhpZ2hsaWdodCBhIGRlbGV0ZWQgaXRlbVxyXG5cdFx0aWYgKChvYmoubWFwID09ICdzZ3JvdXBzJyAmJiBpdGVtLml0ZW0udHlwZSA9PSAnREFUJykgfHwgb2JqLm1hcCA9PSAnc2dyb3VwRGF0YScpIHtcclxuXHRcdFx0Ly8gc2V0IGhpZ2hsaWdodCBmb3IgYm90aCB0aGUgZ3JvdXAgYW5kIHRoZSBkYXRhIGl0ZW1cclxuXHRcdFx0dmFyIGl0ZW0xID0gdGhpcy5jdGFiLnNncm91cHMuZ2V0KG9iai5pZCk7XHJcblx0XHRcdHZhciBpdGVtMiA9IHRoaXMuY3RhYi5zZ3JvdXBEYXRhLmdldChvYmouaWQpO1xyXG5cdFx0XHRpZiAoaXRlbTEgIT0gbnVsbClcclxuXHRcdFx0XHRpdGVtMS5zZXRIaWdobGlnaHQodmlzaWJsZSwgdGhpcyk7XHJcblx0XHRcdGlmIChpdGVtMiAhPSBudWxsKVxyXG5cdFx0XHRcdGl0ZW0yLnNldEhpZ2hsaWdodCh2aXNpYmxlLCB0aGlzKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGl0ZW0uc2V0SGlnaGxpZ2h0KHZpc2libGUsIHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cdHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxucm5kLlJlbmRlci5wcm90b3R5cGUuaXRlbUdldFBvcyA9IGZ1bmN0aW9uIChtYXAsIGlkKVxyXG57XHJcblx0cmV0dXJuIHRoaXMuY3RhYi5tb2xlY3VsZVttYXBdLmdldChpZCkucHA7XHJcbn07XHJcblxyXG5ybmQuUmVuZGVyLnByb3RvdHlwZS5hdG9tR2V0UG9zID0gZnVuY3Rpb24gKGlkKVxyXG57XHJcblx0cm5kLmxvZ01ldGhvZCgnYXRvbUdldFBvcycpO1xyXG5cdHJldHVybiB0aGlzLml0ZW1HZXRQb3MoJ2F0b21zJywgaWQpO1xyXG59O1xyXG5cclxucm5kLlJlbmRlci5wcm90b3R5cGUucnhuQXJyb3dHZXRQb3MgPSBmdW5jdGlvbiAoaWQpXHJcbntcclxuXHRybmQubG9nTWV0aG9kKCdyeG5BcnJvd0dldFBvcycpO1xyXG5cdHJldHVybiB0aGlzLml0ZW1HZXRQb3MoJ3J4bkFycm93cycsIGlkKTtcclxufTtcclxuXHJcbnJuZC5SZW5kZXIucHJvdG90eXBlLnJ4blBsdXNHZXRQb3MgPSBmdW5jdGlvbiAoaWQpXHJcbntcclxuXHRybmQubG9nTWV0aG9kKCdyeG5QbHVzR2V0UG9zJyk7XHJcblx0cmV0dXJuIHRoaXMuaXRlbUdldFBvcygncnhuUGx1c2VzJywgaWQpO1xyXG59O1xyXG5cclxucm5kLlJlbmRlci5wcm90b3R5cGUuZ2V0QWRqYWNlbnRCb25kcyA9IGZ1bmN0aW9uIChhdG9tcykge1xyXG5cdHZhciBhaWRTZXQgPSBTZXQuZnJvbUxpc3QoYXRvbXMpO1xyXG5cdHZhciBiaWRTZXRJbm5lciA9IFNldC5lbXB0eSgpLCBiaWRTZXRDcm9zcyA9IFNldC5lbXB0eSgpO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXRvbXMubGVuZ3RoOyArK2kpIHtcclxuXHRcdHZhciBhaWQgPSBhdG9tc1tpXTtcclxuXHRcdHZhciBhdG9tID0gdGhpcy5jdGFiLmF0b21zLmdldChhaWQpO1xyXG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBhdG9tLmEubmVpZ2hib3JzLmxlbmd0aDsgKytqKSB7XHJcblx0XHRcdHZhciBoYmlkID0gYXRvbS5hLm5laWdoYm9yc1tqXTtcclxuXHRcdFx0dmFyIGhiID0gdGhpcy5jdGFiLm1vbGVjdWxlLmhhbGZCb25kcy5nZXQoaGJpZCk7XHJcblx0XHRcdHZhciBlbmRJZCA9IGhiLmVuZDtcclxuXHRcdFx0dmFyIHNldCA9IFNldC5jb250YWlucyhhaWRTZXQsIGVuZElkKSA/XHJcblx0XHRcdFx0XHRiaWRTZXRJbm5lciA6IGJpZFNldENyb3NzO1xyXG5cdFx0XHRTZXQuYWRkKHNldCwgaGIuYmlkKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIHsnaW5uZXInOiBiaWRTZXRJbm5lciwgJ2Nyb3NzJzogYmlkU2V0Q3Jvc3N9O1xyXG59O1xyXG5cclxucm5kLlJlbmRlci5wcm90b3R5cGUuYm9uZEdldEF0dHIgPSBmdW5jdGlvbiAoYmlkLCBuYW1lKVxyXG57XHJcblx0cm5kLmxvZ01ldGhvZCgnYm9uZEdldEF0dHInKTtcclxuXHRyZXR1cm4gdGhpcy5jdGFiLmJvbmRzLmdldChiaWQpLmJbbmFtZV07XHJcbn07XHJcblxyXG5ybmQuUmVuZGVyLnByb3RvdHlwZS5zZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoc2VsZWN0aW9uKVxyXG57XHJcblx0cm5kLmxvZ01ldGhvZCgnc2V0U2VsZWN0aW9uJyk7XHJcblx0Zm9yICh2YXIgbWFwIGluIHJuZC5SZVN0cnVjdC5tYXBzKSB7XHJcblx0XHRpZiAoIXJuZC5SZVN0cnVjdC5tYXBzW21hcF0uaXNTZWxlY3RhYmxlKCkpXHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0dmFyIHNldCA9IHNlbGVjdGlvbiA/IChzZWxlY3Rpb25bbWFwXSA/IHV0aWwuaWRlbnRpdHlNYXAoc2VsZWN0aW9uW21hcF0pIDoge30pIDogbnVsbDtcclxuXHRcdHRoaXMuY3RhYlttYXBdLmVhY2goZnVuY3Rpb24gKGlkLCBpdGVtKXtcclxuXHRcdFx0dmFyIHNlbGVjdGVkID0gc2V0ID8gc2V0W2lkXSA9PT0gaWQgOiBpdGVtLnNlbGVjdGVkO1xyXG5cdFx0XHRpdGVtLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XHJcblx0XHRcdHRoaXMuY3RhYi5zaG93SXRlbVNlbGVjdGlvbihpZCwgaXRlbSwgc2VsZWN0ZWQpO1xyXG5cdFx0fSwgdGhpcyk7XHJcblx0fVxyXG59O1xyXG5cclxucm5kLlJlbmRlci5wcm90b3R5cGUuaW5pdFN0eWxlcyA9IGZ1bmN0aW9uICgpXHJcbntcclxuXHQvLyBUT0RPIG1vdmUgZm9udHMsIGRhc2hlZCBsaW5lcywgZXRjLiBoZXJlXHJcblx0dmFyIHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncztcclxuXHR0aGlzLnN0eWxlcyA9IHt9O1xyXG5cdHRoaXMuc3R5bGVzLmxpbmVhdHRyID0ge1xyXG5cdFx0c3Ryb2tlOiAnIzAwMCcsXHJcblx0XHQnc3Ryb2tlLXdpZHRoJzogc2V0dGluZ3MubGluZVdpZHRoLFxyXG5cdFx0J3N0cm9rZS1saW5lY2FwJzogJ3JvdW5kJyxcclxuXHRcdCdzdHJva2UtbGluZWpvaW4nOiAncm91bmQnXHJcblx0fTtcclxuXHR0aGlzLnN0eWxlcy5zZWxlY3Rpb25TdHlsZSA9IHtcclxuXHRcdCdmaWxsJzonIzdmNycsXHJcblx0XHQnc3Ryb2tlJzonbm9uZSdcclxuXHR9O1xyXG5cdHRoaXMuc3R5bGVzLnNlbGVjdGlvblpvbmVTdHlsZSA9IHtcclxuXHRcdCdmaWxsJzonIzAwMCcsXHJcblx0XHQnc3Ryb2tlJzonbm9uZScsXHJcblx0XHQnb3BhY2l0eSc6MC4wXHJcblx0fTtcclxuXHR0aGlzLnN0eWxlcy5oaWdobGlnaHRTdHlsZSA9IHtcclxuXHRcdCdzdHJva2UnOicjMGMwJyxcclxuXHRcdCdzdHJva2Utd2lkdGgnOjAuNiAqIHNldHRpbmdzLmxpbmVXaWR0aFxyXG5cdH07XHJcblx0dGhpcy5zdHlsZXMuc0dyb3VwSGlnaGxpZ2h0U3R5bGUgPSB7XHJcblx0XHQnc3Ryb2tlJzonIzk5MDBmZicsXHJcblx0XHQnc3Ryb2tlLXdpZHRoJzowLjYgKiBzZXR0aW5ncy5saW5lV2lkdGhcclxuXHR9O1xyXG5cdHRoaXMuc3R5bGVzLnNncm91cEJyYWNrZXRTdHlsZSA9IHtcclxuXHRcdCdzdHJva2UnOidkYXJrZ3JheScsXHJcblx0XHQnc3Ryb2tlLXdpZHRoJzowLjUgKiBzZXR0aW5ncy5saW5lV2lkdGhcclxuXHR9O1xyXG5cdHRoaXMuc3R5bGVzLmF0b21TZWxlY3Rpb25QbGF0ZVJhZGl1cyA9IHNldHRpbmdzLmxhYmVsRm9udFNpemUgKiAxLjIgO1xyXG59O1xyXG5cclxucm5kLlJlbmRlci5wcm90b3R5cGUuaW5pdFNldHRpbmdzID0gZnVuY3Rpb24gKClcclxue1xyXG5cdHZhciBzZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3MgPSB7fTtcclxuXHRzZXR0aW5ncy5kZWx0YSA9IHRoaXMuY3RhYi5tb2xlY3VsZS5nZXRDb29yZEJvdW5kaW5nQm94KCk7XHJcblx0c2V0dGluZ3MubWFyZ2luID0gMC4xO1xyXG5cdHNldHRpbmdzLnNjYWxlRmFjdG9yID0gdGhpcy5zY2FsZTtcclxuXHRzZXR0aW5ncy5saW5lV2lkdGggPSBzZXR0aW5ncy5zY2FsZUZhY3RvciAvIDIwO1xyXG5cdHNldHRpbmdzLmJvbmRTaGlmdCA9IHNldHRpbmdzLnNjYWxlRmFjdG9yIC8gNjtcclxuXHRzZXR0aW5ncy5ib25kU3BhY2UgPSBzZXR0aW5ncy5zY2FsZUZhY3RvciAvIDc7XHJcblx0c2V0dGluZ3MubGFiZWxGb250U2l6ZSA9IE1hdGguY2VpbCgxLjkgKiAoc2V0dGluZ3Muc2NhbGVGYWN0b3IgLyA2KSk7IC8vIFRPRE86IGRvbid0IHJvdW5kP1xyXG5cdHNldHRpbmdzLnN1YkZvbnRTaXplID0gTWF0aC5jZWlsKDAuNyAqIHNldHRpbmdzLmxhYmVsRm9udFNpemUpO1xyXG5cdC8vIGZvbnQgc2l6ZSBpcyBub3QgZGV0ZXJtaW5lZCBieSB0aGUgbnVtYmVyIGluIHRoaXMgc3RyaW5nLFxyXG5cdC8vICBidXQgYnkgdGhlICdmb250LXNpemUnIHByb3BlcnR5XHJcblx0c2V0dGluZ3MuZm9udCA9ICczMHB4IFwiQXJpYWxcIic7XHJcblx0c2V0dGluZ3MuZm9udHN6ID0gdGhpcy5zZXR0aW5ncy5sYWJlbEZvbnRTaXplO1xyXG5cdHNldHRpbmdzLmZvbnRzenN1YiA9IHRoaXMuc2V0dGluZ3Muc3ViRm9udFNpemU7XHJcblx0c2V0dGluZ3MuZm9udFJMYWJlbCA9IHRoaXMuc2V0dGluZ3MubGFiZWxGb250U2l6ZSAqIDEuMjtcclxuXHRzZXR0aW5ncy5mb250UkxvZ2ljID0gdGhpcy5zZXR0aW5ncy5sYWJlbEZvbnRTaXplICogMC43O1xyXG59O1xyXG5cclxucm5kLlJlbmRlci5wcm90b3R5cGUuZ2V0U3RydWN0Q2VudGVyID0gZnVuY3Rpb24gKHNlbGVjdGlvbilcclxue1xyXG5cdHZhciBiYiA9IHRoaXMuY3RhYi5nZXRWQm94T2JqKHNlbGVjdGlvbik7XHJcblx0cmV0dXJuIFZlYzIubGMyKGJiLnAwLCAwLjUsIGJiLnAxLCAwLjUpO1xyXG59O1xyXG5cclxucm5kLlJlbmRlci5wcm90b3R5cGUub25SZXNpemUgPSBmdW5jdGlvbiAoKVxyXG57XHJcblx0dGhpcy5zZXRWaWV3U2l6ZShuZXcgVmVjMih0aGlzLmNsaWVudEFyZWFbJ2NsaWVudFdpZHRoJ10sIHRoaXMuY2xpZW50QXJlYVsnY2xpZW50SGVpZ2h0J10pKTtcclxufTtcclxuXHJcbnJuZC5SZW5kZXIucHJvdG90eXBlLnNldFZpZXdTaXplID0gZnVuY3Rpb24gKHZpZXdTeilcclxue1xyXG5cdHRoaXMudmlld1N6ID0gbmV3IFZlYzIodmlld1N6KTtcclxufTtcclxuXHJcbnJuZC5SZW5kZXIucHJvdG90eXBlLl9zZXRQYXBlclNpemUgPSBmdW5jdGlvbiAoc3opXHJcbntcclxuXHR2YXIgeiA9IHRoaXMuem9vbTtcclxuXHR0aGlzLnBhcGVyLnNldFNpemUoc3oueCAqIHosIHN6LnkgKiB6KTtcclxuXHR0aGlzLnNldFZpZXdCb3goeik7XHJcbn07XHJcblxyXG5ybmQuUmVuZGVyLnByb3RvdHlwZS5zZXRQYXBlclNpemUgPSBmdW5jdGlvbiAoc3opXHJcbntcclxuXHRybmQubG9nTWV0aG9kKCdzZXRQYXBlclNpemUnKTtcclxuXHR2YXIgb2xkU3ogPSB0aGlzLnN6O1xyXG5cdHRoaXMuc3ogPSBzejtcclxuXHR0aGlzLl9zZXRQYXBlclNpemUoc3opO1xyXG5cdGlmICh0aGlzLm9uQ2FudmFzU2l6ZUNoYW5nZWQpXHJcblx0XHR0aGlzLm9uQ2FudmFzU2l6ZUNoYW5nZWQoc3osIG9sZFN6KTtcclxufTtcclxuXHJcbnJuZC5SZW5kZXIucHJvdG90eXBlLnNldE9mZnNldCA9IGZ1bmN0aW9uIChuZXdvZmZzZXQpXHJcbntcclxuXHRybmQubG9nTWV0aG9kKCdzZXRPZmZzZXQnKTtcclxuXHRpZiAodGhpcy5vbkNhbnZhc09mZnNldENoYW5nZWQpIHRoaXMub25DYW52YXNPZmZzZXRDaGFuZ2VkKG5ld29mZnNldCwgdGhpcy5vZmZzZXQpO1xyXG5cdHRoaXMub2Zmc2V0ID0gbmV3b2Zmc2V0O1xyXG59O1xyXG5cclxucm5kLlJlbmRlci5wcm90b3R5cGUuZ2V0RWxlbWVudFBvcyA9IGZ1bmN0aW9uIChvYmopXHJcbntcclxuXHR2YXIgY3VybGVmdCA9IDAsIGN1cnRvcCA9IDA7XHJcblxyXG5cdGlmIChvYmoub2Zmc2V0UGFyZW50KSB7XHJcblx0XHRkbyB7XHJcblx0XHRcdGN1cmxlZnQgKz0gb2JqLm9mZnNldExlZnQ7XHJcblx0XHRcdGN1cnRvcCArPSBvYmoub2Zmc2V0VG9wO1xyXG5cdFx0fSB3aGlsZSAoKG9iaiA9IG9iai5vZmZzZXRQYXJlbnQpKTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBWZWMyKGN1cmxlZnQsY3VydG9wKTtcclxufTtcclxuXHJcbnJuZC5SZW5kZXIucHJvdG90eXBlLmRyYXdTZWxlY3Rpb25MaW5lID0gZnVuY3Rpb24gKHAwLCBwMSkge1xyXG5cdHJuZC5sb2dNZXRob2QoJ2RyYXdTZWxlY3Rpb25MaW5lJyk7XHJcblx0aWYgKHRoaXMuc2VsZWN0aW9uUmVjdCkge1xyXG5cdFx0dGhpcy5zZWxlY3Rpb25SZWN0LnJlbW92ZSgpO1xyXG5cdFx0dGhpcy5zZWxlY3Rpb25SZWN0ID0gbnVsbDtcclxuXHR9XHJcblx0aWYgKHAwICYmIHAxKSB7XHJcblx0XHRwMCA9IHRoaXMub2JqMnNjYWxlZChwMCkuYWRkKHRoaXMub2Zmc2V0KTtcclxuXHRcdHAxID0gdGhpcy5vYmoyc2NhbGVkKHAxKS5hZGQodGhpcy5vZmZzZXQpO1xyXG5cdFx0dGhpcy5zZWxlY3Rpb25SZWN0ID0gdGhpcy5wYXBlci5wYXRoKFxyXG5cdFx0cm5kLlJlU3RydWN0Lm1ha2VTdHJva2UocDAsIHAxKVxyXG5cdFx0KS5hdHRyKHsnc3Ryb2tlJzonZ3JheScsICdzdHJva2Utd2lkdGgnOicxcHgnfSk7XHJcblx0fVxyXG59O1xyXG5cclxucm5kLlJlbmRlci5wcm90b3R5cGUuZHJhd1NlbGVjdGlvblJlY3RhbmdsZSA9IGZ1bmN0aW9uIChwMCwgcDEpIHtcclxuXHRybmQubG9nTWV0aG9kKCdkcmF3U2VsZWN0aW9uUmVjdGFuZ2xlJyk7XHJcblx0aWYgKHRoaXMuc2VsZWN0aW9uUmVjdCkge1xyXG5cdFx0dGhpcy5zZWxlY3Rpb25SZWN0LnJlbW92ZSgpO1xyXG5cdFx0dGhpcy5zZWxlY3Rpb25SZWN0ID0gbnVsbDtcclxuXHR9XHJcblx0aWYgKHAwICYmIHAxKSB7XHJcblx0XHRwMCA9IHRoaXMub2JqMnNjYWxlZChwMCkuYWRkKHRoaXMub2Zmc2V0KTtcclxuXHRcdHAxID0gdGhpcy5vYmoyc2NhbGVkKHAxKS5hZGQodGhpcy5vZmZzZXQpO1xyXG5cdFx0dGhpcy5zZWxlY3Rpb25SZWN0ID0gdGhpcy5wYXBlci5yZWN0KFxyXG5cdFx0TWF0aC5taW4ocDAueCwgcDEueCksIE1hdGgubWluKHAwLnksIHAxLnkpLCBNYXRoLmFicyhwMS54IC0gcDAueCksIE1hdGguYWJzKHAxLnkgLSBwMC55KVxyXG5cdFx0KS5hdHRyKHsnc3Ryb2tlJzonZ3JheScsICdzdHJva2Utd2lkdGgnOicxcHgnfSk7XHJcblx0fVxyXG59O1xyXG5cclxucm5kLlJlbmRlci5wcm90b3R5cGUuZ2V0RWxlbWVudHNJblJlY3RhbmdsZSA9IGZ1bmN0aW9uIChwMCxwMSkge1xyXG5cdHJuZC5sb2dNZXRob2QoJ2dldEVsZW1lbnRzSW5SZWN0YW5nbGUnKTtcclxuXHR2YXIgYm9uZExpc3QgPSBbXTtcclxuXHR2YXIgYXRvbUxpc3QgPSBbXTtcclxuXHJcblx0dmFyIHgwID0gTWF0aC5taW4ocDAueCwgcDEueCksIHgxID0gTWF0aC5tYXgocDAueCwgcDEueCksIHkwID0gTWF0aC5taW4ocDAueSwgcDEueSksIHkxID0gTWF0aC5tYXgocDAueSwgcDEueSk7XHJcblx0dGhpcy5jdGFiLmJvbmRzLmVhY2goZnVuY3Rpb24gKGJpZCwgYm9uZCl7XHJcblx0XHR2YXIgY2VudHJlID0gVmVjMi5sYzIodGhpcy5jdGFiLmF0b21zLmdldChib25kLmIuYmVnaW4pLmEucHAsIDAuNSxcclxuXHRcdFx0dGhpcy5jdGFiLmF0b21zLmdldChib25kLmIuZW5kKS5hLnBwLCAwLjUpO1xyXG5cdFx0aWYgKGNlbnRyZS54ID4geDAgJiYgY2VudHJlLnggPCB4MSAmJiBjZW50cmUueSA+IHkwICYmIGNlbnRyZS55IDwgeTEpXHJcblx0XHRcdGJvbmRMaXN0LnB1c2goYmlkKTtcclxuXHR9LCB0aGlzKTtcclxuXHR0aGlzLmN0YWIuYXRvbXMuZWFjaChmdW5jdGlvbiAoYWlkLCBhdG9tKSB7XHJcblx0XHRpZiAoYXRvbS5hLnBwLnggPiB4MCAmJiBhdG9tLmEucHAueCA8IHgxICYmIGF0b20uYS5wcC55ID4geTAgJiYgYXRvbS5hLnBwLnkgPCB5MSlcclxuXHRcdFx0YXRvbUxpc3QucHVzaChhaWQpO1xyXG5cdH0sIHRoaXMpO1xyXG5cdHZhciByeG5BcnJvd3NMaXN0ID0gW107XHJcblx0dmFyIHJ4blBsdXNlc0xpc3QgPSBbXTtcclxuXHR0aGlzLmN0YWIucnhuQXJyb3dzLmVhY2goZnVuY3Rpb24gKGlkLCBpdGVtKXtcclxuXHRcdGlmIChpdGVtLml0ZW0ucHAueCA+IHgwICYmIGl0ZW0uaXRlbS5wcC54IDwgeDEgJiYgaXRlbS5pdGVtLnBwLnkgPiB5MCAmJiBpdGVtLml0ZW0ucHAueSA8IHkxKVxyXG5cdFx0XHRyeG5BcnJvd3NMaXN0LnB1c2goaWQpO1xyXG5cdH0sIHRoaXMpO1xyXG5cdHRoaXMuY3RhYi5yeG5QbHVzZXMuZWFjaChmdW5jdGlvbiAoaWQsIGl0ZW0pe1xyXG5cdFx0aWYgKGl0ZW0uaXRlbS5wcC54ID4geDAgJiYgaXRlbS5pdGVtLnBwLnggPCB4MSAmJiBpdGVtLml0ZW0ucHAueSA+IHkwICYmIGl0ZW0uaXRlbS5wcC55IDwgeTEpXHJcblx0XHRcdHJ4blBsdXNlc0xpc3QucHVzaChpZCk7XHJcblx0fSwgdGhpcyk7XHJcblx0dmFyIGNoaXJhbEZsYWdMaXN0ID0gW107XHJcblx0dGhpcy5jdGFiLmNoaXJhbEZsYWdzLmVhY2goZnVuY3Rpb24gKGlkLCBpdGVtKXtcclxuXHRcdGlmIChpdGVtLnBwLnggPiB4MCAmJiBpdGVtLnBwLnggPCB4MSAmJiBpdGVtLnBwLnkgPiB5MCAmJiBpdGVtLnBwLnkgPCB5MSlcclxuXHRcdFx0Y2hpcmFsRmxhZ0xpc3QucHVzaChpZCk7XHJcblx0fSwgdGhpcyk7XHJcblx0dmFyIHNncm91cERhdGFMaXN0ID0gW107XHJcblx0dGhpcy5jdGFiLnNncm91cERhdGEuZWFjaChmdW5jdGlvbiAoaWQsIGl0ZW0pe1xyXG5cdFx0aWYgKGl0ZW0uc2dyb3VwLnBwLnggPiB4MCAmJiBpdGVtLnNncm91cC5wcC54IDwgeDEgJiYgaXRlbS5zZ3JvdXAucHAueSA+IHkwICYmIGl0ZW0uc2dyb3VwLnBwLnkgPCB5MSlcclxuXHRcdFx0c2dyb3VwRGF0YUxpc3QucHVzaChpZCk7XHJcblx0fSwgdGhpcyk7XHJcblx0cmV0dXJuIHtcclxuXHRcdCdhdG9tcyc6YXRvbUxpc3QsXHJcblx0XHQnYm9uZHMnOmJvbmRMaXN0LFxyXG5cdFx0J3J4bkFycm93cyc6cnhuQXJyb3dzTGlzdCxcclxuXHRcdCdyeG5QbHVzZXMnOnJ4blBsdXNlc0xpc3QsXHJcblx0XHQnY2hpcmFsRmxhZ3MnOmNoaXJhbEZsYWdMaXN0LFxyXG5cdFx0J3Nncm91cERhdGEnOnNncm91cERhdGFMaXN0XHJcblx0fTtcclxufTtcclxuXHJcbnJuZC5SZW5kZXIucHJvdG90eXBlLmRyYXdTZWxlY3Rpb25Qb2x5Z29uID0gZnVuY3Rpb24gKHIpIHtcclxuXHRybmQubG9nTWV0aG9kKCdkcmF3U2VsZWN0aW9uUG9seWdvbicpO1xyXG5cdGlmICh0aGlzLnNlbGVjdGlvblJlY3QpIHtcclxuXHRcdHRoaXMuc2VsZWN0aW9uUmVjdC5yZW1vdmUoKTtcclxuXHRcdHRoaXMuc2VsZWN0aW9uUmVjdCA9IG51bGw7XHJcblx0fVxyXG5cdGlmIChyICYmIHIubGVuZ3RoID4gMSkge1xyXG5cdFx0dmFyIHYgPSB0aGlzLm9iajJzY2FsZWQocltyLmxlbmd0aCAtIDFdKS5hZGQodGhpcy5vZmZzZXQpO1xyXG5cdFx0dmFyIHBzdHIgPSAnTScgKyB0Zngodi54KSArICcsJyArIHRmeCh2LnkpO1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCByLmxlbmd0aDsgKytpKSB7XHJcblx0XHRcdHYgPSB0aGlzLm9iajJzY2FsZWQocltpXSkuYWRkKHRoaXMub2Zmc2V0KTtcclxuXHRcdFx0cHN0ciArPSAnTCcgKyB0Zngodi54KSArICcsJyArIHRmeCh2LnkpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5zZWxlY3Rpb25SZWN0ID0gdGhpcy5wYXBlci5wYXRoKHBzdHIpLmF0dHIoeydzdHJva2UnOidncmF5JywgJ3N0cm9rZS13aWR0aCc6JzFweCd9KTtcclxuXHR9XHJcbn07XHJcblxyXG5ybmQuUmVuZGVyLnByb3RvdHlwZS5pc1BvaW50SW5Qb2x5Z29uID0gZnVuY3Rpb24gKHIsIHApIHtcclxuXHR2YXIgZCA9IG5ldyBWZWMyKDAsIDEpO1xyXG5cdHZhciBuID0gZC5yb3RhdGUoTWF0aC5QSSAvIDIpO1xyXG5cdHZhciB2MCA9IFZlYzIuZGlmZihyW3IubGVuZ3RoIC0gMV0sIHApO1xyXG5cdHZhciBuMCA9IFZlYzIuZG90KG4sIHYwKTtcclxuXHR2YXIgZDAgPSBWZWMyLmRvdChkLCB2MCk7XHJcblx0dmFyIHcwID0gbnVsbDtcclxuXHR2YXIgY291bnRlciA9IDA7XHJcblx0dmFyIGVwcyA9IDFlLTU7XHJcblx0dmFyIGZsYWcxID0gZmFsc2UsIGZsYWcwID0gZmFsc2U7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgci5sZW5ndGg7ICsraSkge1xyXG5cdFx0dmFyIHYxID0gVmVjMi5kaWZmKHJbaV0sIHApO1xyXG5cdFx0dmFyIHcxID0gVmVjMi5kaWZmKHYxLCB2MCk7XHJcblx0XHR2YXIgbjEgPSBWZWMyLmRvdChuLCB2MSk7XHJcblx0XHR2YXIgZDEgPSBWZWMyLmRvdChkLCB2MSk7XHJcblx0XHRmbGFnMSA9IGZhbHNlO1xyXG5cdFx0aWYgKG4xICogbjAgPCAwKVxyXG5cdFx0e1xyXG5cdFx0XHRpZiAoZDEgKiBkMCA+IC1lcHMpIHtcclxuXHRcdFx0XHRpZiAoZDAgPiAtZXBzKVxyXG5cdFx0XHRcdFx0ZmxhZzEgPSB0cnVlO1xyXG5cdFx0XHR9IGVsc2UgaWYgKChNYXRoLmFicyhuMCkgKiBNYXRoLmFicyhkMSkgLSBNYXRoLmFicyhuMSkgKiBNYXRoLmFicyhkMCkpICogZDEgPiAwKSB7XHJcblx0XHRcdFx0ZmxhZzEgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAoZmxhZzEgJiYgZmxhZzAgJiYgVmVjMi5kb3QodzEsIG4pICogVmVjMih3MCwgbikgPj0gMClcclxuXHRcdFx0ZmxhZzEgPSBmYWxzZTtcclxuXHRcdGlmIChmbGFnMSlcclxuXHRcdFx0Y291bnRlcisrO1xyXG5cdFx0djAgPSB2MTtcclxuXHRcdG4wID0gbjE7XHJcblx0XHRkMCA9IGQxO1xyXG5cdFx0dzAgPSB3MTtcclxuXHRcdGZsYWcwID0gZmxhZzE7XHJcblx0fVxyXG5cdHJldHVybiAoY291bnRlciAlIDIpICE9IDA7XHJcbn07XHJcblxyXG5ybmQuUmVuZGVyLnByb3RvdHlwZS5wcyA9IGZ1bmN0aW9uIChwcCkge1xyXG5cdHJldHVybiBwcC5zY2FsZWQodGhpcy5zZXR0aW5ncy5zY2FsZUZhY3Rvcik7XHJcbn07XHJcblxyXG5ybmQuUmVuZGVyLnByb3RvdHlwZS5nZXRFbGVtZW50c0luUG9seWdvbiA9IGZ1bmN0aW9uIChycikge1xyXG5cdHJuZC5sb2dNZXRob2QoJ2dldEVsZW1lbnRzSW5Qb2x5Z29uJyk7XHJcblx0dmFyIGJvbmRMaXN0ID0gW107XHJcblx0dmFyIGF0b21MaXN0ID0gW107XHJcblx0dmFyIHIgPSBbXTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHJyLmxlbmd0aDsgKytpKSB7XHJcblx0XHRyW2ldID0gbmV3IFZlYzIocnJbaV0ueCwgcnJbaV0ueSk7XHJcblx0fVxyXG5cdHRoaXMuY3RhYi5ib25kcy5lYWNoKGZ1bmN0aW9uIChiaWQsIGJvbmQpe1xyXG5cdFx0dmFyIGNlbnRyZSA9IFZlYzIubGMyKHRoaXMuY3RhYi5hdG9tcy5nZXQoYm9uZC5iLmJlZ2luKS5hLnBwLCAwLjUsXHJcblx0XHRcdHRoaXMuY3RhYi5hdG9tcy5nZXQoYm9uZC5iLmVuZCkuYS5wcCwgMC41KTtcclxuXHRcdGlmICh0aGlzLmlzUG9pbnRJblBvbHlnb24ociwgY2VudHJlKSlcclxuXHRcdFx0Ym9uZExpc3QucHVzaChiaWQpO1xyXG5cdH0sIHRoaXMpO1xyXG5cdHRoaXMuY3RhYi5hdG9tcy5lYWNoKGZ1bmN0aW9uIChhaWQsIGF0b20pe1xyXG5cdFx0aWYgKHRoaXMuaXNQb2ludEluUG9seWdvbihyLCBhdG9tLmEucHApKVxyXG5cdFx0XHRhdG9tTGlzdC5wdXNoKGFpZCk7XHJcblx0fSwgdGhpcyk7XHJcblx0dmFyIHJ4bkFycm93c0xpc3QgPSBbXTtcclxuXHR2YXIgcnhuUGx1c2VzTGlzdCA9IFtdO1xyXG5cdHRoaXMuY3RhYi5yeG5BcnJvd3MuZWFjaChmdW5jdGlvbiAoaWQsIGl0ZW0pe1xyXG5cdFx0aWYgKHRoaXMuaXNQb2ludEluUG9seWdvbihyLCBpdGVtLml0ZW0ucHApKVxyXG5cdFx0XHRyeG5BcnJvd3NMaXN0LnB1c2goaWQpO1xyXG5cdH0sIHRoaXMpO1xyXG5cdHRoaXMuY3RhYi5yeG5QbHVzZXMuZWFjaChmdW5jdGlvbiAoaWQsIGl0ZW0pe1xyXG5cdFx0aWYgKHRoaXMuaXNQb2ludEluUG9seWdvbihyLCBpdGVtLml0ZW0ucHApKVxyXG5cdFx0XHRyeG5QbHVzZXNMaXN0LnB1c2goaWQpO1xyXG5cdH0sIHRoaXMpO1xyXG5cdHZhciBjaGlyYWxGbGFnTGlzdCA9IFtdO1xyXG5cdHRoaXMuY3RhYi5jaGlyYWxGbGFncy5lYWNoKGZ1bmN0aW9uIChpZCwgaXRlbSl7XHJcblx0XHRpZiAodGhpcy5pc1BvaW50SW5Qb2x5Z29uKHIsIGl0ZW0ucHApKVxyXG5cdFx0XHRjaGlyYWxGbGFnTGlzdC5wdXNoKGlkKTtcclxuXHR9LCB0aGlzKTtcclxuXHR2YXIgc2dyb3VwRGF0YUxpc3QgPSBbXTtcclxuXHR0aGlzLmN0YWIuc2dyb3VwRGF0YS5lYWNoKGZ1bmN0aW9uIChpZCwgaXRlbSl7XHJcblx0XHRpZiAodGhpcy5pc1BvaW50SW5Qb2x5Z29uKHIsIGl0ZW0uc2dyb3VwLnBwKSlcclxuXHRcdFx0c2dyb3VwRGF0YUxpc3QucHVzaChpZCk7XHJcblx0fSwgdGhpcyk7XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHQnYXRvbXMnOmF0b21MaXN0LFxyXG5cdFx0J2JvbmRzJzpib25kTGlzdCxcclxuXHRcdCdyeG5BcnJvd3MnOnJ4bkFycm93c0xpc3QsXHJcblx0XHQncnhuUGx1c2VzJzpyeG5QbHVzZXNMaXN0LFxyXG5cdFx0J2NoaXJhbEZsYWdzJzpjaGlyYWxGbGFnTGlzdCxcclxuXHRcdCdzZ3JvdXBEYXRhJzpzZ3JvdXBEYXRhTGlzdFxyXG5cdH07XHJcbn07XHJcblxyXG5ybmQuUmVuZGVyLnByb3RvdHlwZS50ZXN0UG9seWdvbiA9IGZ1bmN0aW9uIChycikge1xyXG5cdHJyID0gcnIgfHwgW1xyXG5cdHtcclxuXHRcdHg6NTAsXHJcblx0XHR5OjEwXHJcblx0fSxcclxuXHJcblx0e1xyXG5cdFx0eDoyMCxcclxuXHRcdHk6OTBcclxuXHR9LFxyXG5cclxuXHR7XHJcblx0XHR4OjkwLFxyXG5cdFx0eTozMFxyXG5cdH0sXHJcblxyXG5cdHtcclxuXHRcdHg6MTAsXHJcblx0XHR5OjMwXHJcblx0fSxcclxuXHJcblx0e1xyXG5cdFx0eDo5MCxcclxuXHRcdHk6ODBcclxuXHR9XHJcblx0XHRdO1xyXG5cdGlmIChyci5sZW5ndGggPCAzKVxyXG5cdFx0cmV0dXJuO1xyXG5cdHZhciBtaW4gPSByclswXSwgbWF4ID0gcnJbMF07XHJcblx0Zm9yICh2YXIgaiA9IDE7IGogPCByci5sZW5ndGg7ICsraikge1xyXG5cdFx0bWluID0gVmVjMi5taW4obWluLCBycltqXSk7XHJcblx0XHRtYXggPSBWZWMyLm1heChtYXgsIHJyW2pdKTtcclxuXHR9XHJcblx0dGhpcy5kcmF3U2VsZWN0aW9uUG9seWdvbihycik7XHJcblx0dmFyIHp6ID0gMTA7XHJcblx0Zm9yICh2YXIgayA9IDA7IGsgPCAxMDAwOyArK2spIHtcclxuXHRcdHZhciBwID0gbmV3IFZlYzIoTWF0aC5yYW5kb20oKSAqIHp6LCBNYXRoLnJhbmRvbSgpICogenopO1xyXG5cdFx0dmFyIGlzaW4gPSB0aGlzLmlzUG9pbnRJblBvbHlnb24ocnIsIHApO1xyXG5cdFx0dmFyIGNvbG9yID0gaXNpbiA/ICcjMGYwJyA6ICcjZjAwJztcclxuXHRcdHRoaXMucGFwZXIuY2lyY2xlKHAueCwgcC55LCAyKS5hdHRyKHtcclxuXHRcdFx0J2ZpbGwnOmNvbG9yLFxyXG5cdFx0XHQnc3Ryb2tlJzonbm9uZSdcclxuXHRcdH0pO1xyXG5cdH1cclxuXHR0aGlzLmRyYXdTZWxlY3Rpb25Qb2x5Z29uKHJyKTtcclxufTtcclxuXHJcbnJuZC5SZW5kZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChmb3JjZSlcclxue1xyXG5cdHJuZC5sb2dNZXRob2QoJ3VwZGF0ZScpO1xyXG5cclxuXHRpZiAoIXRoaXMuc2V0dGluZ3MgfHwgdGhpcy5kaXJ0eSkge1xyXG5cdFx0aWYgKHRoaXMub3B0LmF1dG9TY2FsZSkge1xyXG5cdFx0XHR2YXIgY2JiID0gdGhpcy5jdGFiLm1vbGVjdWxlLmdldENvb3JkQm91bmRpbmdCb3goKTtcclxuXHRcdFx0Ly8gdGhpcyBpcyBvbmx5IGFuIGFwcHJveGltYXRpb24gdG8gc2VsZWN0IHNvbWUgc2NhbGUgdGhhdCdzIGNsb3NlIGVub3VnaCB0byB0aGUgdGFyZ2V0IG9uZVxyXG5cdFx0XHR2YXIgc3kgPSBjYmIubWF4LnkgLSBjYmIubWluLnkgPiAwID8gMC44ICogdGhpcy52aWV3U3oueSAvIChjYmIubWF4LnkgLSBjYmIubWluLnkpIDogMTAwO1xyXG5cdFx0XHR2YXIgc3ggPSBjYmIubWF4LnggLSBjYmIubWluLnggPiAwID8gMC44ICogdGhpcy52aWV3U3oueCAvIChjYmIubWF4LnggLSBjYmIubWluLngpIDogMTAwO1xyXG5cdFx0XHR0aGlzLnNjYWxlID0gTWF0aC5taW4oc3ksIHN4KTtcclxuXHRcdFx0aWYgKHRoaXMub3B0Lm1heEJvbmRMZW5ndGggPiAwICYmIHRoaXMuc2NhbGUgPiB0aGlzLm9wdC5tYXhCb25kTGVuZ3RoKVxyXG5cdFx0XHRcdHRoaXMuc2NhbGUgPSB0aGlzLm9wdC5tYXhCb25kTGVuZ3RoO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5pbml0U2V0dGluZ3MoKTtcclxuXHRcdHRoaXMuaW5pdFN0eWxlcygpO1xyXG5cdFx0dGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG5cdFx0Zm9yY2UgPSB0cnVlO1xyXG5cdH1cclxuXHJcblx0dmFyIHN0YXJ0ID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcclxuXHR2YXIgY2hhbmdlcyA9IHRoaXMuY3RhYi51cGRhdGUoZm9yY2UpO1xyXG5cdHRoaXMuc2V0U2VsZWN0aW9uKG51bGwpOyAvLyBbTUtdIHJlZHJhdyB0aGUgc2VsZWN0aW9uIGJpdHMgd2hlcmUgbmVjZXNzYXJ5XHJcblx0dmFyIHRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gc3RhcnQ7XHJcblx0aWYgKGZvcmNlICYmICQoJ2xvZycpKVxyXG5cdFx0JCgnbG9nJykuaW5uZXJIVE1MID0gdGltZS50b1N0cmluZygpICsgJ1xcbic7XHJcblx0aWYgKGNoYW5nZXMpIHtcclxuXHRcdHZhciBzZiA9IHRoaXMuc2V0dGluZ3Muc2NhbGVGYWN0b3I7XHJcblx0XHR2YXIgYmIgPSB0aGlzLmN0YWIuZ2V0VkJveE9iaigpLnRyYW5zZm9ybSh0aGlzLm9iajJzY2FsZWQsIHRoaXMpLnRyYW5zbGF0ZSh0aGlzLm9mZnNldCB8fCBuZXcgVmVjMigpKTtcclxuXHJcblx0XHRpZiAoIXRoaXMub3B0LmF1dG9TY2FsZSkge1xyXG5cdFx0XHR2YXIgZXh0ID0gVmVjMi5VTklULnNjYWxlZChzZik7XHJcblx0XHRcdHZhciBlYiA9IGJiLnN6KCkubGVuZ3RoKCkgPiAwID8gYmIuZXh0ZW5kKGV4dCwgZXh0KSA6IGJiO1xyXG5cdFx0XHQvLyBUaGUgb25seSByZWZlcmVuY2UgdG8gdWkuem9vbVxyXG5cdFx0XHRjb25zb2xlLmFzc2VydCh1aS56b29tID09IHRoaXMuem9vbSk7XHJcblx0XHRcdHZhciB2YiA9IG5ldyBCb3gyQWJzKHVpLnNjcm9sbFBvcygpLCB0aGlzLnZpZXdTei5zY2FsZWQoMSAvIHVpLnpvb20pLnN1YihWZWMyLlVOSVQuc2NhbGVkKDIwKSkpO1xyXG5cdFx0XHR2YXIgY2IgPSBCb3gyQWJzLnVuaW9uKHZiLCBlYik7XHJcblx0XHRcdGlmICghdGhpcy5vbGRDYilcclxuXHRcdFx0XHR0aGlzLm9sZENiID0gbmV3IEJveDJBYnMoKTtcclxuXHJcblx0XHRcdHZhciBzeiA9IGNiLnN6KCkuZmxvb3IoKTtcclxuXHRcdFx0dmFyIGRlbHRhID0gdGhpcy5vbGRDYi5wMC5zdWIoY2IucDApLmNlaWwoKTtcclxuXHRcdFx0dGhpcy5vbGRCYiA9IGJiO1xyXG5cdFx0XHRpZiAoIXRoaXMuc3ogfHwgc3oueCAhPSB0aGlzLnN6LnggfHwgc3oueSAhPSB0aGlzLnN6LnkpXHJcblx0XHRcdFx0dGhpcy5zZXRQYXBlclNpemUoc3opO1xyXG5cclxuXHRcdFx0dGhpcy5vZmZzZXQgPSB0aGlzLm9mZnNldCB8fCBuZXcgVmVjMigpO1xyXG5cdFx0XHRpZiAoZGVsdGEueCAhPSAwIHx8IGRlbHRhLnkgIT0gMCkge1xyXG5cdFx0XHRcdHRoaXMuc2V0T2Zmc2V0KHRoaXMub2Zmc2V0LmFkZChkZWx0YSkpO1xyXG5cdFx0XHRcdHRoaXMuY3RhYi50cmFuc2xhdGUoZGVsdGEpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgc3oxID0gYmIuc3ooKTtcclxuXHRcdFx0dmFyIG1hcmcgPSB0aGlzLm9wdC5hdXRvU2NhbGVNYXJnaW47XHJcblx0XHRcdHZhciBtdiA9IG5ldyBWZWMyKG1hcmcsIG1hcmcpO1xyXG5cdFx0XHR2YXIgY3N6ID0gdGhpcy52aWV3U3o7XHJcblx0XHRcdGlmIChjc3oueCA8IDIgKiBtYXJnICsgMSB8fCBjc3oueSA8IDIgKiBtYXJnICsgMSlcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1ZpZXcgYm94IHRvbyBzbWFsbCBmb3IgdGhlIGdpdmVuIG1hcmdpbicpO1xyXG5cdFx0XHR2YXIgcmVzY2FsZSA9IE1hdGgubWF4KHN6MS54IC8gKGNzei54IC0gMiAqIG1hcmcpLCBzejEueSAvIChjc3oueSAtIDIgKiBtYXJnKSk7XHJcblx0XHRcdGlmICh0aGlzLm9wdC5tYXhCb25kTGVuZ3RoIC8gcmVzY2FsZSA+IDEuMClcclxuXHRcdFx0XHRyZXNjYWxlID0gMS4wO1xyXG5cdFx0XHR2YXIgc3oyID0gc3oxLmFkZChtdi5zY2FsZWQoMiAqIHJlc2NhbGUpKTtcclxuXHRcdFx0dGhpcy5wYXBlci5zZXRWaWV3Qm94KGJiLnBvcygpLnggLSBtYXJnICogcmVzY2FsZSAtIChjc3oueCAqIHJlc2NhbGUgLSBzejIueCkgLyAyLCBiYi5wb3MoKS55IC0gbWFyZyAqIHJlc2NhbGUgLSAoY3N6LnkgKiByZXNjYWxlIC0gc3oyLnkpIC8gMiwgY3N6LnggKiByZXNjYWxlLCBjc3oueSAqIHJlc2NhbGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbnJuZC5SZW5kZXIucHJvdG90eXBlLmNoZWNrQm9uZEV4aXN0cyA9IGZ1bmN0aW9uIChiZWdpbiwgZW5kKSB7XHJcblx0cmV0dXJuIHRoaXMuY3RhYi5tb2xlY3VsZS5jaGVja0JvbmRFeGlzdHMoYmVnaW4sIGVuZCk7XHJcbn07XHJcblxyXG52YXIgZmluZENsb3Nlc3RDaGlyYWxGbGFnID0gZnVuY3Rpb24gKHJlbmRlciwgcCkge1xyXG4gICAgdmFyIG1pbkRpc3Q7XHJcbiAgICB2YXIgcmV0O1xyXG4gICAgXHJcbiAgICAvLyB0aGVyZSBpcyBvbmx5IG9uZSBjaGlyYWwgZmxhZywgYnV0IHdlIHRyZWF0IGl0IGFzIGEgXCJtYXBcIiBmb3IgY29udmVuaWVuY2VcclxuICAgIHJlbmRlci5jdGFiLmNoaXJhbEZsYWdzLmVhY2goZnVuY3Rpb24gKGlkLCBpdGVtKSB7XHJcbiAgICAgICAgdmFyIHBvcyA9IGl0ZW0ucHA7XHJcbiAgICAgICAgaWYgKE1hdGguYWJzKHAueCAtIHBvcy54KSA8IDEuMCkge1xyXG4gICAgICAgICAgICB2YXIgZGlzdCA9IE1hdGguYWJzKHAueSAtIHBvcy55KTtcclxuICAgICAgICAgICAgaWYgKGRpc3QgPCAwLjMgJiYgKCFyZXQgfHwgZGlzdCA8IG1pbkRpc3QpKSB7XHJcbiAgICAgICAgICAgICAgICBtaW5EaXN0ID0gZGlzdDtcclxuICAgICAgICAgICAgICAgIHJldCA9IHsgJ2lkJzogaWQsICdkaXN0JzogbWluRGlzdCB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmV0O1xyXG59O1xyXG5cclxudmFyIGZpbmRDbG9zZXN0U0dyb3VwID0gZnVuY3Rpb24gKHJlbmRlciwgcCkge1xyXG4gICAgdmFyIHJldCA9IG51bGw7XHJcbiAgICB2YXIgbWluRGlzdCA9IHJlbmRlci5vcHQuc2VsZWN0aW9uRGlzdGFuY2VDb2VmZmljaWVudDtcclxuICAgIHJlbmRlci5jdGFiLm1vbGVjdWxlLnNncm91cHMuZWFjaChmdW5jdGlvbiAoc2dpZCwgc2cpIHtcclxuICAgICAgICB2YXIgZCA9IHNnLmJyYWNrZXREaXIsIG4gPSBkLnJvdGF0ZVNDKDEsIDApO1xyXG4gICAgICAgIHZhciBwZyA9IG5ldyBWZWMyKFZlYzIuZG90KHAsIGQpLCBWZWMyLmRvdChwLCBuKSk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZy5hcmVhcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgYm94ID0gc2cuYXJlYXNbaV07XHJcbiAgICAgICAgICAgIHZhciBpbkJveCA9IGJveC5wMC55IDwgcGcueSAmJiBib3gucDEueSA+IHBnLnkgJiYgYm94LnAwLnggPCBwZy54ICYmIGJveC5wMS54ID4gcGcueDtcclxuICAgICAgICAgICAgdmFyIHhEaXN0ID0gTWF0aC5taW4oTWF0aC5hYnMoYm94LnAwLnggLSBwZy54KSwgTWF0aC5hYnMoYm94LnAxLnggLSBwZy54KSk7XHJcbiAgICAgICAgICAgIGlmIChpbkJveCAmJiAocmV0ID09IG51bGwgfHwgeERpc3QgPCBtaW5EaXN0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0ID0gc2dpZDtcclxuICAgICAgICAgICAgICAgIG1pbkRpc3QgPSB4RGlzdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIHRoaXMpO1xyXG4gICAgaWYgKHJldCAhPSBudWxsKVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICdpZCc6IHJldCxcclxuICAgICAgICAgICAgJ2Rpc3QnOiBtaW5EaXN0XHJcbiAgICAgICAgfTtcclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxudmFyIGZpbmRDbG9zZXN0UnhuQXJyb3cgPSBmdW5jdGlvbiAocmVuZGVyLCBwKSB7XHJcbiAgICB2YXIgbWluRGlzdDtcclxuICAgIHZhciByZXQ7XHJcbiAgICBcclxuICAgIHJlbmRlci5jdGFiLnJ4bkFycm93cy5lYWNoKGZ1bmN0aW9uIChpZCwgYXJyb3cpIHtcclxuICAgICAgICB2YXIgcG9zID0gYXJyb3cuaXRlbS5wcDtcclxuICAgICAgICBpZiAoTWF0aC5hYnMocC54IC0gcG9zLngpIDwgMS4wKSB7XHJcbiAgICAgICAgICAgIHZhciBkaXN0ID0gTWF0aC5hYnMocC55IC0gcG9zLnkpO1xyXG4gICAgICAgICAgICBpZiAoZGlzdCA8IDAuMyAmJiAoIXJldCB8fCBkaXN0IDwgbWluRGlzdCkpIHtcclxuICAgICAgICAgICAgICAgIG1pbkRpc3QgPSBkaXN0O1xyXG4gICAgICAgICAgICAgICAgcmV0ID0geyAnaWQnOiBpZCwgJ2Rpc3QnOiBtaW5EaXN0IH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXQ7XHJcbn07XHJcblxyXG52YXIgZmluZENsb3Nlc3RTR3JvdXBEYXRhID0gZnVuY3Rpb24gKHJlbmRlciwgcCkge1xyXG4gICAgdmFyIG1pbkRpc3QgPSBudWxsO1xyXG4gICAgdmFyIHJldCA9IG51bGw7XHJcbiAgICBcclxuICAgIHJlbmRlci5jdGFiLnNncm91cERhdGEuZWFjaChmdW5jdGlvbiAoaWQsIGl0ZW0pIHtcclxuICAgICAgICBpZiAoaXRlbS5zZ3JvdXAudHlwZSAhPSAnREFUJylcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIGdyb3VwIGV4cGVjdGVkJyk7XHJcbiAgICAgICAgdmFyIGJveCA9IGl0ZW0uc2dyb3VwLmRhdGFBcmVhO1xyXG4gICAgICAgIHZhciBpbkJveCA9IGJveC5wMC55IDwgcC55ICYmIGJveC5wMS55ID4gcC55ICYmIGJveC5wMC54IDwgcC54ICYmIGJveC5wMS54ID4gcC54O1xyXG4gICAgICAgIHZhciB4RGlzdCA9IE1hdGgubWluKE1hdGguYWJzKGJveC5wMC54IC0gcC54KSwgTWF0aC5hYnMoYm94LnAxLnggLSBwLngpKTtcclxuICAgICAgICBpZiAoaW5Cb3ggJiYgKHJldCA9PSBudWxsIHx8IHhEaXN0IDwgbWluRGlzdCkpIHtcclxuICAgICAgICAgICAgcmV0ID0geyAnaWQnOiBpZCwgJ2Rpc3QnOiB4RGlzdCB9O1xyXG4gICAgICAgICAgICBtaW5EaXN0ID0geERpc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmV0O1xyXG59O1xyXG5cclxuXHJcbnZhciBmaW5kQ2xvc2VzdFJ4blBsdXMgPSBmdW5jdGlvbiAocmVuZGVyLCBwKSB7XHJcbiAgICB2YXIgbWluRGlzdDtcclxuICAgIHZhciByZXQ7XHJcbiAgICBcclxuICAgIHJlbmRlci5jdGFiLnJ4blBsdXNlcy5lYWNoKGZ1bmN0aW9uIChpZCwgcGx1cykge1xyXG4gICAgICAgIHZhciBwb3MgPSBwbHVzLml0ZW0ucHA7XHJcbiAgICAgICAgdmFyIGRpc3QgPSBNYXRoLm1heChNYXRoLmFicyhwLnggLSBwb3MueCksIE1hdGguYWJzKHAueSAtIHBvcy55KSk7XHJcbiAgICAgICAgaWYgKGRpc3QgPCAwLjUgJiYgKCFyZXQgfHwgZGlzdCA8IG1pbkRpc3QpKSB7XHJcbiAgICAgICAgICAgIG1pbkRpc3QgPSBkaXN0O1xyXG4gICAgICAgICAgICByZXQgPSB7ICdpZCc6IGlkLCAnZGlzdCc6IG1pbkRpc3QgfTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXQ7XHJcbn07XHJcbnZhciBmaW5kQ2xvc2VzdEZyYWcgPSBmdW5jdGlvbiAocmVuZGVyLCBwLCBza2lwLCBtaW5EaXN0KSB7XHJcbiAgICBtaW5EaXN0ID0gTWF0aC5taW4obWluRGlzdCB8fCByZW5kZXIub3B0LnNlbGVjdGlvbkRpc3RhbmNlQ29lZmZpY2llbnQsIHJlbmRlci5vcHQuc2VsZWN0aW9uRGlzdGFuY2VDb2VmZmljaWVudCk7XHJcbiAgICB2YXIgcmV0O1xyXG4gICAgcmVuZGVyLmN0YWIuZnJhZ3MuZWFjaChmdW5jdGlvbiAoZmlkLCBmcmFnKSB7XHJcbiAgICAgICAgaWYgKGZpZCAhPSBza2lwKSB7XHJcbiAgICAgICAgICAgIHZhciBiYiA9IGZyYWcuY2FsY0JCb3gocmVuZGVyLCBmaWQpOyAvLyBUT0RPIGFueSBmYXN0ZXIgd2F5IHRvIG9idGFpbiBiYj9cclxuICAgICAgICAgICAgaWYgKGJiLnAwLnkgPCBwLnkgJiYgYmIucDEueSA+IHAueSAmJiBiYi5wMC54IDwgcC54ICYmIGJiLnAxLnggPiBwLngpIHtcclxuICAgICAgICAgICAgICAgIHZhciB4RGlzdCA9IE1hdGgubWluKE1hdGguYWJzKGJiLnAwLnggLSBwLngpLCBNYXRoLmFicyhiYi5wMS54IC0gcC54KSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJldCB8fCB4RGlzdCA8IG1pbkRpc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW5EaXN0ID0geERpc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0geyAnaWQnOiBmaWQsICdkaXN0JzogbWluRGlzdCB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmV0O1xyXG59O1xyXG5cclxudmFyIGZpbmRDbG9zZXN0Ukdyb3VwID0gZnVuY3Rpb24gKHJlbmRlciwgcCwgc2tpcCwgbWluRGlzdCkge1xyXG4gICAgbWluRGlzdCA9IE1hdGgubWluKG1pbkRpc3QgfHwgcmVuZGVyLm9wdC5zZWxlY3Rpb25EaXN0YW5jZUNvZWZmaWNpZW50LCByZW5kZXIub3B0LnNlbGVjdGlvbkRpc3RhbmNlQ29lZmZpY2llbnQpO1xyXG4gICAgdmFyIHJldDtcclxuICAgIHJlbmRlci5jdGFiLnJncm91cHMuZWFjaChmdW5jdGlvbiAocmdpZCwgcmdyb3VwKSB7XHJcbiAgICAgICAgaWYgKHJnaWQgIT0gc2tpcCkge1xyXG4gICAgICAgICAgICBpZiAocmdyb3VwLmxhYmVsQm94KSB7IC8vIHNob3VsZCBiZSB0cnVlIGF0IHRoaXMgc3RhZ2UsIGFzIHRoZSBsYWJlbCBpcyB2aXNpYmxlXHJcbiAgICAgICAgICAgICAgICBpZiAocmdyb3VwLmxhYmVsQm94LmNvbnRhaW5zKHAsIDAuNSkpIHsgLy8gaW5zaWRlIHRoZSBib3ggb3Igd2l0aGluIDAuNSB1bml0cyBmcm9tIHRoZSBlZGdlXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3QgPSBWZWMyLmRpc3Qocmdyb3VwLmxhYmVsQm94LmNlbnRyZSgpLCBwKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJldCB8fCBkaXN0IDwgbWluRGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5EaXN0ID0gZGlzdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0geyAnaWQnOiByZ2lkLCAnZGlzdCc6IG1pbkRpc3QgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXQ7XHJcbn07XHJcblxyXG5ybmQuUmVuZGVyLnByb3RvdHlwZS5maW5kQ2xvc2VzdEF0b20gPSBmdW5jdGlvbiAocG9zLCBtaW5EaXN0LCBza2lwKSB7IC8vIFRPRE8gc2hvdWxkIGJlIGEgbWVtYmVyIG9mIFJlQXRvbSAoc2VlIFJlRnJhZylcclxuXHR2YXIgY2xvc2VzdEF0b20gPSBudWxsO1xyXG5cdHZhciBtYXhNaW5EaXN0ID0gdGhpcy5vcHQuc2VsZWN0aW9uRGlzdGFuY2VDb2VmZmljaWVudDtcclxuXHRtaW5EaXN0ID0gbWluRGlzdCB8fCBtYXhNaW5EaXN0O1xyXG5cdG1pbkRpc3RcdCA9IE1hdGgubWluKG1pbkRpc3QsIG1heE1pbkRpc3QpO1xyXG5cdHRoaXMuY3RhYi5hdG9tcy5lYWNoKGZ1bmN0aW9uIChhaWQsIGF0b20pe1xyXG5cdFx0aWYgKGFpZCAhPSBza2lwKSB7XHJcblx0XHRcdHZhciBkaXN0ID0gVmVjMi5kaXN0KHBvcywgYXRvbS5hLnBwKTtcclxuXHRcdFx0aWYgKGRpc3QgPCBtaW5EaXN0KSB7XHJcblx0XHRcdFx0Y2xvc2VzdEF0b20gPSBhaWQ7XHJcblx0XHRcdFx0bWluRGlzdCA9IGRpc3Q7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LCB0aGlzKTtcclxuXHRpZiAoY2xvc2VzdEF0b20gIT0gbnVsbClcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdCdpZCc6Y2xvc2VzdEF0b20sXHJcblx0XHRcdCdkaXN0JzptaW5EaXN0XHJcblx0XHR9O1xyXG5cdHJldHVybiBudWxsO1xyXG59O1xyXG5cclxudmFyIGZpbmRDbG9zZXN0Qm9uZCA9IGZ1bmN0aW9uIChyZW5kZXIsIHBvcywgbWluRGlzdCkgeyAvLyBUT0RPIHNob3VsZCBiZSBhIG1lbWJlciBvZiBSZUJvbmQgKHNlZSBSZUZyYWcpXHJcblx0dmFyIGNsb3Nlc3RCb25kID0gbnVsbDtcclxuXHR2YXIgY2xvc2VzdEJvbmRDZW50ZXIgPSBudWxsO1xyXG5cdHZhciBtYXhNaW5EaXN0ID0gcmVuZGVyLm9wdC5zZWxlY3Rpb25EaXN0YW5jZUNvZWZmaWNpZW50O1xyXG5cdG1pbkRpc3QgPSBtaW5EaXN0IHx8IG1heE1pbkRpc3Q7XHJcblx0bWluRGlzdCA9IE1hdGgubWluKG1pbkRpc3QsIG1heE1pbkRpc3QpO1xyXG5cdHZhciBtaW5DRGlzdCA9IG1pbkRpc3Q7XHJcbiAgICByZW5kZXIuY3RhYi5ib25kcy5lYWNoKGZ1bmN0aW9uIChiaWQsIGJvbmQpe1xyXG5cdFx0dmFyIHAxID0gcmVuZGVyLmN0YWIuYXRvbXMuZ2V0KGJvbmQuYi5iZWdpbikuYS5wcCxcclxuXHRcdHAyID0gcmVuZGVyLmN0YWIuYXRvbXMuZ2V0KGJvbmQuYi5lbmQpLmEucHA7XHJcblx0XHR2YXIgbWlkID0gVmVjMi5sYzIocDEsIDAuNSwgcDIsIDAuNSk7XHJcblx0XHR2YXIgY2Rpc3QgPSBWZWMyLmRpc3QocG9zLCBtaWQpO1xyXG5cdFx0aWYgKGNkaXN0IDwgbWluQ0Rpc3QpIHtcclxuXHRcdFx0bWluQ0Rpc3QgPSBjZGlzdDtcclxuXHRcdFx0Y2xvc2VzdEJvbmRDZW50ZXIgPSBiaWQ7XHJcblx0XHR9XHJcblx0fSwgcmVuZGVyKTtcclxuICAgIHJlbmRlci5jdGFiLmJvbmRzLmVhY2goZnVuY3Rpb24gKGJpZCwgYm9uZCl7XHJcblx0XHR2YXIgaGIgPSByZW5kZXIuY3RhYi5tb2xlY3VsZS5oYWxmQm9uZHMuZ2V0KGJvbmQuYi5oYjEpO1xyXG5cdFx0dmFyIGQgPSBoYi5kaXI7XHJcblx0XHR2YXIgbiA9IGhiLm5vcm07XHJcblx0XHR2YXIgcDEgPSByZW5kZXIuY3RhYi5hdG9tcy5nZXQoYm9uZC5iLmJlZ2luKS5hLnBwLFxyXG5cdFx0cDIgPSByZW5kZXIuY3RhYi5hdG9tcy5nZXQoYm9uZC5iLmVuZCkuYS5wcDtcclxuXHJcblx0XHR2YXIgaW5TdHJpcGUgPSBWZWMyLmRvdChwb3Muc3ViKHAxKSxkKSAqIFZlYzIuZG90KHBvcy5zdWIocDIpLGQpIDwgMDtcclxuXHRcdGlmIChpblN0cmlwZSkge1xyXG5cdFx0XHR2YXIgZGlzdCA9IE1hdGguYWJzKFZlYzIuZG90KHBvcy5zdWIocDEpLG4pKTtcclxuXHRcdFx0aWYgKGRpc3QgPCBtaW5EaXN0KSB7XHJcblx0XHRcdFx0Y2xvc2VzdEJvbmQgPSBiaWQ7XHJcblx0XHRcdFx0bWluRGlzdCA9IGRpc3Q7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LCByZW5kZXIpO1xyXG5cdGlmIChjbG9zZXN0Qm9uZCAhPT0gbnVsbCB8fCBjbG9zZXN0Qm9uZENlbnRlciAhPT0gbnVsbClcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdCdpZCc6IGNsb3Nlc3RCb25kLFxyXG5cdFx0XHQnZGlzdCc6IG1pbkRpc3QsXHJcblx0XHRcdCdjaWQnOiBjbG9zZXN0Qm9uZENlbnRlcixcclxuXHRcdFx0J2NkaXN0JzogbWluQ0Rpc3RcclxuXHRcdH07XHJcblx0cmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG5ybmQuUmVuZGVyLnByb3RvdHlwZS5maW5kQ2xvc2VzdEl0ZW0gPSBmdW5jdGlvbiAocG9zLCBtYXBzLCBza2lwKSB7XHJcblx0dmFyIHJldCA9IG51bGw7XHJcblx0dmFyIHVwZHJldCA9IGZ1bmN0aW9uICh0eXBlLCBpdGVtLCBmb3JjZSkge1xyXG5cdFx0aWYgKGl0ZW0gIT0gbnVsbCAmJiAocmV0ID09IG51bGwgfHwgcmV0LmRpc3QgPiBpdGVtLmRpc3QgfHwgZm9yY2UpKSB7XHJcblx0XHRcdHJldCA9IHtcclxuXHRcdFx0XHQndHlwZSc6dHlwZSxcclxuXHRcdFx0XHQnaWQnOml0ZW0uaWQsXHJcblx0XHRcdFx0J2Rpc3QnOml0ZW0uZGlzdFxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8vIFRPRE8gbWFrZSBpdCBcIm1hcC1pbmRlcGVuZGVudFwiLCBlYWNoIG9iamVjdCBzaG91bGQgYmUgYWJsZSB0byBcInJlcG9ydFwiIGl0cyBkaXN0YW5jZSB0byBwb2ludCAoc29tZXRoaW5nIGxpa2UgUmVBdG9tLmRpc3QocG9pbnQpKVxyXG5cdGlmICghbWFwcyB8fCBtYXBzLmluZGV4T2YoJ2F0b21zJykgPj0gMCkge1xyXG5cdFx0dmFyIGF0b20gPSB0aGlzLmZpbmRDbG9zZXN0QXRvbShcclxuXHRcdFx0cG9zLCB1bmRlZmluZWQsICFPYmplY3QuaXNVbmRlZmluZWQoc2tpcCkgJiYgc2tpcC5tYXAgPT0gJ2F0b21zJyA/IHNraXAuaWQgOiB1bmRlZmluZWRcclxuXHRcdCk7XHJcblx0XHR1cGRyZXQoJ0F0b20nLCBhdG9tKTtcclxuXHR9XHJcblx0aWYgKCFtYXBzIHx8IG1hcHMuaW5kZXhPZignYm9uZHMnKSA+PSAwKSB7XHJcblx0XHR2YXIgYm9uZCA9IGZpbmRDbG9zZXN0Qm9uZCh0aGlzLCBwb3MpO1xyXG5cdFx0aWYgKGJvbmQpIHtcclxuXHRcdFx0aWYgKGJvbmQuY2lkICE9PSBudWxsKVxyXG5cdFx0XHRcdHVwZHJldCgnQm9uZCcsIHsnaWQnOiBib25kLmNpZCwgJ2Rpc3QnOiBib25kLmNkaXN0fSk7XHJcblx0XHRcdGlmIChyZXQgPT0gbnVsbCB8fCByZXQuZGlzdCA+IDAuNCAqIHRoaXMuc2NhbGUpIC8vIGhhY2tcclxuXHRcdFx0XHR1cGRyZXQoJ0JvbmQnLCBib25kKTtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKCFtYXBzIHx8IG1hcHMuaW5kZXhPZignY2hpcmFsRmxhZ3MnKSA+PSAwKSB7XHJcblx0XHR2YXIgZmxhZyA9IGZpbmRDbG9zZXN0Q2hpcmFsRmxhZyh0aGlzLCBwb3MpO1xyXG5cdFx0dXBkcmV0KCdDaGlyYWxGbGFnJywgZmxhZyk7IC8vIFtNS10gVE9ETzogcmVwbGFjZSB0aGlzIHdpdGggbWFwIG5hbWUsICdDaGlyYWxGbGFnJyAtPiAnY2hpcmFsRmxhZ3MnLCB0byBhdm9pZCB0aGUgZXh0cmEgbWFwcGluZyBcImlmIChjaS50eXBlID09ICdDaGlyYWxGbGFnJykgY2kubWFwID0gJ2NoaXJhbEZsYWdzJztcIlxyXG5cdH1cclxuXHRpZiAoIW1hcHMgfHwgbWFwcy5pbmRleE9mKCdzZ3JvdXBEYXRhJykgPj0gMCkge1xyXG5cdFx0dmFyIHNnZCA9IGZpbmRDbG9zZXN0U0dyb3VwRGF0YSh0aGlzLCBwb3MpO1xyXG5cdFx0dXBkcmV0KCdEYXRhU0dyb3VwRGF0YScsIHNnZCk7XHJcblx0fVxyXG5cdGlmICghbWFwcyB8fCBtYXBzLmluZGV4T2YoJ3Nncm91cHMnKSA+PSAwKSB7XHJcblx0XHR2YXIgc2cgPSBmaW5kQ2xvc2VzdFNHcm91cCh0aGlzLCBwb3MpO1xyXG5cdFx0dXBkcmV0KCdTR3JvdXAnLCBzZyk7XHJcblx0fVxyXG5cdGlmICghbWFwcyB8fCBtYXBzLmluZGV4T2YoJ3J4bkFycm93cycpID49IDApIHtcclxuXHRcdHZhciBhcnJvdyA9IGZpbmRDbG9zZXN0UnhuQXJyb3codGhpcywgcG9zKTtcclxuXHRcdHVwZHJldCgnUnhuQXJyb3cnLGFycm93KTtcclxuXHR9XHJcblx0aWYgKCFtYXBzIHx8IG1hcHMuaW5kZXhPZigncnhuUGx1c2VzJykgPj0gMCkge1xyXG5cdFx0dmFyIHBsdXMgPSBmaW5kQ2xvc2VzdFJ4blBsdXModGhpcywgcG9zKTtcclxuXHRcdHVwZHJldCgnUnhuUGx1cycscGx1cyk7XHJcblx0fVxyXG5cdGlmICghbWFwcyB8fCBtYXBzLmluZGV4T2YoJ2ZyYWdzJykgPj0gMCkge1xyXG5cdFx0dmFyIGZyYWcgPSBmaW5kQ2xvc2VzdEZyYWcodGhpcywgcG9zLCBza2lwICYmIHNraXAubWFwID09ICdhdG9tcycgPyBza2lwLmlkIDogdW5kZWZpbmVkKTtcclxuXHRcdHVwZHJldCgnRnJhZ21lbnQnLCBmcmFnKTtcclxuXHR9XHJcblx0aWYgKCFtYXBzIHx8IG1hcHMuaW5kZXhPZigncmdyb3VwcycpID49IDApIHtcclxuXHRcdHZhciByZ3JvdXAgPSBmaW5kQ2xvc2VzdFJHcm91cCh0aGlzLCBwb3MpO1xyXG5cdFx0dXBkcmV0KCdSR3JvdXAnLCByZ3JvdXApO1xyXG5cdH1cclxuXHJcblx0cmV0ID0gcmV0IHx8IHtcclxuXHRcdCd0eXBlJzonQ2FudmFzJyxcclxuXHRcdCdpZCc6LTFcclxuXHRcdH07XHJcblx0cmV0dXJuIHJldDtcclxufTtcclxuXHJcbnJuZC5SZW5kZXIucHJvdG90eXBlLnNldFpvb20gPSBmdW5jdGlvbiAoem9vbSkge1xyXG5cdHRoaXMuem9vbSA9IHpvb207XHJcblx0dGhpcy5fc2V0UGFwZXJTaXplKHRoaXMuc3opO1xyXG59O1xyXG5cclxucm5kLlJlbmRlci5wcm90b3R5cGUuZXh0ZW5kQ2FudmFzID0gZnVuY3Rpb24gKHgwLCB5MCwgeDEsIHkxKSB7XHJcblx0dmFyIGV4ID0gMCwgZXkgPSAwLCBkeCA9IDAsIGR5ID0gMDtcclxuXHR4MCA9IHgwIC0gMDtcclxuXHR4MSA9IHgxIC0gMDtcclxuXHR5MCA9IHkwIC0gMDtcclxuXHR5MSA9IHkxIC0gMDtcclxuXHJcblx0aWYgKHgwIDwgMCkge1xyXG5cdFx0ZXggKz0gLXgwO1xyXG5cdFx0ZHggKz0gLXgwO1xyXG5cdH1cclxuXHRpZiAoeTAgPCAwKSB7XHJcblx0XHRleSArPSAteTA7XHJcblx0XHRkeSArPSAteTA7XHJcblx0fVxyXG5cclxuXHR2YXIgc3p4ID0gdGhpcy5zei54ICogdGhpcy56b29tLCBzenkgPSB0aGlzLnN6LnkgKiB0aGlzLnpvb207XHJcblx0aWYgKHN6eCA8IHgxKSB7XHJcblx0XHRleCArPSB4MSAtIHN6eDtcclxuXHR9XHJcblx0aWYgKHN6eSA8IHkxKSB7XHJcblx0XHRleSArPSB5MSAtIHN6eTtcclxuXHR9XHJcblxyXG5cdHZhciBkID0gbmV3IFZlYzIoZHgsIGR5KS5zY2FsZWQoMSAvIHRoaXMuem9vbSk7XHJcblx0aWYgKGV5ID4gMCB8fCBleCA+IDApIHtcclxuXHRcdHZhciBlID0gbmV3IFZlYzIoZXgsIGV5KS5zY2FsZWQoMSAvIHRoaXMuem9vbSk7XHJcblx0XHR2YXIgc3ogPSB0aGlzLnN6LmFkZChlKTtcclxuXHJcblx0XHR0aGlzLnNldFBhcGVyU2l6ZShzeik7XHJcblx0XHRpZiAoZC54ID4gMCB8fCBkLnkgPiAwKSB7XHJcblx0XHRcdHRoaXMuY3RhYi50cmFuc2xhdGUoZCk7XHJcblx0XHRcdHRoaXMuc2V0T2Zmc2V0KHRoaXMub2Zmc2V0LmFkZChkKSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBkO1xyXG59O1xyXG5cclxucm5kLlJlbmRlci5wcm90b3R5cGUuc2V0U2NhbGUgPSBmdW5jdGlvbiAoeikge1xyXG5cdGlmICh0aGlzLm9mZnNldClcclxuXHRcdHRoaXMub2Zmc2V0ID0gdGhpcy5vZmZzZXQuc2NhbGVkKDEgLyB6KS5zY2FsZWQodGhpcy56b29tKTtcclxuXHR0aGlzLnNjYWxlID0gdGhpcy5iYXNlU2NhbGUgKiB0aGlzLnpvb207XHJcblx0dGhpcy5zZXR0aW5ncyA9IG51bGw7XHJcblx0dGhpcy51cGRhdGUodHJ1ZSk7XHJcbn07XHJcblxyXG5ybmQuUmVuZGVyLnByb3RvdHlwZS5zZXRWaWV3Qm94ID0gZnVuY3Rpb24gKHopIHtcclxuXHRpZiAoIXRoaXMudXNlT2xkWm9vbSlcclxuXHRcdHRoaXMucGFwZXIuY2FudmFzLnNldEF0dHJpYnV0ZSgndmlld0JveCcsICcwIDAgJyArIHRoaXMuc3oueCArICcgJyArIHRoaXMuc3oueSk7XHJcblx0ZWxzZVxyXG5cdFx0dGhpcy5zZXRTY2FsZSh6KTtcclxufTtcclxuIiwiLy8gUmVTdHJ1Y3QgaXMgdG8gc3RvcmUgYWxsIHRoZSBhdXhpbGlhcnkgaW5mb3JtYXRpb24gZm9yXHJcbi8vIFN0cnVjdCB3aGlsZSByZW5kZXJpbmdcclxudmFyIEJveDJBYnMgPSByZXF1aXJlKCcuLi91dGlsL2JveDJhYnMnKTtcclxudmFyIE1hcCA9IHJlcXVpcmUoJy4uL3V0aWwvbWFwJyk7XHJcbnZhciBQb29sID0gcmVxdWlyZSgnLi4vdXRpbC9wb29sJyk7XHJcbnZhciBTZXQgPSByZXF1aXJlKCcuLi91dGlsL3NldCcpO1xyXG52YXIgVmVjMiA9IHJlcXVpcmUoJy4uL3V0aWwvdmVjMicpO1xyXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcclxuXHJcbnZhciBlbGVtZW50ID0gcmVxdWlyZSgnLi4vY2hlbS9lbGVtZW50Jyk7XHJcbnZhciBTdHJ1Y3QgPSByZXF1aXJlKCcuLi9jaGVtL3N0cnVjdCcpO1xyXG52YXIgU0dyb3VwID0gcmVxdWlyZSgnLi4vY2hlbS9zZ3JvdXAnKTtcclxudmFyIEJvbmQgPSByZXF1aXJlKCcuLi9jaGVtL2JvbmQnKTtcclxuXHJcbnZhciBWaXNlbCA9IHJlcXVpcmUoJy4vdmlzZWwnKTtcclxuXHJcbnZhciBybmQgPSBnbG9iYWwucm5kID0gZ2xvYmFsLnJuZCB8fCB7fTtcclxudmFyIHRmeCA9IHV0aWwudGZ4O1xyXG5cclxucm5kLlJlT2JqZWN0ID0gZnVuY3Rpb24gKCkgIC8vIFRPRE8gPz8/IHNob3VsZCBpdCBiZSBpbiBSZVN0cnVjdCBuYW1lc3BhY2Vcclxue1xyXG5cdHRoaXMuX19leHQgPSBuZXcgVmVjMigwLjA1ICogMywgMC4wNSAqIDMpO1xyXG59O1xyXG5cclxucm5kLlJlT2JqZWN0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKHZpc2VsVHlwZSlcclxue1xyXG5cdHRoaXMudmlzZWwgPSBuZXcgVmlzZWwodmlzZWxUeXBlKTtcclxuXHJcblx0dGhpcy5oaWdobGlnaHQgPSBmYWxzZTtcclxuXHR0aGlzLmhpZ2hsaWdodGluZyA9IG51bGw7XHJcblx0dGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xyXG5cdHRoaXMuc2VsZWN0aW9uUGxhdGUgPSBudWxsO1xyXG59O1xyXG5cclxuLy8gcmV0dXJucyB0aGUgYm91bmRpbmcgYm94IG9mIGEgUmVPYmplY3QgaW4gdGhlIG9iamVjdCBjb29yZGluYXRlc1xyXG5ybmQuUmVPYmplY3QucHJvdG90eXBlLmdldFZCb3hPYmogPSBmdW5jdGlvbiAocmVuZGVyKSB7XHJcblx0dmFyIHZib3ggPSB0aGlzLnZpc2VsLmJvdW5kaW5nQm94O1xyXG5cdGlmICh1dGlsLmlzTnVsbCh2Ym94KSlcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdGlmIChyZW5kZXIub2Zmc2V0KVxyXG5cdFx0dmJveCA9IHZib3gudHJhbnNsYXRlKHJlbmRlci5vZmZzZXQubmVnYXRlZCgpKTtcclxuXHRyZXR1cm4gdmJveC50cmFuc2Zvcm0ocmVuZGVyLnNjYWxlZDJvYmosIHJlbmRlcik7XHJcbn07XHJcblxyXG5ybmQuUmVPYmplY3QucHJvdG90eXBlLmRyYXdIaWdobGlnaHQgPSBmdW5jdGlvbiAocmVuZGVyKSB7XHJcblx0Y29uc29sZS5sb2coJ1JlT2JqZWN0LmRyYXdIaWdobGlnaHQgaXMgbm90IG92ZXJyaWRkZW4nKTtcclxufTtcclxuXHJcbnJuZC5SZU9iamVjdC5wcm90b3R5cGUuc2V0SGlnaGxpZ2h0ID0gZnVuY3Rpb24gKGhpZ2hMaWdodCwgcmVuZGVyKSB7IC8vIFRPRE8gcmVuZGVyIHNob3VsZCBiZSBmaWVsZFxyXG5cdGlmIChoaWdoTGlnaHQpIHtcclxuXHRcdHZhciBub3JlZHJhdyA9ICdoaWdobGlnaHRpbmcnIGluIHRoaXMgJiYgdGhpcy5oaWdobGlnaHRpbmcgIT0gbnVsbDsvLyAmJiAhdGhpcy5oaWdobGlnaHRpbmcucmVtb3ZlZDtcclxuXHRcdGlmIChub3JlZHJhdykge1xyXG5cdFx0XHRpZiAodGhpcy5oaWdobGlnaHRpbmcudHlwZSA9PSAnc2V0Jykge1xyXG5cdFx0XHRcdG5vcmVkcmF3ID0gIXRoaXMuaGlnaGxpZ2h0aW5nWzBdLnJlbW92ZWQ7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bm9yZWRyYXcgPSAhdGhpcy5oaWdobGlnaHRpbmcucmVtb3ZlZDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Ly8gcmJhbGFiYW5vdjogaGVyZSBpcyB0ZW1wb3JhcnkgZml4IGZvciBcImRyYWcgaXNzdWVcIiBvbiBpUGFkXHJcblx0XHQvL0JFR0lOXHJcblx0XHRub3JlZHJhdyA9IG5vcmVkcmF3ICYmICghKCdoaWRkZW5QYXRocycgaW4gcm5kLlJlU3RydWN0LnByb3RvdHlwZSkgfHwgcm5kLlJlU3RydWN0LnByb3RvdHlwZS5oaWRkZW5QYXRocy5pbmRleE9mKHRoaXMuaGlnaGxpZ2h0aW5nKSA8IDApO1xyXG5cdFx0Ly9FTkRcclxuXHRcdGlmIChub3JlZHJhdykge1xyXG5cdFx0XHR0aGlzLmhpZ2hsaWdodGluZy5zaG93KCk7XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0cmVuZGVyLnBhcGVyLnNldFN0YXJ0KCk7XHJcblx0XHRcdHRoaXMuZHJhd0hpZ2hsaWdodChyZW5kZXIpO1xyXG5cdFx0XHR0aGlzLmhpZ2hsaWdodGluZyA9IHJlbmRlci5wYXBlci5zZXRGaW5pc2goKTtcclxuXHRcdH1cclxuXHR9IGVsc2Uge1xyXG5cdFx0aWYgKHRoaXMuaGlnaGxpZ2h0aW5nKSB0aGlzLmhpZ2hsaWdodGluZy5oaWRlKCk7XHJcblx0fVxyXG5cdHRoaXMuaGlnaGxpZ2h0ID0gaGlnaExpZ2h0O1xyXG59O1xyXG5cclxucm5kLlJlT2JqZWN0LnByb3RvdHlwZS5tYWtlU2VsZWN0aW9uUGxhdGUgPSBmdW5jdGlvbiAocmVuZGVyKSB7XHJcblx0Y29uc29sZS5sb2coJ1JlT2JqZWN0Lm1ha2VTZWxlY3Rpb25QbGF0ZSBpcyBub3Qgb3ZlcnJpZGRlbicpO1xyXG59O1xyXG5cclxudmFyIFJlQXRvbSA9IGZ1bmN0aW9uICgvKmNoZW0uQXRvbSovYXRvbSlcclxue1xyXG5cdHRoaXMuaW5pdChWaXNlbC5UWVBFLkFUT00pO1xyXG5cclxuXHR0aGlzLmEgPSBhdG9tOyAvLyBUT0RPIHJlbmFtZSBhIHRvIGl0ZW1cclxuXHR0aGlzLnNob3dMYWJlbCA9IGZhbHNlO1xyXG5cclxuXHR0aGlzLmh5ZHJvZ2VuT25UaGVMZWZ0ID0gZmFsc2U7XHJcblxyXG5cdHRoaXMuY29tcG9uZW50ID0gLTE7XHJcbn07XHJcblJlQXRvbS5wcm90b3R5cGUgPSBuZXcgcm5kLlJlT2JqZWN0KCk7XHJcblJlQXRvbS5pc1NlbGVjdGFibGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG5SZUF0b20ucHJvdG90eXBlLmdldFZCb3hPYmogPSBmdW5jdGlvbiAocmVuZGVyKSB7XHJcblx0aWYgKHRoaXMudmlzZWwuYm91bmRpbmdCb3gpXHJcblx0XHRyZXR1cm4gcm5kLlJlT2JqZWN0LnByb3RvdHlwZS5nZXRWQm94T2JqLmNhbGwodGhpcywgcmVuZGVyKTtcclxuXHRyZXR1cm4gbmV3IEJveDJBYnModGhpcy5hLnBwLCB0aGlzLmEucHApO1xyXG59O1xyXG5cclxuUmVBdG9tLnByb3RvdHlwZS5kcmF3SGlnaGxpZ2h0ID0gZnVuY3Rpb24gKHJlbmRlcikge1xyXG5cdHZhciByZXQgPSB0aGlzLm1ha2VIaWdobGlnaHRQbGF0ZShyZW5kZXIpO1xyXG5cdHJlbmRlci5jdGFiLmFkZFJlT2JqZWN0UGF0aCgnaGlnaGxpZ2h0aW5nJywgdGhpcy52aXNlbCwgcmV0KTtcclxuXHRyZXR1cm4gcmV0O1xyXG59O1xyXG5cclxuUmVBdG9tLnByb3RvdHlwZS5tYWtlSGlnaGxpZ2h0UGxhdGUgPSBmdW5jdGlvbiAocmVuZGVyKSB7XHJcblx0dmFyIHBhcGVyID0gcmVuZGVyLnBhcGVyO1xyXG5cdHZhciBzdHlsZXMgPSByZW5kZXIuc3R5bGVzO1xyXG5cdHZhciBwcyA9IHJlbmRlci5wcyh0aGlzLmEucHApO1xyXG5cdHJldHVybiBwYXBlci5jaXJjbGUocHMueCwgcHMueSwgc3R5bGVzLmF0b21TZWxlY3Rpb25QbGF0ZVJhZGl1cylcclxuXHQuYXR0cihzdHlsZXMuaGlnaGxpZ2h0U3R5bGUpO1xyXG59O1xyXG5cclxuUmVBdG9tLnByb3RvdHlwZS5tYWtlU2VsZWN0aW9uUGxhdGUgPSBmdW5jdGlvbiAocmVzdHJ1Y3QsIHBhcGVyLCBzdHlsZXMpIHtcclxuXHR2YXIgcHMgPSByZXN0cnVjdC5yZW5kZXIucHModGhpcy5hLnBwKTtcclxuXHRyZXR1cm4gcGFwZXIuY2lyY2xlKHBzLngsIHBzLnksIHN0eWxlcy5hdG9tU2VsZWN0aW9uUGxhdGVSYWRpdXMpXHJcblx0LmF0dHIoc3R5bGVzLnNlbGVjdGlvblN0eWxlKTtcclxufTtcclxuXHJcbnZhciBSZUJvbmQgPSBmdW5jdGlvbiAoLypjaGVtLkJvbmQqL2JvbmQpXHJcbntcclxuXHR0aGlzLmluaXQoVmlzZWwuVFlQRS5CT05EKTtcclxuXHJcblx0dGhpcy5iID0gYm9uZDsgLy8gVE9ETyByZW5hbWUgYiB0byBpdGVtXHJcblx0dGhpcy5kb3VibGVCb25kU2hpZnQgPSAwO1xyXG59O1xyXG5SZUJvbmQucHJvdG90eXBlID0gbmV3IHJuZC5SZU9iamVjdCgpO1xyXG5SZUJvbmQuaXNTZWxlY3RhYmxlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuUmVCb25kLnByb3RvdHlwZS5kcmF3SGlnaGxpZ2h0ID0gZnVuY3Rpb24gKHJlbmRlcikge1xyXG5cdHZhciByZXQgPSB0aGlzLm1ha2VIaWdobGlnaHRQbGF0ZShyZW5kZXIpO1xyXG5cdHJlbmRlci5jdGFiLmFkZFJlT2JqZWN0UGF0aCgnaGlnaGxpZ2h0aW5nJywgdGhpcy52aXNlbCwgcmV0KTtcclxuXHRyZXR1cm4gcmV0O1xyXG59O1xyXG5cclxuUmVCb25kLnByb3RvdHlwZS5tYWtlSGlnaGxpZ2h0UGxhdGUgPSBmdW5jdGlvbiAocmVuZGVyKSB7XHJcblx0cmVuZGVyLmN0YWIuYm9uZFJlY2FsYyhyZW5kZXIuc2V0dGluZ3MsIHRoaXMpO1xyXG5cdHZhciBjID0gcmVuZGVyLnBzKHRoaXMuYi5jZW50ZXIpO1xyXG5cdHJldHVybiByZW5kZXIucGFwZXIuY2lyY2xlKGMueCwgYy55LCAwLjggKiByZW5kZXIuc3R5bGVzLmF0b21TZWxlY3Rpb25QbGF0ZVJhZGl1cylcclxuXHQuYXR0cihyZW5kZXIuc3R5bGVzLmhpZ2hsaWdodFN0eWxlKTtcclxufTtcclxuXHJcblJlQm9uZC5wcm90b3R5cGUubWFrZVNlbGVjdGlvblBsYXRlID0gZnVuY3Rpb24gKHJlc3RydWN0LCBwYXBlciwgc3R5bGVzKSB7XHJcblx0cmVzdHJ1Y3QuYm9uZFJlY2FsYyhyZXN0cnVjdC5yZW5kZXIuc2V0dGluZ3MsIHRoaXMpO1xyXG5cdHZhciBjID0gcmVzdHJ1Y3QucmVuZGVyLnBzKHRoaXMuYi5jZW50ZXIpO1xyXG5cdHJldHVybiBwYXBlci5jaXJjbGUoYy54LCBjLnksIDAuOCAqIHN0eWxlcy5hdG9tU2VsZWN0aW9uUGxhdGVSYWRpdXMpXHJcblx0LmF0dHIoc3R5bGVzLnNlbGVjdGlvblN0eWxlKTtcclxufTtcclxuXHJcbnJuZC5SZVN0cnVjdCA9IGZ1bmN0aW9uIChtb2xlY3VsZSwgcmVuZGVyLCBub3Jlc2NhbGUpXHJcbntcclxuXHR0aGlzLnJlbmRlciA9IHJlbmRlcjtcclxuXHR0aGlzLmF0b21zID0gbmV3IE1hcCgpO1xyXG5cdHRoaXMuYm9uZHMgPSBuZXcgTWFwKCk7XHJcblx0dGhpcy5yZWxvb3BzID0gbmV3IE1hcCgpO1xyXG5cdHRoaXMucnhuUGx1c2VzID0gbmV3IE1hcCgpO1xyXG5cdHRoaXMucnhuQXJyb3dzID0gbmV3IE1hcCgpO1xyXG5cdHRoaXMuZnJhZ3MgPSBuZXcgTWFwKCk7XHJcblx0dGhpcy5yZ3JvdXBzID0gbmV3IE1hcCgpO1xyXG5cdHRoaXMuc2dyb3VwcyA9IG5ldyBNYXAoKTtcclxuXHR0aGlzLnNncm91cERhdGEgPSBuZXcgTWFwKCk7XHJcblx0dGhpcy5jaGlyYWxGbGFncyA9IG5ldyBNYXAoKTtcclxuXHR0aGlzLm1vbGVjdWxlID0gbW9sZWN1bGUgfHwgbmV3IFN0cnVjdCgpO1xyXG5cdHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuXHR0aGlzLmxheWVycyA9IFtdO1xyXG5cdHRoaXMuaW5pdExheWVycygpO1xyXG5cclxuXHR0aGlzLmNvbm5lY3RlZENvbXBvbmVudHMgPSBuZXcgUG9vbCgpO1xyXG5cdHRoaXMuY2NGcmFnbWVudFR5cGUgPSBuZXcgTWFwKCk7XHJcblxyXG5cdGZvciAodmFyIG1hcCBpbiBybmQuUmVTdHJ1Y3QubWFwcykge1xyXG5cdFx0dGhpc1ttYXAgKyAnQ2hhbmdlZCddID0ge307XHJcblx0fVxyXG5cdHRoaXMuc3RydWN0Q2hhbmdlZCA9IGZhbHNlO1xyXG5cclxuXHRtb2xlY3VsZS5hdG9tcy5lYWNoKGZ1bmN0aW9uIChhaWQsIGF0b20pe1xyXG5cdFx0dGhpcy5hdG9tcy5zZXQoYWlkLCBuZXcgUmVBdG9tKGF0b20pKTtcclxuXHR9LCB0aGlzKTtcclxuXHJcblx0bW9sZWN1bGUuYm9uZHMuZWFjaChmdW5jdGlvbiAoYmlkLCBib25kKXtcclxuXHRcdHRoaXMuYm9uZHMuc2V0KGJpZCwgbmV3IFJlQm9uZChib25kKSk7XHJcblx0fSwgdGhpcyk7XHJcblxyXG5cdG1vbGVjdWxlLmxvb3BzLmVhY2goZnVuY3Rpb24gKGxpZCwgbG9vcCl7XHJcblx0XHR0aGlzLnJlbG9vcHMuc2V0KGxpZCwgbmV3IHJuZC5SZUxvb3AobG9vcCkpO1xyXG5cdH0sIHRoaXMpO1xyXG5cclxuXHRtb2xlY3VsZS5yeG5QbHVzZXMuZWFjaChmdW5jdGlvbiAoaWQsIGl0ZW0pe1xyXG5cdFx0dGhpcy5yeG5QbHVzZXMuc2V0KGlkLCBuZXcgcm5kLlJlUnhuUGx1cyhpdGVtKSk7XHJcblx0fSwgdGhpcyk7XHJcblxyXG5cdG1vbGVjdWxlLnJ4bkFycm93cy5lYWNoKGZ1bmN0aW9uIChpZCwgaXRlbSl7XHJcblx0XHR0aGlzLnJ4bkFycm93cy5zZXQoaWQsIG5ldyBybmQuUmVSeG5BcnJvdyhpdGVtKSk7XHJcblx0fSwgdGhpcyk7XHJcblxyXG5cdG1vbGVjdWxlLmZyYWdzLmVhY2goZnVuY3Rpb24gKGlkLCBpdGVtKSB7XHJcblx0XHR0aGlzLmZyYWdzLnNldChpZCwgbmV3IHJuZC5SZUZyYWcoaXRlbSkpO1xyXG5cdH0sIHRoaXMpO1xyXG5cclxuXHRtb2xlY3VsZS5yZ3JvdXBzLmVhY2goZnVuY3Rpb24gKGlkLCBpdGVtKSB7XHJcblx0XHR0aGlzLnJncm91cHMuc2V0KGlkLCBuZXcgcm5kLlJlUkdyb3VwKGl0ZW0pKTtcclxuXHR9LCB0aGlzKTtcclxuXHJcblx0bW9sZWN1bGUuc2dyb3Vwcy5lYWNoKGZ1bmN0aW9uIChpZCwgaXRlbSkge1xyXG5cdFx0dGhpcy5zZ3JvdXBzLnNldChpZCwgbmV3IHJuZC5SZVNHcm91cChpdGVtKSk7XHJcblx0XHRpZiAoaXRlbS50eXBlID09ICdEQVQnICYmICFpdGVtLmRhdGEuYXR0YWNoZWQpIHtcclxuXHRcdFx0dGhpcy5zZ3JvdXBEYXRhLnNldChpZCwgbmV3IHJuZC5SZURhdGFTR3JvdXBEYXRhKGl0ZW0pKTsgLy8gW01LXSBzb3J0IG9mIGEgaGFjaywgd2UgdXNlIHRoZSBTR3JvdXAgaWQgZm9yIHRoZSBkYXRhIGZpZWxkIGlkXHJcblx0XHR9XHJcblx0fSwgdGhpcyk7XHJcblxyXG5cdGlmIChtb2xlY3VsZS5pc0NoaXJhbCAmJiAhdGhpcy5yZW5kZXIub3B0LmhpZGVDaGlyYWxGbGFnKSB7XHJcblx0XHR2YXIgYmIgPSBtb2xlY3VsZS5nZXRDb29yZEJvdW5kaW5nQm94KCk7XHJcblx0XHR0aGlzLmNoaXJhbEZsYWdzLnNldCgwLG5ldyBybmQuUmVDaGlyYWxGbGFnKG5ldyBWZWMyKGJiLm1heC54LCBiYi5taW4ueSAtIDEpKSk7XHJcblx0fVxyXG5cclxuXHR0aGlzLmNvb3JkUHJvY2Vzcyhub3Jlc2NhbGUpO1xyXG59O1xyXG5cclxucm5kLlJlU3RydWN0LnByb3RvdHlwZS5jb25uZWN0ZWRDb21wb25lbnRSZW1vdmVBdG9tID0gZnVuY3Rpb24gKGFpZCwgYXRvbSkge1xyXG5cdGF0b20gPSBhdG9tIHx8IHRoaXMuYXRvbXMuZ2V0KGFpZCk7XHJcblx0aWYgKGF0b20uY29tcG9uZW50IDwgMClcclxuXHRcdHJldHVybjtcclxuXHR2YXIgY2MgPSB0aGlzLmNvbm5lY3RlZENvbXBvbmVudHMuZ2V0KGF0b20uY29tcG9uZW50KTtcclxuXHRTZXQucmVtb3ZlKGNjLCBhaWQpO1xyXG5cdGlmIChTZXQuc2l6ZShjYykgPCAxKVxyXG5cdFx0dGhpcy5jb25uZWN0ZWRDb21wb25lbnRzLnJlbW92ZShhdG9tLmNvbXBvbmVudCk7XHJcblxyXG5cdGF0b20uY29tcG9uZW50ID0gLTE7XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QucHJvdG90eXBlLnByaW50Q29ubmVjdGVkQ29tcG9uZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgc3RycyA9IFtdO1xyXG5cdHRoaXMuY29ubmVjdGVkQ29tcG9uZW50cy5lYWNoKGZ1bmN0aW9uIChjY2lkLCBjYyl7XHJcblx0XHRzdHJzLnB1c2goJyAnICsgY2NpZCArICc6WycgKyBTZXQubGlzdChjYykudG9TdHJpbmcoKSArICddLicgKyBTZXQuc2l6ZShjYykudG9TdHJpbmcoKSk7XHJcblx0fSwgdGhpcyk7XHJcblx0Y29uc29sZS5sb2coc3Rycy50b1N0cmluZygpKTtcclxufTtcclxuXHJcbnJuZC5SZVN0cnVjdC5wcm90b3R5cGUuY2xlYXJDb25uZWN0ZWRDb21wb25lbnRzID0gZnVuY3Rpb24gKCkge1xyXG5cdHRoaXMuY29ubmVjdGVkQ29tcG9uZW50cy5jbGVhcigpO1xyXG5cdHRoaXMuYXRvbXMuZWFjaChmdW5jdGlvbiAoYWlkLCBhdG9tKSB7XHJcblx0XHRhdG9tLmNvbXBvbmVudCA9IC0xO1xyXG5cdH0pO1xyXG59O1xyXG5cclxucm5kLlJlU3RydWN0LnByb3RvdHlwZS5nZXRDb25uZWN0ZWRDb21wb25lbnQgPSBmdW5jdGlvbiAoYWlkLCBhZGphY2VudENvbXBvbmVudHMpIHtcclxuXHR2YXIgbGlzdCA9ICh0eXBlb2YoYWlkWydsZW5ndGgnXSkgPT0gJ251bWJlcicpID8gdXRpbC5hcnJheShhaWQpIDogW2FpZF07XHJcblx0dmFyIGlkcyA9IFNldC5lbXB0eSgpO1xyXG5cclxuXHR3aGlsZSAobGlzdC5sZW5ndGggPiAwKSB7XHJcblx0XHQoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR2YXIgYWlkID0gbGlzdC5wb3AoKTtcclxuXHRcdFx0U2V0LmFkZChpZHMsIGFpZCk7XHJcblx0XHRcdHZhciBhdG9tID0gdGhpcy5hdG9tcy5nZXQoYWlkKTtcclxuXHRcdFx0aWYgKGF0b20uY29tcG9uZW50ID49IDApIHtcclxuXHRcdFx0XHRTZXQuYWRkKGFkamFjZW50Q29tcG9uZW50cywgYXRvbS5jb21wb25lbnQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXRvbS5hLm5laWdoYm9ycy5sZW5ndGg7ICsraSkge1xyXG5cdFx0XHRcdHZhciBuZWlJZCA9IHRoaXMubW9sZWN1bGUuaGFsZkJvbmRzLmdldChhdG9tLmEubmVpZ2hib3JzW2ldKS5lbmQ7XHJcblx0XHRcdFx0aWYgKCFTZXQuY29udGFpbnMoaWRzLCBuZWlJZCkpXHJcblx0XHRcdFx0XHRsaXN0LnB1c2gobmVpSWQpO1xyXG5cdFx0XHR9XHJcblx0XHR9KS5hcHBseSh0aGlzKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBpZHM7XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QucHJvdG90eXBlLmFkZENvbm5lY3RlZENvbXBvbmVudCA9IGZ1bmN0aW9uIChpZHMpIHtcclxuXHR2YXIgY29tcElkID0gdGhpcy5jb25uZWN0ZWRDb21wb25lbnRzLmFkZChpZHMpO1xyXG5cdHZhciBhZGphY2VudENvbXBvbmVudHMgPSBTZXQuZW1wdHkoKTtcclxuXHR2YXIgYXRvbUlkcyA9IHRoaXMuZ2V0Q29ubmVjdGVkQ29tcG9uZW50KFNldC5saXN0KGlkcyksIGFkamFjZW50Q29tcG9uZW50cyk7XHJcblx0U2V0LnJlbW92ZShhZGphY2VudENvbXBvbmVudHMsIGNvbXBJZCk7XHJcblx0dmFyIHR5cGUgPSAtMTtcclxuXHRTZXQuZWFjaChhdG9tSWRzLCBmdW5jdGlvbiAoYWlkKSB7XHJcblx0XHR2YXIgYXRvbSA9IHRoaXMuYXRvbXMuZ2V0KGFpZCk7XHJcblx0XHRhdG9tLmNvbXBvbmVudCA9IGNvbXBJZDtcclxuXHRcdGlmIChhdG9tLmEucnhuRnJhZ21lbnRUeXBlICE9IC0xKSB7XHJcblx0XHRcdGlmICh0eXBlICE9IC0xICYmIGF0b20uYS5yeG5GcmFnbWVudFR5cGUgIT0gdHlwZSlcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ3JlYWN0aW9uIGZyYWdtZW50IHR5cGUgbWlzbWF0Y2gnKTtcclxuXHRcdFx0dHlwZSA9IGF0b20uYS5yeG5GcmFnbWVudFR5cGU7XHJcblx0XHR9XHJcblx0fSwgdGhpcyk7XHJcblxyXG5cdHRoaXMuY2NGcmFnbWVudFR5cGUuc2V0KGNvbXBJZCwgdHlwZSk7XHJcblx0cmV0dXJuIGNvbXBJZDtcclxufTtcclxuXHJcbnJuZC5SZVN0cnVjdC5wcm90b3R5cGUucmVtb3ZlQ29ubmVjdGVkQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNjaWQpIHtcclxuXHRTZXQuZWFjaCh0aGlzLmNvbm5lY3RlZENvbXBvbmVudHMuZ2V0KGNjaWQpLCBmdW5jdGlvbiAoYWlkKSB7XHJcblx0XHR0aGlzLmF0b21zLmdldChhaWQpLmNvbXBvbmVudCA9IC0xO1xyXG5cdH0sIHRoaXMpO1xyXG5cdHJldHVybiB0aGlzLmNvbm5lY3RlZENvbXBvbmVudHMucmVtb3ZlKGNjaWQpO1xyXG59O1xyXG5cclxucm5kLlJlU3RydWN0LnByb3RvdHlwZS5jb25uZWN0ZWRDb21wb25lbnRNZXJnZUluID0gZnVuY3Rpb24gKGNjaWQsIHNldCkge1xyXG5cdFNldC5lYWNoKHNldCwgZnVuY3Rpb24gKGFpZCkge1xyXG5cdFx0dGhpcy5hdG9tcy5nZXQoYWlkKS5jb21wb25lbnQgPSBjY2lkO1xyXG5cdH0sIHRoaXMpO1xyXG5cdFNldC5tZXJnZUluKHRoaXMuY29ubmVjdGVkQ29tcG9uZW50cy5nZXQoY2NpZCksIHNldCk7XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QucHJvdG90eXBlLmFzc2lnbkNvbm5lY3RlZENvbXBvbmVudHMgPSBmdW5jdGlvbiAoKSB7XHJcblx0dGhpcy5hdG9tcy5lYWNoKGZ1bmN0aW9uIChhaWQsYXRvbSl7XHJcblx0XHRpZiAoYXRvbS5jb21wb25lbnQgPj0gMClcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0dmFyIGFkamFjZW50Q29tcG9uZW50cyA9IFNldC5lbXB0eSgpO1xyXG5cdFx0dmFyIGlkcyA9IHRoaXMuZ2V0Q29ubmVjdGVkQ29tcG9uZW50KGFpZCwgYWRqYWNlbnRDb21wb25lbnRzKTtcclxuXHRcdFNldC5lYWNoKGFkamFjZW50Q29tcG9uZW50cywgZnVuY3Rpb24gKGNjaWQpe1xyXG5cdFx0XHR0aGlzLnJlbW92ZUNvbm5lY3RlZENvbXBvbmVudChjY2lkKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdFx0dGhpcy5hZGRDb25uZWN0ZWRDb21wb25lbnQoaWRzKTtcclxuXHR9LCB0aGlzKTtcclxufTtcclxuXHJcbnJuZC5SZVN0cnVjdC5wcm90b3R5cGUuY29ubmVjdGVkQ29tcG9uZW50R2V0Qm91bmRpbmdCb3ggPSBmdW5jdGlvbiAoY2NpZCwgY2MsIGJiKSB7XHJcblx0Y2MgPSBjYyB8fCB0aGlzLmNvbm5lY3RlZENvbXBvbmVudHMuZ2V0KGNjaWQpO1xyXG5cdGJiID0gYmIgfHwgeydtaW4nOm51bGwsICdtYXgnOm51bGx9O1xyXG5cdFNldC5lYWNoKGNjLCBmdW5jdGlvbiAoYWlkKSB7XHJcblx0XHR2YXIgcHMgPSB0aGlzLnJlbmRlci5wcyh0aGlzLmF0b21zLmdldChhaWQpLmEucHApO1xyXG5cdFx0aWYgKGJiLm1pbiA9PSBudWxsKSB7XHJcblx0XHRcdGJiLm1pbiA9IGJiLm1heCA9IHBzO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0YmIubWluID0gYmIubWluLm1pbihwcyk7XHJcblx0XHRcdGJiLm1heCA9IGJiLm1heC5tYXgocHMpO1xyXG5cdFx0fVxyXG5cdH0sIHRoaXMpO1xyXG5cdHJldHVybiBiYjtcclxufTtcclxuXHJcbnJuZC5SZVN0cnVjdC5wcm90b3R5cGUuaW5pdExheWVycyA9IGZ1bmN0aW9uICgpIHtcclxuXHRmb3IgKHZhciBncm91cCBpbiBybmQuUmVTdHJ1Y3QubGF5ZXJNYXApXHJcblx0XHR0aGlzLmxheWVyc1tybmQuUmVTdHJ1Y3QubGF5ZXJNYXBbZ3JvdXBdXSA9XHJcblx0XHR0aGlzLnJlbmRlci5wYXBlci5yZWN0KDAsIDAsIDEwLCAxMClcclxuXHRcdC5hdHRyKHtcclxuXHRcdFx0J2ZpbGwnOicjMDAwJyxcclxuXHRcdFx0J29wYWNpdHknOicwLjAnXHJcblx0XHR9KS50b0Zyb250KCk7XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QucHJvdG90eXBlLmluc2VydEluTGF5ZXIgPSBmdW5jdGlvbiAobGlkLCBwYXRoKSB7XHJcblx0cGF0aC5pbnNlcnRCZWZvcmUodGhpcy5sYXllcnNbbGlkXSk7XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QucHJvdG90eXBlLmNsZWFyTWFya3MgPSBmdW5jdGlvbiAoKSB7XHJcblx0Zm9yICh2YXIgbWFwIGluIHJuZC5SZVN0cnVjdC5tYXBzKSB7XHJcblx0XHR0aGlzW21hcCArICdDaGFuZ2VkJ10gPSB7fTtcclxuXHR9XHJcblx0dGhpcy5zdHJ1Y3RDaGFuZ2VkID0gZmFsc2U7XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QucHJvdG90eXBlLm1hcmtJdGVtUmVtb3ZlZCA9IGZ1bmN0aW9uICgpIHtcclxuXHR0aGlzLnN0cnVjdENoYW5nZWQgPSB0cnVlO1xyXG59O1xyXG5cclxucm5kLlJlU3RydWN0LnByb3RvdHlwZS5tYXJrQm9uZCA9IGZ1bmN0aW9uIChiaWQsIG1hcmspIHtcclxuXHR0aGlzLm1hcmtJdGVtKCdib25kcycsIGJpZCwgbWFyayk7XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QucHJvdG90eXBlLm1hcmtBdG9tID0gZnVuY3Rpb24gKGFpZCwgbWFyaykge1xyXG5cdHRoaXMubWFya0l0ZW0oJ2F0b21zJywgYWlkLCBtYXJrKTtcclxufTtcclxuXHJcbnJuZC5SZVN0cnVjdC5wcm90b3R5cGUubWFya0l0ZW0gPSBmdW5jdGlvbiAobWFwLCBpZCwgbWFyaykge1xyXG5cdHZhciBtYXBDaGFuZ2VkID0gdGhpc1ttYXAgKyAnQ2hhbmdlZCddO1xyXG5cdG1hcENoYW5nZWRbaWRdID0gKHR5cGVvZihtYXBDaGFuZ2VkW2lkXSkgIT0gJ3VuZGVmaW5lZCcpID9cclxuXHRcdE1hdGgubWF4KG1hcmssIG1hcENoYW5nZWRbaWRdKSA6IG1hcms7XHJcblx0aWYgKHRoaXNbbWFwXS5oYXMoaWQpKVxyXG5cdFx0dGhpcy5jbGVhclZpc2VsKHRoaXNbbWFwXS5nZXQoaWQpLnZpc2VsKTtcclxufTtcclxuXHJcbnJuZC5SZVN0cnVjdC5wcm90b3R5cGUuZWFjaFZpc2VsID0gZnVuY3Rpb24gKGZ1bmMsIGNvbnRleHQpIHtcclxuXHRmb3IgKHZhciBtYXAgaW4gcm5kLlJlU3RydWN0Lm1hcHMpIHtcclxuXHRcdHRoaXNbbWFwXS5lYWNoKGZ1bmN0aW9uIChpZCwgaXRlbSkge1xyXG5cdFx0XHRmdW5jLmNhbGwoY29udGV4dCwgaXRlbS52aXNlbCk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHR9XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QucHJvdG90eXBlLmdldFZCb3hPYmogPSBmdW5jdGlvbiAoc2VsZWN0aW9uKVxyXG57XHJcblx0c2VsZWN0aW9uID0gc2VsZWN0aW9uIHx8IHt9O1xyXG5cdGlmICh0aGlzLnNlbGVjdGlvbklzRW1wdHkoc2VsZWN0aW9uKSkge1xyXG5cdFx0Zm9yICh2YXIgbWFwIGluIHJuZC5SZVN0cnVjdC5tYXBzKSB7XHJcblx0XHRcdHNlbGVjdGlvblttYXBdID0gdGhpc1ttYXBdLmtleXMoKTtcclxuXHRcdH1cclxuXHR9XHJcblx0dmFyIHZib3ggPSBudWxsO1xyXG5cdGZvciAodmFyIG1hcCBpbiBybmQuUmVTdHJ1Y3QubWFwcykge1xyXG5cdFx0aWYgKHNlbGVjdGlvblttYXBdKSB7XHJcblx0XHRcdHV0aWwuZWFjaChzZWxlY3Rpb25bbWFwXSwgZnVuY3Rpb24gKGlkKSB7XHJcblx0XHRcdFx0dmFyIGJveCA9IHRoaXNbbWFwXS5nZXQoaWQpLmdldFZCb3hPYmoodGhpcy5yZW5kZXIpO1xyXG5cdFx0XHRcdGlmIChib3gpXHJcblx0XHRcdFx0XHR2Ym94ID0gdmJveCA/IEJveDJBYnMudW5pb24odmJveCwgYm94KSA6IGJveC5jbG9uZSgpO1xyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdH1cclxuXHR9XHJcblx0dmJveCA9IHZib3ggfHwgbmV3IEJveDJBYnMoMCwgMCwgMCwgMCk7XHJcblx0cmV0dXJuIHZib3g7XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QucHJvdG90eXBlLnNlbGVjdGlvbklzRW1wdHkgPSBmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XHJcblx0dXRpbC5hc3NlcnQoIXV0aWwuaXNVbmRlZmluZWQoc2VsZWN0aW9uKSwgJ1xcJ3NlbGVjdGlvblxcJyBpcyBub3QgZGVmaW5lZCcpO1xyXG5cdGlmICh1dGlsLmlzTnVsbChzZWxlY3Rpb24pKVxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0Zm9yICh2YXIgbWFwIGluIHJuZC5SZVN0cnVjdC5tYXBzKVxyXG5cdFx0aWYgKHNlbGVjdGlvblttYXBdICYmIHNlbGVjdGlvblttYXBdLmxlbmd0aCA+IDApXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRyZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxucm5kLlJlU3RydWN0LnByb3RvdHlwZS50cmFuc2xhdGUgPSBmdW5jdGlvbiAoZCkge1xyXG5cdHRoaXMuZWFjaFZpc2VsKGZ1bmN0aW9uICh2aXNlbCl7XHJcblx0XHR2aXNlbC50cmFuc2xhdGUoZCk7XHJcblx0fSwgdGhpcyk7XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24gKHMpIHtcclxuXHQvLyBOT1RFOiBib3VuZGluZyBib3hlcyBhcmUgbm90IHZhbGlkIGFmdGVyIHNjYWxpbmdcclxuXHR0aGlzLmVhY2hWaXNlbChmdW5jdGlvbiAodmlzZWwpe1xyXG5cdFx0dGhpcy5zY2FsZVZpc2VsKHZpc2VsLCBzKTtcclxuXHR9LCB0aGlzKTtcclxufTtcclxuXHJcbnJuZC5SZVN0cnVjdC5wcm90b3R5cGUuc2NhbGVSUGF0aCA9IGZ1bmN0aW9uIChwYXRoLCBzKSB7XHJcblx0aWYgKHBhdGgudHlwZSA9PSAnc2V0JykgeyAvLyBUT0RPOiByZXdvcmsgc2NhbGluZ1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgKytpKVxyXG5cdFx0XHR0aGlzLnNjYWxlUlBhdGgocGF0aFtpXSwgcyk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGlmICghT2JqZWN0LmlzVW5kZWZpbmVkKHBhdGguYXR0cnMpKSB7XHJcblx0XHRcdGlmICgnZm9udC1zaXplJyBpbiBwYXRoLmF0dHJzKVxyXG5cdFx0XHRcdHBhdGguYXR0cignZm9udC1zaXplJywgcGF0aC5hdHRyc1snZm9udC1zaXplJ10gKiBzKTtcclxuXHRcdFx0ZWxzZSBpZiAoJ3N0cm9rZS13aWR0aCcgaW4gcGF0aC5hdHRycylcclxuXHRcdFx0XHRwYXRoLmF0dHIoJ3N0cm9rZS13aWR0aCcsIHBhdGguYXR0cnNbJ3N0cm9rZS13aWR0aCddICogcyk7XHJcblx0XHR9XHJcblx0XHRwYXRoLnNjYWxlKHMsIHMsIDAsIDApO1xyXG5cdH1cclxufTtcclxuXHJcbnJuZC5SZVN0cnVjdC5wcm90b3R5cGUuc2NhbGVWaXNlbCA9IGZ1bmN0aW9uICh2aXNlbCwgcykge1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdmlzZWwucGF0aHMubGVuZ3RoOyArK2kpXHJcblx0XHR0aGlzLnNjYWxlUlBhdGgodmlzZWwucGF0aHNbaV0sIHMpO1xyXG59O1xyXG5cclxucm5kLlJlU3RydWN0LnByb3RvdHlwZS5jbGVhclZpc2VscyA9IGZ1bmN0aW9uICgpIHtcclxuXHR0aGlzLmVhY2hWaXNlbChmdW5jdGlvbiAodmlzZWwpe1xyXG5cdFx0dGhpcy5jbGVhclZpc2VsKHZpc2VsKTtcclxuXHR9LCB0aGlzKTtcclxufTtcclxuXHJcbnJuZC5SZVN0cnVjdC5wcm90b3R5cGUuZmluZEluY29taW5nU3RlcmVvVXBCb25kID0gZnVuY3Rpb24gKGF0b20sIGJpZDAsIGluY2x1ZGVCb2xkU3RlcmVvQm9uZCkge1xyXG5cdHJldHVybiB1dGlsLmZpbmRJbmRleChhdG9tLm5laWdoYm9ycywgZnVuY3Rpb24gKGhiaWQpIHtcclxuXHRcdHZhciBoYiA9IHRoaXMubW9sZWN1bGUuaGFsZkJvbmRzLmdldChoYmlkKTtcclxuXHRcdHZhciBiaWQgPSBoYi5iaWQ7XHJcblx0XHRpZiAoYmlkID09PSBiaWQwKVxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR2YXIgbmVpYm9uZCA9IHRoaXMuYm9uZHMuZ2V0KGJpZCk7XHJcblx0XHRpZiAobmVpYm9uZC5iLnR5cGUgPT09IEJvbmQuUEFUVEVSTi5UWVBFLlNJTkdMRSAmJiBuZWlib25kLmIuc3RlcmVvID09PSBCb25kLlBBVFRFUk4uU1RFUkVPLlVQKVxyXG5cdFx0XHRyZXR1cm4gbmVpYm9uZC5iLmVuZCA9PT0gaGIuYmVnaW4gfHwgKG5laWJvbmQuYm9sZFN0ZXJlbyAmJiBpbmNsdWRlQm9sZFN0ZXJlb0JvbmQpO1xyXG5cdFx0aWYgKG5laWJvbmQuYi50eXBlID09PSBCb25kLlBBVFRFUk4uVFlQRS5ET1VCTEUgJiYgbmVpYm9uZC5iLnN0ZXJlbyA9PT0gQm9uZC5QQVRURVJOLlNURVJFTy5OT05FICYmIGluY2x1ZGVCb2xkU3RlcmVvQm9uZCAmJiBuZWlib25kLmJvbGRTdGVyZW8pXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sIHRoaXMpO1xyXG59XHJcblxyXG5ybmQuUmVTdHJ1Y3QucHJvdG90eXBlLmNoZWNrU3RlcmVvQm9sZCA9IGZ1bmN0aW9uIChiaWQwLCBib25kKSB7XHJcblx0dmFyIGhhbGZib25kcyA9IHV0aWwubWFwKFtib25kLmIuYmVnaW4sIGJvbmQuYi5lbmRdLCBmdW5jdGlvbiAoYWlkKSB7XHJcblx0XHR2YXIgYXRvbSA9IHRoaXMubW9sZWN1bGUuYXRvbXMuZ2V0KGFpZCk7XHJcblx0XHR2YXIgcG9zID0gIHRoaXMuZmluZEluY29taW5nU3RlcmVvVXBCb25kKGF0b20sIGJpZDAsIGZhbHNlKTtcclxuXHRcdHJldHVybiBwb3MgPCAwID8gLTEgOiBhdG9tLm5laWdoYm9yc1twb3NdO1xyXG5cdH0sIHRoaXMpO1xyXG5cdHV0aWwuYXNzZXJ0KGhhbGZib25kcy5sZW5ndGggPT09IDIpO1xyXG5cdGJvbmQuYm9sZFN0ZXJlbyA9IGhhbGZib25kc1swXSA+PSAwICYmIGhhbGZib25kc1sxXSA+PSAwO1xyXG59O1xyXG5cclxucm5kLlJlU3RydWN0LnByb3RvdHlwZS5maW5kSW5jb21pbmdVcEJvbmRzID0gZnVuY3Rpb24gKGJpZDAsIGJvbmQpIHtcclxuXHR2YXIgaGFsZmJvbmRzID0gdXRpbC5tYXAoW2JvbmQuYi5iZWdpbiwgYm9uZC5iLmVuZF0sIGZ1bmN0aW9uIChhaWQpIHtcclxuXHRcdHZhciBhdG9tID0gdGhpcy5tb2xlY3VsZS5hdG9tcy5nZXQoYWlkKTtcclxuXHRcdHZhciBwb3MgPSAgdGhpcy5maW5kSW5jb21pbmdTdGVyZW9VcEJvbmQoYXRvbSwgYmlkMCwgdHJ1ZSk7XHJcblx0XHRyZXR1cm4gcG9zIDwgMCA/IC0xIDogYXRvbS5uZWlnaGJvcnNbcG9zXTtcclxuXHR9LCB0aGlzKTtcclxuXHR1dGlsLmFzc2VydChoYWxmYm9uZHMubGVuZ3RoID09PSAyKTtcclxuXHRib25kLm5laWhiaWQxID0gdGhpcy5hdG9tcy5nZXQoYm9uZC5iLmJlZ2luKS5zaG93TGFiZWwgPyAtMSA6IGhhbGZib25kc1swXTtcclxuXHRib25kLm5laWhiaWQyID0gdGhpcy5hdG9tcy5nZXQoYm9uZC5iLmVuZCkuc2hvd0xhYmVsID8gLTEgOiBoYWxmYm9uZHNbMV07XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QucHJvdG90eXBlLmNoZWNrU3RlcmVvQm9sZEJvbmRzID0gZnVuY3Rpb24gKCkge1xyXG5cdHRoaXMuYm9uZHMuZWFjaCh0aGlzLmNoZWNrU3RlcmVvQm9sZCwgdGhpcyk7XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChmb3JjZSlcclxue1xyXG5cdGZvcmNlID0gZm9yY2UgfHwgIXRoaXMuaW5pdGlhbGl6ZWQ7XHJcblxyXG5cdC8vIGNoZWNrIGl0ZW1zIHRvIHVwZGF0ZVxyXG5cdHZhciBpZDtcclxuXHRpZiAoZm9yY2UpIHtcclxuXHRcdChmdW5jdGlvbiAoKXtcclxuXHRcdFx0Zm9yICh2YXIgbWFwIGluIHJuZC5SZVN0cnVjdC5tYXBzKSB7XHJcblx0XHRcdFx0dmFyIG1hcENoYW5nZWQgPSB0aGlzW21hcCArICdDaGFuZ2VkJ107XHJcblx0XHRcdFx0dGhpc1ttYXBdLmVhY2goZnVuY3Rpb24gKGlkKXtcclxuXHRcdFx0XHRcdG1hcENoYW5nZWRbaWRdID0gMTtcclxuXHRcdFx0XHR9LCB0aGlzKTtcclxuXHRcdFx0fVxyXG5cdFx0fSkuY2FsbCh0aGlzKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Ly8gY2hlY2sgaWYgc29tZSBvZiB0aGUgaXRlbXMgbWFya2VkIGFyZSBhbHJlYWR5IGdvbmVcclxuXHRcdChmdW5jdGlvbiAoKXtcclxuXHRcdFx0Zm9yICh2YXIgbWFwIGluIHJuZC5SZVN0cnVjdC5tYXBzKSB7XHJcblx0XHRcdFx0dmFyIG1hcENoYW5nZWQgPSB0aGlzW21hcCArICdDaGFuZ2VkJ107XHJcblx0XHRcdFx0Zm9yIChpZCBpbiBtYXBDaGFuZ2VkKVxyXG5cdFx0XHRcdFx0aWYgKCF0aGlzW21hcF0uaGFzKGlkKSlcclxuXHRcdFx0XHRcdFx0ZGVsZXRlIG1hcENoYW5nZWRbaWRdO1xyXG5cdFx0XHR9XHJcblx0XHR9KS5jYWxsKHRoaXMpO1xyXG5cdH1cclxuXHRmb3IgKGlkIGluIHRoaXMuYXRvbXNDaGFuZ2VkKVxyXG5cdFx0dGhpcy5jb25uZWN0ZWRDb21wb25lbnRSZW1vdmVBdG9tKGlkKTtcclxuXHJcblx0Ly8gY2xlYW4gdXAgZW1wdHkgZnJhZ21lbnRzXHJcblx0Ly8gVE9ETzogZnJhZ21lbnQgcmVtb3ZhbCBzaG91bGQgYmUgdHJpZ2dlcmVkIGJ5IHRoZSBhY3Rpb24gcmVzcG9uc2libGUgZm9yIHRoZSBmcmFnbWVudCBjb250ZW50cyByZW1vdmFsIGFuZCBmb3JtIGFuIG9wZXJhdGlvbiBvZiBpdHMgb3duXHJcblx0dmFyIGVtcHR5RnJhZ3MgPSB0aGlzLmZyYWdzLmZpbmRBbGwoZnVuY3Rpb24gKGZpZCwgZnJhZykge1xyXG5cdFx0cmV0dXJuICFmcmFnLmNhbGNCQm94KHRoaXMucmVuZGVyLCBmaWQpO1xyXG5cdH0sIHRoaXMpO1xyXG5cdGZvciAodmFyIGogPSAwOyBqIDwgZW1wdHlGcmFncy5sZW5ndGg7ICsraikge1xyXG5cdFx0dmFyIGZpZCA9IGVtcHR5RnJhZ3Nbal07XHJcblx0XHR0aGlzLmNsZWFyVmlzZWwodGhpcy5mcmFncy5nZXQoZmlkKS52aXNlbCk7XHJcblx0XHR0aGlzLmZyYWdzLnVuc2V0KGZpZCk7XHJcblx0XHR0aGlzLm1vbGVjdWxlLmZyYWdzLnJlbW92ZShmaWQpO1xyXG5cdH1cclxuXHJcblx0KGZ1bmN0aW9uICgpe1xyXG5cdFx0Zm9yICh2YXIgbWFwIGluIHJuZC5SZVN0cnVjdC5tYXBzKSB7XHJcblx0XHRcdHZhciBtYXBDaGFuZ2VkID0gdGhpc1ttYXAgKyAnQ2hhbmdlZCddO1xyXG5cdFx0XHRmb3IgKGlkIGluIG1hcENoYW5nZWQpIHtcclxuXHRcdFx0XHR0aGlzLmNsZWFyVmlzZWwodGhpc1ttYXBdLmdldChpZCkudmlzZWwpO1xyXG5cdFx0XHRcdHRoaXMuc3RydWN0Q2hhbmdlZCB8PSBtYXBDaGFuZ2VkW2lkXSA+IDA7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9KS5jYWxsKHRoaXMpO1xyXG5cdGlmICh0aGlzLnN0cnVjdENoYW5nZWQpXHJcblx0XHR1dGlsLmVhY2godGhpcy5yZW5kZXIuc3RydWN0Q2hhbmdlSGFuZGxlcnMsIGZ1bmN0aW9uIChoYW5kbGVyKXtoYW5kbGVyLmNhbGwoKTt9KTtcclxuXHJcblx0Ly8gVE9ETzogd2hlbiB0byB1cGRhdGUgc2dyb3VwP1xyXG5cdHRoaXMuc2dyb3Vwcy5lYWNoKGZ1bmN0aW9uIChzaWQsIHNncm91cCl7XHJcblx0XHR0aGlzLmNsZWFyVmlzZWwoc2dyb3VwLnZpc2VsKTtcclxuXHRcdHNncm91cC5oaWdobGlnaHRpbmcgPSBudWxsO1xyXG5cdFx0c2dyb3VwLnNlbGVjdGlvblBsYXRlID0gbnVsbDtcclxuXHR9LCB0aGlzKTtcclxuXHJcblx0Ly8gVE9ETyBbUkJdIG5lZWQgdG8gaW1wbGVtZW50IHVwZGF0ZS1vbi1kZW1hbmQgZm9yIGZyYWdtZW50cyBhbmQgci1ncm91cHNcclxuXHR0aGlzLmZyYWdzLmVhY2goZnVuY3Rpb24gKGZyaWQsIGZyYWcpIHtcclxuXHRcdHRoaXMuY2xlYXJWaXNlbChmcmFnLnZpc2VsKTtcclxuXHR9LCB0aGlzKTtcclxuXHR0aGlzLnJncm91cHMuZWFjaChmdW5jdGlvbiAocmdpZCwgcmdyb3VwKSB7XHJcblx0XHR0aGlzLmNsZWFyVmlzZWwocmdyb3VwLnZpc2VsKTtcclxuXHR9LCB0aGlzKTtcclxuXHJcblx0aWYgKGZvcmNlKSB7IC8vIGNsZWFyIGFuZCByZWNyZWF0ZSBhbGwgaGFsZi1ib25kc1xyXG5cdFx0dGhpcy5jbGVhckNvbm5lY3RlZENvbXBvbmVudHMoKTtcclxuXHRcdHRoaXMubW9sZWN1bGUuaW5pdEhhbGZCb25kcygpO1xyXG5cdFx0dGhpcy5tb2xlY3VsZS5pbml0TmVpZ2hib3JzKCk7XHJcblx0fVxyXG5cclxuXHQvLyBvbmx5IHVwZGF0ZSBoYWxmLWJvbmRzIGFkamFjZW50IHRvIGF0b21zIHRoYXQgaGF2ZSBtb3ZlZFxyXG5cdHRoaXMubW9sZWN1bGUudXBkYXRlSGFsZkJvbmRzKG5ldyBNYXAodGhpcy5hdG9tc0NoYW5nZWQpLmZpbmRBbGwoZnVuY3Rpb24gKGFpZCwgc3RhdHVzKXsgcmV0dXJuIHN0YXR1cyA+PSAwOyB9LCB0aGlzKSk7XHJcblx0dGhpcy5tb2xlY3VsZS5zb3J0TmVpZ2hib3JzKG5ldyBNYXAodGhpcy5hdG9tc0NoYW5nZWQpLmZpbmRBbGwoZnVuY3Rpb24gKGFpZCwgc3RhdHVzKXsgcmV0dXJuIHN0YXR1cyA+PSAxOyB9LCB0aGlzKSk7XHJcblx0dGhpcy5hc3NpZ25Db25uZWN0ZWRDb21wb25lbnRzKCk7XHJcblx0dGhpcy5zZXRJbXBsaWNpdEh5ZHJvZ2VuKCk7XHJcblx0dGhpcy5zZXRIeWRyb2dlblBvcygpO1xyXG5cdHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG5cclxuXHR0aGlzLnZlcmlmeUxvb3BzKCk7XHJcblx0dmFyIHVwZExvb3BzID0gZm9yY2UgfHwgdGhpcy5zdHJ1Y3RDaGFuZ2VkO1xyXG5cdGlmICh1cGRMb29wcylcclxuXHRcdHRoaXMudXBkYXRlTG9vcHMoKTtcclxuXHR0aGlzLnNldERvdWJsZUJvbmRTaGlmdCgpO1xyXG5cdHRoaXMuY2hlY2tMYWJlbHNUb1Nob3coKTtcclxuXHR0aGlzLmNoZWNrU3RlcmVvQm9sZEJvbmRzKCk7XHJcblx0dGhpcy5zaG93TGFiZWxzKCk7XHJcblx0dGhpcy5zaG93Qm9uZHMoKTtcclxuXHRpZiAodXBkTG9vcHMpXHJcblx0XHR0aGlzLnJlbmRlckxvb3BzKCk7XHJcblx0dGhpcy5kcmF3UmVhY3Rpb25TeW1ib2xzKCk7XHJcblx0dGhpcy5kcmF3U0dyb3VwcygpO1xyXG5cdHRoaXMuZHJhd0ZyYWdtZW50cygpO1xyXG5cdHRoaXMuZHJhd1JHcm91cHMoKTtcclxuXHR0aGlzLmNoaXJhbEZsYWdzLmVhY2goZnVuY3Rpb24gKGlkLCBpdGVtKSB7XHJcblx0XHRpZiAodGhpcy5jaGlyYWxGbGFnc0NoYW5nZWRbaWRdID4gMClcclxuXHRcdFx0aXRlbS5kcmF3KHRoaXMucmVuZGVyKTtcclxuXHR9LCB0aGlzKTtcclxuXHR0aGlzLmNsZWFyTWFya3MoKTtcclxuXHRyZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbnJuZC5SZVN0cnVjdC5wcm90b3R5cGUuZHJhd1JlYWN0aW9uU3ltYm9scyA9IGZ1bmN0aW9uICgpXHJcbntcclxuXHR2YXIgaXRlbTtcclxuXHR2YXIgaWQ7XHJcblx0Zm9yIChpZCBpbiB0aGlzLnJ4bkFycm93c0NoYW5nZWQpIHtcclxuXHRcdGl0ZW0gPSB0aGlzLnJ4bkFycm93cy5nZXQoaWQpO1xyXG5cdFx0dGhpcy5kcmF3UmVhY3Rpb25BcnJvdyhpZCwgaXRlbSk7XHJcblx0fVxyXG5cdGZvciAoaWQgaW4gdGhpcy5yeG5QbHVzZXNDaGFuZ2VkKSB7XHJcblx0XHRpdGVtID0gdGhpcy5yeG5QbHVzZXMuZ2V0KGlkKTtcclxuXHRcdHRoaXMuZHJhd1JlYWN0aW9uUGx1cyhpZCwgaXRlbSk7XHJcblx0fVxyXG59O1xyXG5cclxucm5kLlJlU3RydWN0LnByb3RvdHlwZS5kcmF3UmVhY3Rpb25BcnJvdyA9IGZ1bmN0aW9uIChpZCwgaXRlbSlcclxue1xyXG5cdHZhciBjZW50cmUgPSB0aGlzLnJlbmRlci5wcyhpdGVtLml0ZW0ucHApO1xyXG5cdHZhciBwYXRoID0gdGhpcy5kcmF3QXJyb3cobmV3IFZlYzIoY2VudHJlLnggLSB0aGlzLnJlbmRlci5zY2FsZSwgY2VudHJlLnkpLCBuZXcgVmVjMihjZW50cmUueCArIHRoaXMucmVuZGVyLnNjYWxlLCBjZW50cmUueSkpO1xyXG5cdGl0ZW0udmlzZWwuYWRkKHBhdGgsIEJveDJBYnMuZnJvbVJlbEJveCh1dGlsLnJlbEJveChwYXRoLmdldEJCb3goKSkpKTtcclxuXHR2YXIgb2Zmc2V0ID0gdGhpcy5yZW5kZXIub2Zmc2V0O1xyXG5cdGlmIChvZmZzZXQgIT0gbnVsbClcclxuXHRcdHBhdGgudHJhbnNsYXRlQWJzKG9mZnNldC54LCBvZmZzZXQueSk7XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QucHJvdG90eXBlLmRyYXdSZWFjdGlvblBsdXMgPSBmdW5jdGlvbiAoaWQsIGl0ZW0pXHJcbntcclxuXHR2YXIgY2VudHJlID0gdGhpcy5yZW5kZXIucHMoaXRlbS5pdGVtLnBwKTtcclxuXHR2YXIgcGF0aCA9IHRoaXMuZHJhd1BsdXMoY2VudHJlKTtcclxuXHRpdGVtLnZpc2VsLmFkZChwYXRoLCBCb3gyQWJzLmZyb21SZWxCb3godXRpbC5yZWxCb3gocGF0aC5nZXRCQm94KCkpKSk7XHJcblx0dmFyIG9mZnNldCA9IHRoaXMucmVuZGVyLm9mZnNldDtcclxuXHRpZiAob2Zmc2V0ICE9IG51bGwpXHJcblx0XHRwYXRoLnRyYW5zbGF0ZUFicyhvZmZzZXQueCwgb2Zmc2V0LnkpO1xyXG59O1xyXG5cclxucm5kLlJlU3RydWN0LnByb3RvdHlwZS5kcmF3U0dyb3VwcyA9IGZ1bmN0aW9uICgpXHJcbntcclxuXHR1dGlsLmVhY2godGhpcy5tb2xlY3VsZS5zR3JvdXBGb3Jlc3QuZ2V0U0dyb3Vwc0JGUygpLnJldmVyc2UoKSwgZnVuY3Rpb24gKGlkKSB7XHJcblx0XHR2YXIgc2dyb3VwID0gdGhpcy5zZ3JvdXBzLmdldChpZCk7XHJcblx0XHR2YXIgcGF0aCA9IHNncm91cC5kcmF3KHRoaXMucmVuZGVyKTtcclxuXHRcdHRoaXMuYWRkUmVPYmplY3RQYXRoKCdkYXRhJywgc2dyb3VwLnZpc2VsLCBwYXRoLCBudWxsLCB0cnVlKTtcclxuXHRcdHNncm91cC5zZXRIaWdobGlnaHQoc2dyb3VwLmhpZ2hsaWdodCwgdGhpcy5yZW5kZXIpOyAvLyBUT0RPOiBmaXggdGhpc1xyXG5cdH0sIHRoaXMpO1xyXG59O1xyXG5cclxucm5kLlJlU3RydWN0LnByb3RvdHlwZS5kcmF3RnJhZ21lbnRzID0gZnVuY3Rpb24gKCkge1xyXG5cdHRoaXMuZnJhZ3MuZWFjaChmdW5jdGlvbiAoaWQsIGZyYWcpIHtcclxuXHRcdHZhciBwYXRoID0gZnJhZy5kcmF3KHRoaXMucmVuZGVyLCBpZCk7XHJcblx0XHRpZiAocGF0aCkgdGhpcy5hZGRSZU9iamVjdFBhdGgoJ2RhdGEnLCBmcmFnLnZpc2VsLCBwYXRoLCBudWxsLCB0cnVlKTtcclxuXHRcdC8vIFRPRE8gZnJhZ21lbnQgc2VsZWN0aW9uICYgaGlnaGxpZ2h0aW5nXHJcblx0fSwgdGhpcyk7XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QucHJvdG90eXBlLmRyYXdSR3JvdXBzID0gZnVuY3Rpb24gKCkge1xyXG5cdHRoaXMucmdyb3Vwcy5lYWNoKGZ1bmN0aW9uIChpZCwgcmdyb3VwKSB7XHJcblx0XHR2YXIgZHJhd2luZyA9IHJncm91cC5kcmF3KHRoaXMucmVuZGVyKTtcclxuXHRcdGZvciAodmFyIGdyb3VwIGluIGRyYXdpbmcpIHtcclxuXHRcdFx0d2hpbGUgKGRyYXdpbmdbZ3JvdXBdLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHR0aGlzLmFkZFJlT2JqZWN0UGF0aChncm91cCwgcmdyb3VwLnZpc2VsLCBkcmF3aW5nW2dyb3VwXS5zaGlmdCgpLCBudWxsLCB0cnVlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Ly8gVE9ETyByZ3JvdXAgc2VsZWN0aW9uICYgaGlnaGxpZ2h0aW5nXHJcblx0fSwgdGhpcyk7XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QucHJvdG90eXBlLmVhY2hDQyA9IGZ1bmN0aW9uIChmdW5jLCB0eXBlLCBjb250ZXh0KSB7XHJcblx0dGhpcy5jb25uZWN0ZWRDb21wb25lbnRzLmVhY2goZnVuY3Rpb24gKGNjaWQsIGNjKSB7XHJcblx0XHRpZiAoIXR5cGUgfHwgdGhpcy5jY0ZyYWdtZW50VHlwZS5nZXQoY2NpZCkgPT0gdHlwZSlcclxuXHRcdFx0ZnVuYy5jYWxsKGNvbnRleHQgfHwgdGhpcywgY2NpZCwgY2MpO1xyXG5cdH0sIHRoaXMpO1xyXG59O1xyXG5cclxucm5kLlJlU3RydWN0LnByb3RvdHlwZS5nZXRHcm91cEJCID0gZnVuY3Rpb24gKHR5cGUpXHJcbntcclxuXHR2YXIgYmIgPSB7J21pbic6bnVsbCwgJ21heCc6bnVsbH07XHJcblxyXG5cdHRoaXMuZWFjaENDKGZ1bmN0aW9uIChjY2lkLCBjYykge1xyXG5cdFx0YmIgPSB0aGlzLmNvbm5lY3RlZENvbXBvbmVudEdldEJvdW5kaW5nQm94KGNjaWQsIGNjLCBiYik7XHJcblx0fSwgdHlwZSwgdGhpcyk7XHJcblxyXG5cdHJldHVybiBiYjtcclxufTtcclxuXHJcbnJuZC5SZVN0cnVjdC5wcm90b3R5cGUuc2V0SHlkcm9nZW5Qb3MgPSBmdW5jdGlvbiAoKSB7XHJcblx0Ly8gY2hlY2sgd2hlcmUgc2hvdWxkIHRoZSBoeWRyb2dlbiBiZSBwdXQgb24gdGhlIGxlZnQgb2YgdGhlIGxhYmVsXHJcblx0Zm9yICh2YXIgYWlkIGluIHRoaXMuYXRvbXNDaGFuZ2VkKSB7XHJcblx0XHR2YXIgYXRvbSA9IHRoaXMuYXRvbXMuZ2V0KGFpZCk7XHJcblxyXG5cdFx0aWYgKGF0b20uYS5uZWlnaGJvcnMubGVuZ3RoID09IDApIHtcclxuXHRcdFx0dmFyIGVsZW0gPSBlbGVtZW50LmdldEVsZW1lbnRCeUxhYmVsKGF0b20uYS5sYWJlbCk7XHJcblx0XHRcdGlmIChlbGVtICE9IG51bGwpIHtcclxuXHRcdFx0XHRhdG9tLmh5ZHJvZ2VuT25UaGVMZWZ0ID0gZWxlbWVudC5nZXQoZWxlbSkucHV0SHlkcm9nZW5PblRoZUxlZnQ7XHJcblx0XHRcdH1cclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblx0XHR2YXIgeWwgPSAxLCB5ciA9IDEsIG5sID0gMCwgbnIgPSAwO1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhdG9tLmEubmVpZ2hib3JzLmxlbmd0aDsgKytpKSB7XHJcblx0XHRcdHZhciBkID0gdGhpcy5tb2xlY3VsZS5oYWxmQm9uZHMuZ2V0KGF0b20uYS5uZWlnaGJvcnNbaV0pLmRpcjtcclxuXHRcdFx0aWYgKGQueCA8PSAwKSB7XHJcblx0XHRcdFx0eWwgPSBNYXRoLm1pbih5bCwgTWF0aC5hYnMoZC55KSk7XHJcblx0XHRcdFx0bmwrKztcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR5ciA9IE1hdGgubWluKHlyLCBNYXRoLmFicyhkLnkpKTtcclxuXHRcdFx0XHRucisrO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAoeWwgPCAwLjUxIHx8IHlyIDwgMC41MSlcclxuXHRcdFx0YXRvbS5oeWRyb2dlbk9uVGhlTGVmdCA9IHlyIDwgeWw7XHJcblx0XHRlbHNlXHJcblx0XHRcdGF0b20uaHlkcm9nZW5PblRoZUxlZnQgPSBuciA+IG5sO1xyXG5cdH1cclxufTtcclxuXHJcbnJuZC5SZVN0cnVjdC5wcm90b3R5cGUuc2V0SW1wbGljaXRIeWRyb2dlbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQvLyBjYWxjdWxhdGUgaW1wbGljaXQgaHlkcm9nZW5zIGZvciBhdG9tcyB0aGF0IGhhdmUgYmVlbiBtb2RpZmllZFxyXG5cdHRoaXMubW9sZWN1bGUuc2V0SW1wbGljaXRIeWRyb2dlbih1dGlsLmlkTGlzdCh0aGlzLmF0b21zQ2hhbmdlZCkpO1xyXG59O1xyXG5cclxucm5kLlJlTG9vcCA9IGZ1bmN0aW9uIChsb29wKVxyXG57XHJcblx0dGhpcy5sb29wID0gbG9vcDtcclxuXHR0aGlzLnZpc2VsID0gbmV3IFZpc2VsKFZpc2VsLlRZUEUuTE9PUCk7XHJcblx0dGhpcy5jZW50cmUgPSBuZXcgVmVjMigpO1xyXG5cdHRoaXMucmFkaXVzID0gbmV3IFZlYzIoKTtcclxufTtcclxucm5kLlJlTG9vcC5wcm90b3R5cGUgPSBuZXcgcm5kLlJlT2JqZWN0KCk7XHJcbnJuZC5SZUxvb3AuaXNTZWxlY3RhYmxlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbnJuZC5SZVN0cnVjdC5wcm90b3R5cGUuY29vcmRQcm9jZXNzID0gZnVuY3Rpb24gKG5vcmVzY2FsZSlcclxue1xyXG5cdGlmICghbm9yZXNjYWxlKSB7XHJcblx0XHR0aGlzLm1vbGVjdWxlLnJlc2NhbGUoKTtcclxuXHR9XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QucHJvdG90eXBlLm5vdGlmeUF0b21BZGRlZCA9IGZ1bmN0aW9uIChhaWQpIHtcclxuXHR2YXIgYXRvbURhdGEgPSBuZXcgUmVBdG9tKHRoaXMubW9sZWN1bGUuYXRvbXMuZ2V0KGFpZCkpO1xyXG5cdGF0b21EYXRhLmNvbXBvbmVudCA9IHRoaXMuY29ubmVjdGVkQ29tcG9uZW50cy5hZGQoU2V0LnNpbmdsZShhaWQpKTtcclxuXHR0aGlzLmF0b21zLnNldChhaWQsIGF0b21EYXRhKTtcclxuXHR0aGlzLm1hcmtBdG9tKGFpZCwgMSk7XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QucHJvdG90eXBlLm5vdGlmeVJ4blBsdXNBZGRlZCA9IGZ1bmN0aW9uIChwbGlkKSB7XHJcblx0dGhpcy5yeG5QbHVzZXMuc2V0KHBsaWQsIG5ldyBybmQuUmVSeG5QbHVzKHRoaXMubW9sZWN1bGUucnhuUGx1c2VzLmdldChwbGlkKSkpO1xyXG59O1xyXG5cclxucm5kLlJlU3RydWN0LnByb3RvdHlwZS5ub3RpZnlSeG5BcnJvd0FkZGVkID0gZnVuY3Rpb24gKGFyaWQpIHtcclxuXHR0aGlzLnJ4bkFycm93cy5zZXQoYXJpZCwgbmV3IHJuZC5SZVJ4bkFycm93KHRoaXMubW9sZWN1bGUucnhuQXJyb3dzLmdldChhcmlkKSkpO1xyXG59O1xyXG5cclxucm5kLlJlU3RydWN0LnByb3RvdHlwZS5ub3RpZnlSeG5BcnJvd1JlbW92ZWQgPSBmdW5jdGlvbiAoYXJpZCkge1xyXG5cdHRoaXMubWFya0l0ZW1SZW1vdmVkKCk7XHJcblx0dGhpcy5jbGVhclZpc2VsKHRoaXMucnhuQXJyb3dzLmdldChhcmlkKS52aXNlbCk7XHJcblx0dGhpcy5yeG5BcnJvd3MudW5zZXQoYXJpZCk7XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QucHJvdG90eXBlLm5vdGlmeVJ4blBsdXNSZW1vdmVkID0gZnVuY3Rpb24gKHBsaWQpIHtcclxuXHR0aGlzLm1hcmtJdGVtUmVtb3ZlZCgpO1xyXG5cdHRoaXMuY2xlYXJWaXNlbCh0aGlzLnJ4blBsdXNlcy5nZXQocGxpZCkudmlzZWwpO1xyXG5cdHRoaXMucnhuUGx1c2VzLnVuc2V0KHBsaWQpO1xyXG59O1xyXG5cclxucm5kLlJlU3RydWN0LnByb3RvdHlwZS5ub3RpZnlCb25kQWRkZWQgPSBmdW5jdGlvbiAoYmlkKSB7XHJcblx0dGhpcy5ib25kcy5zZXQoYmlkLCBuZXcgUmVCb25kKHRoaXMubW9sZWN1bGUuYm9uZHMuZ2V0KGJpZCkpKTtcclxuXHR0aGlzLm1hcmtCb25kKGJpZCwgMSk7XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QucHJvdG90eXBlLm5vdGlmeUF0b21SZW1vdmVkID0gZnVuY3Rpb24gKGFpZCkge1xyXG5cdHZhciBhdG9tID0gdGhpcy5hdG9tcy5nZXQoYWlkKTtcclxuXHR2YXIgc2V0ID0gdGhpcy5jb25uZWN0ZWRDb21wb25lbnRzLmdldChhdG9tLmNvbXBvbmVudCk7XHJcblx0U2V0LnJlbW92ZShzZXQsIGFpZCk7XHJcblx0aWYgKFNldC5zaXplKHNldCkgPT0gMCkge1xyXG5cdFx0dGhpcy5jb25uZWN0ZWRDb21wb25lbnRzLnJlbW92ZShhdG9tLmNvbXBvbmVudCk7XHJcblx0fVxyXG5cdHRoaXMuY2xlYXJWaXNlbChhdG9tLnZpc2VsKTtcclxuXHR0aGlzLmF0b21zLnVuc2V0KGFpZCk7XHJcblx0dGhpcy5tYXJrSXRlbVJlbW92ZWQoKTtcclxufTtcclxuXHJcbnJuZC5SZVN0cnVjdC5wcm90b3R5cGUubm90aWZ5Qm9uZFJlbW92ZWQgPSBmdW5jdGlvbiAoYmlkKSB7XHJcblx0dmFyIGJvbmQgPSB0aGlzLmJvbmRzLmdldChiaWQpO1xyXG5cdFtib25kLmIuaGIxLCBib25kLmIuaGIyXS5lYWNoKGZ1bmN0aW9uIChoYmlkKSB7XHJcblx0XHR2YXIgaGIgPSB0aGlzLm1vbGVjdWxlLmhhbGZCb25kcy5nZXQoaGJpZCk7XHJcblx0XHRpZiAoaGIubG9vcCA+PSAwKVxyXG5cdFx0XHR0aGlzLmxvb3BSZW1vdmUoaGIubG9vcCk7XHJcblx0fSwgdGhpcyk7XHJcblx0dGhpcy5jbGVhclZpc2VsKGJvbmQudmlzZWwpO1xyXG5cdHRoaXMuYm9uZHMudW5zZXQoYmlkKTtcclxuXHR0aGlzLm1hcmtJdGVtUmVtb3ZlZCgpO1xyXG59O1xyXG5cclxucm5kLlJlU3RydWN0LnByb3RvdHlwZS5sb29wUmVtb3ZlID0gZnVuY3Rpb24gKGxvb3BJZClcclxue1xyXG5cdGlmICghdGhpcy5yZWxvb3BzLmhhcyhsb29wSWQpKVxyXG5cdFx0cmV0dXJuO1xyXG5cdHZhciByZWxvb3AgPSB0aGlzLnJlbG9vcHMuZ2V0KGxvb3BJZCk7XHJcblx0dGhpcy5jbGVhclZpc2VsKHJlbG9vcC52aXNlbCk7XHJcblx0dmFyIGJvbmRsaXN0ID0gW107XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCByZWxvb3AubG9vcC5oYnMubGVuZ3RoOyArK2kpIHtcclxuXHRcdHZhciBoYmlkID0gcmVsb29wLmxvb3AuaGJzW2ldO1xyXG5cdFx0aWYgKCF0aGlzLm1vbGVjdWxlLmhhbGZCb25kcy5oYXMoaGJpZCkpXHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0dmFyIGhiID0gdGhpcy5tb2xlY3VsZS5oYWxmQm9uZHMuZ2V0KGhiaWQpO1xyXG5cdFx0aGIubG9vcCA9IC0xO1xyXG5cdFx0dGhpcy5tYXJrQm9uZChoYi5iaWQsIDEpO1xyXG5cdFx0dGhpcy5tYXJrQXRvbShoYi5iZWdpbiwgMSk7XHJcblx0XHRib25kbGlzdC5wdXNoKGhiLmJpZCk7XHJcblx0fVxyXG5cdHRoaXMucmVsb29wcy51bnNldChsb29wSWQpO1xyXG5cdHRoaXMubW9sZWN1bGUubG9vcHMucmVtb3ZlKGxvb3BJZCk7XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QucHJvdG90eXBlLmxvb3BJc1ZhbGlkID0gZnVuY3Rpb24gKHJsaWQsIHJlbG9vcCkge1xyXG5cdHZhciBoYWxmQm9uZHMgPSB0aGlzLm1vbGVjdWxlLmhhbGZCb25kcztcclxuXHR2YXIgbG9vcCA9IHJlbG9vcC5sb29wO1xyXG5cdHZhciBiYWQgPSBmYWxzZTtcclxuXHRsb29wLmhicy5lYWNoKGZ1bmN0aW9uIChoYmlkKXtcclxuXHRcdGlmICghaGFsZkJvbmRzLmhhcyhoYmlkKSB8fCBoYWxmQm9uZHMuZ2V0KGhiaWQpLmxvb3AgIT09IHJsaWQpIHtcclxuXHRcdFx0YmFkID0gdHJ1ZTtcclxuXHRcdH1cclxuXHR9LCB0aGlzKTtcclxuXHRyZXR1cm4gIWJhZDtcclxufTtcclxuXHJcbnJuZC5SZVN0cnVjdC5wcm90b3R5cGUudmVyaWZ5TG9vcHMgPSBmdW5jdGlvbiAoKVxyXG57XHJcblx0dmFyIHRvUmVtb3ZlID0gW107XHJcblx0dGhpcy5yZWxvb3BzLmVhY2goZnVuY3Rpb24gKHJsaWQsIHJlbG9vcCl7XHJcblx0XHRpZiAoIXRoaXMubG9vcElzVmFsaWQocmxpZCwgcmVsb29wKSkge1xyXG5cdFx0XHR0b1JlbW92ZS5wdXNoKHJsaWQpO1xyXG5cdFx0fVxyXG5cdH0sIHRoaXMpO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdG9SZW1vdmUubGVuZ3RoOyArK2kpIHtcclxuXHRcdHRoaXMubG9vcFJlbW92ZSh0b1JlbW92ZVtpXSk7XHJcblx0fVxyXG59O1xyXG5cclxucm5kLlJlU3RydWN0LnByb3RvdHlwZS5CRlMgPSBmdW5jdGlvbiAob25BdG9tLCBvcmlnLCBjb250ZXh0KSB7XHJcblx0b3JpZyA9IG9yaWcgLSAwO1xyXG5cdHZhciBxdWV1ZSA9IG5ldyBBcnJheSgpO1xyXG5cdHZhciBtYXNrID0ge307XHJcblx0cXVldWUucHVzaChvcmlnKTtcclxuXHRtYXNrW29yaWddID0gMTtcclxuXHR3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xyXG5cdFx0dmFyIGFpZCA9IHF1ZXVlLnNoaWZ0KCk7XHJcblx0XHRvbkF0b20uY2FsbChjb250ZXh0LCBhaWQpO1xyXG5cdFx0dmFyIGF0b20gPSB0aGlzLmF0b21zLmdldChhaWQpO1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhdG9tLmEubmVpZ2hib3JzLmxlbmd0aDsgKytpKSB7XHJcblx0XHRcdHZhciBuZWkgPSBhdG9tLmEubmVpZ2hib3JzW2ldO1xyXG5cdFx0XHR2YXIgaGIgPSB0aGlzLm1vbGVjdWxlLmhhbGZCb25kcy5nZXQobmVpKTtcclxuXHRcdFx0aWYgKCFtYXNrW2hiLmVuZF0pIHtcclxuXHRcdFx0XHRtYXNrW2hiLmVuZF0gPSAxO1xyXG5cdFx0XHRcdHF1ZXVlLnB1c2goaGIuZW5kKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbnJuZC5SZVJ4blBsdXMgPSBmdW5jdGlvbiAoLypjaGVtLlJ4blBsdXMqL3BsdXMpXHJcbntcclxuXHR0aGlzLmluaXQoVmlzZWwuVFlQRS5QTFVTKTtcclxuXHJcblx0dGhpcy5pdGVtID0gcGx1cztcclxufTtcclxucm5kLlJlUnhuUGx1cy5wcm90b3R5cGUgPSBuZXcgcm5kLlJlT2JqZWN0KCk7XHJcbnJuZC5SZVJ4blBsdXMuaXNTZWxlY3RhYmxlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxucm5kLlJlUnhuUGx1cy5wcm90b3R5cGUuaGlnaGxpZ2h0UGF0aCA9IGZ1bmN0aW9uIChyZW5kZXIpIHtcclxuXHR2YXIgcCA9IHJlbmRlci5wcyh0aGlzLml0ZW0ucHApO1xyXG5cdHZhciBzID0gcmVuZGVyLnNldHRpbmdzLnNjYWxlRmFjdG9yO1xyXG5cdHJldHVybiByZW5kZXIucGFwZXIucmVjdChwLnggLSBzIC8gNCwgcC55IC0gcyAvIDQsIHMgLyAyLCBzIC8gMiwgcyAvIDgpO1xyXG59O1xyXG5cclxucm5kLlJlUnhuUGx1cy5wcm90b3R5cGUuZHJhd0hpZ2hsaWdodCA9IGZ1bmN0aW9uIChyZW5kZXIpIHtcclxuXHR2YXIgcmV0ID0gdGhpcy5oaWdobGlnaHRQYXRoKHJlbmRlcikuYXR0cihyZW5kZXIuc3R5bGVzLmhpZ2hsaWdodFN0eWxlKTtcclxuXHRyZW5kZXIuY3RhYi5hZGRSZU9iamVjdFBhdGgoJ2hpZ2hsaWdodGluZycsIHRoaXMudmlzZWwsIHJldCk7XHJcblx0cmV0dXJuIHJldDtcclxufTtcclxuXHJcbnJuZC5SZVJ4blBsdXMucHJvdG90eXBlLm1ha2VTZWxlY3Rpb25QbGF0ZSA9IGZ1bmN0aW9uIChyZXN0cnVjdCwgcGFwZXIsIHN0eWxlcykgeyAvLyBUT0RPIFtNS10gcmV2aWV3IHBhcmFtZXRlcnNcclxuXHRyZXR1cm4gdGhpcy5oaWdobGlnaHRQYXRoKHJlc3RydWN0LnJlbmRlcikuYXR0cihzdHlsZXMuc2VsZWN0aW9uU3R5bGUpO1xyXG59O1xyXG5cclxucm5kLlJlUnhuQXJyb3cgPSBmdW5jdGlvbiAoLypjaGVtLlJ4bkFycm93Ki9hcnJvdylcclxue1xyXG5cdHRoaXMuaW5pdChWaXNlbC5UWVBFLkFSUk9XKTtcclxuXHJcblx0dGhpcy5pdGVtID0gYXJyb3c7XHJcbn07XHJcbnJuZC5SZVJ4bkFycm93LnByb3RvdHlwZSA9IG5ldyBybmQuUmVPYmplY3QoKTtcclxucm5kLlJlUnhuQXJyb3cuaXNTZWxlY3RhYmxlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxucm5kLlJlUnhuQXJyb3cucHJvdG90eXBlLmhpZ2hsaWdodFBhdGggPSBmdW5jdGlvbiAocmVuZGVyKSB7XHJcblx0dmFyIHAgPSByZW5kZXIucHModGhpcy5pdGVtLnBwKTtcclxuXHR2YXIgcyA9IHJlbmRlci5zZXR0aW5ncy5zY2FsZUZhY3RvcjtcclxuXHRyZXR1cm4gcmVuZGVyLnBhcGVyLnJlY3QocC54IC0gcywgcC55IC0gcyAvIDQsIDIgKiBzLCBzIC8gMiwgcyAvIDgpO1xyXG59O1xyXG5cclxucm5kLlJlUnhuQXJyb3cucHJvdG90eXBlLmRyYXdIaWdobGlnaHQgPSBmdW5jdGlvbiAocmVuZGVyKSB7XHJcblx0dmFyIHJldCA9IHRoaXMuaGlnaGxpZ2h0UGF0aChyZW5kZXIpLmF0dHIocmVuZGVyLnN0eWxlcy5oaWdobGlnaHRTdHlsZSk7XHJcblx0cmVuZGVyLmN0YWIuYWRkUmVPYmplY3RQYXRoKCdoaWdobGlnaHRpbmcnLCB0aGlzLnZpc2VsLCByZXQpO1xyXG5cdHJldHVybiByZXQ7XHJcbn07XHJcblxyXG5ybmQuUmVSeG5BcnJvdy5wcm90b3R5cGUubWFrZVNlbGVjdGlvblBsYXRlID0gZnVuY3Rpb24gKHJlc3RydWN0LCBwYXBlciwgc3R5bGVzKSB7XHJcblx0cmV0dXJuIHRoaXMuaGlnaGxpZ2h0UGF0aChyZXN0cnVjdC5yZW5kZXIpLmF0dHIoc3R5bGVzLnNlbGVjdGlvblN0eWxlKTtcclxufTtcclxuXHJcbnJuZC5SZUZyYWcgPSBmdW5jdGlvbiAoLypTdHJ1Y3QuRnJhZ21lbnQqL2ZyYWcpIHtcclxuXHR0aGlzLmluaXQoVmlzZWwuVFlQRS5GUkFHTUVOVCk7XHJcblxyXG5cdHRoaXMuaXRlbSA9IGZyYWc7XHJcbn07XHJcbnJuZC5SZUZyYWcucHJvdG90eXBlID0gbmV3IHJuZC5SZU9iamVjdCgpO1xyXG5ybmQuUmVGcmFnLmlzU2VsZWN0YWJsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9O1xyXG5cclxuXHJcbnJuZC5SZUZyYWcucHJvdG90eXBlLmZyYWdHZXRBdG9tcyA9IGZ1bmN0aW9uIChyZW5kZXIsIGZpZCkge1xyXG5cdHZhciByZXQgPSBbXTtcclxuXHRyZW5kZXIuY3RhYi5hdG9tcy5lYWNoKGZ1bmN0aW9uIChhaWQsIGF0b20pIHtcclxuXHRcdGlmIChhdG9tLmEuZnJhZ21lbnQgPT0gZmlkKSB7XHJcblx0XHRcdHJldC5wdXNoKGFpZCk7XHJcblx0XHR9XHJcblx0fSwgdGhpcyk7XHJcblx0cmV0dXJuIHJldDtcclxufTtcclxuXHJcbnJuZC5SZUZyYWcucHJvdG90eXBlLmZyYWdHZXRCb25kcyA9IGZ1bmN0aW9uIChyZW5kZXIsIGZpZCkge1xyXG5cdHZhciByZXQgPSBbXTtcclxuXHRyZW5kZXIuY3RhYi5ib25kcy5lYWNoKGZ1bmN0aW9uIChiaWQsIGJvbmQpIHtcclxuXHRcdGlmIChyZW5kZXIuY3RhYi5hdG9tcy5nZXQoYm9uZC5iLmJlZ2luKS5hLmZyYWdtZW50ID09IGZpZCAmJlxyXG5cdFx0cmVuZGVyLmN0YWIuYXRvbXMuZ2V0KGJvbmQuYi5lbmQpLmEuZnJhZ21lbnQgPT0gZmlkKSB7XHJcblx0XHRcdHJldC5wdXNoKGJpZCk7XHJcblx0XHR9XHJcblx0fSwgdGhpcyk7XHJcblx0cmV0dXJuIHJldDtcclxufTtcclxuXHJcbnJuZC5SZUZyYWcucHJvdG90eXBlLmNhbGNCQm94ID0gZnVuY3Rpb24gKHJlbmRlciwgZmlkKSB7IC8vIFRPRE8gbmVlZCB0byByZXZpZXcgcGFyYW1ldGVyIGxpc3RcclxuXHR2YXIgcmV0O1xyXG5cdHJlbmRlci5jdGFiLmF0b21zLmVhY2goZnVuY3Rpb24gKGFpZCwgYXRvbSkge1xyXG5cdFx0aWYgKGF0b20uYS5mcmFnbWVudCA9PSBmaWQpIHtcclxuXHRcdFx0Ly8gVE9ETyBSZU9iamVjdC5jYWxjQkJveCB0byBiZSB1c2VkIGluc3RlYWRcclxuXHRcdFx0dmFyIGJiYSA9IGF0b20udmlzZWwuYm91bmRpbmdCb3g7XHJcblx0XHRcdGlmICghYmJhKSB7XHJcblx0XHRcdFx0YmJhID0gbmV3IEJveDJBYnMoYXRvbS5hLnBwLCBhdG9tLmEucHApO1xyXG5cdFx0XHRcdHZhciBleHQgPSBuZXcgVmVjMigwLjA1ICogMywgMC4wNSAqIDMpO1xyXG5cdFx0XHRcdGJiYSA9IGJiYS5leHRlbmQoZXh0LCBleHQpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGJiYSA9IGJiYS50cmFuc2xhdGUoKHJlbmRlci5vZmZzZXQgfHwgbmV3IFZlYzIoKSkubmVnYXRlZCgpKS50cmFuc2Zvcm0ocmVuZGVyLnNjYWxlZDJvYmosIHJlbmRlcik7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0ID0gKHJldCA/IEJveDJBYnMudW5pb24ocmV0LCBiYmEpIDogYmJhKTtcclxuXHRcdH1cclxuXHR9LCB0aGlzKTtcclxuXHRyZXR1cm4gcmV0O1xyXG59O1xyXG5cclxucm5kLlJlRnJhZy5wcm90b3R5cGUuX2RyYXcgPSBmdW5jdGlvbiAocmVuZGVyLCBmaWQsIGF0dHJzKSB7IC8vIFRPRE8gbmVlZCB0byByZXZpZXcgcGFyYW1ldGVyIGxpc3RcclxuXHR2YXIgYmIgPSB0aGlzLmNhbGNCQm94KHJlbmRlciwgZmlkKTtcclxuXHRpZiAoYmIpIHtcclxuXHRcdHZhciBwMCA9IHJlbmRlci5vYmoyc2NhbGVkKG5ldyBWZWMyKGJiLnAwLngsIGJiLnAwLnkpKTtcclxuXHRcdHZhciBwMSA9IHJlbmRlci5vYmoyc2NhbGVkKG5ldyBWZWMyKGJiLnAxLngsIGJiLnAxLnkpKTtcclxuXHRcdHJldHVybiByZW5kZXIucGFwZXIucmVjdChwMC54LCBwMC55LCBwMS54IC0gcDAueCwgcDEueSAtIHAwLnksIDApLmF0dHIoYXR0cnMpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHQvLyBUT0RPIGFibm9ybWFsIHNpdHVhdGlvbiwgZW1wdHkgZnJhZ21lbnRzIG11c3QgYmUgZGVzdHJveWVkIGJ5IHRvb2xzXHJcblx0fVxyXG59O1xyXG5cclxucm5kLlJlRnJhZy5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChyZW5kZXIpIHtcclxuXHRyZXR1cm4gbnVsbDsvL3RoaXMuX2RyYXcocmVuZGVyLCBmaWQsIHsgJ3N0cm9rZScgOiAnbGlnaHRncmF5JyB9KTsgLy8gW1JCXSBmb3IgZGVidWdnaW5nIG9ubHlcclxufTtcclxuXHJcbnJuZC5SZUZyYWcucHJvdG90eXBlLmRyYXdIaWdobGlnaHQgPSBmdW5jdGlvbiAocmVuZGVyKSB7XHJcblx0Ly8gRG8gbm90aGluZy4gVGhpcyBtZXRob2Qgc2hvdWxkbid0IGFjdHVhbGx5IGJlIGNhbGxlZC5cclxufVxyXG5cclxucm5kLlJlRnJhZy5wcm90b3R5cGUuc2V0SGlnaGxpZ2h0ID0gZnVuY3Rpb24gKGhpZ2hMaWdodCwgcmVuZGVyKSB7XHJcblx0dmFyIGZpZCA9IHJlbmRlci5jdGFiLmZyYWdzLmtleU9mKHRoaXMpO1xyXG5cdGlmICghT2JqZWN0LmlzVW5kZWZpbmVkKGZpZCkpIHtcclxuXHRcdHJlbmRlci5jdGFiLmF0b21zLmVhY2goZnVuY3Rpb24gKGFpZCwgYXRvbSkge1xyXG5cdFx0XHRpZiAoYXRvbS5hLmZyYWdtZW50ID09IGZpZCkge1xyXG5cdFx0XHRcdGF0b20uc2V0SGlnaGxpZ2h0KGhpZ2hMaWdodCwgcmVuZGVyKTtcclxuXHRcdFx0fVxyXG5cdFx0fSwgdGhpcyk7XHJcblx0XHRyZW5kZXIuY3RhYi5ib25kcy5lYWNoKGZ1bmN0aW9uIChiaWQsIGJvbmQpIHtcclxuXHRcdFx0aWYgKHJlbmRlci5jdGFiLmF0b21zLmdldChib25kLmIuYmVnaW4pLmEuZnJhZ21lbnQgPT0gZmlkKVxyXG5cdFx0XHRcdGJvbmQuc2V0SGlnaGxpZ2h0KGhpZ2hMaWdodCwgcmVuZGVyKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHQvLyBUT0RPIGFibm9ybWFsIHNpdHVhdGlvbiwgZnJhZ21lbnQgZG9lcyBub3QgYmVsb25nIHRvIHRoZSByZW5kZXJcclxuXHR9XHJcbn07XHJcblxyXG5ybmQuUmVSR3JvdXAgPSBmdW5jdGlvbiAoLypTdHJ1Y3QuUkdyb3VwKi9yZ3JvdXApIHtcclxuXHR0aGlzLmluaXQoVmlzZWwuVFlQRS5SR1JPVVApO1xyXG5cclxuXHR0aGlzLmxhYmVsQm94ID0gbnVsbDtcclxuXHR0aGlzLml0ZW0gPSByZ3JvdXA7XHJcbn07XHJcbnJuZC5SZVJHcm91cC5wcm90b3R5cGUgPSBuZXcgcm5kLlJlT2JqZWN0KCk7XHJcbnJuZC5SZVJHcm91cC5pc1NlbGVjdGFibGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxucm5kLlJlUkdyb3VwLnByb3RvdHlwZS5nZXRBdG9tcyA9IGZ1bmN0aW9uIChyZW5kZXIpIHtcclxuXHR2YXIgcmV0ID0gW107XHJcblx0dGhpcy5pdGVtLmZyYWdzLmVhY2goZnVuY3Rpb24gKGZudW0sIGZpZCkge1xyXG5cdFx0cmV0ID0gcmV0LmNvbmNhdChyZW5kZXIuY3RhYi5mcmFncy5nZXQoZmlkKS5mcmFnR2V0QXRvbXMocmVuZGVyLCBmaWQpKTtcclxuXHR9KTtcclxuXHRyZXR1cm4gcmV0O1xyXG59O1xyXG5cclxucm5kLlJlUkdyb3VwLnByb3RvdHlwZS5nZXRCb25kcyA9IGZ1bmN0aW9uIChyZW5kZXIpIHtcclxuXHR2YXIgcmV0ID0gW107XHJcblx0dGhpcy5pdGVtLmZyYWdzLmVhY2goZnVuY3Rpb24gKGZudW0sIGZpZCkge1xyXG5cdFx0cmV0ID0gcmV0LmNvbmNhdChyZW5kZXIuY3RhYi5mcmFncy5nZXQoZmlkKS5mcmFnR2V0Qm9uZHMocmVuZGVyLCBmaWQpKTtcclxuXHR9KTtcclxuXHRyZXR1cm4gcmV0O1xyXG59O1xyXG5cclxucm5kLlJlUkdyb3VwLnByb3RvdHlwZS5jYWxjQkJveCA9IGZ1bmN0aW9uIChyZW5kZXIpIHtcclxuXHR2YXIgcmV0O1xyXG5cdHRoaXMuaXRlbS5mcmFncy5lYWNoKGZ1bmN0aW9uIChmbnVtLCBmaWQpIHtcclxuXHRcdHZhciBiYmYgPSByZW5kZXIuY3RhYi5mcmFncy5nZXQoZmlkKS5jYWxjQkJveChyZW5kZXIsIGZpZCk7XHJcblx0XHRpZiAoYmJmKSB7XHJcblx0XHRcdHJldCA9IChyZXQgPyBCb3gyQWJzLnVuaW9uKHJldCwgYmJmKSA6IGJiZik7XHJcblx0XHR9XHJcblx0fSk7XHJcblx0cmV0ID0gcmV0LmV4dGVuZCh0aGlzLl9fZXh0LCB0aGlzLl9fZXh0KTtcclxuXHRyZXR1cm4gcmV0O1xyXG59O1xyXG5cclxucm5kLlJlUkdyb3VwLmRyYXdCcmFja2V0cyA9IGZ1bmN0aW9uIChzZXQsIHJlbmRlciwgYmIsIGQsIG4pIHtcclxuXHRkID0gZCB8fCBuZXcgVmVjMigxLCAwKTtcclxuXHR2YXIgYnJhY2tldFdpZHRoID0gTWF0aC5taW4oMC4yNSwgYmIuc3ooKS54ICogMC4zKTtcclxuXHR2YXIgaGVpZ2h0ID0gYmIucDEueSAtIGJiLnAwLnk7XHJcblx0dmFyIGN5ID0gMC41ICogKGJiLnAxLnkgKyBiYi5wMC55KTtcclxuXHR2YXIgbGVmdEJyYWNrZXQgPSBTR3JvdXAuZHJhd0JyYWNrZXQocmVuZGVyLCByZW5kZXIucGFwZXIsIHJlbmRlci5zdHlsZXMsIGQubmVnYXRlZCgpLCBkLm5lZ2F0ZWQoKS5yb3RhdGVTQygxLCAwKSwgbmV3IFZlYzIoYmIucDAueCwgY3kpLCBicmFja2V0V2lkdGgsIGhlaWdodCk7XHJcblx0dmFyIHJpZ2h0QnJhY2tldCA9IFNHcm91cC5kcmF3QnJhY2tldChyZW5kZXIsIHJlbmRlci5wYXBlciwgcmVuZGVyLnN0eWxlcywgZCwgZC5yb3RhdGVTQygxLCAwKSwgbmV3IFZlYzIoYmIucDEueCwgY3kpLCBicmFja2V0V2lkdGgsIGhlaWdodCk7XHJcblx0c2V0LnB1c2gobGVmdEJyYWNrZXQsIHJpZ2h0QnJhY2tldCk7XHJcbn07XHJcblxyXG5ybmQuUmVSR3JvdXAucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAocmVuZGVyKSB7IC8vIFRPRE8gbmVlZCB0byByZXZpZXcgcGFyYW1ldGVyIGxpc3RcclxuXHR2YXIgYmIgPSB0aGlzLmNhbGNCQm94KHJlbmRlcik7XHJcblx0dmFyIHNldHRpbmdzID0gcmVuZGVyLnNldHRpbmdzO1xyXG5cdGlmIChiYikge1xyXG5cdFx0dmFyIHJldCA9IHsgJ2RhdGEnOiBbXSB9O1xyXG5cdFx0dmFyIHAwID0gcmVuZGVyLm9iajJzY2FsZWQoYmIucDApO1xyXG5cdFx0dmFyIHAxID0gcmVuZGVyLm9iajJzY2FsZWQoYmIucDEpO1xyXG5cdFx0dmFyIGJyYWNrZXRzID0gcmVuZGVyLnBhcGVyLnNldCgpO1xyXG5cdFx0cm5kLlJlUkdyb3VwLmRyYXdCcmFja2V0cyhicmFja2V0cywgcmVuZGVyLCBiYik7XHJcblx0XHRyZXQuZGF0YS5wdXNoKGJyYWNrZXRzKTtcclxuXHRcdHZhciBrZXkgPSByZW5kZXIuY3RhYi5yZ3JvdXBzLmtleU9mKHRoaXMpO1xyXG5cdFx0dmFyIGxhYmVsU2V0ID0gcmVuZGVyLnBhcGVyLnNldCgpO1xyXG5cdFx0dmFyIGxhYmVsID0gcmVuZGVyLnBhcGVyLnRleHQocDAueCwgKHAwLnkgKyBwMS55KSAvIDIsICdSJyArIGtleSArICc9JylcclxuXHRcdC5hdHRyKHtcclxuXHRcdFx0J2ZvbnQnOiBzZXR0aW5ncy5mb250LFxyXG5cdFx0XHQnZm9udC1zaXplJzogc2V0dGluZ3MuZm9udFJMYWJlbCxcclxuXHRcdFx0J2ZpbGwnOiAnYmxhY2snXHJcblx0XHR9KTtcclxuXHRcdHZhciBsYWJlbEJveCA9IHV0aWwucmVsQm94KGxhYmVsLmdldEJCb3goKSk7XHJcblx0XHRsYWJlbC50cmFuc2xhdGVBYnMoLWxhYmVsQm94LndpZHRoIC8gMiAtIHNldHRpbmdzLmxpbmVXaWR0aCwgMCk7XHJcblx0XHRsYWJlbFNldC5wdXNoKGxhYmVsKTtcclxuXHRcdHZhciBsb2dpY1N0eWxlID0ge1xyXG5cdFx0XHQnZm9udCc6IHNldHRpbmdzLmZvbnQsXHJcblx0XHRcdCdmb250LXNpemUnOiBzZXR0aW5ncy5mb250UkxvZ2ljLFxyXG5cdFx0XHQnZmlsbCc6ICdibGFjaydcclxuXHRcdH07XHJcblxyXG5cdFx0dmFyIGxvZ2ljID0gW107XHJcblx0XHQvLyBUT0RPIFtSQl0gdGVtcG9yYXJ5IHNvbHV0aW9uLCBuZWVkIHRvIHJldmlld1xyXG5cdFx0Ly9CRUdJTlxyXG5cdFx0LypcclxuICAgICAgICAgaWYgKHRoaXMuaXRlbS5yYW5nZS5sZW5ndGggPiAwKVxyXG4gICAgICAgICBsb2dpYy5wdXNoKHRoaXMuaXRlbS5yYW5nZSk7XHJcbiAgICAgICAgIGlmICh0aGlzLml0ZW0ucmVzdGgpXHJcbiAgICAgICAgIGxvZ2ljLnB1c2goXCJSZXN0SFwiKTtcclxuICAgICAgICAgaWYgKHRoaXMuaXRlbS5pZnRoZW4gPiAwKVxyXG4gICAgICAgICBsb2dpYy5wdXNoKFwiSUYgUlwiICsga2V5LnRvU3RyaW5nKCkgKyBcIiBUSEVOIFJcIiArIHRoaXMuaXRlbS5pZnRoZW4udG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICovXHJcblx0XHRsb2dpYy5wdXNoKFxyXG5cdFx0XHQodGhpcy5pdGVtLmlmdGhlbiA+IDAgPyAnSUYgJyA6ICcnKVxyXG5cdFx0XHQgKyAnUicgKyBrZXkudG9TdHJpbmcoKVxyXG5cdFx0XHQgKyAodGhpcy5pdGVtLnJhbmdlLmxlbmd0aCA+IDBcclxuXHRcdFx0ID8gdGhpcy5pdGVtLnJhbmdlLnN0YXJ0c1dpdGgoJz4nKSB8fCB0aGlzLml0ZW0ucmFuZ2Uuc3RhcnRzV2l0aCgnPCcpIHx8IHRoaXMuaXRlbS5yYW5nZS5zdGFydHNXaXRoKCc9JylcclxuXHRcdFx0XHQgPyB0aGlzLml0ZW0ucmFuZ2VcclxuXHRcdFx0XHQgOiAnPScgKyB0aGlzLml0ZW0ucmFuZ2VcclxuXHRcdFx0IDogJz4wJylcclxuXHRcdFx0ICsgKHRoaXMuaXRlbS5yZXN0aCA/ICcgKFJlc3RIKScgOiAnJylcclxuXHRcdFx0ICsgKHRoaXMuaXRlbS5pZnRoZW4gPiAwID8gJ1xcblRIRU4gUicgKyB0aGlzLml0ZW0uaWZ0aGVuLnRvU3RyaW5nKCkgOiAnJylcclxuXHRcdCk7XHJcblx0XHQvL0VORFxyXG5cdFx0dmFyIHNoaWZ0ID0gbGFiZWxCb3guaGVpZ2h0IC8gMiArIHNldHRpbmdzLmxpbmVXaWR0aCAvIDI7XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxvZ2ljLmxlbmd0aDsgKytpKSB7XHJcblx0XHRcdHZhciBsb2dpY1BhdGggPSByZW5kZXIucGFwZXIudGV4dChwMC54LCAocDAueSArIHAxLnkpIC8gMiwgbG9naWNbaV0pLmF0dHIobG9naWNTdHlsZSk7XHJcblx0XHRcdHZhciBsb2dpY0JveCA9IHV0aWwucmVsQm94KGxvZ2ljUGF0aC5nZXRCQm94KCkpO1xyXG5cdFx0XHRzaGlmdCArPSBsb2dpY0JveC5oZWlnaHQgLyAyO1xyXG5cdFx0XHRsb2dpY1BhdGgudHJhbnNsYXRlQWJzKC1sb2dpY0JveC53aWR0aCAvIDIgLSA2ICogc2V0dGluZ3MubGluZVdpZHRoLCBzaGlmdCk7XHJcblx0XHRcdHNoaWZ0ICs9IGxvZ2ljQm94LmhlaWdodCAvIDIgKyBzZXR0aW5ncy5saW5lV2lkdGggLyAyO1xyXG5cdFx0XHRyZXQuZGF0YS5wdXNoKGxvZ2ljUGF0aCk7XHJcblx0XHRcdGxhYmVsU2V0LnB1c2gobG9naWNQYXRoKTtcclxuXHRcdH1cclxuXHRcdHJldC5kYXRhLnB1c2gobGFiZWwpO1xyXG5cdFx0dGhpcy5sYWJlbEJveCA9IEJveDJBYnMuZnJvbVJlbEJveChsYWJlbFNldC5nZXRCQm94KCkpLnRyYW5zZm9ybShyZW5kZXIuc2NhbGVkMm9iaiwgcmVuZGVyKTtcclxuXHRcdHJldHVybiByZXQ7XHJcblx0fSBlbHNlIHtcclxuXHRcdC8vIFRPRE8gYWJub3JtYWwgc2l0dWF0aW9uLCBlbXB0eSBmcmFnbWVudHMgbXVzdCBiZSBkZXN0cm95ZWQgYnkgdG9vbHNcclxuXHRcdHJldHVybiB7fTtcclxuXHR9XHJcbn07XHJcblxyXG5ybmQuUmVSR3JvdXAucHJvdG90eXBlLl9kcmF3ID0gZnVuY3Rpb24gKHJlbmRlciwgcmdpZCwgYXR0cnMpIHsgLy8gVE9ETyBuZWVkIHRvIHJldmlldyBwYXJhbWV0ZXIgbGlzdFxyXG5cdHZhciBiYiA9IHRoaXMuZ2V0VkJveE9iaihyZW5kZXIpLmV4dGVuZCh0aGlzLl9fZXh0LCB0aGlzLl9fZXh0KTtcclxuXHRpZiAoYmIpIHtcclxuXHRcdHZhciBwMCA9IHJlbmRlci5vYmoyc2NhbGVkKGJiLnAwKTtcclxuXHRcdHZhciBwMSA9IHJlbmRlci5vYmoyc2NhbGVkKGJiLnAxKTtcclxuXHRcdHJldHVybiByZW5kZXIucGFwZXIucmVjdChwMC54LCBwMC55LCBwMS54IC0gcDAueCwgcDEueSAtIHAwLnksIDApLmF0dHIoYXR0cnMpO1xyXG5cdH1cclxufTtcclxuXHJcbnJuZC5SZVJHcm91cC5wcm90b3R5cGUuZHJhd0hpZ2hsaWdodCA9IGZ1bmN0aW9uIChyZW5kZXIpIHtcclxuXHR2YXIgcmdpZCA9IHJlbmRlci5jdGFiLnJncm91cHMua2V5T2YodGhpcyk7XHJcblx0aWYgKCFPYmplY3QuaXNVbmRlZmluZWQocmdpZCkpIHtcclxuXHRcdHZhciByZXQgPSB0aGlzLl9kcmF3KHJlbmRlciwgcmdpZCwgcmVuZGVyLnN0eWxlcy5oaWdobGlnaHRTdHlsZS8qeyAnZmlsbCcgOiAncmVkJyB9Ki8pO1xyXG5cdFx0cmVuZGVyLmN0YWIuYWRkUmVPYmplY3RQYXRoKCdoaWdobGlnaHRpbmcnLCB0aGlzLnZpc2VsLCByZXQpO1xyXG5cdFx0LypcclxuICAgICAgICAgdGhpcy5nZXRBdG9tcyhyZW5kZXIpLmVhY2goZnVuY3Rpb24oYWlkKSB7XHJcbiAgICAgICAgIHJlbmRlci5jdGFiLmF0b21zLmdldChhaWQpLmRyYXdIaWdobGlnaHQocmVuZGVyKTtcclxuICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgICovXHJcblx0XHR0aGlzLml0ZW0uZnJhZ3MuZWFjaChmdW5jdGlvbiAoZm51bSwgZmlkKSB7XHJcblx0XHRcdHJlbmRlci5jdGFiLmZyYWdzLmdldChmaWQpLmRyYXdIaWdobGlnaHQocmVuZGVyKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdFx0cmV0dXJuIHJldDtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Ly8gVE9ETyBhYm5vcm1hbCBzaXR1YXRpb24sIGZyYWdtZW50IGRvZXMgbm90IGJlbG9uZyB0byB0aGUgcmVuZGVyXHJcblx0fVxyXG59O1xyXG5cclxucm5kLlJlU0dyb3VwID0gZnVuY3Rpb24gKHNncm91cCkge1xyXG5cdHRoaXMuaW5pdChWaXNlbC5UWVBFLlNHUk9VUCk7XHJcblxyXG5cdHRoaXMuaXRlbSA9IHNncm91cDtcclxufTtcclxucm5kLlJlU0dyb3VwLnByb3RvdHlwZSA9IG5ldyBybmQuUmVPYmplY3QoKTtcclxucm5kLlJlU0dyb3VwLmlzU2VsZWN0YWJsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5ybmQuUmVTR3JvdXAucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAocmVuZGVyKSB7IC8vIFRPRE8gbmVlZCB0byByZXZpZXcgcGFyYW1ldGVyIGxpc3RcclxuXHRyZXR1cm4gdGhpcy5pdGVtLmRyYXcocmVuZGVyLmN0YWIpO1xyXG59O1xyXG5cclxucm5kLlJlU0dyb3VwLnByb3RvdHlwZS5kcmF3SGlnaGxpZ2h0ID0gZnVuY3Rpb24gKHJlbmRlcikge1xyXG5cdHZhciBzdHlsZXMgPSByZW5kZXIuc3R5bGVzO1xyXG5cdHZhciBzZXR0aW5ncyA9IHJlbmRlci5zZXR0aW5ncztcclxuXHR2YXIgcGFwZXIgPSByZW5kZXIucGFwZXI7XHJcblx0dmFyIHNnID0gdGhpcy5pdGVtO1xyXG5cdHZhciBiYiA9IHNnLmJyYWNrZXRCb3gudHJhbnNmb3JtKHJlbmRlci5vYmoyc2NhbGVkLCByZW5kZXIpO1xyXG5cdHZhciBsdyA9IHNldHRpbmdzLmxpbmVXaWR0aDtcclxuXHR2YXIgdmV4dCA9IG5ldyBWZWMyKGx3ICogNCwgbHcgKiA2KTtcclxuXHRiYiA9IGJiLmV4dGVuZCh2ZXh0LCB2ZXh0KTtcclxuXHR2YXIgZCA9IHNnLmJyYWNrZXREaXIsIG4gPSBkLnJvdGF0ZVNDKDEsMCk7XHJcblx0dmFyIGEwID0gVmVjMi5sYzIoZCwgYmIucDAueCwgbiwgYmIucDAueSk7XHJcblx0dmFyIGExID0gVmVjMi5sYzIoZCwgYmIucDAueCwgbiwgYmIucDEueSk7XHJcblx0dmFyIGIwID0gVmVjMi5sYzIoZCwgYmIucDEueCwgbiwgYmIucDAueSk7XHJcblx0dmFyIGIxID0gVmVjMi5sYzIoZCwgYmIucDEueCwgbiwgYmIucDEueSk7XHJcblxyXG5cdHZhciBzZXQgPSBwYXBlci5zZXQoKTtcclxuXHRzZy5oaWdobGlnaHRpbmcgPSBwYXBlclxyXG5cdC5wYXRoKCdNezB9LHsxfUx7Mn0sezN9THs0fSx7NX1MezZ9LHs3fUx7MH0sezF9JywgdGZ4KGEwLngpLCB0ZngoYTAueSksIHRmeChhMS54KSwgdGZ4KGExLnkpLCB0ZngoYjEueCksIHRmeChiMS55KSwgdGZ4KGIwLngpLCB0ZngoYjAueSkpXHJcblx0LmF0dHIoc3R5bGVzLmhpZ2hsaWdodFN0eWxlKTtcclxuXHRzZXQucHVzaChzZy5oaWdobGlnaHRpbmcpO1xyXG5cclxuXHRTR3JvdXAuZ2V0QXRvbXMocmVuZGVyLmN0YWIubW9sZWN1bGUsIHNnKS5lYWNoKGZ1bmN0aW9uIChhaWQpIHtcclxuXHRcdHNldC5wdXNoKHJlbmRlci5jdGFiLmF0b21zLmdldChhaWQpLm1ha2VIaWdobGlnaHRQbGF0ZShyZW5kZXIpKTtcclxuXHR9LCB0aGlzKTtcclxuXHRTR3JvdXAuZ2V0Qm9uZHMocmVuZGVyLmN0YWIubW9sZWN1bGUsIHNnKS5lYWNoKGZ1bmN0aW9uIChiaWQpIHtcclxuXHRcdHNldC5wdXNoKHJlbmRlci5jdGFiLmJvbmRzLmdldChiaWQpLm1ha2VIaWdobGlnaHRQbGF0ZShyZW5kZXIpKTtcclxuXHR9LCB0aGlzKTtcclxuXHRyZW5kZXIuY3RhYi5hZGRSZU9iamVjdFBhdGgoJ2hpZ2hsaWdodGluZycsIHRoaXMudmlzZWwsIHNldCk7XHJcbn07XHJcblxyXG5ybmQuUmVEYXRhU0dyb3VwRGF0YSA9IGZ1bmN0aW9uIChzZ3JvdXApXHJcbntcclxuXHR0aGlzLmluaXQoVmlzZWwuVFlQRS5TR1JPVVBfREFUQSk7XHJcblxyXG5cdHRoaXMuc2dyb3VwID0gc2dyb3VwO1xyXG59O1xyXG5cclxucm5kLlJlRGF0YVNHcm91cERhdGEucHJvdG90eXBlID0gbmV3IHJuZC5SZU9iamVjdCgpO1xyXG5ybmQuUmVEYXRhU0dyb3VwRGF0YS5pc1NlbGVjdGFibGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG5ybmQuUmVEYXRhU0dyb3VwRGF0YS5wcm90b3R5cGUuaGlnaGxpZ2h0UGF0aCA9IGZ1bmN0aW9uIChyZW5kZXIpIHtcclxuXHR2YXIgYm94ID0gdGhpcy5zZ3JvdXAuZGF0YUFyZWE7XHJcblx0dmFyIHAwID0gcmVuZGVyLm9iajJzY2FsZWQoYm94LnAwKTtcclxuXHR2YXIgc3ogPSByZW5kZXIub2JqMnNjYWxlZChib3gucDEpLnN1YihwMCk7XHJcblx0cmV0dXJuIHJlbmRlci5wYXBlci5yZWN0KHAwLngsIHAwLnksIHN6LngsIHN6LnkpO1xyXG59O1xyXG5cclxucm5kLlJlRGF0YVNHcm91cERhdGEucHJvdG90eXBlLmRyYXdIaWdobGlnaHQgPSBmdW5jdGlvbiAocmVuZGVyKSB7XHJcblx0dmFyIHJldCA9IHRoaXMuaGlnaGxpZ2h0UGF0aChyZW5kZXIpLmF0dHIocmVuZGVyLnN0eWxlcy5oaWdobGlnaHRTdHlsZSk7XHJcblx0cmVuZGVyLmN0YWIuYWRkUmVPYmplY3RQYXRoKCdoaWdobGlnaHRpbmcnLCB0aGlzLnZpc2VsLCByZXQpO1xyXG5cdHJldHVybiByZXQ7XHJcbn07XHJcblxyXG5ybmQuUmVEYXRhU0dyb3VwRGF0YS5wcm90b3R5cGUubWFrZVNlbGVjdGlvblBsYXRlID0gZnVuY3Rpb24gKHJlc3RydWN0LCBwYXBlciwgc3R5bGVzKSB7IC8vIFRPRE8gW01LXSByZXZpZXcgcGFyYW1ldGVyc1xyXG5cdHJldHVybiB0aGlzLmhpZ2hsaWdodFBhdGgocmVzdHJ1Y3QucmVuZGVyKS5hdHRyKHN0eWxlcy5zZWxlY3Rpb25TdHlsZSk7XHJcbn07XHJcblxyXG5ybmQuUmVDaGlyYWxGbGFnID0gZnVuY3Rpb24gKHBvcylcclxue1xyXG5cdHRoaXMuaW5pdChWaXNlbC5UWVBFLkNISVJBTF9GTEFHKTtcclxuXHJcblx0dGhpcy5wcCA9IHBvcztcclxufTtcclxucm5kLlJlQ2hpcmFsRmxhZy5wcm90b3R5cGUgPSBuZXcgcm5kLlJlT2JqZWN0KCk7XHJcbnJuZC5SZUNoaXJhbEZsYWcuaXNTZWxlY3RhYmxlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxucm5kLlJlQ2hpcmFsRmxhZy5wcm90b3R5cGUuaGlnaGxpZ2h0UGF0aCA9IGZ1bmN0aW9uIChyZW5kZXIpIHtcclxuXHR2YXIgYm94ID0gQm94MkFicy5mcm9tUmVsQm94KHRoaXMucGF0aC5nZXRCQm94KCkpO1xyXG5cdHZhciBzeiA9IGJveC5wMS5zdWIoYm94LnAwKTtcclxuXHR2YXIgcDAgPSBib3gucDAuc3ViKHJlbmRlci5vZmZzZXQpO1xyXG5cdHJldHVybiByZW5kZXIucGFwZXIucmVjdChwMC54LCBwMC55LCBzei54LCBzei55KTtcclxufTtcclxuXHJcbnJuZC5SZUNoaXJhbEZsYWcucHJvdG90eXBlLmRyYXdIaWdobGlnaHQgPSBmdW5jdGlvbiAocmVuZGVyKSB7XHJcblx0dmFyIHJldCA9IHRoaXMuaGlnaGxpZ2h0UGF0aChyZW5kZXIpLmF0dHIocmVuZGVyLnN0eWxlcy5oaWdobGlnaHRTdHlsZSk7XHJcblx0cmVuZGVyLmN0YWIuYWRkUmVPYmplY3RQYXRoKCdoaWdobGlnaHRpbmcnLCB0aGlzLnZpc2VsLCByZXQpO1xyXG5cdHJldHVybiByZXQ7XHJcbn07XHJcblxyXG5ybmQuUmVDaGlyYWxGbGFnLnByb3RvdHlwZS5tYWtlU2VsZWN0aW9uUGxhdGUgPSBmdW5jdGlvbiAocmVzdHJ1Y3QsIHBhcGVyLCBzdHlsZXMpIHtcclxuXHRyZXR1cm4gdGhpcy5oaWdobGlnaHRQYXRoKHJlc3RydWN0LnJlbmRlcikuYXR0cihzdHlsZXMuc2VsZWN0aW9uU3R5bGUpO1xyXG59O1xyXG5cclxucm5kLlJlQ2hpcmFsRmxhZy5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChyZW5kZXIpIHtcclxuXHR2YXIgcGFwZXIgPSByZW5kZXIucGFwZXI7XHJcblx0dmFyIHNldHRpbmdzID0gcmVuZGVyLnNldHRpbmdzO1xyXG5cdHZhciBwcyA9IHJlbmRlci5wcyh0aGlzLnBwKTtcclxuXHR0aGlzLnBhdGggPSBwYXBlci50ZXh0KHBzLngsIHBzLnksICdDaGlyYWwnKVxyXG5cdC5hdHRyKHtcclxuXHRcdCdmb250Jzogc2V0dGluZ3MuZm9udCxcclxuXHRcdCdmb250LXNpemUnOiBzZXR0aW5ncy5mb250c3osXHJcblx0XHQnZmlsbCc6ICcjMDAwJ1xyXG5cdH0pO1xyXG5cdHJlbmRlci5jdGFiLmFkZFJlT2JqZWN0UGF0aCgnZGF0YScsIHRoaXMudmlzZWwsIHRoaXMucGF0aCwgbnVsbCwgdHJ1ZSk7XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QubWFwcyA9IHtcclxuXHQnYXRvbXMnOiAgICAgICBSZUF0b20sXHJcblx0J2JvbmRzJzogICAgICAgUmVCb25kLFxyXG5cdCdyeG5QbHVzZXMnOiAgIHJuZC5SZVJ4blBsdXMsXHJcblx0J3J4bkFycm93cyc6ICAgcm5kLlJlUnhuQXJyb3csXHJcblx0J2ZyYWdzJzogICAgICAgcm5kLlJlRnJhZyxcclxuXHQncmdyb3Vwcyc6ICAgICBybmQuUmVSR3JvdXAsXHJcblx0J3Nncm91cERhdGEnOiAgcm5kLlJlRGF0YVNHcm91cERhdGEsXHJcblx0J2NoaXJhbEZsYWdzJzogcm5kLlJlQ2hpcmFsRmxhZyxcclxuXHQnc2dyb3Vwcyc6ICAgICBybmQuUmVTR3JvdXAsXHJcblx0J3JlbG9vcHMnOiAgICAgcm5kLlJlTG9vcFxyXG59O1xyXG4iLCJ2YXIgQm94MkFicyA9IHJlcXVpcmUoJy4uL3V0aWwvYm94MmFicycpO1xyXG52YXIgVmVjMiA9IHJlcXVpcmUoJy4uL3V0aWwvdmVjMicpO1xyXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcclxudmFyIGVsZW1lbnQgPSByZXF1aXJlKCcuLi9jaGVtL2VsZW1lbnQnKTtcclxudmFyIEJvbmQgPSByZXF1aXJlKCcuLi9jaGVtL2JvbmQnKTtcclxuXHJcbnJlcXVpcmUoJy4vcmVzdHJ1Y3QnKTtcclxudmFyIHJuZCA9IGdsb2JhbC5ybmQgPSBnbG9iYWwucm5kIHx8IHt9OyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxudmFyIHRmeCA9IHV0aWwudGZ4O1xyXG5cclxucm5kLlJlU3RydWN0LnByb3RvdHlwZS5kcmF3QXJyb3cgPSBmdW5jdGlvbiAoYSwgYilcclxue1xyXG5cdHZhciB3aWR0aCA9IDUsIGxlbmd0aCA9IDc7XHJcblx0dmFyIHBhcGVyID0gdGhpcy5yZW5kZXIucGFwZXI7XHJcblx0dmFyIHN0eWxlcyA9IHRoaXMucmVuZGVyLnN0eWxlcztcclxuXHRyZXR1cm4gcGFwZXIucGF0aCgnTXswfSx7MX1MezJ9LHszfUx7NH0sezV9TXsyfSx7M31MezR9LHs2fScsIHRmeChhLngpLCB0ZngoYS55KSwgdGZ4KGIueCksIHRmeChiLnkpLCB0ZngoYi54IC0gbGVuZ3RoKSwgdGZ4KGIueSAtIHdpZHRoKSwgdGZ4KGIueSArIHdpZHRoKSlcclxuXHQuYXR0cihzdHlsZXMubGluZWF0dHIpO1xyXG59O1xyXG5cclxucm5kLlJlU3RydWN0LnByb3RvdHlwZS5kcmF3UGx1cyA9IGZ1bmN0aW9uIChjKVxyXG57XHJcblx0dmFyIHMgPSB0aGlzLnJlbmRlci5zY2FsZSAvIDU7XHJcblx0dmFyIHBhcGVyID0gdGhpcy5yZW5kZXIucGFwZXI7XHJcblx0dmFyIHN0eWxlcyA9IHRoaXMucmVuZGVyLnN0eWxlcztcclxuXHRyZXR1cm4gcGFwZXIucGF0aCgnTXswfSx7NH1MezB9LHs1fU17Mn0sezF9THszfSx7MX0nLCB0ZngoYy54KSwgdGZ4KGMueSksIHRmeChjLnggLSBzKSwgdGZ4KGMueCArIHMpLCB0ZngoYy55IC0gcyksIHRmeChjLnkgKyBzKSlcclxuXHQuYXR0cihzdHlsZXMubGluZWF0dHIpO1xyXG59O1xyXG5cclxucm5kLlJlU3RydWN0LnByb3RvdHlwZS5kcmF3Qm9uZFNpbmdsZSA9IGZ1bmN0aW9uIChoYjEsIGhiMilcclxue1xyXG5cdHZhciBhID0gaGIxLnAsIGIgPSBoYjIucDtcclxuXHR2YXIgcGFwZXIgPSB0aGlzLnJlbmRlci5wYXBlcjtcclxuXHR2YXIgc3R5bGVzID0gdGhpcy5yZW5kZXIuc3R5bGVzO1xyXG5cdHJldHVybiBwYXBlci5wYXRoKHJuZC5SZVN0cnVjdC5tYWtlU3Ryb2tlKGEsIGIpKVxyXG5cdC5hdHRyKHN0eWxlcy5saW5lYXR0cik7XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QucHJvdG90eXBlLmRyYXdCb25kU2luZ2xlVXAgPSBmdW5jdGlvbiAoaGIxLCBoYjIsIGJvbmQpXHJcbntcclxuXHR2YXIgYSA9IGhiMS5wLCBiID0gaGIyLnAsIG4gPSBoYjEubm9ybTtcclxuXHR2YXIgc2V0dGluZ3MgPSB0aGlzLnJlbmRlci5zZXR0aW5ncztcclxuXHR2YXIgcGFwZXIgPSB0aGlzLnJlbmRlci5wYXBlcjtcclxuXHR2YXIgc3R5bGVzID0gdGhpcy5yZW5kZXIuc3R5bGVzO1xyXG5cdHZhciBic3AgPSAwLjcgKiBzZXR0aW5ncy5ib25kU3BhY2U7XHJcblx0dmFyIGIyID0gYi5hZGRTY2FsZWQobiwgYnNwKTtcclxuXHR2YXIgYjMgPSBiLmFkZFNjYWxlZChuLCAtYnNwKTtcclxuXHRpZiAoYm9uZC5uZWloYmlkMiA+PSAwKSB7IC8vIGlmIHRoZSBlbmQgaXMgc2hhcmVkIHdpdGggYW5vdGhlciB1cC1ib25kIGhlYWRpbmcgdGhpcyB3YXlcclxuXHRcdHZhciBjb29yZHMgPSB0aGlzLnN0ZXJlb1VwQm9uZEdldENvb3JkaW5hdGVzKGhiMiwgYm9uZC5uZWloYmlkMik7XHJcblx0XHRiMiA9IGNvb3Jkc1swXTtcclxuXHRcdGIzID0gY29vcmRzWzFdO1xyXG5cdH1cclxuXHRyZXR1cm4gcGFwZXIucGF0aCgnTXswfSx7MX1MezJ9LHszfUx7NH0sezV9WicsXHJcblx0dGZ4KGEueCksIHRmeChhLnkpLCB0ZngoYjIueCksIHRmeChiMi55KSwgdGZ4KGIzLngpLCB0ZngoYjMueSkpXHJcblx0LmF0dHIoc3R5bGVzLmxpbmVhdHRyKS5hdHRyKHtcclxuXHRcdCdmaWxsJzonIzAwMCdcclxuXHR9KTtcclxufTtcclxuXHJcbnJuZC5SZVN0cnVjdC5wcm90b3R5cGUuZHJhd1ZlYyA9IGZ1bmN0aW9uIChhLCBkaXIsIGNvbG9yLCBsZW4pIHtcclxuXHR2YXIgc2V0dGluZ3MgPSB0aGlzLnJlbmRlci5zZXR0aW5ncztcclxuXHR2YXIgcGFwZXIgPSB0aGlzLnJlbmRlci5wYXBlcjtcclxuXHR2YXIgc3R5bGVzID0gdGhpcy5yZW5kZXIuc3R5bGVzO1xyXG5cdHZhciBic3AgPSBzZXR0aW5ncy5ib25kU3BhY2U7XHJcblx0dmFyIGIgPSBhLmFkZFNjYWxlZChkaXIsIGxlbiB8fCAzICogYnNwKTtcclxuXHRyZXR1cm4gcGFwZXIucGF0aCgnTXswfSx7MX1MezJ9LHszfScsXHJcblx0dGZ4KGEueCksIHRmeChhLnkpLCB0ZngoYi54KSwgdGZ4KGIueSkpXHJcblx0LmF0dHIoc3R5bGVzLmxpbmVhdHRyKS5hdHRyKHtcclxuXHRcdCdzdHJva2UnOihjb2xvciB8fCAnIzBGMCcpXHJcblx0fSk7XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QucHJvdG90eXBlLnN0ZXJlb1VwQm9uZEdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gKGhiLCBuZWloYmlkKVxyXG57XHJcblx0dmFyIGJzcCA9IHRoaXMucmVuZGVyLnNldHRpbmdzLmJvbmRTcGFjZTtcclxuXHR2YXIgbmVpaGIgPSB0aGlzLm1vbGVjdWxlLmhhbGZCb25kcy5nZXQobmVpaGJpZCk7XHJcblx0dmFyIGNvcyA9IFZlYzIuZG90KGhiLmRpciwgbmVpaGIuZGlyKTtcclxuXHR2YXIgc2luID0gVmVjMi5jcm9zcyhoYi5kaXIsIG5laWhiLmRpcik7XHJcblx0dmFyIGNvc0hhbGYgPSBNYXRoLnNxcnQoMC41ICogKDEgLSBjb3MpKTtcclxuXHR2YXIgYmlzcyA9IG5laWhiLmRpci5yb3RhdGVTQygoc2luID49IDAgPyAtMSA6IDEpICogY29zSGFsZiwgTWF0aC5zcXJ0KDAuNSAqICgxICsgY29zKSkpO1xyXG5cclxuXHR2YXIgZGVub21fYWRkID0gMC4zO1xyXG5cdHZhciBzY2FsZSA9IDAuNztcclxuXHR2YXIgYTEgPSBoYi5wLmFkZFNjYWxlZChiaXNzLCBzY2FsZSAqIGJzcCAvIChjb3NIYWxmICsgZGVub21fYWRkKSk7XHJcblx0dmFyIGEyID0gaGIucC5hZGRTY2FsZWQoYmlzcy5uZWdhdGVkKCksIHNjYWxlICogYnNwIC8gKGNvc0hhbGYgKyBkZW5vbV9hZGQpKTtcclxuXHRyZXR1cm4gc2luID4gMCA/IFthMSwgYTJdIDogW2EyLCBhMV07XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QucHJvdG90eXBlLmRyYXdCb25kU2luZ2xlU3RlcmVvQm9sZCA9IGZ1bmN0aW9uIChoYjEsIGhiMiwgYm9uZCwgaXNEb3VibGUpXHJcbntcclxuXHR2YXIgcGFwZXIgPSB0aGlzLnJlbmRlci5wYXBlcjtcclxuXHR2YXIgc2V0dGluZ3MgPSB0aGlzLnJlbmRlci5zZXR0aW5ncztcclxuXHR2YXIgc3R5bGVzID0gdGhpcy5yZW5kZXIuc3R5bGVzO1xyXG5cdHZhciBjb29yZHMxID0gdGhpcy5zdGVyZW9VcEJvbmRHZXRDb29yZGluYXRlcyhoYjEsIGJvbmQubmVpaGJpZDEpO1xyXG5cdHZhciBjb29yZHMyID0gdGhpcy5zdGVyZW9VcEJvbmRHZXRDb29yZGluYXRlcyhoYjIsIGJvbmQubmVpaGJpZDIpO1xyXG5cdHZhciBhMSA9IGNvb3JkczFbMF07XHJcblx0dmFyIGEyID0gY29vcmRzMVsxXTtcclxuXHR2YXIgYTMgPSBjb29yZHMyWzBdO1xyXG5cdHZhciBhNCA9IGNvb3JkczJbMV07XHJcblx0dmFyIHBhdGhNYWluID0gcGFwZXIucGF0aCgnTXswfSx7MX1MezJ9LHszfUx7NH0sezV9THs2fSx7N31aJyxcclxuXHR0ZngoYTEueCksIHRmeChhMS55KSwgdGZ4KGEyLngpLCB0ZngoYTIueSksIHRmeChhMy54KSwgdGZ4KGEzLnkpLCB0ZngoYTQueCksIHRmeChhNC55KSlcclxuXHQuYXR0cihzdHlsZXMubGluZWF0dHIpLmF0dHIoe1xyXG5cdFx0J3N0cm9rZSc6ICcjMDAwJyxcclxuXHRcdCdmaWxsJzogJyMwMDAnXHJcblx0fSk7XHJcblx0aWYgKGlzRG91YmxlKSB7XHJcblx0XHR2YXIgYSA9IGhiMS5wLCBiID0gaGIyLnAsIG4gPSBoYjEubm9ybSwgc2hpZnQgPSBib25kLmRvdWJsZUJvbmRTaGlmdDtcclxuXHRcdHZhciBic3AgPSAxLjUgKiBzZXR0aW5ncy5ib25kU3BhY2U7XHJcblx0XHR2YXIgYjEgPSBhLmFkZFNjYWxlZChuLCBic3AgKiBzaGlmdCk7XHJcblx0XHR2YXIgYjIgPSBiLmFkZFNjYWxlZChuLCBic3AgKiBzaGlmdCk7XHJcblx0XHR2YXIgc2hpZnRBID0gIXRoaXMuYXRvbXMuZ2V0KGhiMS5iZWdpbikuc2hvd0xhYmVsO1xyXG5cdFx0dmFyIHNoaWZ0QiA9ICF0aGlzLmF0b21zLmdldChoYjIuYmVnaW4pLnNob3dMYWJlbDtcclxuXHRcdGlmIChzaGlmdCA+IDApIHtcclxuXHRcdFx0aWYgKHNoaWZ0QSlcclxuXHRcdFx0XHRiMSA9IGIxLmFkZFNjYWxlZChoYjEuZGlyLCBic3AgKiB0aGlzLmdldEJvbmRMaW5lU2hpZnQoaGIxLnJpZ2h0Q29zLCBoYjEucmlnaHRTaW4pKTtcclxuXHRcdFx0aWYgKHNoaWZ0QilcclxuXHRcdFx0XHRiMiA9IGIyLmFkZFNjYWxlZChoYjEuZGlyLCAtYnNwICogdGhpcy5nZXRCb25kTGluZVNoaWZ0KGhiMi5sZWZ0Q29zLCBoYjIubGVmdFNpbikpO1xyXG5cdFx0fSBlbHNlIGlmIChzaGlmdCA8IDApIHtcclxuXHRcdFx0aWYgKHNoaWZ0QSlcclxuXHRcdFx0XHRiMSA9IGIxLmFkZFNjYWxlZChoYjEuZGlyLCBic3AgKiB0aGlzLmdldEJvbmRMaW5lU2hpZnQoaGIxLmxlZnRDb3MsIGhiMS5sZWZ0U2luKSk7XHJcblx0XHRcdGlmIChzaGlmdEIpXHJcblx0XHRcdFx0YjIgPSBiMi5hZGRTY2FsZWQoaGIxLmRpciwgLWJzcCAqIHRoaXMuZ2V0Qm9uZExpbmVTaGlmdChoYjIucmlnaHRDb3MsIGhiMi5yaWdodFNpbikpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwYXBlci5zZXQoW3BhdGhNYWluLCBwYXBlci5wYXRoKFxyXG5cdFx0XHRcdCdNezB9LHsxfUx7Mn0sezN9JywgdGZ4KGIxLngpLCB0ZngoYjEueSksIHRmeChiMi54KSwgdGZ4KGIyLnkpKVxyXG5cdFx0XHQuYXR0cihzdHlsZXMubGluZWF0dHIpXSk7XHJcblx0fVxyXG5cdHJldHVybiBwYXRoTWFpbjtcclxufTtcclxuXHJcbnJuZC5SZVN0cnVjdC5wcm90b3R5cGUuZHJhd0JvbmRTaW5nbGVEb3duID0gZnVuY3Rpb24gKGhiMSwgaGIyKVxyXG57XHJcblx0dmFyIGEgPSBoYjEucCwgYiA9IGhiMi5wLCBuID0gaGIxLm5vcm07XHJcblx0dmFyIHNldHRpbmdzID0gdGhpcy5yZW5kZXIuc2V0dGluZ3M7XHJcblx0dmFyIHBhcGVyID0gdGhpcy5yZW5kZXIucGFwZXI7XHJcblx0dmFyIHN0eWxlcyA9IHRoaXMucmVuZGVyLnN0eWxlcztcclxuXHR2YXIgYnNwID0gMC43ICogc2V0dGluZ3MuYm9uZFNwYWNlO1xyXG5cdHZhciBkID0gYi5zdWIoYSk7XHJcblx0dmFyIGxlbiA9IGQubGVuZ3RoKCkgKyAwLjI7XHJcblx0ZCA9IGQubm9ybWFsaXplZCgpO1xyXG5cdHZhciBpbnRlcnZhbCA9IDEuMiAqIHNldHRpbmdzLmxpbmVXaWR0aDtcclxuXHR2YXIgbmxpbmVzID0gTWF0aC5tYXgoTWF0aC5mbG9vcigobGVuIC0gc2V0dGluZ3MubGluZVdpZHRoKSAvXHJcblx0KHNldHRpbmdzLmxpbmVXaWR0aCArIGludGVydmFsKSksMCkgKyAyO1xyXG5cdHZhciBzdGVwID0gbGVuIC8gKG5saW5lcyAtIDEpO1xyXG5cclxuXHR2YXIgcGF0aCA9ICcnLCBwLCBxLCByID0gYTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IG5saW5lczsgKytpKSB7XHJcblx0XHRyID0gYS5hZGRTY2FsZWQoZCwgc3RlcCAqIGkpO1xyXG5cdFx0cCA9IHIuYWRkU2NhbGVkKG4sIGJzcCAqIChpICsgMC41KSAvIChubGluZXMgLSAwLjUpKTtcclxuXHRcdHEgPSByLmFkZFNjYWxlZChuLCAtYnNwICogKGkgKyAwLjUpIC8gKG5saW5lcyAtIDAuNSkpO1xyXG5cdFx0cGF0aCArPSBybmQuUmVTdHJ1Y3QubWFrZVN0cm9rZShwLCBxKTtcclxuXHR9XHJcblx0cmV0dXJuIHBhcGVyLnBhdGgocGF0aClcclxuXHQuYXR0cihzdHlsZXMubGluZWF0dHIpO1xyXG59O1xyXG5cclxucm5kLlJlU3RydWN0LnByb3RvdHlwZS5kcmF3Qm9uZFNpbmdsZUVpdGhlciA9IGZ1bmN0aW9uIChoYjEsIGhiMilcclxue1xyXG5cdHZhciBhID0gaGIxLnAsIGIgPSBoYjIucCwgbiA9IGhiMS5ub3JtO1xyXG5cdHZhciBzZXR0aW5ncyA9IHRoaXMucmVuZGVyLnNldHRpbmdzO1xyXG5cdHZhciBwYXBlciA9IHRoaXMucmVuZGVyLnBhcGVyO1xyXG5cdHZhciBzdHlsZXMgPSB0aGlzLnJlbmRlci5zdHlsZXM7XHJcblx0dmFyIGJzcCA9IDAuNyAqIHNldHRpbmdzLmJvbmRTcGFjZTtcclxuXHR2YXIgZCA9IGIuc3ViKGEpO1xyXG5cdHZhciBsZW4gPSBkLmxlbmd0aCgpO1xyXG5cdGQgPSBkLm5vcm1hbGl6ZWQoKTtcclxuXHR2YXIgaW50ZXJ2YWwgPSAwLjYgKiBzZXR0aW5ncy5saW5lV2lkdGg7XHJcblx0dmFyIG5saW5lcyA9IE1hdGgubWF4KE1hdGguZmxvb3IoKGxlbiAtIHNldHRpbmdzLmxpbmVXaWR0aCkgL1xyXG5cdChzZXR0aW5ncy5saW5lV2lkdGggKyBpbnRlcnZhbCkpLDApICsgMjtcclxuXHR2YXIgc3RlcCA9IGxlbiAvIChubGluZXMgLSAwLjUpO1xyXG5cclxuXHR2YXIgcGF0aCA9ICdNJyArIHRmeChhLngpICsgJywnICsgdGZ4KGEueSksIHIgPSBhO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbmxpbmVzOyArK2kpIHtcclxuXHRcdHIgPSBhLmFkZFNjYWxlZChkLCBzdGVwICogKGkgKyAwLjUpKS5hZGRTY2FsZWQobixcclxuXHRcdFx0KChpICYgMSkgPyAtMSA6ICsxKSAqIGJzcCAqIChpICsgMC41KSAvIChubGluZXMgLSAwLjUpKTtcclxuXHRcdHBhdGggKz0gJ0wnICsgdGZ4KHIueCkgKyAnLCcgKyB0Zngoci55KTtcclxuXHR9XHJcblx0cmV0dXJuIHBhcGVyLnBhdGgocGF0aClcclxuXHQuYXR0cihzdHlsZXMubGluZWF0dHIpO1xyXG59O1xyXG5cclxucm5kLlJlU3RydWN0LnByb3RvdHlwZS5nZXRCb25kTGluZVNoaWZ0ID0gZnVuY3Rpb24gKGNvcywgc2luKVxyXG57XHJcblx0aWYgKHNpbiA8IDAgfHwgTWF0aC5hYnMoY29zKSA+IDAuOSlcclxuXHRcdHJldHVybiAwO1xyXG5cdHJldHVybiBzaW4gLyAoMSAtIGNvcyk7XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QucHJvdG90eXBlLmRyYXdCb25kRG91YmxlID0gZnVuY3Rpb24gKGhiMSwgaGIyLCBib25kLCBjaXNfdHJhbnMpXHJcbntcclxuXHR2YXIgYSA9IGhiMS5wLCBiID0gaGIyLnAsIG4gPSBoYjEubm9ybSwgc2hpZnQgPSBjaXNfdHJhbnMgPyAwIDogYm9uZC5kb3VibGVCb25kU2hpZnQ7XHJcblx0dmFyIHNldHRpbmdzID0gdGhpcy5yZW5kZXIuc2V0dGluZ3M7XHJcblx0dmFyIHBhcGVyID0gdGhpcy5yZW5kZXIucGFwZXI7XHJcblx0dmFyIHN0eWxlcyA9IHRoaXMucmVuZGVyLnN0eWxlcztcclxuXHR2YXIgYnNwID0gc2V0dGluZ3MuYm9uZFNwYWNlIC8gMjtcclxuXHR2YXIgczEgPSBic3AsIHMyID0gLWJzcDtcclxuXHRzMSArPSBzaGlmdCAqIGJzcDtcclxuXHRzMiArPSBzaGlmdCAqIGJzcDtcclxuXHR2YXIgYTIgPSBhLmFkZFNjYWxlZChuLCBzMSk7XHJcblx0dmFyIGIyID0gYi5hZGRTY2FsZWQobiwgczEpO1xyXG5cdHZhciBhMyA9IGEuYWRkU2NhbGVkKG4sIHMyKTtcclxuXHR2YXIgYjMgPSBiLmFkZFNjYWxlZChuLCBzMik7XHJcblxyXG5cdHZhciBzaGlmdEEgPSAhdGhpcy5hdG9tcy5nZXQoaGIxLmJlZ2luKS5zaG93TGFiZWw7XHJcblx0dmFyIHNoaWZ0QiA9ICF0aGlzLmF0b21zLmdldChoYjIuYmVnaW4pLnNob3dMYWJlbDtcclxuXHRpZiAoc2hpZnQgPiAwKSB7XHJcblx0XHRpZiAoc2hpZnRBKVxyXG5cdFx0XHRhMiA9IGEyLmFkZFNjYWxlZChoYjEuZGlyLCBzZXR0aW5ncy5ib25kU3BhY2UgKlxyXG5cdFx0XHR0aGlzLmdldEJvbmRMaW5lU2hpZnQoaGIxLnJpZ2h0Q29zLCBoYjEucmlnaHRTaW4pKTtcclxuXHRcdGlmIChzaGlmdEIpXHJcblx0XHRcdGIyID0gYjIuYWRkU2NhbGVkKGhiMS5kaXIsIC1zZXR0aW5ncy5ib25kU3BhY2UgKlxyXG5cdFx0XHR0aGlzLmdldEJvbmRMaW5lU2hpZnQoaGIyLmxlZnRDb3MsIGhiMi5sZWZ0U2luKSk7XHJcblx0fSBlbHNlIGlmIChzaGlmdCA8IDApIHtcclxuXHRcdGlmIChzaGlmdEEpXHJcblx0XHRcdGEzID0gYTMuYWRkU2NhbGVkKGhiMS5kaXIsIHNldHRpbmdzLmJvbmRTcGFjZSAqXHJcblx0XHRcdHRoaXMuZ2V0Qm9uZExpbmVTaGlmdChoYjEubGVmdENvcywgaGIxLmxlZnRTaW4pKTtcclxuXHRcdGlmIChzaGlmdEIpXHJcblx0XHRcdGIzID0gYjMuYWRkU2NhbGVkKGhiMS5kaXIsIC1zZXR0aW5ncy5ib25kU3BhY2UgKlxyXG5cdFx0XHR0aGlzLmdldEJvbmRMaW5lU2hpZnQoaGIyLnJpZ2h0Q29zLCBoYjIucmlnaHRTaW4pKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBwYXBlci5wYXRoKGNpc190cmFucyA/XHJcblx0XHRcdCdNezB9LHsxfUx7Nn0sezd9TXs0fSx7NX1MezJ9LHszfScgOlxyXG5cdFx0XHQnTXswfSx7MX1MezJ9LHszfU17NH0sezV9THs2fSx7N30nLFxyXG5cdHRmeChhMi54KSwgdGZ4KGEyLnkpLCB0ZngoYjIueCksIHRmeChiMi55KSwgdGZ4KGEzLngpLCB0ZngoYTMueSksIHRmeChiMy54KSwgdGZ4KGIzLnkpKVxyXG5cdC5hdHRyKHN0eWxlcy5saW5lYXR0cik7XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QubWFrZVN0cm9rZSA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcblx0cmV0dXJuICdNJyArIHRmeChhLngpICsgJywnICsgdGZ4KGEueSkgK1xyXG5cdFx0J0wnICsgdGZ4KGIueCkgKyAnLCcgKyB0ZngoYi55KSArICdcdCc7XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QucHJvdG90eXBlLmRyYXdCb25kU2luZ2xlT3JEb3VibGUgPSBmdW5jdGlvbiAoaGIxLCBoYjIpXHJcbntcclxuXHR2YXIgYSA9IGhiMS5wLCBiID0gaGIyLnAsIG4gPSBoYjEubm9ybTtcclxuXHR2YXIgcmVuZGVyID0gdGhpcy5yZW5kZXI7XHJcblx0dmFyIHNldHRpbmdzID0gcmVuZGVyLnNldHRpbmdzO1xyXG5cdHZhciBwYXBlciA9IHJlbmRlci5wYXBlcjtcclxuXHR2YXIgc3R5bGVzID0gcmVuZGVyLnN0eWxlcztcclxuXHR2YXIgYnNwID0gc2V0dGluZ3MuYm9uZFNwYWNlIC8gMjtcclxuXHJcblx0dmFyIG5TZWN0ID0gKFZlYzIuZGlzdChhLCBiKSAvIChzZXR0aW5ncy5ib25kU3BhY2UgKyBzZXR0aW5ncy5saW5lV2lkdGgpKS50b0ZpeGVkKCkgLSAwO1xyXG5cdGlmICghKG5TZWN0ICYgMSkpXHJcblx0XHRuU2VjdCArPSAxO1xyXG5cdHZhciBwYXRoID0gJycsIHBwID0gYTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDE7IGkgPD0gblNlY3Q7ICsraSkge1xyXG5cdFx0dmFyIHBpID0gVmVjMi5sYzIoYSwgKG5TZWN0IC0gaSkgLyBuU2VjdCwgYiwgaSAvIG5TZWN0KTtcclxuXHRcdGlmIChpICYgMSkge1xyXG5cdFx0XHRwYXRoICs9IHJuZC5SZVN0cnVjdC5tYWtlU3Ryb2tlKHBwLCBwaSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRwYXRoICs9IHJuZC5SZVN0cnVjdC5tYWtlU3Ryb2tlKHBwLmFkZFNjYWxlZChuLCBic3ApLCBwaS5hZGRTY2FsZWQobiwgYnNwKSk7XHJcblx0XHRcdHBhdGggKz0gcm5kLlJlU3RydWN0Lm1ha2VTdHJva2UocHAuYWRkU2NhbGVkKG4sIC1ic3ApLCBwaS5hZGRTY2FsZWQobiwgLWJzcCkpO1xyXG5cdFx0fVxyXG5cdFx0cHAgPSBwaTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBwYXBlci5wYXRoKHBhdGgpXHJcblx0LmF0dHIoc3R5bGVzLmxpbmVhdHRyKTtcclxufTtcclxuXHJcbnJuZC5SZVN0cnVjdC5wcm90b3R5cGUuZHJhd0JvbmRUcmlwbGUgPSBmdW5jdGlvbiAoaGIxLCBoYjIpXHJcbntcclxuXHR2YXIgYSA9IGhiMS5wLCBiID0gaGIyLnAsIG4gPSBoYjEubm9ybTtcclxuXHR2YXIgcmVuZGVyID0gdGhpcy5yZW5kZXI7XHJcblx0dmFyIHNldHRpbmdzID0gcmVuZGVyLnNldHRpbmdzO1xyXG5cdHZhciBwYXBlciA9IHJlbmRlci5wYXBlcjtcclxuXHR2YXIgc3R5bGVzID0gcmVuZGVyLnN0eWxlcztcclxuXHR2YXIgYTIgPSBhLmFkZFNjYWxlZChuLCBzZXR0aW5ncy5ib25kU3BhY2UpO1xyXG5cdHZhciBiMiA9IGIuYWRkU2NhbGVkKG4sIHNldHRpbmdzLmJvbmRTcGFjZSk7XHJcblx0dmFyIGEzID0gYS5hZGRTY2FsZWQobiwgLXNldHRpbmdzLmJvbmRTcGFjZSk7XHJcblx0dmFyIGIzID0gYi5hZGRTY2FsZWQobiwgLXNldHRpbmdzLmJvbmRTcGFjZSk7XHJcblx0cmV0dXJuIHBhcGVyLnBhdGgocm5kLlJlU3RydWN0Lm1ha2VTdHJva2UoYSxiKSArIHJuZC5SZVN0cnVjdC5tYWtlU3Ryb2tlKGEyLGIyKSArIHJuZC5SZVN0cnVjdC5tYWtlU3Ryb2tlKGEzLGIzKSlcclxuXHQuYXR0cihzdHlsZXMubGluZWF0dHIpO1xyXG59O1xyXG5cclxucm5kLmRhc2hlZFBhdGggPSBmdW5jdGlvbiAocDAsIHAxLCBkYXNoKSB7XHJcblx0dmFyIHQwID0gMDtcclxuXHR2YXIgdDEgPSBWZWMyLmRpc3QocDAsIHAxKTtcclxuXHR2YXIgZCA9IFZlYzIuZGlmZihwMSwgcDApLm5vcm1hbGl6ZWQoKTtcclxuXHR2YXIgYmxhY2sgPSB0cnVlO1xyXG5cdHZhciBwYXRoID0gJyc7XHJcblx0dmFyIGkgPSAwO1xyXG5cclxuXHR3aGlsZSAodDAgPCB0MSkge1xyXG5cdFx0dmFyIGxlbiA9IGRhc2hbaSAlIGRhc2gubGVuZ3RoXTtcclxuXHRcdHZhciB0MiA9IHQwICsgTWF0aC5taW4obGVuLCB0MSAtIHQwKTtcclxuXHRcdGlmIChibGFjaylcclxuXHRcdFx0cGF0aCArPSAnTSAnICsgcDAuYWRkU2NhbGVkKGQsIHQwKS5jb29yZFN0cigpICsgJyBMICcgKyBwMC5hZGRTY2FsZWQoZCwgdDIpLmNvb3JkU3RyKCk7XHJcblx0XHR0MCArPSBsZW47XHJcblx0XHRibGFjayA9ICFibGFjaztcclxuXHRcdGkrKztcclxuXHR9XHJcblx0cmV0dXJuIHBhdGg7XHJcbn1cclxuXHJcbnJuZC5SZVN0cnVjdC5wcm90b3R5cGUuZHJhd0JvbmRBcm9tYXRpYyA9IGZ1bmN0aW9uIChoYjEsIGhiMiwgYm9uZCwgZHJhd0Rhc2hMaW5lKVxyXG57XHJcblx0aWYgKCFkcmF3RGFzaExpbmUpIHtcclxuXHRcdHJldHVybiB0aGlzLmRyYXdCb25kU2luZ2xlKGhiMSwgaGIyKTtcclxuXHR9XHJcblx0dmFyIHNoaWZ0ID0gYm9uZC5kb3VibGVCb25kU2hpZnQ7XHJcblx0dmFyIHBhcGVyID0gdGhpcy5yZW5kZXIucGFwZXI7XHJcblx0dmFyIHBhdGhzID0gdGhpcy5wcmVwYXJlUGF0aHNGb3JBcm9tYXRpY0JvbmQoaGIxLCBoYjIsIHNoaWZ0KTtcclxuXHR2YXIgbDEgPSBwYXRoc1swXSwgbDIgPSBwYXRoc1sxXTtcclxuXHQoc2hpZnQgPiAwID8gbDEgOiBsMikuYXR0cih7XHJcblx0XHQnc3Ryb2tlLWRhc2hhcnJheSc6Jy0gJ1xyXG5cdH0pO1xyXG5cdHJldHVybiBwYXBlci5zZXQoW2wxLGwyXSk7XHJcbn07XHJcblxyXG5ybmQuZGFzaGRvdFBhdHRlcm4gPSBbMC4xMjUsMC4xMjUsMC4wMDUsMC4xMjVdO1xyXG5cclxucm5kLlJlU3RydWN0LnByb3RvdHlwZS5kcmF3Qm9uZFNpbmdsZU9yQXJvbWF0aWMgPSBmdW5jdGlvbiAoaGIxLCBoYjIsIGJvbmQpXHJcbntcclxuXHR2YXIgc2hpZnQgPSBib25kLmRvdWJsZUJvbmRTaGlmdDtcclxuXHR2YXIgcGFwZXIgPSB0aGlzLnJlbmRlci5wYXBlcjtcclxuXHR2YXIgc2NhbGUgPSB0aGlzLnJlbmRlci5zZXR0aW5ncy5zY2FsZUZhY3RvcjtcclxuXHR2YXIgZGFzaCA9IHV0aWwubWFwKHJuZC5kYXNoZG90UGF0dGVybiwgZnVuY3Rpb24gKHYpeyByZXR1cm4gdiAqIHNjYWxlOyB9KTtcclxuXHR2YXIgcGF0aHMgPSB0aGlzLnByZXBhcmVQYXRoc0ZvckFyb21hdGljQm9uZChoYjEsIGhiMiwgc2hpZnQsIHNoaWZ0ID4gMCA/IDEgOiAyLCBkYXNoKTtcclxuXHR2YXIgbDEgPSBwYXRoc1swXSwgbDIgPSBwYXRoc1sxXTtcclxuLy8gZG90dGVkIGxpbmUgZG9lc24ndCB3b3JrIGluIENocm9tZSwgcmVuZGVyIG1hbnVhbGx5IGluc3RlYWQgKHNlZSBybmQuZGFzaGVkUGF0aClcclxuLy9cdChzaGlmdCA+IDAgPyBsMSA6IGwyKS5hdHRyKHtcclxuLy9cdFx0J3N0cm9rZS1kYXNoYXJyYXknOictLidcclxuLy9cdH0pO1xyXG5cdHJldHVybiBwYXBlci5zZXQoW2wxLGwyXSk7XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QucHJvdG90eXBlLnByZXBhcmVQYXRoc0ZvckFyb21hdGljQm9uZCA9IGZ1bmN0aW9uIChoYjEsIGhiMiwgc2hpZnQsIG1hc2ssIGRhc2gpXHJcbntcclxuXHR2YXIgc2V0dGluZ3MgPSB0aGlzLnJlbmRlci5zZXR0aW5ncztcclxuXHR2YXIgcGFwZXIgPSB0aGlzLnJlbmRlci5wYXBlcjtcclxuXHR2YXIgc3R5bGVzID0gdGhpcy5yZW5kZXIuc3R5bGVzO1xyXG5cdHZhciBhID0gaGIxLnAsIGIgPSBoYjIucCwgbiA9IGhiMS5ub3JtO1xyXG5cdHZhciBic3AgPSBzZXR0aW5ncy5ib25kU3BhY2UgLyAyO1xyXG5cdHZhciBzMSA9IGJzcCwgczIgPSAtYnNwO1xyXG5cdHMxICs9IHNoaWZ0ICogYnNwO1xyXG5cdHMyICs9IHNoaWZ0ICogYnNwO1xyXG5cdHZhciBhMiA9IGEuYWRkU2NhbGVkKG4sIHMxKTtcclxuXHR2YXIgYjIgPSBiLmFkZFNjYWxlZChuLCBzMSk7XHJcblx0dmFyIGEzID0gYS5hZGRTY2FsZWQobiwgczIpO1xyXG5cdHZhciBiMyA9IGIuYWRkU2NhbGVkKG4sIHMyKTtcclxuXHR2YXIgc2hpZnRBID0gIXRoaXMuYXRvbXMuZ2V0KGhiMS5iZWdpbikuc2hvd0xhYmVsO1xyXG5cdHZhciBzaGlmdEIgPSAhdGhpcy5hdG9tcy5nZXQoaGIyLmJlZ2luKS5zaG93TGFiZWw7XHJcblx0aWYgKHNoaWZ0ID4gMCkge1xyXG5cdFx0aWYgKHNoaWZ0QSlcclxuXHRcdFx0YTIgPSBhMi5hZGRTY2FsZWQoaGIxLmRpciwgc2V0dGluZ3MuYm9uZFNwYWNlICpcclxuXHRcdFx0dGhpcy5nZXRCb25kTGluZVNoaWZ0KGhiMS5yaWdodENvcywgaGIxLnJpZ2h0U2luKSk7XHJcblx0XHRpZiAoc2hpZnRCKVxyXG5cdFx0XHRiMiA9IGIyLmFkZFNjYWxlZChoYjEuZGlyLCAtc2V0dGluZ3MuYm9uZFNwYWNlICpcclxuXHRcdFx0dGhpcy5nZXRCb25kTGluZVNoaWZ0KGhiMi5sZWZ0Q29zLCBoYjIubGVmdFNpbikpO1xyXG5cdH0gZWxzZSBpZiAoc2hpZnQgPCAwKSB7XHJcblx0XHRpZiAoc2hpZnRBKVxyXG5cdFx0XHRhMyA9IGEzLmFkZFNjYWxlZChoYjEuZGlyLCBzZXR0aW5ncy5ib25kU3BhY2UgKlxyXG5cdFx0XHR0aGlzLmdldEJvbmRMaW5lU2hpZnQoaGIxLmxlZnRDb3MsIGhiMS5sZWZ0U2luKSk7XHJcblx0XHRpZiAoc2hpZnRCKVxyXG5cdFx0XHRiMyA9IGIzLmFkZFNjYWxlZChoYjEuZGlyLCAtc2V0dGluZ3MuYm9uZFNwYWNlICpcclxuXHRcdFx0dGhpcy5nZXRCb25kTGluZVNoaWZ0KGhiMi5yaWdodENvcywgaGIyLnJpZ2h0U2luKSk7XHJcblx0fVxyXG5cdHZhciBsMSA9IHBhcGVyLnBhdGgoZGFzaCAmJiAobWFzayAmIDEpID8gcm5kLmRhc2hlZFBhdGgoYTIsIGIyLCBkYXNoKSA6IHJuZC5SZVN0cnVjdC5tYWtlU3Ryb2tlKGEyLCBiMikpLmF0dHIoc3R5bGVzLmxpbmVhdHRyKTtcclxuXHR2YXIgbDIgPSBwYXBlci5wYXRoKGRhc2ggJiYgKG1hc2sgJiAyKSA/IHJuZC5kYXNoZWRQYXRoKGEzLCBiMywgZGFzaCkgOiBybmQuUmVTdHJ1Y3QubWFrZVN0cm9rZShhMywgYjMpKS5hdHRyKHN0eWxlcy5saW5lYXR0cik7XHJcblx0cmV0dXJuIFtsMSwgbDJdO1xyXG59O1xyXG5cclxuXHJcbnJuZC5SZVN0cnVjdC5wcm90b3R5cGUuZHJhd0JvbmREb3VibGVPckFyb21hdGljID0gZnVuY3Rpb24gKGhiMSwgaGIyLCBib25kKVxyXG57XHJcblx0dmFyIHNoaWZ0ID0gYm9uZC5kb3VibGVCb25kU2hpZnQ7XHJcblx0dmFyIHBhcGVyID0gdGhpcy5yZW5kZXIucGFwZXI7XHJcblx0dmFyIHNjYWxlID0gdGhpcy5yZW5kZXIuc2V0dGluZ3Muc2NhbGVGYWN0b3I7XHJcblx0dmFyIGRhc2ggPSB1dGlsLm1hcChybmQuZGFzaGRvdFBhdHRlcm4sIGZ1bmN0aW9uICh2KXsgcmV0dXJuIHYgKiBzY2FsZTsgfSk7XHJcblx0dmFyIHBhdGhzID0gdGhpcy5wcmVwYXJlUGF0aHNGb3JBcm9tYXRpY0JvbmQoaGIxLCBoYjIsIHNoaWZ0LCAzLCBkYXNoKTtcclxuXHR2YXIgbDEgPSBwYXRoc1swXSwgbDIgPSBwYXRoc1sxXTtcclxuLy8gZG90dGVkIGxpbmUgZG9lc24ndCB3b3JrIGluIENocm9tZSwgcmVuZGVyIG1hbnVhbGx5IGluc3RlYWQgKHNlZSBybmQuZGFzaGVkUGF0aClcclxuLy9cdGwxLmF0dHIoeydzdHJva2UtZGFzaGFycmF5JzonLS4nfSk7XHJcbi8vXHRsMi5hdHRyKHsnc3Ryb2tlLWRhc2hhcnJheSc6Jy0uJ30pO1xyXG5cdHJldHVybiBwYXBlci5zZXQoW2wxLGwyXSk7XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QucHJvdG90eXBlLmRyYXdCb25kQW55ID0gZnVuY3Rpb24gKGhiMSwgaGIyKVxyXG57XHJcblx0dmFyIGEgPSBoYjEucCwgYiA9IGhiMi5wO1xyXG5cdHZhciBwYXBlciA9IHRoaXMucmVuZGVyLnBhcGVyO1xyXG5cdHZhciBzdHlsZXMgPSB0aGlzLnJlbmRlci5zdHlsZXM7XHJcblx0cmV0dXJuIHBhcGVyLnBhdGgocm5kLlJlU3RydWN0Lm1ha2VTdHJva2UoYSxiKSlcclxuXHQuYXR0cihzdHlsZXMubGluZWF0dHIpLmF0dHIoe1xyXG5cdFx0J3N0cm9rZS1kYXNoYXJyYXknOictICdcclxuXHR9KTtcclxufTtcclxuXHJcbnJuZC5SZVN0cnVjdC5wcm90b3R5cGUuZHJhd1JlYWN0aW5nQ2VudGVyID0gZnVuY3Rpb24gKGJvbmQsIGhiMSwgaGIyKVxyXG57XHJcblx0dmFyIGEgPSBoYjEucCwgYiA9IGhiMi5wO1xyXG5cdHZhciBjID0gYi5hZGQoYSkuc2NhbGVkKDAuNSk7XHJcblx0dmFyIGQgPSBiLnN1YihhKS5ub3JtYWxpemVkKCk7XHJcblx0dmFyIG4gPSBkLnJvdGF0ZVNDKDEsIDApO1xyXG5cclxuXHR2YXIgcGFwZXIgPSB0aGlzLnJlbmRlci5wYXBlcjtcclxuXHR2YXIgc3R5bGVzID0gdGhpcy5yZW5kZXIuc3R5bGVzO1xyXG5cdHZhciBzZXR0aW5ncyA9IHRoaXMucmVuZGVyLnNldHRpbmdzO1xyXG5cclxuXHR2YXIgcCA9IFtdO1xyXG5cclxuXHR2YXIgbHcgPSBzZXR0aW5ncy5saW5lV2lkdGgsIGJzID0gc2V0dGluZ3MuYm9uZFNwYWNlIC8gMjtcclxuXHR2YXIgYWxvbmdJbnRSYyA9IGx3LCAvLyBoYWxmIGludGVydmFsIGFsb25nIGZvciBDRU5URVJcclxuXHRhbG9uZ0ludE1hZGVCcm9rZW4gPSAyICogbHcsIC8vIGhhbGYgaW50ZXJ2YWwgYmV0d2VlbiBhbG9uZyBmb3IgTUFERV9PUl9CUk9LRU5cclxuXHRhbG9uZ1N6ID0gMS41ICogYnMsIC8vIGhhbGYgc2l6ZSBhbG9uZyBmb3IgQ0VOVEVSXHJcblx0YWNyb3NzSW50ID0gMS41ICogYnMsIC8vIGhhbGYgaW50ZXJ2YWwgYWNyb3NzIGZvciBDRU5URVJcclxuXHRhY3Jvc3NTeiA9IDMuMCAqIGJzLCAvLyBoYWxmIHNpemUgYWNyb3NzIGZvciBhbGxcclxuXHR0aWx0VGFuID0gMC4yOyAvLyB0YW5nZW50IG9mIHRoZSB0aWx0IGFuZ2xlXHJcblxyXG5cdHN3aXRjaCAoYm9uZC5iLnJlYWN0aW5nQ2VudGVyU3RhdHVzKVxyXG5cdFx0e1xyXG5cdFx0Y2FzZSBCb25kLlBBVFRFUk4uUkVBQ1RJTkdfQ0VOVEVSLk5PVF9DRU5URVI6IC8vIFhcclxuXHRcdFx0cC5wdXNoKGMuYWRkU2NhbGVkKG4sIGFjcm9zc1N6KS5hZGRTY2FsZWQoZCwgdGlsdFRhbiAqIGFjcm9zc1N6KSk7XHJcblx0XHRcdHAucHVzaChjLmFkZFNjYWxlZChuLCAtYWNyb3NzU3opLmFkZFNjYWxlZChkLCAtdGlsdFRhbiAqIGFjcm9zc1N6KSk7XHJcblx0XHRcdHAucHVzaChjLmFkZFNjYWxlZChuLCBhY3Jvc3NTeikuYWRkU2NhbGVkKGQsIC10aWx0VGFuICogYWNyb3NzU3opKTtcclxuXHRcdFx0cC5wdXNoKGMuYWRkU2NhbGVkKG4sIC1hY3Jvc3NTeikuYWRkU2NhbGVkKGQsIHRpbHRUYW4gKiBhY3Jvc3NTeikpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgQm9uZC5QQVRURVJOLlJFQUNUSU5HX0NFTlRFUi5DRU5URVI6ICAvLyAjXHJcblx0XHRcdHAucHVzaChjLmFkZFNjYWxlZChuLCBhY3Jvc3NTeikuYWRkU2NhbGVkKGQsIHRpbHRUYW4gKiBhY3Jvc3NTeikuYWRkU2NhbGVkKGQsIGFsb25nSW50UmMpKTtcclxuXHRcdFx0cC5wdXNoKGMuYWRkU2NhbGVkKG4sIC1hY3Jvc3NTeikuYWRkU2NhbGVkKGQsIC10aWx0VGFuICogYWNyb3NzU3opLmFkZFNjYWxlZChkLCBhbG9uZ0ludFJjKSk7XHJcblx0XHRcdHAucHVzaChjLmFkZFNjYWxlZChuLCBhY3Jvc3NTeikuYWRkU2NhbGVkKGQsIHRpbHRUYW4gKiBhY3Jvc3NTeikuYWRkU2NhbGVkKGQsIC1hbG9uZ0ludFJjKSk7XHJcblx0XHRcdHAucHVzaChjLmFkZFNjYWxlZChuLCAtYWNyb3NzU3opLmFkZFNjYWxlZChkLCAtdGlsdFRhbiAqIGFjcm9zc1N6KS5hZGRTY2FsZWQoZCwgLWFsb25nSW50UmMpKTtcclxuXHRcdFx0cC5wdXNoKGMuYWRkU2NhbGVkKGQsIGFsb25nU3opLmFkZFNjYWxlZChuLCBhY3Jvc3NJbnQpKTtcclxuXHRcdFx0cC5wdXNoKGMuYWRkU2NhbGVkKGQsIC1hbG9uZ1N6KS5hZGRTY2FsZWQobiwgYWNyb3NzSW50KSk7XHJcblx0XHRcdHAucHVzaChjLmFkZFNjYWxlZChkLCBhbG9uZ1N6KS5hZGRTY2FsZWQobiwgLWFjcm9zc0ludCkpO1xyXG5cdFx0XHRwLnB1c2goYy5hZGRTY2FsZWQoZCwgLWFsb25nU3opLmFkZFNjYWxlZChuLCAtYWNyb3NzSW50KSk7XHJcblx0XHRcdGJyZWFrO1xyXG4vL1x0Y2FzZSBCb25kLlBBVFRFUk4uUkVBQ1RJTkdfQ0VOVEVSLlVOQ0hBTkdFRDogIC8vIG9cclxuLy9cdFx0Ly9kcmF3IGEgY2lyY2xlXHJcbi8vXHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSBCb25kLlBBVFRFUk4uUkVBQ1RJTkdfQ0VOVEVSLk1BREVfT1JfQlJPS0VOOlxyXG5cdFx0XHRwLnB1c2goYy5hZGRTY2FsZWQobiwgYWNyb3NzU3opLmFkZFNjYWxlZChkLCBhbG9uZ0ludE1hZGVCcm9rZW4pKTtcclxuXHRcdFx0cC5wdXNoKGMuYWRkU2NhbGVkKG4sIC1hY3Jvc3NTeikuYWRkU2NhbGVkKGQsIGFsb25nSW50TWFkZUJyb2tlbikpO1xyXG5cdFx0XHRwLnB1c2goYy5hZGRTY2FsZWQobiwgYWNyb3NzU3opLmFkZFNjYWxlZChkLCAtYWxvbmdJbnRNYWRlQnJva2VuKSk7XHJcblx0XHRcdHAucHVzaChjLmFkZFNjYWxlZChuLCAtYWNyb3NzU3opLmFkZFNjYWxlZChkLCAtYWxvbmdJbnRNYWRlQnJva2VuKSk7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSBCb25kLlBBVFRFUk4uUkVBQ1RJTkdfQ0VOVEVSLk9SREVSX0NIQU5HRUQ6XHJcblx0XHRcdHAucHVzaChjLmFkZFNjYWxlZChuLCBhY3Jvc3NTeikpO1xyXG5cdFx0XHRwLnB1c2goYy5hZGRTY2FsZWQobiwgLWFjcm9zc1N6KSk7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSBCb25kLlBBVFRFUk4uUkVBQ1RJTkdfQ0VOVEVSLk1BREVfT1JfQlJPS0VOX0FORF9DSEFOR0VEOlxyXG5cdFx0XHRwLnB1c2goYy5hZGRTY2FsZWQobiwgYWNyb3NzU3opLmFkZFNjYWxlZChkLCBhbG9uZ0ludE1hZGVCcm9rZW4pKTtcclxuXHRcdFx0cC5wdXNoKGMuYWRkU2NhbGVkKG4sIC1hY3Jvc3NTeikuYWRkU2NhbGVkKGQsIGFsb25nSW50TWFkZUJyb2tlbikpO1xyXG5cdFx0XHRwLnB1c2goYy5hZGRTY2FsZWQobiwgYWNyb3NzU3opLmFkZFNjYWxlZChkLCAtYWxvbmdJbnRNYWRlQnJva2VuKSk7XHJcblx0XHRcdHAucHVzaChjLmFkZFNjYWxlZChuLCAtYWNyb3NzU3opLmFkZFNjYWxlZChkLCAtYWxvbmdJbnRNYWRlQnJva2VuKSk7XHJcblx0XHRcdHAucHVzaChjLmFkZFNjYWxlZChuLCBhY3Jvc3NTeikpO1xyXG5cdFx0XHRwLnB1c2goYy5hZGRTY2FsZWQobiwgLWFjcm9zc1N6KSk7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0ZGVmYXVsdDpcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cclxuXHR2YXIgcGF0aGRlc2MgPSAnJztcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoIC8gMjsgKytpKVxyXG5cdFx0cGF0aGRlc2MgKz0gcm5kLlJlU3RydWN0Lm1ha2VTdHJva2UocFsyICogaV0sIHBbMiAqIGkgKyAxXSk7XHJcblx0cmV0dXJuIHBhcGVyLnBhdGgocGF0aGRlc2MpLmF0dHIoc3R5bGVzLmxpbmVhdHRyKTtcclxufTtcclxuXHJcbnJuZC5SZVN0cnVjdC5wcm90b3R5cGUuZHJhd1RvcG9sb2d5TWFyayA9IGZ1bmN0aW9uIChib25kLCBoYjEsIGhiMilcclxue1xyXG5cdHZhciB0b3BvbG9neU1hcmsgPSBudWxsO1xyXG5cclxuXHRpZiAoYm9uZC5iLnRvcG9sb2d5ID09IEJvbmQuUEFUVEVSTi5UT1BPTE9HWS5SSU5HKVxyXG5cdFx0dG9wb2xvZ3lNYXJrID0gJ3JuZyc7XHJcblx0ZWxzZSBpZiAoYm9uZC5iLnRvcG9sb2d5ID09IEJvbmQuUEFUVEVSTi5UT1BPTE9HWS5DSEFJTilcclxuXHRcdHRvcG9sb2d5TWFyayA9ICdjaG4nO1xyXG5cdGVsc2VcclxuXHRcdHJldHVybiBudWxsO1xyXG5cclxuXHR2YXIgcGFwZXIgPSB0aGlzLnJlbmRlci5wYXBlcjtcclxuXHR2YXIgc2V0dGluZ3MgPSB0aGlzLnJlbmRlci5zZXR0aW5ncztcclxuXHJcblx0dmFyIGEgPSBoYjEucCwgYiA9IGhiMi5wO1xyXG5cdHZhciBjID0gYi5hZGQoYSkuc2NhbGVkKDAuNSk7XHJcblx0dmFyIGQgPSBiLnN1YihhKS5ub3JtYWxpemVkKCk7XHJcblx0dmFyIG4gPSBkLnJvdGF0ZVNDKDEsIDApO1xyXG5cdHZhciBmaXhlZCA9IHNldHRpbmdzLmxpbmVXaWR0aDtcclxuXHRpZiAoYm9uZC5kb3VibGVCb25kU2hpZnQgPiAwKVxyXG5cdFx0biA9IG4uc2NhbGVkKC1ib25kLmRvdWJsZUJvbmRTaGlmdCk7XHJcblx0ZWxzZSBpZiAoYm9uZC5kb3VibGVCb25kU2hpZnQgPT0gMClcclxuXHRcdGZpeGVkICs9IHNldHRpbmdzLmJvbmRTcGFjZSAvIDI7XHJcblxyXG5cdHZhciBzID0gbmV3IFZlYzIoMiwgMSkuc2NhbGVkKHNldHRpbmdzLmJvbmRTcGFjZSk7XHJcblx0aWYgKGJvbmQuYi50eXBlID09IEJvbmQuUEFUVEVSTi5UWVBFLlRSSVBMRSlcclxuXHRcdGZpeGVkICs9IHNldHRpbmdzLmJvbmRTcGFjZTtcclxuXHR2YXIgcCA9IGMuYWRkKG5ldyBWZWMyKG4ueCAqIChzLnggKyBmaXhlZCksIG4ueSAqIChzLnkgKyBmaXhlZCkpKTtcclxuXHR2YXIgcGF0aCA9IHBhcGVyLnRleHQocC54LCBwLnksIHRvcG9sb2d5TWFyaylcclxuXHQuYXR0cih7XHJcblx0XHQnZm9udCc6IHNldHRpbmdzLmZvbnQsXHJcblx0XHQnZm9udC1zaXplJzogc2V0dGluZ3MuZm9udHN6c3ViLFxyXG5cdFx0J2ZpbGwnOiAnIzAwMCdcclxuXHR9KTtcclxuXHR2YXIgcmJiID0gdXRpbC5yZWxCb3gocGF0aC5nZXRCQm94KCkpO1xyXG5cdHRoaXMuY2VudGVyVGV4dChwYXRoLCByYmIpO1xyXG5cdHJldHVybiBwYXRoO1xyXG59O1xyXG5cclxucm5kLlJlU3RydWN0LnByb3RvdHlwZS5kcmF3Qm9uZCA9IGZ1bmN0aW9uIChib25kLCBoYjEsIGhiMilcclxue1xyXG5cdHZhciBwYXRoID0gbnVsbDtcclxuXHR2YXIgbW9sZWN1bGUgPSB0aGlzLm1vbGVjdWxlO1xyXG5cdHN3aXRjaCAoYm9uZC5iLnR5cGUpXHJcblx0XHR7XHJcblx0XHRjYXNlIEJvbmQuUEFUVEVSTi5UWVBFLlNJTkdMRTpcclxuXHRcdFx0c3dpdGNoIChib25kLmIuc3RlcmVvKSB7XHJcblx0XHRcdFx0Y2FzZSBCb25kLlBBVFRFUk4uU1RFUkVPLlVQOlxyXG5cdFx0XHRcdFx0dGhpcy5maW5kSW5jb21pbmdVcEJvbmRzKGhiMS5iaWQsIGJvbmQpO1xyXG5cdFx0XHRcdFx0aWYgKGJvbmQuYm9sZFN0ZXJlbyAmJiBib25kLm5laWhiaWQxID49IDAgJiYgYm9uZC5uZWloYmlkMiA+PSAwKVxyXG5cdFx0XHRcdFx0XHRwYXRoID0gdGhpcy5kcmF3Qm9uZFNpbmdsZVN0ZXJlb0JvbGQoaGIxLCBoYjIsIGJvbmQpO1xyXG5cdFx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0XHRwYXRoID0gdGhpcy5kcmF3Qm9uZFNpbmdsZVVwKGhiMSwgaGIyLCBib25kKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgQm9uZC5QQVRURVJOLlNURVJFTy5ET1dOOlxyXG5cdFx0XHRcdFx0cGF0aCA9IHRoaXMuZHJhd0JvbmRTaW5nbGVEb3duKGhiMSwgaGIyLCBib25kKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgQm9uZC5QQVRURVJOLlNURVJFTy5FSVRIRVI6XHJcblx0XHRcdFx0XHRwYXRoID0gdGhpcy5kcmF3Qm9uZFNpbmdsZUVpdGhlcihoYjEsIGhiMiwgYm9uZCk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdFx0cGF0aCA9IHRoaXMuZHJhd0JvbmRTaW5nbGUoaGIxLCBoYjIpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlIEJvbmQuUEFUVEVSTi5UWVBFLkRPVUJMRTpcclxuXHRcdFx0dGhpcy5maW5kSW5jb21pbmdVcEJvbmRzKGhiMS5iaWQsIGJvbmQpO1xyXG5cdFx0XHRpZiAoYm9uZC5iLnN0ZXJlbyA9PT0gQm9uZC5QQVRURVJOLlNURVJFTy5OT05FICYmIGJvbmQuYm9sZFN0ZXJlb1xyXG5cdFx0XHRcdCAmJiBib25kLm5laWhiaWQxID49IDAgJiYgYm9uZC5uZWloYmlkMiA+PSAwKVxyXG5cdFx0XHRcdHBhdGggPSB0aGlzLmRyYXdCb25kU2luZ2xlU3RlcmVvQm9sZChoYjEsIGhiMiwgYm9uZCwgdHJ1ZSk7XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHRwYXRoID0gdGhpcy5kcmF3Qm9uZERvdWJsZShoYjEsIGhiMiwgYm9uZCxcclxuXHRcdFx0XHRib25kLmIuc3RlcmVvID09PSBCb25kLlBBVFRFUk4uU1RFUkVPLkNJU19UUkFOUyk7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSBCb25kLlBBVFRFUk4uVFlQRS5UUklQTEU6XHJcblx0XHRcdHBhdGggPSB0aGlzLmRyYXdCb25kVHJpcGxlKGhiMSwgaGIyLCBib25kKTtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlIEJvbmQuUEFUVEVSTi5UWVBFLkFST01BVElDOlxyXG5cdFx0XHR2YXIgaW5Bcm9tYXRpY0xvb3AgPSAoaGIxLmxvb3AgPj0gMCAmJiBtb2xlY3VsZS5sb29wcy5nZXQoaGIxLmxvb3ApLmFyb21hdGljKSB8fFxyXG5cdFx0XHQoaGIyLmxvb3AgPj0gMCAmJiBtb2xlY3VsZS5sb29wcy5nZXQoaGIyLmxvb3ApLmFyb21hdGljKTtcclxuXHRcdFx0cGF0aCA9IHRoaXMuZHJhd0JvbmRBcm9tYXRpYyhoYjEsIGhiMiwgYm9uZCwgIWluQXJvbWF0aWNMb29wKTtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlIEJvbmQuUEFUVEVSTi5UWVBFLlNJTkdMRV9PUl9ET1VCTEU6XHJcblx0XHRcdHBhdGggPSB0aGlzLmRyYXdCb25kU2luZ2xlT3JEb3VibGUoaGIxLCBoYjIsIGJvbmQpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgQm9uZC5QQVRURVJOLlRZUEUuU0lOR0xFX09SX0FST01BVElDOlxyXG5cdFx0XHRwYXRoID0gdGhpcy5kcmF3Qm9uZFNpbmdsZU9yQXJvbWF0aWMoaGIxLCBoYjIsIGJvbmQpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgQm9uZC5QQVRURVJOLlRZUEUuRE9VQkxFX09SX0FST01BVElDOlxyXG5cdFx0XHRwYXRoID0gdGhpcy5kcmF3Qm9uZERvdWJsZU9yQXJvbWF0aWMoaGIxLCBoYjIsIGJvbmQpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgQm9uZC5QQVRURVJOLlRZUEUuQU5ZOlxyXG5cdFx0XHRwYXRoID0gdGhpcy5kcmF3Qm9uZEFueShoYjEsIGhiMiwgYm9uZCk7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0ZGVmYXVsdDpcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdCb25kIHR5cGUgJyArIGJvbmQuYi50eXBlICsgJyBub3Qgc3VwcG9ydGVkJyk7XHJcblx0fVxyXG5cdHJldHVybiBwYXRoO1xyXG59O1xyXG5cclxucm5kLlJlU3RydWN0LnByb3RvdHlwZS5yYWRpY2FsQ2FwID0gZnVuY3Rpb24gKHApXHJcbntcclxuXHR2YXIgc2V0dGluZ3MgPSB0aGlzLnJlbmRlci5zZXR0aW5ncztcclxuXHR2YXIgcGFwZXIgPSB0aGlzLnJlbmRlci5wYXBlcjtcclxuXHR2YXIgcyA9IHNldHRpbmdzLmxpbmVXaWR0aCAqIDAuOTtcclxuXHR2YXIgZHcgPSBzLCBkaCA9IDIgKiBzO1xyXG5cdHJldHVybiBwYXBlci5wYXRoKCdNezB9LHsxfUx7Mn0sezN9THs0fSx7NX0nLFxyXG5cdHRmeChwLnggLSBkdyksIHRmeChwLnkgKyBkaCksIHRmeChwLngpLCB0ZngocC55KSwgdGZ4KHAueCArIGR3KSwgdGZ4KHAueSArIGRoKSlcclxuXHQuYXR0cih7XHJcblx0XHQnc3Ryb2tlJzogJyMwMDAnLFxyXG5cdFx0J3N0cm9rZS13aWR0aCc6IHNldHRpbmdzLmxpbmVXaWR0aCAqIDAuNyxcclxuXHRcdCdzdHJva2UtbGluZWNhcCc6ICdzcXVhcmUnLFxyXG5cdFx0J3N0cm9rZS1saW5lam9pbic6ICdtaXRlcidcclxuXHR9KTtcclxufTtcclxuXHJcbnJuZC5SZVN0cnVjdC5wcm90b3R5cGUucmFkaWNhbEJ1bGxldCA9IGZ1bmN0aW9uIChwKVxyXG57XHJcblx0dmFyIHNldHRpbmdzID0gdGhpcy5yZW5kZXIuc2V0dGluZ3M7XHJcblx0dmFyIHBhcGVyID0gdGhpcy5yZW5kZXIucGFwZXI7XHJcblx0cmV0dXJuIHBhcGVyLmNpcmNsZShwLngsIHAueSwgc2V0dGluZ3MubGluZVdpZHRoKVxyXG5cdC5hdHRyKHtcclxuXHRcdHN0cm9rZTogbnVsbCxcclxuXHRcdGZpbGw6ICcjMDAwJ1xyXG5cdH0pO1xyXG59O1xyXG5cclxucm5kLlJlU3RydWN0LnByb3RvdHlwZS5jZW50ZXJUZXh0ID0gZnVuY3Rpb24gKHBhdGgsIHJiYilcclxue1xyXG5cdC8vIFRPRE86IGZpbmQgYSBiZXR0ZXIgd2F5XHJcblx0aWYgKHRoaXMucmVuZGVyLnBhcGVyLnJhcGhhZWwudm1sKSB7XHJcblx0XHR0aGlzLnBhdGhBbmRSQm94VHJhbnNsYXRlKHBhdGgsIHJiYiwgMCwgcmJiLmhlaWdodCAqIDAuMTYpOyAvLyBkaXJ0eSBoYWNrXHJcblx0fVxyXG59O1xyXG5cclxucm5kLlJlU3RydWN0LnByb3RvdHlwZS5zaG93SXRlbVNlbGVjdGlvbiA9IGZ1bmN0aW9uIChpZCwgaXRlbSwgdmlzaWJsZSlcclxue1xyXG5cdHZhciBleGlzdHMgPSAoaXRlbS5zZWxlY3Rpb25QbGF0ZSAhPSBudWxsKSAmJiAhaXRlbS5zZWxlY3Rpb25QbGF0ZS5yZW1vdmVkO1xyXG5cdC8vIHJiYWxhYmFub3Y6IGhlcmUgaXMgdGVtcG9yYXJ5IGZpeCBmb3IgXCJkcmFnIGlzc3VlXCIgb24gaVBhZFxyXG5cdC8vQkVHSU5cclxuXHRleGlzdHMgPSBleGlzdHMgJiYgKCEoJ2hpZGRlblBhdGhzJyBpbiBybmQuUmVTdHJ1Y3QucHJvdG90eXBlKSB8fCBybmQuUmVTdHJ1Y3QucHJvdG90eXBlLmhpZGRlblBhdGhzLmluZGV4T2YoaXRlbS5zZWxlY3Rpb25QbGF0ZSkgPCAwKTtcclxuXHQvL0VORFxyXG5cdGlmICh2aXNpYmxlKSB7XHJcblx0XHRpZiAoIWV4aXN0cykge1xyXG5cdFx0XHR2YXIgcmVuZGVyID0gdGhpcy5yZW5kZXI7XHJcblx0XHRcdHZhciBzdHlsZXMgPSByZW5kZXIuc3R5bGVzO1xyXG5cdFx0XHR2YXIgcGFwZXIgPSByZW5kZXIucGFwZXI7XHJcblx0XHRcdGl0ZW0uc2VsZWN0aW9uUGxhdGUgPSBpdGVtLm1ha2VTZWxlY3Rpb25QbGF0ZSh0aGlzLCBwYXBlciwgc3R5bGVzKTtcclxuXHRcdFx0dGhpcy5hZGRSZU9iamVjdFBhdGgoJ3NlbGVjdGlvbi1wbGF0ZScsIGl0ZW0udmlzZWwsIGl0ZW0uc2VsZWN0aW9uUGxhdGUpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGl0ZW0uc2VsZWN0aW9uUGxhdGUpIGl0ZW0uc2VsZWN0aW9uUGxhdGUuc2hvdygpOyAvLyBUT0RPIFtSQl0gcmV2aWV3XHJcblx0fSBlbHNlIHtcclxuXHRcdGlmIChleGlzdHMpXHJcblx0XHRpZiAoaXRlbS5zZWxlY3Rpb25QbGF0ZSkgaXRlbS5zZWxlY3Rpb25QbGF0ZS5oaWRlKCk7IC8vIFRPRE8gW1JCXSByZXZpZXdcclxuXHR9XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QucHJvdG90eXBlLnBhdGhBbmRSQm94VHJhbnNsYXRlID0gZnVuY3Rpb24gKHBhdGgsIHJiYiwgeCwgeSlcclxue1xyXG5cdHBhdGgudHJhbnNsYXRlQWJzKHgsIHkpO1xyXG5cdHJiYi54ICs9IHg7XHJcblx0cmJiLnkgKz0geTtcclxufTtcclxuXHJcbnZhciBtYXJrZXJDb2xvcnMgPSBbJ2JsYWNrJywgJ2N5YW4nLCAnbWFnZW50YScsICdyZWQnLCAnZ3JlZW4nLCAnYmx1ZScsICdncmVlbiddO1xyXG5cclxucm5kLlJlU3RydWN0LnByb3RvdHlwZS5zaG93TGFiZWxzID0gZnVuY3Rpb24gKClcclxue1xyXG5cdHZhciByZW5kZXIgPSB0aGlzLnJlbmRlcjtcclxuXHR2YXIgc2V0dGluZ3MgPSByZW5kZXIuc2V0dGluZ3M7XHJcblx0dmFyIHN0eWxlcyA9IHJlbmRlci5zdHlsZXM7XHJcblx0dmFyIG9wdCA9IHJlbmRlci5vcHQ7XHJcblx0dmFyIHBhcGVyID0gcmVuZGVyLnBhcGVyO1xyXG5cdHZhciBkZWx0YSA9IDAuNSAqIHNldHRpbmdzLmxpbmVXaWR0aDtcclxuXHRmb3IgKHZhciBhaWQgaW4gdGhpcy5hdG9tc0NoYW5nZWQpIHtcclxuXHRcdHZhciBhdG9tID0gdGhpcy5hdG9tcy5nZXQoYWlkKTtcclxuXHJcblx0XHR2YXIgcHMgPSByZW5kZXIucHMoYXRvbS5hLnBwKTtcclxuXHRcdHZhciBpbmRleCA9IG51bGw7XHJcblx0XHRpZiAob3B0LnNob3dBdG9tSWRzKSB7XHJcblx0XHRcdGluZGV4ID0ge307XHJcblx0XHRcdGluZGV4LnRleHQgPSBhaWQudG9TdHJpbmcoKTtcclxuXHRcdFx0aW5kZXgucGF0aCA9IHBhcGVyLnRleHQocHMueCwgcHMueSwgaW5kZXgudGV4dClcclxuXHRcdFx0LmF0dHIoe1xyXG5cdFx0XHRcdCdmb250Jzogc2V0dGluZ3MuZm9udCxcclxuXHRcdFx0XHQnZm9udC1zaXplJzogc2V0dGluZ3MuZm9udHN6c3ViLFxyXG5cdFx0XHRcdCdmaWxsJzogJyMwNzAnXHJcblx0XHRcdH0pO1xyXG5cdFx0XHRpbmRleC5yYmIgPSB1dGlsLnJlbEJveChpbmRleC5wYXRoLmdldEJCb3goKSk7XHJcblx0XHRcdHRoaXMuY2VudGVyVGV4dChpbmRleC5wYXRoLCBpbmRleC5yYmIpO1xyXG5cdFx0XHR0aGlzLmFkZFJlT2JqZWN0UGF0aCgnaW5kaWNlcycsIGF0b20udmlzZWwsIGluZGV4LnBhdGgsIHBzKTtcclxuXHRcdH1cclxuXHRcdGF0b20uc2V0SGlnaGxpZ2h0KGF0b20uaGlnaGxpZ2h0LCByZW5kZXIpO1xyXG5cclxuXHRcdHZhciBjb2xvciA9ICcjMDAwMDAwJztcclxuXHRcdGlmIChhdG9tLnNob3dMYWJlbClcclxuXHRcdHtcclxuXHRcdFx0dmFyIHJpZ2h0TWFyZ2luID0gMCwgbGVmdE1hcmdpbiA9IDA7XHJcblx0XHRcdC8vIGxhYmVsXHJcblx0XHRcdHZhciBsYWJlbCA9IHt9O1xyXG5cdFx0XHRpZiAoYXRvbS5hLmF0b21MaXN0ICE9IG51bGwpIHtcclxuXHRcdFx0XHRsYWJlbC50ZXh0ID0gYXRvbS5hLmF0b21MaXN0LmxhYmVsKCk7XHJcblx0XHRcdH0gZWxzZSBpZiAoYXRvbS5hLmxhYmVsID09ICdSIycgJiYgYXRvbS5hLnJnbGFiZWwgIT0gbnVsbCkge1xyXG5cdFx0XHRcdGxhYmVsLnRleHQgPSAnJztcclxuXHRcdFx0XHRmb3IgKHZhciByZ2kgPSAwOyByZ2kgPCAzMjsgcmdpKyspIHtcclxuXHRcdFx0XHRcdGlmIChhdG9tLmEucmdsYWJlbCAmICgxIDw8IHJnaSkpIGxhYmVsLnRleHQgKz0gKCdSJyArIChyZ2kgKyAxKS50b1N0cmluZygpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKGxhYmVsLnRleHQgPT0gJycpIGxhYmVsID0gJ1IjJzsgLy8gZm9yIHN0cnVjdHVyZXMgdGhhdCBtaXNzZWQgJ00gIFJHUCcgdGFnIGluIG1vbGZpbGVcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsYWJlbC50ZXh0ID0gYXRvbS5hLmxhYmVsO1xyXG5cdFx0XHRcdGlmIChvcHQuYXRvbUNvbG9yaW5nKSB7XHJcblx0XHRcdFx0XHR2YXIgZWxlbSA9IGVsZW1lbnQuZ2V0RWxlbWVudEJ5TGFiZWwobGFiZWwudGV4dCk7XHJcblx0XHRcdFx0XHRpZiAoZWxlbSlcclxuXHRcdFx0XHRcdFx0Y29sb3IgPSBlbGVtZW50LmdldChlbGVtKS5jb2xvcjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0bGFiZWwucGF0aCA9IHBhcGVyLnRleHQocHMueCwgcHMueSwgbGFiZWwudGV4dClcclxuXHRcdFx0LmF0dHIoe1xyXG5cdFx0XHRcdCdmb250Jzogc2V0dGluZ3MuZm9udCxcclxuXHRcdFx0XHQnZm9udC1zaXplJzogc2V0dGluZ3MuZm9udHN6LFxyXG5cdFx0XHRcdCdmaWxsJzogY29sb3JcclxuXHRcdFx0fSk7XHJcblx0XHRcdGxhYmVsLnJiYiA9IHV0aWwucmVsQm94KGxhYmVsLnBhdGguZ2V0QkJveCgpKTtcclxuXHRcdFx0dGhpcy5jZW50ZXJUZXh0KGxhYmVsLnBhdGgsIGxhYmVsLnJiYik7XHJcblx0XHRcdGlmIChhdG9tLmEuYXRvbUxpc3QgIT0gbnVsbClcclxuXHRcdFx0XHR0aGlzLnBhdGhBbmRSQm94VHJhbnNsYXRlKGxhYmVsLnBhdGgsIGxhYmVsLnJiYiwgKGF0b20uaHlkcm9nZW5PblRoZUxlZnQgPyAtMSA6IDEpICogKGxhYmVsLnJiYi53aWR0aCAtIGxhYmVsLnJiYi5oZWlnaHQpIC8gMiwgMCk7XHJcblx0XHRcdHRoaXMuYWRkUmVPYmplY3RQYXRoKCdkYXRhJywgYXRvbS52aXNlbCwgbGFiZWwucGF0aCwgcHMsIHRydWUpO1xyXG5cdFx0XHRyaWdodE1hcmdpbiA9IGxhYmVsLnJiYi53aWR0aCAvIDI7XHJcblx0XHRcdGxlZnRNYXJnaW4gPSAtbGFiZWwucmJiLndpZHRoIC8gMjtcclxuXHRcdFx0dmFyIGltcGxoID0gTWF0aC5mbG9vcihhdG9tLmEuaW1wbGljaXRIKTtcclxuXHRcdFx0dmFyIGlzSHlkcm9nZW4gPSBsYWJlbC50ZXh0ID09ICdIJztcclxuXHRcdFx0dmFyIGh5ZHJvZ2VuID0ge30sIGh5ZHJvSW5kZXggPSBudWxsO1xyXG5cdFx0XHR2YXIgaHlkcm9nZW5MZWZ0ID0gYXRvbS5oeWRyb2dlbk9uVGhlTGVmdDtcclxuXHRcdFx0aWYgKGlzSHlkcm9nZW4gJiYgaW1wbGggPiAwKSB7XHJcblx0XHRcdFx0aHlkcm9JbmRleCA9IHt9O1xyXG5cdFx0XHRcdGh5ZHJvSW5kZXgudGV4dCA9IChpbXBsaCArIDEpLnRvU3RyaW5nKCk7XHJcblx0XHRcdFx0aHlkcm9JbmRleC5wYXRoID1cclxuXHRcdFx0XHRwYXBlci50ZXh0KHBzLngsIHBzLnksIGh5ZHJvSW5kZXgudGV4dClcclxuXHRcdFx0XHQuYXR0cih7XHJcblx0XHRcdFx0XHQnZm9udCc6IHNldHRpbmdzLmZvbnQsXHJcblx0XHRcdFx0XHQnZm9udC1zaXplJzogc2V0dGluZ3MuZm9udHN6c3ViLFxyXG5cdFx0XHRcdFx0J2ZpbGwnOiBjb2xvclxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdGh5ZHJvSW5kZXgucmJiID0gdXRpbC5yZWxCb3goaHlkcm9JbmRleC5wYXRoLmdldEJCb3goKSk7XHJcblx0XHRcdFx0dGhpcy5jZW50ZXJUZXh0KGh5ZHJvSW5kZXgucGF0aCwgaHlkcm9JbmRleC5yYmIpO1xyXG5cdFx0XHRcdHRoaXMucGF0aEFuZFJCb3hUcmFuc2xhdGUoaHlkcm9JbmRleC5wYXRoLCBoeWRyb0luZGV4LnJiYixcclxuXHRcdFx0XHRcdHJpZ2h0TWFyZ2luICsgMC41ICogaHlkcm9JbmRleC5yYmIud2lkdGggKyBkZWx0YSxcclxuXHRcdFx0XHRcdDAuMiAqIGxhYmVsLnJiYi5oZWlnaHQpO1xyXG5cdFx0XHRcdHJpZ2h0TWFyZ2luICs9IGh5ZHJvSW5kZXgucmJiLndpZHRoICsgZGVsdGE7XHJcblx0XHRcdFx0dGhpcy5hZGRSZU9iamVjdFBhdGgoJ2RhdGEnLGF0b20udmlzZWwsIGh5ZHJvSW5kZXgucGF0aCwgcHMsIHRydWUpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgcmFkaWNhbCA9IHt9O1xyXG5cdFx0XHRpZiAoYXRvbS5hLnJhZGljYWwgIT0gMClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHZhciBoc2hpZnQ7XHJcblx0XHRcdFx0c3dpdGNoIChhdG9tLmEucmFkaWNhbClcclxuXHRcdFx0XHRcdHtcclxuXHRcdFx0XHRcdGNhc2UgMTpcclxuXHRcdFx0XHRcdFx0cmFkaWNhbC5wYXRoID0gcGFwZXIuc2V0KCk7XHJcblx0XHRcdFx0XHRcdGhzaGlmdCA9IDEuNiAqIHNldHRpbmdzLmxpbmVXaWR0aDtcclxuXHRcdFx0XHRcdFx0cmFkaWNhbC5wYXRoLnB1c2goXHJcblx0XHRcdFx0XHRcdHRoaXMucmFkaWNhbEJ1bGxldChwcy5hZGQobmV3IFZlYzIoLWhzaGlmdCwgMCkpKSxcclxuXHRcdFx0XHRcdFx0dGhpcy5yYWRpY2FsQnVsbGV0KHBzLmFkZChuZXcgVmVjMihoc2hpZnQsIDApKSkpO1xyXG5cdFx0XHRcdFx0XHRyYWRpY2FsLnBhdGguYXR0cignZmlsbCcsIGNvbG9yKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlIDI6XHJcblx0XHRcdFx0XHRcdHJhZGljYWwucGF0aCA9IHRoaXMucmFkaWNhbEJ1bGxldChwcylcclxuXHRcdFx0XHRcdFx0LmF0dHIoJ2ZpbGwnLCBjb2xvcik7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAzOlxyXG5cdFx0XHRcdFx0XHRyYWRpY2FsLnBhdGggPSBwYXBlci5zZXQoKTtcclxuXHRcdFx0XHRcdFx0aHNoaWZ0ID0gMS42ICogc2V0dGluZ3MubGluZVdpZHRoO1xyXG5cdFx0XHRcdFx0XHRyYWRpY2FsLnBhdGgucHVzaChcclxuXHRcdFx0XHRcdFx0dGhpcy5yYWRpY2FsQ2FwKHBzLmFkZChuZXcgVmVjMigtaHNoaWZ0LCAwKSkpLFxyXG5cdFx0XHRcdFx0XHR0aGlzLnJhZGljYWxDYXAocHMuYWRkKG5ldyBWZWMyKGhzaGlmdCwgMCkpKSk7XHJcblx0XHRcdFx0XHRcdHJhZGljYWwucGF0aC5hdHRyKCdzdHJva2UnLCBjb2xvcik7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyYWRpY2FsLnJiYiA9IHV0aWwucmVsQm94KHJhZGljYWwucGF0aC5nZXRCQm94KCkpO1xyXG5cdFx0XHRcdHZhciB2c2hpZnQgPSAtMC41ICogKGxhYmVsLnJiYi5oZWlnaHQgKyByYWRpY2FsLnJiYi5oZWlnaHQpO1xyXG5cdFx0XHRcdGlmIChhdG9tLmEucmFkaWNhbCA9PSAzKVxyXG5cdFx0XHRcdFx0dnNoaWZ0IC09IHNldHRpbmdzLmxpbmVXaWR0aCAvIDI7XHJcblx0XHRcdFx0dGhpcy5wYXRoQW5kUkJveFRyYW5zbGF0ZShyYWRpY2FsLnBhdGgsIHJhZGljYWwucmJiLFxyXG5cdFx0XHRcdFx0MCwgdnNoaWZ0KTtcclxuXHRcdFx0XHR0aGlzLmFkZFJlT2JqZWN0UGF0aCgnZGF0YScsIGF0b20udmlzZWwsIHJhZGljYWwucGF0aCwgcHMsIHRydWUpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgaXNvdG9wZSA9IHt9O1xyXG5cdFx0XHRpZiAoYXRvbS5hLmlzb3RvcGUgIT0gMClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGlzb3RvcGUudGV4dCA9IGF0b20uYS5pc290b3BlLnRvU3RyaW5nKCk7XHJcblx0XHRcdFx0aXNvdG9wZS5wYXRoID0gcGFwZXIudGV4dChwcy54LCBwcy55LCBpc290b3BlLnRleHQpXHJcblx0XHRcdFx0LmF0dHIoe1xyXG5cdFx0XHRcdFx0J2ZvbnQnOiBzZXR0aW5ncy5mb250LFxyXG5cdFx0XHRcdFx0J2ZvbnQtc2l6ZSc6IHNldHRpbmdzLmZvbnRzenN1YixcclxuXHRcdFx0XHRcdCdmaWxsJzogY29sb3JcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHRpc290b3BlLnJiYiA9IHV0aWwucmVsQm94KGlzb3RvcGUucGF0aC5nZXRCQm94KCkpO1xyXG5cdFx0XHRcdHRoaXMuY2VudGVyVGV4dChpc290b3BlLnBhdGgsIGlzb3RvcGUucmJiKTtcclxuXHRcdFx0XHR0aGlzLnBhdGhBbmRSQm94VHJhbnNsYXRlKGlzb3RvcGUucGF0aCwgaXNvdG9wZS5yYmIsXHJcblx0XHRcdFx0XHRsZWZ0TWFyZ2luIC0gMC41ICogaXNvdG9wZS5yYmIud2lkdGggLSBkZWx0YSxcclxuXHRcdFx0XHRcdC0wLjMgKiBsYWJlbC5yYmIuaGVpZ2h0KTtcclxuXHRcdFx0XHRsZWZ0TWFyZ2luIC09IGlzb3RvcGUucmJiLndpZHRoICsgZGVsdGE7XHJcblx0XHRcdFx0dGhpcy5hZGRSZU9iamVjdFBhdGgoJ2RhdGEnLCBhdG9tLnZpc2VsLCBpc290b3BlLnBhdGgsIHBzLCB0cnVlKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIWlzSHlkcm9nZW4gJiYgaW1wbGggPiAwICYmICFyZW5kZXIub3B0LmhpZGVJbXBsaWNpdEh5ZHJvZ2VuKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0aHlkcm9nZW4udGV4dCA9ICdIJztcclxuXHRcdFx0XHRoeWRyb2dlbi5wYXRoID0gcGFwZXIudGV4dChwcy54LCBwcy55LCBoeWRyb2dlbi50ZXh0KVxyXG5cdFx0XHRcdC5hdHRyKHtcclxuXHRcdFx0XHRcdCdmb250Jzogc2V0dGluZ3MuZm9udCxcclxuXHRcdFx0XHRcdCdmb250LXNpemUnOiBzZXR0aW5ncy5mb250c3osXHJcblx0XHRcdFx0XHQnZmlsbCc6IGNvbG9yXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdFx0aHlkcm9nZW4ucmJiID0gdXRpbC5yZWxCb3goaHlkcm9nZW4ucGF0aC5nZXRCQm94KCkpO1xyXG5cdFx0XHRcdHRoaXMuY2VudGVyVGV4dChoeWRyb2dlbi5wYXRoLCBoeWRyb2dlbi5yYmIpO1xyXG5cdFx0XHRcdGlmICghaHlkcm9nZW5MZWZ0KSB7XHJcblx0XHRcdFx0XHR0aGlzLnBhdGhBbmRSQm94VHJhbnNsYXRlKGh5ZHJvZ2VuLnBhdGgsIGh5ZHJvZ2VuLnJiYixcclxuXHRcdFx0XHRcdFx0cmlnaHRNYXJnaW4gKyAwLjUgKiBoeWRyb2dlbi5yYmIud2lkdGggKyBkZWx0YSwgMCk7XHJcblx0XHRcdFx0XHRyaWdodE1hcmdpbiArPSBoeWRyb2dlbi5yYmIud2lkdGggKyBkZWx0YTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKGltcGxoID4gMSkge1xyXG5cdFx0XHRcdFx0aHlkcm9JbmRleCA9IHt9O1xyXG5cdFx0XHRcdFx0aHlkcm9JbmRleC50ZXh0ID0gaW1wbGgudG9TdHJpbmcoKTtcclxuXHRcdFx0XHRcdGh5ZHJvSW5kZXgucGF0aCA9XHJcblx0XHRcdFx0XHRwYXBlci50ZXh0KHBzLngsIHBzLnksIGh5ZHJvSW5kZXgudGV4dClcclxuXHRcdFx0XHRcdC5hdHRyKHtcclxuXHRcdFx0XHRcdFx0J2ZvbnQnOiBzZXR0aW5ncy5mb250LFxyXG5cdFx0XHRcdFx0XHQnZm9udC1zaXplJzogc2V0dGluZ3MuZm9udHN6c3ViLFxyXG5cdFx0XHRcdFx0XHQnZmlsbCc6IGNvbG9yXHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdGh5ZHJvSW5kZXgucmJiID0gdXRpbC5yZWxCb3goaHlkcm9JbmRleC5wYXRoLmdldEJCb3goKSk7XHJcblx0XHRcdFx0XHR0aGlzLmNlbnRlclRleHQoaHlkcm9JbmRleC5wYXRoLCBoeWRyb0luZGV4LnJiYik7XHJcblx0XHRcdFx0XHRpZiAoIWh5ZHJvZ2VuTGVmdCkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLnBhdGhBbmRSQm94VHJhbnNsYXRlKGh5ZHJvSW5kZXgucGF0aCwgaHlkcm9JbmRleC5yYmIsXHJcblx0XHRcdFx0XHRcdFx0cmlnaHRNYXJnaW4gKyAwLjUgKiBoeWRyb0luZGV4LnJiYi53aWR0aCArIGRlbHRhLFxyXG5cdFx0XHRcdFx0XHRcdDAuMiAqIGxhYmVsLnJiYi5oZWlnaHQpO1xyXG5cdFx0XHRcdFx0XHRyaWdodE1hcmdpbiArPSBoeWRyb0luZGV4LnJiYi53aWR0aCArIGRlbHRhO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoaHlkcm9nZW5MZWZ0KSB7XHJcblx0XHRcdFx0XHRpZiAoaHlkcm9JbmRleCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMucGF0aEFuZFJCb3hUcmFuc2xhdGUoaHlkcm9JbmRleC5wYXRoLCBoeWRyb0luZGV4LnJiYixcclxuXHRcdFx0XHRcdFx0XHRsZWZ0TWFyZ2luIC0gMC41ICogaHlkcm9JbmRleC5yYmIud2lkdGggLSBkZWx0YSxcclxuXHRcdFx0XHRcdFx0XHQwLjIgKiBsYWJlbC5yYmIuaGVpZ2h0KTtcclxuXHRcdFx0XHRcdFx0bGVmdE1hcmdpbiAtPSBoeWRyb0luZGV4LnJiYi53aWR0aCArIGRlbHRhO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dGhpcy5wYXRoQW5kUkJveFRyYW5zbGF0ZShoeWRyb2dlbi5wYXRoLCBoeWRyb2dlbi5yYmIsXHJcblx0XHRcdFx0XHRcdGxlZnRNYXJnaW4gLSAwLjUgKiBoeWRyb2dlbi5yYmIud2lkdGggLSBkZWx0YSwgMCk7XHJcblx0XHRcdFx0XHRsZWZ0TWFyZ2luIC09IGh5ZHJvZ2VuLnJiYi53aWR0aCArIGRlbHRhO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aGlzLmFkZFJlT2JqZWN0UGF0aCgnZGF0YScsIGF0b20udmlzZWwsIGh5ZHJvZ2VuLnBhdGgsIHBzLCB0cnVlKTtcclxuXHRcdFx0XHRpZiAoaHlkcm9JbmRleCAhPSBudWxsKVxyXG5cdFx0XHRcdFx0dGhpcy5hZGRSZU9iamVjdFBhdGgoJ2RhdGEnLCBhdG9tLnZpc2VsLCBoeWRyb0luZGV4LnBhdGgsIHBzLCB0cnVlKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGNoYXJnZSA9IHt9O1xyXG5cdFx0XHRpZiAoYXRvbS5hLmNoYXJnZSAhPSAwKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0Y2hhcmdlLnRleHQgPSAnJztcclxuXHRcdFx0XHR2YXIgYWJzQ2hhcmdlID0gTWF0aC5hYnMoYXRvbS5hLmNoYXJnZSk7XHJcblx0XHRcdFx0aWYgKGFic0NoYXJnZSAhPSAxKVxyXG5cdFx0XHRcdFx0Y2hhcmdlLnRleHQgPSBhYnNDaGFyZ2UudG9TdHJpbmcoKTtcclxuXHRcdFx0XHRpZiAoYXRvbS5hLmNoYXJnZSA8IDApXHJcblx0XHRcdFx0XHRjaGFyZ2UudGV4dCArPSAnXFx1MjAxMyc7XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0Y2hhcmdlLnRleHQgKz0gJysnO1xyXG5cclxuXHRcdFx0XHRjaGFyZ2UucGF0aCA9IHBhcGVyLnRleHQocHMueCwgcHMueSwgY2hhcmdlLnRleHQpXHJcblx0XHRcdFx0LmF0dHIoe1xyXG5cdFx0XHRcdFx0J2ZvbnQnOiBzZXR0aW5ncy5mb250LFxyXG5cdFx0XHRcdFx0J2ZvbnQtc2l6ZSc6IHNldHRpbmdzLmZvbnRzenN1YixcclxuXHRcdFx0XHRcdCdmaWxsJzogY29sb3JcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHRjaGFyZ2UucmJiID0gdXRpbC5yZWxCb3goY2hhcmdlLnBhdGguZ2V0QkJveCgpKTtcclxuXHRcdFx0XHR0aGlzLmNlbnRlclRleHQoY2hhcmdlLnBhdGgsIGNoYXJnZS5yYmIpO1xyXG5cdFx0XHRcdHRoaXMucGF0aEFuZFJCb3hUcmFuc2xhdGUoY2hhcmdlLnBhdGgsIGNoYXJnZS5yYmIsXHJcblx0XHRcdFx0XHRyaWdodE1hcmdpbiArIDAuNSAqIGNoYXJnZS5yYmIud2lkdGggKyBkZWx0YSxcclxuXHRcdFx0XHRcdC0wLjMgKiBsYWJlbC5yYmIuaGVpZ2h0KTtcclxuXHRcdFx0XHRyaWdodE1hcmdpbiArPSBjaGFyZ2UucmJiLndpZHRoICsgZGVsdGE7XHJcblx0XHRcdFx0dGhpcy5hZGRSZU9iamVjdFBhdGgoJ2RhdGEnLCBhdG9tLnZpc2VsLCBjaGFyZ2UucGF0aCwgcHMsIHRydWUpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgdmFsZW5jZSA9IHt9O1xyXG5cdFx0XHR2YXIgbWFwVmFsZW5jZSA9IHtcclxuXHRcdFx0XHQwOiAnMCcsXHJcblx0XHRcdFx0MTogJ0knLFxyXG5cdFx0XHRcdDI6ICdJSScsXHJcblx0XHRcdFx0MzogJ0lJSScsXHJcblx0XHRcdFx0NDogJ0lWJyxcclxuXHRcdFx0XHQ1OiAnVicsXHJcblx0XHRcdFx0NjogJ1ZJJyxcclxuXHRcdFx0XHQ3OiAnVklJJyxcclxuXHRcdFx0XHQ4OiAnVklJSScsXHJcblx0XHRcdFx0OTogJ0lYJyxcclxuXHRcdFx0XHQxMDogJ1gnLFxyXG5cdFx0XHRcdDExOiAnWEknLFxyXG5cdFx0XHRcdDEyOiAnWElJJyxcclxuXHRcdFx0XHQxMzogJ1hJSUknLFxyXG5cdFx0XHRcdDE0OiAnWElWJ1xyXG5cdFx0XHR9O1xyXG5cdFx0XHRpZiAoYXRvbS5hLmV4cGxpY2l0VmFsZW5jZSA+PSAwKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dmFsZW5jZS50ZXh0ID0gbWFwVmFsZW5jZVthdG9tLmEuZXhwbGljaXRWYWxlbmNlXTtcclxuXHRcdFx0XHRpZiAoIXZhbGVuY2UudGV4dClcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignaW52YWxpZCB2YWxlbmNlICcgKyBhdG9tLmEuZXhwbGljaXRWYWxlbmNlLnRvU3RyaW5nKCkpO1xyXG5cdFx0XHRcdHZhbGVuY2UudGV4dCA9ICcoJyArIHZhbGVuY2UudGV4dCArICcpJztcclxuXHRcdFx0XHR2YWxlbmNlLnBhdGggPSBwYXBlci50ZXh0KHBzLngsIHBzLnksIHZhbGVuY2UudGV4dClcclxuXHRcdFx0XHQuYXR0cih7XHJcblx0XHRcdFx0XHQnZm9udCc6IHNldHRpbmdzLmZvbnQsXHJcblx0XHRcdFx0XHQnZm9udC1zaXplJzogc2V0dGluZ3MuZm9udHN6c3ViLFxyXG5cdFx0XHRcdFx0J2ZpbGwnOiBjb2xvclxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdHZhbGVuY2UucmJiID0gdXRpbC5yZWxCb3godmFsZW5jZS5wYXRoLmdldEJCb3goKSk7XHJcblx0XHRcdFx0dGhpcy5jZW50ZXJUZXh0KHZhbGVuY2UucGF0aCwgdmFsZW5jZS5yYmIpO1xyXG5cdFx0XHRcdHRoaXMucGF0aEFuZFJCb3hUcmFuc2xhdGUodmFsZW5jZS5wYXRoLCB2YWxlbmNlLnJiYixcclxuXHRcdFx0XHRcdHJpZ2h0TWFyZ2luICsgMC41ICogdmFsZW5jZS5yYmIud2lkdGggKyBkZWx0YSxcclxuXHRcdFx0XHRcdC0wLjMgKiBsYWJlbC5yYmIuaGVpZ2h0KTtcclxuXHRcdFx0XHRyaWdodE1hcmdpbiArPSB2YWxlbmNlLnJiYi53aWR0aCArIGRlbHRhO1xyXG5cdFx0XHRcdHRoaXMuYWRkUmVPYmplY3RQYXRoKCdkYXRhJywgYXRvbS52aXNlbCwgdmFsZW5jZS5wYXRoLCBwcywgdHJ1ZSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChhdG9tLmEuYmFkQ29ubiAmJiBvcHQuc2hvd1ZhbGVuY2VXYXJuaW5ncykge1xyXG5cdFx0XHRcdHZhciB3YXJuaW5nID0ge307XHJcblx0XHRcdFx0dmFyIHkgPSBwcy55ICsgbGFiZWwucmJiLmhlaWdodCAvIDIgKyBkZWx0YTtcclxuXHRcdFx0XHR3YXJuaW5nLnBhdGggPSBwYXBlci5wYXRoKCdNezB9LHsxfUx7Mn0sezN9JyxcclxuXHRcdFx0XHR0ZngocHMueCArIGxlZnRNYXJnaW4pLCB0ZngoeSksIHRmeChwcy54ICsgcmlnaHRNYXJnaW4pLCB0ZngoeSkpXHJcblx0XHRcdFx0LmF0dHIodGhpcy5yZW5kZXIuc3R5bGVzLmxpbmVhdHRyKVxyXG5cdFx0XHRcdC5hdHRyKHtcclxuXHRcdFx0XHRcdCdzdHJva2UnOicjRjAwJ1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdHdhcm5pbmcucmJiID0gdXRpbC5yZWxCb3god2FybmluZy5wYXRoLmdldEJCb3goKSk7XHJcblx0XHRcdFx0dGhpcy5hZGRSZU9iamVjdFBhdGgoJ3dhcm5pbmdzJywgYXRvbS52aXNlbCwgd2FybmluZy5wYXRoLCBwcywgdHJ1ZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGluZGV4KVxyXG5cdFx0XHRcdHRoaXMucGF0aEFuZFJCb3hUcmFuc2xhdGUoaW5kZXgucGF0aCwgaW5kZXgucmJiLFxyXG5cdFx0XHRcdFx0LTAuNSAqIGxhYmVsLnJiYi53aWR0aCAtIDAuNSAqIGluZGV4LnJiYi53aWR0aCAtIGRlbHRhLFxyXG5cdFx0XHRcdFx0MC4zICogbGFiZWwucmJiLmhlaWdodCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGxzYiA9IHRoaXMuYmlzZWN0TGFyZ2VzdFNlY3RvcihhdG9tKTtcclxuXHJcblx0XHR2YXIgYXN0ZXJpc2sgPSBQcm90b3R5cGUuQnJvd3Nlci5JRSA/ICcqJyA6ICfiiJcnO1xyXG5cdFx0aWYgKGF0b20uYS5hdHRwbnQpIHtcclxuXHRcdFx0dmFyIGksIGMsIGo7XHJcblx0XHRcdGZvciAoaSA9IDAsIGMgPSAwOyBpIDwgNDsgKytpKSB7XHJcblx0XHRcdFx0dmFyIGF0dHBudFRleHQgPSAnJztcclxuXHRcdFx0XHRpZiAoYXRvbS5hLmF0dHBudCAmICgxIDw8IGkpKSB7XHJcblx0XHRcdFx0XHRpZiAoYXR0cG50VGV4dC5sZW5ndGggPiAwKVxyXG5cdFx0XHRcdFx0XHRhdHRwbnRUZXh0ICs9ICcgJztcclxuXHRcdFx0XHRcdGF0dHBudFRleHQgKz0gYXN0ZXJpc2s7XHJcblx0XHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgKGkgPT0gMCA/IDAgOiAoaSArIDEpKTsgKytqKSB7XHJcblx0XHRcdFx0XHRcdGF0dHBudFRleHQgKz0gJ1xcJyc7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR2YXIgcG9zMCA9IG5ldyBWZWMyKHBzKTtcclxuXHRcdFx0XHRcdHZhciBwb3MxID0gcHMuYWRkU2NhbGVkKGxzYiwgMC43ICogc2V0dGluZ3Muc2NhbGVGYWN0b3IpO1xyXG5cclxuXHRcdFx0XHRcdHZhciBhdHRwbnRQYXRoMSA9IHBhcGVyLnRleHQocG9zMS54LCBwb3MxLnksIGF0dHBudFRleHQpXHJcblx0XHRcdFx0XHQuYXR0cih7XHJcblx0XHRcdFx0XHRcdCdmb250Jzogc2V0dGluZ3MuZm9udCxcclxuXHRcdFx0XHRcdFx0J2ZvbnQtc2l6ZSc6IHNldHRpbmdzLmZvbnRzeixcclxuXHRcdFx0XHRcdFx0J2ZpbGwnOiBjb2xvclxyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHR2YXIgYXR0cG50UmJiID0gdXRpbC5yZWxCb3goYXR0cG50UGF0aDEuZ2V0QkJveCgpKTtcclxuXHRcdFx0XHRcdHRoaXMuY2VudGVyVGV4dChhdHRwbnRQYXRoMSwgYXR0cG50UmJiKTtcclxuXHJcblx0XHRcdFx0XHR2YXIgbHNibiA9IGxzYi5uZWdhdGVkKCk7XHJcblx0XHRcdFx0XHRwb3MxID0gcG9zMS5hZGRTY2FsZWQobHNibiwgVmVjMi5zaGlmdFJheUJveChwb3MxLCBsc2JuLCBCb3gyQWJzLmZyb21SZWxCb3goYXR0cG50UmJiKSkgKyBzZXR0aW5ncy5saW5lV2lkdGggLyAyKTtcclxuXHRcdFx0XHRcdHBvczAgPSB0aGlzLnNoaWZ0Qm9uZEVuZChhdG9tLCBwb3MwLCBsc2IsIHNldHRpbmdzLmxpbmVXaWR0aCk7XHJcblx0XHRcdFx0XHR2YXIgbiA9IGxzYi5yb3RhdGVTQygxLCAwKTtcclxuXHRcdFx0XHRcdHZhciBhcnJvd0xlZnQgPSBwb3MxLmFkZFNjYWxlZChuLCAwLjA1ICogc2V0dGluZ3Muc2NhbGVGYWN0b3IpLmFkZFNjYWxlZChsc2JuLCAwLjA5ICogc2V0dGluZ3Muc2NhbGVGYWN0b3IpO1xyXG5cdFx0XHRcdFx0dmFyIGFycm93UmlnaHQgPSBwb3MxLmFkZFNjYWxlZChuLCAtMC4wNSAqIHNldHRpbmdzLnNjYWxlRmFjdG9yKS5hZGRTY2FsZWQobHNibiwgMC4wOSAqIHNldHRpbmdzLnNjYWxlRmFjdG9yKTtcclxuXHRcdFx0XHRcdHZhciBhdHRwbnRQYXRoID0gcGFwZXIuc2V0KCk7XHJcblx0XHRcdFx0XHRhdHRwbnRQYXRoLnB1c2goXHJcblx0XHRcdFx0XHRcdGF0dHBudFBhdGgxLFxyXG5cdFx0XHRcdFx0cGFwZXIucGF0aCgnTXswfSx7MX1MezJ9LHszfU17NH0sezV9THsyfSx7M31MezZ9LHs3fScsIHRmeChwb3MwLngpLCB0ZngocG9zMC55KSwgdGZ4KHBvczEueCksIHRmeChwb3MxLnkpLCB0ZngoYXJyb3dMZWZ0LngpLCB0ZngoYXJyb3dMZWZ0LnkpLCB0ZngoYXJyb3dSaWdodC54KSwgdGZ4KGFycm93UmlnaHQueSkpXHJcblx0XHRcdFx0XHQuYXR0cihzdHlsZXMubGluZWF0dHIpLmF0dHIoeydzdHJva2Utd2lkdGgnOiBzZXR0aW5ncy5saW5lV2lkdGggLyAyfSlcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHR0aGlzLmFkZFJlT2JqZWN0UGF0aCgnaW5kaWNlcycsIGF0b20udmlzZWwsIGF0dHBudFBhdGgsIHBzKTtcclxuXHRcdFx0XHRcdGxzYiA9IGxzYi5yb3RhdGUoTWF0aC5QSSAvIDYpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBhYW1UZXh0ID0gJyc7XHJcblx0XHRpZiAoYXRvbS5hLmFhbSA+IDApIHtcclxuXHRcdFx0YWFtVGV4dCArPSBhdG9tLmEuYWFtO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGF0b20uYS5pbnZSZXQgPiAwKSB7XHJcblx0XHRcdGlmIChhYW1UZXh0Lmxlbmd0aCA+IDApXHJcblx0XHRcdFx0YWFtVGV4dCArPSAnLCc7XHJcblx0XHRcdGlmIChhdG9tLmEuaW52UmV0ID09IDEpXHJcblx0XHRcdFx0YWFtVGV4dCArPSAnSW52JztcclxuXHRcdFx0ZWxzZSBpZiAoYXRvbS5hLmludlJldCA9PSAyKVxyXG5cdFx0XHRcdGFhbVRleHQgKz0gJ1JldCc7XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIHRoZSBpbnZlcnQvcmV0YWluIGZsYWcnKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcXVlcnlBdHRyc1RleHQgPSAnJztcclxuXHRcdGlmIChhdG9tLmEucmluZ0JvbmRDb3VudCAhPSAwKSB7XHJcblx0XHRcdGlmIChhdG9tLmEucmluZ0JvbmRDb3VudCA+IDApXHJcblx0XHRcdFx0cXVlcnlBdHRyc1RleHQgKz0gJ3JiJyArIGF0b20uYS5yaW5nQm9uZENvdW50LnRvU3RyaW5nKCk7XHJcblx0XHRcdGVsc2UgaWYgKGF0b20uYS5yaW5nQm9uZENvdW50ID09IC0xKVxyXG5cdFx0XHRcdHF1ZXJ5QXR0cnNUZXh0ICs9ICdyYjAnO1xyXG5cdFx0XHRlbHNlIGlmIChhdG9tLmEucmluZ0JvbmRDb3VudCA9PSAtMilcclxuXHRcdFx0XHRxdWVyeUF0dHJzVGV4dCArPSAncmIqJztcclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignUmluZyBib25kIGNvdW50IGludmFsaWQnKTtcclxuXHRcdH1cclxuXHRcdGlmIChhdG9tLmEuc3Vic3RpdHV0aW9uQ291bnQgIT0gMCkge1xyXG5cdFx0XHRpZiAocXVlcnlBdHRyc1RleHQubGVuZ3RoID4gMClcclxuXHRcdFx0XHRxdWVyeUF0dHJzVGV4dCArPSAnLCc7XHJcblxyXG5cdFx0XHRpZiAoYXRvbS5hLnN1YnN0aXR1dGlvbkNvdW50ID4gMClcclxuXHRcdFx0XHRxdWVyeUF0dHJzVGV4dCArPSAncycgKyBhdG9tLmEuc3Vic3RpdHV0aW9uQ291bnQudG9TdHJpbmcoKTtcclxuXHRcdFx0ZWxzZSBpZiAoYXRvbS5hLnN1YnN0aXR1dGlvbkNvdW50ID09IC0xKVxyXG5cdFx0XHRcdHF1ZXJ5QXR0cnNUZXh0ICs9ICdzMCc7XHJcblx0XHRcdGVsc2UgaWYgKGF0b20uYS5zdWJzdGl0dXRpb25Db3VudCA9PSAtMilcclxuXHRcdFx0XHRxdWVyeUF0dHJzVGV4dCArPSAncyonO1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdTdWJzdGl0dXRpb24gY291bnQgaW52YWxpZCcpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGF0b20uYS51bnNhdHVyYXRlZEF0b20gPiAwKSB7XHJcblx0XHRcdGlmIChxdWVyeUF0dHJzVGV4dC5sZW5ndGggPiAwKVxyXG5cdFx0XHRcdHF1ZXJ5QXR0cnNUZXh0ICs9ICcsJztcclxuXHJcblx0XHRcdGlmIChhdG9tLmEudW5zYXR1cmF0ZWRBdG9tID09IDEpXHJcblx0XHRcdFx0cXVlcnlBdHRyc1RleHQgKz0gJ3UnO1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbnNhdHVyYXRlZCBhdG9tIGludmFsaWQgdmFsdWUnKTtcclxuXHRcdH1cclxuXHRcdGlmIChhdG9tLmEuaENvdW50ID4gMCkge1xyXG5cdFx0XHRpZiAocXVlcnlBdHRyc1RleHQubGVuZ3RoID4gMClcclxuXHRcdFx0XHRxdWVyeUF0dHJzVGV4dCArPSAnLCc7XHJcblxyXG5cdFx0XHRxdWVyeUF0dHJzVGV4dCArPSAnSCcgKyAoYXRvbS5hLmhDb3VudCAtIDEpLnRvU3RyaW5nKCk7XHJcblx0XHR9XHJcblxyXG5cclxuXHRcdGlmIChhdG9tLmEuZXhhY3RDaGFuZ2VGbGFnID4gMCkge1xyXG5cdFx0XHRpZiAoYWFtVGV4dC5sZW5ndGggPiAwKVxyXG5cdFx0XHRcdGFhbVRleHQgKz0gJywnO1xyXG5cdFx0XHRpZiAoYXRvbS5hLmV4YWN0Q2hhbmdlRmxhZyA9PSAxKVxyXG5cdFx0XHRcdGFhbVRleHQgKz0gJ2V4dCc7XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIHRoZSBleGFjdCBjaGFuZ2UgZmxhZycpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHRoaXMgaW5jbHVkZXMgYm90aCBhYW0gZmxhZ3MsIGlmIGFueSwgYW5kIHF1ZXJ5IGZlYXR1cmVzLCBpZiBhbnlcclxuXHRcdC8vIHdlIHJlbmRlciB0aGVtIHRvZ2V0aGVyIHRvIGF2b2lkIHBvc3NpYmxlIGNvbGxpc2lvbnNcclxuXHRcdGFhbVRleHQgPSAocXVlcnlBdHRyc1RleHQubGVuZ3RoID4gMCA/IHF1ZXJ5QXR0cnNUZXh0ICsgJ1xcbicgOiAnJykgKyAoYWFtVGV4dC5sZW5ndGggPiAwID8gJy4nICsgYWFtVGV4dCArICcuJyA6ICcnKTtcclxuXHRcdGlmIChhYW1UZXh0Lmxlbmd0aCA+IDApIHtcclxuXHRcdFx0dmFyIGFhbVBhdGggPSBwYXBlci50ZXh0KHBzLngsIHBzLnksIGFhbVRleHQpXHJcblx0XHRcdC5hdHRyKHtcclxuXHRcdFx0XHQnZm9udCc6IHNldHRpbmdzLmZvbnQsXHJcblx0XHRcdFx0J2ZvbnQtc2l6ZSc6IHNldHRpbmdzLmZvbnRzenN1YixcclxuXHRcdFx0XHQnZmlsbCc6IGNvbG9yXHJcblx0XHRcdH0pO1xyXG5cdFx0XHR2YXIgYWFtQm94ID0gdXRpbC5yZWxCb3goYWFtUGF0aC5nZXRCQm94KCkpO1xyXG5cdFx0XHR0aGlzLmNlbnRlclRleHQoYWFtUGF0aCwgYWFtQm94KTtcclxuXHRcdFx0dmFyIGRpciA9IHRoaXMuYmlzZWN0TGFyZ2VzdFNlY3RvcihhdG9tKTtcclxuXHRcdFx0dmFyIHZpc2VsID0gYXRvbS52aXNlbDtcclxuXHRcdFx0dmFyIHQgPSAzO1xyXG5cdFx0XHQvLyBlc3RpbWF0ZSB0aGUgc2hpZnQgdG8gY2xlYXIgdGhlIGF0b20gbGFiZWxcclxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHZpc2VsLmV4dHMubGVuZ3RoOyArK2kpXHJcblx0XHRcdFx0dCA9IE1hdGgubWF4KHQsIFZlYzIuc2hpZnRSYXlCb3gocHMsIGRpciwgdmlzZWwuZXh0c1tpXS50cmFuc2xhdGUocHMpKSk7XHJcblx0XHRcdC8vIGVzdGltYXRlIHRoZSBzaGlmdCBiYWNrd2FyZHMgdG8gYWNjb3VudCBmb3IgdGhlIHNpemUgb2YgdGhlIGFhbS9xdWVyeSB0ZXh0IGJveCBpdHNlbGZcclxuXHRcdFx0dCArPSBWZWMyLnNoaWZ0UmF5Qm94KHBzLCBkaXIubmVnYXRlZCgpLCBCb3gyQWJzLmZyb21SZWxCb3goYWFtQm94KSlcclxuXHRcdFx0ZGlyID0gZGlyLnNjYWxlZCg4ICsgdCk7XHJcblx0XHRcdHRoaXMucGF0aEFuZFJCb3hUcmFuc2xhdGUoYWFtUGF0aCwgYWFtQm94LCBkaXIueCwgZGlyLnkpO1xyXG5cdFx0XHR0aGlzLmFkZFJlT2JqZWN0UGF0aCgnZGF0YScsIGF0b20udmlzZWwsIGFhbVBhdGgsIHBzLCB0cnVlKTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QucHJvdG90eXBlLnNoaWZ0Qm9uZEVuZCA9IGZ1bmN0aW9uIChhdG9tLCBwb3MwLCBkaXIsIG1hcmdpbil7XHJcblx0dmFyIHQgPSAwO1xyXG5cdHZhciB2aXNlbCA9IGF0b20udmlzZWw7XHJcblx0Zm9yICh2YXIgayA9IDA7IGsgPCB2aXNlbC5leHRzLmxlbmd0aDsgKytrKSB7XHJcblx0XHR2YXIgYm94ID0gdmlzZWwuZXh0c1trXS50cmFuc2xhdGUocG9zMCk7XHJcblx0XHR0ID0gTWF0aC5tYXgodCwgVmVjMi5zaGlmdFJheUJveChwb3MwLCBkaXIsIGJveCkpO1xyXG5cdH1cclxuXHRpZiAodCA+IDApXHJcblx0XHRwb3MwID0gcG9zMC5hZGRTY2FsZWQoZGlyLCB0ICsgbWFyZ2luKTtcclxuXHRyZXR1cm4gcG9zMDtcclxufTtcclxuXHJcbnJuZC5SZVN0cnVjdC5wcm90b3R5cGUuYmlzZWN0TGFyZ2VzdFNlY3RvciA9IGZ1bmN0aW9uIChhdG9tKVxyXG57XHJcblx0dmFyIGFuZ2xlcyA9IFtdO1xyXG5cdGF0b20uYS5uZWlnaGJvcnMuZWFjaCggZnVuY3Rpb24gKGhiaWQpIHtcclxuXHRcdHZhciBoYiA9IHRoaXMubW9sZWN1bGUuaGFsZkJvbmRzLmdldChoYmlkKTtcclxuXHRcdGFuZ2xlcy5wdXNoKGhiLmFuZyk7XHJcblx0fSwgdGhpcyk7XHJcblx0YW5nbGVzID0gYW5nbGVzLnNvcnQoZnVuY3Rpb24gKGEsYil7cmV0dXJuIGEgLSBiO30pO1xyXG5cdHZhciBkYSA9IFtdO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYW5nbGVzLmxlbmd0aCAtIDE7ICsraSkge1xyXG5cdFx0ZGEucHVzaChhbmdsZXNbKGkgKyAxKSAlIGFuZ2xlcy5sZW5ndGhdIC0gYW5nbGVzW2ldKTtcclxuXHR9XHJcblx0ZGEucHVzaChhbmdsZXNbMF0gLSBhbmdsZXNbYW5nbGVzLmxlbmd0aCAtIDFdICsgMiAqIE1hdGguUEkpO1xyXG5cdHZhciBkYU1heCA9IDA7XHJcblx0dmFyIGFuZyA9IC1NYXRoLlBJIC8gMjtcclxuXHRmb3IgKGkgPSAwOyBpIDwgYW5nbGVzLmxlbmd0aDsgKytpKSB7XHJcblx0XHRpZiAoZGFbaV0gPiBkYU1heCkge1xyXG5cdFx0XHRkYU1heCA9IGRhW2ldO1xyXG5cdFx0XHRhbmcgPSBhbmdsZXNbaV0gKyBkYVtpXSAvIDI7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBuZXcgVmVjMihNYXRoLmNvcyhhbmcpLCBNYXRoLnNpbihhbmcpKTtcclxufTtcclxuXHJcbnJuZC5SZVN0cnVjdC5wcm90b3R5cGUuYm9uZFJlY2FsYyA9IGZ1bmN0aW9uIChzZXR0aW5ncywgYm9uZCkge1xyXG5cclxuXHR2YXIgcmVuZGVyID0gdGhpcy5yZW5kZXI7XHJcblx0dmFyIGF0b20xID0gdGhpcy5hdG9tcy5nZXQoYm9uZC5iLmJlZ2luKTtcclxuXHR2YXIgYXRvbTIgPSB0aGlzLmF0b21zLmdldChib25kLmIuZW5kKTtcclxuXHR2YXIgcDEgPSByZW5kZXIucHMoYXRvbTEuYS5wcCk7XHJcblx0dmFyIHAyID0gcmVuZGVyLnBzKGF0b20yLmEucHApO1xyXG5cdHZhciBoYjEgPSB0aGlzLm1vbGVjdWxlLmhhbGZCb25kcy5nZXQoYm9uZC5iLmhiMSk7XHJcblx0dmFyIGhiMiA9IHRoaXMubW9sZWN1bGUuaGFsZkJvbmRzLmdldChib25kLmIuaGIyKTtcclxuXHRoYjEucCA9IHRoaXMuc2hpZnRCb25kRW5kKGF0b20xLCBwMSwgaGIxLmRpciwgMiAqIHNldHRpbmdzLmxpbmVXaWR0aCk7XHJcblx0aGIyLnAgPSB0aGlzLnNoaWZ0Qm9uZEVuZChhdG9tMiwgcDIsIGhiMi5kaXIsIDIgKiBzZXR0aW5ncy5saW5lV2lkdGgpO1xyXG5cdGJvbmQuYi5jZW50ZXIgPSBWZWMyLmxjMihhdG9tMS5hLnBwLCAwLjUsIGF0b20yLmEucHAsIDAuNSk7XHJcblx0Ym9uZC5iLmxlbiA9IFZlYzIuZGlzdChwMSwgcDIpO1xyXG5cdGJvbmQuYi5zYiA9IHNldHRpbmdzLmxpbmVXaWR0aCAqIDU7XHJcblx0Ym9uZC5iLnNhID0gTWF0aC5tYXgoYm9uZC5iLnNiLCAgYm9uZC5iLmxlbiAvIDIgLSBzZXR0aW5ncy5saW5lV2lkdGggKiAyKTtcclxuXHRib25kLmIuYW5nbGUgPSBNYXRoLmF0YW4yKGhiMS5kaXIueSwgaGIxLmRpci54KSAqIDE4MCAvIE1hdGguUEk7XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QucHJvdG90eXBlLnNob3dCb25kcyA9IGZ1bmN0aW9uICgpXHJcbntcclxuXHR2YXIgcmVuZGVyID0gdGhpcy5yZW5kZXI7XHJcblx0dmFyIHNldHRpbmdzID0gcmVuZGVyLnNldHRpbmdzO1xyXG5cdHZhciBwYXBlciA9IHJlbmRlci5wYXBlcjtcclxuXHR2YXIgb3B0ID0gcmVuZGVyLm9wdDtcclxuXHRmb3IgKHZhciBiaWQgaW4gdGhpcy5ib25kc0NoYW5nZWQpIHtcclxuXHRcdHZhciBib25kID0gdGhpcy5ib25kcy5nZXQoYmlkKTtcclxuXHRcdHZhciBoYjEgPSB0aGlzLm1vbGVjdWxlLmhhbGZCb25kcy5nZXQoYm9uZC5iLmhiMSksXHJcblx0XHRoYjIgPSB0aGlzLm1vbGVjdWxlLmhhbGZCb25kcy5nZXQoYm9uZC5iLmhiMik7XHJcblx0XHR0aGlzLmJvbmRSZWNhbGMoc2V0dGluZ3MsIGJvbmQpO1xyXG5cdFx0Ym9uZC5wYXRoID0gdGhpcy5kcmF3Qm9uZChib25kLCBoYjEsIGhiMik7XHJcblx0XHRib25kLnJiYiA9IHV0aWwucmVsQm94KGJvbmQucGF0aC5nZXRCQm94KCkpO1xyXG5cdFx0dGhpcy5hZGRSZU9iamVjdFBhdGgoJ2RhdGEnLCBib25kLnZpc2VsLCBib25kLnBhdGgsIG51bGwsIHRydWUpO1xyXG5cdFx0dmFyIHJlYWN0aW5nQ2VudGVyID0ge307XHJcblx0XHRyZWFjdGluZ0NlbnRlci5wYXRoID0gdGhpcy5kcmF3UmVhY3RpbmdDZW50ZXIoYm9uZCwgaGIxLCBoYjIpO1xyXG5cdFx0aWYgKHJlYWN0aW5nQ2VudGVyLnBhdGgpIHtcclxuXHRcdFx0cmVhY3RpbmdDZW50ZXIucmJiID0gdXRpbC5yZWxCb3gocmVhY3RpbmdDZW50ZXIucGF0aC5nZXRCQm94KCkpO1xyXG5cdFx0XHR0aGlzLmFkZFJlT2JqZWN0UGF0aCgnZGF0YScsIGJvbmQudmlzZWwsIHJlYWN0aW5nQ2VudGVyLnBhdGgsIG51bGwsIHRydWUpO1xyXG5cdFx0fVxyXG5cdFx0dmFyIHRvcG9sb2d5ID0ge307XHJcblx0XHR0b3BvbG9neS5wYXRoID0gdGhpcy5kcmF3VG9wb2xvZ3lNYXJrKGJvbmQsIGhiMSwgaGIyKTtcclxuXHRcdGlmICh0b3BvbG9neS5wYXRoKSB7XHJcblx0XHRcdHRvcG9sb2d5LnJiYiA9IHV0aWwucmVsQm94KHRvcG9sb2d5LnBhdGguZ2V0QkJveCgpKTtcclxuXHRcdFx0dGhpcy5hZGRSZU9iamVjdFBhdGgoJ2RhdGEnLCBib25kLnZpc2VsLCB0b3BvbG9neS5wYXRoLCBudWxsLCB0cnVlKTtcclxuXHRcdH1cclxuXHRcdGJvbmQuc2V0SGlnaGxpZ2h0KGJvbmQuaGlnaGxpZ2h0LCByZW5kZXIpO1xyXG5cdFx0dmFyIGJvbmRJZHhPZmYgPSBzZXR0aW5ncy5zdWJGb250U2l6ZSAqIDAuNjtcclxuXHRcdHZhciBpcGF0aCA9IG51bGwsIGlyYmIgPSBudWxsO1xyXG5cdFx0aWYgKG9wdC5zaG93Qm9uZElkcykge1xyXG5cdFx0XHR2YXIgcGIgPSBWZWMyLmxjKGhiMS5wLCAwLjUsIGhiMi5wLCAwLjUsIGhiMS5ub3JtLCBib25kSWR4T2ZmKTtcclxuXHRcdFx0aXBhdGggPSBwYXBlci50ZXh0KHBiLngsIHBiLnksIGJpZC50b1N0cmluZygpKTtcclxuXHRcdFx0aXJiYiA9IHV0aWwucmVsQm94KGlwYXRoLmdldEJCb3goKSk7XHJcblx0XHRcdHRoaXMuY2VudGVyVGV4dChpcGF0aCwgaXJiYik7XHJcblx0XHRcdHRoaXMuYWRkUmVPYmplY3RQYXRoKCdpbmRpY2VzJywgYm9uZC52aXNlbCwgaXBhdGgpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKG9wdC5zaG93SGFsZkJvbmRJZHMpIHtcclxuXHRcdFx0dmFyIHBoYjEgPSBWZWMyLmxjKGhiMS5wLCAwLjgsIGhiMi5wLCAwLjIsIGhiMS5ub3JtLCBib25kSWR4T2ZmKTtcclxuXHRcdFx0aXBhdGggPSBwYXBlci50ZXh0KHBoYjEueCwgcGhiMS55LCBib25kLmIuaGIxLnRvU3RyaW5nKCkpO1xyXG5cdFx0XHRpcmJiID0gdXRpbC5yZWxCb3goaXBhdGguZ2V0QkJveCgpKTtcclxuXHRcdFx0dGhpcy5jZW50ZXJUZXh0KGlwYXRoLCBpcmJiKTtcclxuXHRcdFx0dGhpcy5hZGRSZU9iamVjdFBhdGgoJ2luZGljZXMnLCBib25kLnZpc2VsLCBpcGF0aCk7XHJcblx0XHRcdHZhciBwaGIyID0gVmVjMi5sYyhoYjEucCwgMC4yLCBoYjIucCwgMC44LCBoYjIubm9ybSwgYm9uZElkeE9mZik7XHJcblx0XHRcdGlwYXRoID0gcGFwZXIudGV4dChwaGIyLngsIHBoYjIueSwgYm9uZC5iLmhiMi50b1N0cmluZygpKTtcclxuXHRcdFx0aXJiYiA9IHV0aWwucmVsQm94KGlwYXRoLmdldEJCb3goKSk7XHJcblx0XHRcdHRoaXMuY2VudGVyVGV4dChpcGF0aCwgaXJiYik7XHJcblx0XHRcdHRoaXMuYWRkUmVPYmplY3RQYXRoKCdpbmRpY2VzJywgYm9uZC52aXNlbCwgaXBhdGgpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKG9wdC5zaG93TG9vcElkcyAmJiAhb3B0LnNob3dCb25kSWRzKSB7XHJcblx0XHRcdHZhciBwbDEgPSBWZWMyLmxjKGhiMS5wLCAwLjUsIGhiMi5wLCAwLjUsIGhiMi5ub3JtLCBib25kSWR4T2ZmKTtcclxuXHRcdFx0aXBhdGggPSBwYXBlci50ZXh0KHBsMS54LCBwbDEueSwgaGIxLmxvb3AudG9TdHJpbmcoKSk7XHJcblx0XHRcdGlyYmIgPSB1dGlsLnJlbEJveChpcGF0aC5nZXRCQm94KCkpO1xyXG5cdFx0XHR0aGlzLmNlbnRlclRleHQoaXBhdGgsIGlyYmIpO1xyXG5cdFx0XHR0aGlzLmFkZFJlT2JqZWN0UGF0aCgnaW5kaWNlcycsIGJvbmQudmlzZWwsIGlwYXRoKTtcclxuXHRcdFx0dmFyIHBsMiA9IFZlYzIubGMoaGIxLnAsIDAuNSwgaGIyLnAsIDAuNSwgaGIxLm5vcm0sIGJvbmRJZHhPZmYpO1xyXG5cdFx0XHRpcGF0aCA9IHBhcGVyLnRleHQocGwyLngsIHBsMi55LCBoYjIubG9vcC50b1N0cmluZygpKTtcclxuXHRcdFx0aXJiYiA9IHV0aWwucmVsQm94KGlwYXRoLmdldEJCb3goKSk7XHJcblx0XHRcdHRoaXMuY2VudGVyVGV4dChpcGF0aCwgaXJiYik7XHJcblx0XHRcdHRoaXMuYWRkUmVPYmplY3RQYXRoKCdpbmRpY2VzJywgYm9uZC52aXNlbCwgaXBhdGgpO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbnJuZC5SZVN0cnVjdC5wcm90b3R5cGUubGFiZWxJc1Zpc2libGUgPSBmdW5jdGlvbiAoYWlkLCBhdG9tKVxyXG57XHJcblx0aWYgKGF0b20uYS5uZWlnaGJvcnMubGVuZ3RoID09IDAgfHxcclxuXHRcdChhdG9tLmEubmVpZ2hib3JzLmxlbmd0aCA8IDIgJiYgIXRoaXMucmVuZGVyLm9wdC5oaWRlVGVybWluYWxMYWJlbHMpIHx8XHJcblx0YXRvbS5hLmxhYmVsLnRvTG93ZXJDYXNlKCkgIT0gJ2MnIHx8XHJcblx0XHQoYXRvbS5hLmJhZENvbm4gJiYgdGhpcy5yZW5kZXIub3B0LnNob3dWYWxlbmNlV2FybmluZ3MpIHx8XHJcblx0YXRvbS5hLmlzb3RvcGUgIT0gMCB8fFxyXG5cdGF0b20uYS5yYWRpY2FsICE9IDAgfHxcclxuXHRhdG9tLmEuY2hhcmdlICE9IDAgfHxcclxuXHRhdG9tLmEuZXhwbGljaXRWYWxlbmNlID49IDAgfHxcclxuXHRhdG9tLmEuYXRvbUxpc3QgIT0gbnVsbCB8fFxyXG5cdGF0b20uYS5yZ2xhYmVsICE9IG51bGwpXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRpZiAoYXRvbS5hLm5laWdoYm9ycy5sZW5ndGggPT0gMikge1xyXG5cdFx0dmFyIG4xID0gYXRvbS5hLm5laWdoYm9yc1swXTtcclxuXHRcdHZhciBuMiA9IGF0b20uYS5uZWlnaGJvcnNbMV07XHJcblx0XHR2YXIgaGIxID0gdGhpcy5tb2xlY3VsZS5oYWxmQm9uZHMuZ2V0KG4xKTtcclxuXHRcdHZhciBoYjIgPSB0aGlzLm1vbGVjdWxlLmhhbGZCb25kcy5nZXQobjIpO1xyXG5cdFx0dmFyIGIxID0gdGhpcy5ib25kcy5nZXQoaGIxLmJpZCk7XHJcblx0XHR2YXIgYjIgPSB0aGlzLmJvbmRzLmdldChoYjIuYmlkKTtcclxuXHRcdGlmIChiMS5iLnR5cGUgPT0gYjIuYi50eXBlICYmIGIxLmIuc3RlcmVvID09IEJvbmQuUEFUVEVSTi5TVEVSRU8uTk9ORSAmJiBiMi5iLnN0ZXJlbyA9PSBCb25kLlBBVFRFUk4uU1RFUkVPLk5PTkUpXHJcblx0XHRpZiAoTWF0aC5hYnMoVmVjMi5jcm9zcyhoYjEuZGlyLCBoYjIuZGlyKSkgPCAwLjIpXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHRyZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QucHJvdG90eXBlLmNoZWNrTGFiZWxzVG9TaG93ID0gZnVuY3Rpb24gKClcclxue1xyXG5cdGZvciAodmFyIGFpZCBpbiB0aGlzLmF0b21zQ2hhbmdlZCkge1xyXG5cdFx0dmFyIGF0b20gPSB0aGlzLmF0b21zLmdldChhaWQpO1xyXG5cdFx0YXRvbS5zaG93TGFiZWwgPSB0aGlzLmxhYmVsSXNWaXNpYmxlKGFpZCwgYXRvbSk7XHJcblx0fVxyXG59O1xyXG5cclxucm5kLlJlU3RydWN0LmxheWVyTWFwID0ge1xyXG5cdCdiYWNrZ3JvdW5kJzogMCxcclxuXHQnc2VsZWN0aW9uLXBsYXRlJzogMSxcclxuXHQnaGlnaGxpZ2h0aW5nJzogMixcclxuXHQnd2FybmluZ3MnOiAzLFxyXG5cdCdkYXRhJzogNCxcclxuXHQnaW5kaWNlcyc6IDVcclxufTtcclxuXHJcbnJuZC5SZVN0cnVjdC5wcm90b3R5cGUuYWRkUmVPYmplY3RQYXRoID0gZnVuY3Rpb24gKGdyb3VwLCB2aXNlbCwgcGF0aCwgcG9zLCB2aXNpYmxlKSB7XHJcblx0aWYgKCFwYXRoKVxyXG5cdFx0cmV0dXJuO1xyXG5cdHZhciBvZmZzZXQgPSB0aGlzLnJlbmRlci5vZmZzZXQ7XHJcblx0dmFyIGJiID0gdmlzaWJsZSA/IEJveDJBYnMuZnJvbVJlbEJveCh1dGlsLnJlbEJveChwYXRoLmdldEJCb3goKSkpIDogbnVsbDtcclxuXHR2YXIgZXh0ID0gcG9zICYmIGJiID8gYmIudHJhbnNsYXRlKHBvcy5uZWdhdGVkKCkpIDogbnVsbDtcclxuXHRpZiAob2Zmc2V0ICE9PSBudWxsKSB7XHJcblx0XHRwYXRoLnRyYW5zbGF0ZUFicyhvZmZzZXQueCwgb2Zmc2V0LnkpO1xyXG5cdFx0YmIgPSBiYiA/IGJiLnRyYW5zbGF0ZShvZmZzZXQpIDogbnVsbDtcclxuXHR9XHJcblx0dmlzZWwuYWRkKHBhdGgsIGJiLCBleHQpO1xyXG5cdHRoaXMuaW5zZXJ0SW5MYXllcihybmQuUmVTdHJ1Y3QubGF5ZXJNYXBbZ3JvdXBdLCBwYXRoKTtcclxufTtcclxuXHJcbnJuZC5SZVN0cnVjdC5wcm90b3R5cGUuY2xlYXJWaXNlbCA9IGZ1bmN0aW9uICh2aXNlbClcclxue1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdmlzZWwucGF0aHMubGVuZ3RoOyArK2kpXHJcblx0XHR2aXNlbC5wYXRoc1tpXS5yZW1vdmUoKTtcclxuXHR2aXNlbC5jbGVhcigpO1xyXG59O1xyXG5cclxucm5kLlJlU3RydWN0LnByb3RvdHlwZS5zZWxlY3REb3VibGVCb25kU2hpZnQgPSBmdW5jdGlvbiAobjEsIG4yLCBkMSwgZDIpIHtcclxuXHRpZiAobjEgPT0gNiAmJiBuMiAhPSA2ICYmIChkMSA+IDEgfHwgZDIgPT0gMSkpXHJcblx0XHRyZXR1cm4gLTE7XHJcblx0aWYgKG4yID09IDYgJiYgbjEgIT0gNiAmJiAoZDIgPiAxIHx8IGQxID09IDEpKVxyXG5cdFx0cmV0dXJuIDE7XHJcblx0aWYgKG4yICogZDEgPiBuMSAqIGQyKVxyXG5cdFx0cmV0dXJuIC0xO1xyXG5cdGlmIChuMiAqIGQxIDwgbjEgKiBkMilcclxuXHRcdHJldHVybiAxO1xyXG5cdGlmIChuMiA+IG4xKVxyXG5cdFx0cmV0dXJuIC0xO1xyXG5cdHJldHVybiAxO1xyXG59O1xyXG5cclxucm5kLlJlU3RydWN0LnByb3RvdHlwZS5zZWxlY3REb3VibGVCb25kU2hpZnRfQ2hhaW4gPSBmdW5jdGlvbiAoYm9uZCkge1xyXG5cdHZhciBzdHJ1Y3QgPSB0aGlzLm1vbGVjdWxlO1xyXG5cdHZhciBoYjEgPSBzdHJ1Y3QuaGFsZkJvbmRzLmdldChib25kLmIuaGIxKTtcclxuXHR2YXIgaGIyID0gc3RydWN0LmhhbGZCb25kcy5nZXQoYm9uZC5iLmhiMik7XHJcblx0dmFyIG5MZWZ0ID0gKGhiMS5sZWZ0U2luID4gMC4zID8gMSA6IDApICsgKGhiMi5yaWdodFNpbiA+IDAuMyA/IDEgOiAwKTtcclxuXHR2YXIgblJpZ2h0ID0gKGhiMi5sZWZ0U2luID4gMC4zID8gMSA6IDApICsgKGhiMS5yaWdodFNpbiA+IDAuMyA/IDEgOiAwKTtcclxuXHRpZiAobkxlZnQgPiBuUmlnaHQpXHJcblx0XHRyZXR1cm4gLTE7XHJcblx0aWYgKG5MZWZ0IDwgblJpZ2h0KVxyXG5cdFx0cmV0dXJuIDE7XHJcblx0aWYgKChoYjEubGVmdFNpbiA+IDAuMyA/IDEgOiAwKSArIChoYjEucmlnaHRTaW4gPiAwLjMgPyAxIDogMCkgPT0gMSlcclxuXHRcdHJldHVybiAxO1xyXG5cdHJldHVybiAwO1xyXG59O1xyXG5cclxucm5kLlJlU3RydWN0LnByb3RvdHlwZS5zZXREb3VibGVCb25kU2hpZnQgPSBmdW5jdGlvbiAoKVxyXG57XHJcblx0dmFyIHN0cnVjdCA9IHRoaXMubW9sZWN1bGU7XHJcblx0Ly8gZG91YmxlIGJvbmRzIGluIGxvb3BzXHJcblx0Zm9yICh2YXIgYmlkIGluIHRoaXMuYm9uZHNDaGFuZ2VkKSB7XHJcblx0XHR2YXIgYm9uZCA9IHRoaXMuYm9uZHMuZ2V0KGJpZCk7XHJcblx0XHR2YXIgbG9vcDEsIGxvb3AyO1xyXG5cdFx0bG9vcDEgPSBzdHJ1Y3QuaGFsZkJvbmRzLmdldChib25kLmIuaGIxKS5sb29wO1xyXG5cdFx0bG9vcDIgPSBzdHJ1Y3QuaGFsZkJvbmRzLmdldChib25kLmIuaGIyKS5sb29wO1xyXG5cdFx0aWYgKGxvb3AxID49IDAgJiYgbG9vcDIgPj0gMCkge1xyXG5cdFx0XHR2YXIgZDEgPSBzdHJ1Y3QubG9vcHMuZ2V0KGxvb3AxKS5kYmxCb25kcztcclxuXHRcdFx0dmFyIGQyID0gc3RydWN0Lmxvb3BzLmdldChsb29wMikuZGJsQm9uZHM7XHJcblx0XHRcdHZhciBuMSA9IHN0cnVjdC5sb29wcy5nZXQobG9vcDEpLmhicy5sZW5ndGg7XHJcblx0XHRcdHZhciBuMiA9IHN0cnVjdC5sb29wcy5nZXQobG9vcDIpLmhicy5sZW5ndGg7XHJcblx0XHRcdGJvbmQuZG91YmxlQm9uZFNoaWZ0ID0gdGhpcy5zZWxlY3REb3VibGVCb25kU2hpZnQobjEsIG4yLCBkMSwgZDIpO1xyXG5cdFx0fSBlbHNlIGlmIChsb29wMSA+PSAwKSB7XHJcblx0XHRcdGJvbmQuZG91YmxlQm9uZFNoaWZ0ID0gLTE7XHJcblx0XHR9IGVsc2UgaWYgKGxvb3AyID49IDApIHtcclxuXHRcdFx0Ym9uZC5kb3VibGVCb25kU2hpZnQgPSAxO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ym9uZC5kb3VibGVCb25kU2hpZnQgPSB0aGlzLnNlbGVjdERvdWJsZUJvbmRTaGlmdF9DaGFpbihib25kKTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QucHJvdG90eXBlLnVwZGF0ZUxvb3BzID0gZnVuY3Rpb24gKClcclxue1xyXG5cdHRoaXMucmVsb29wcy5lYWNoKGZ1bmN0aW9uIChybGlkLCByZWxvb3Ape1xyXG5cdFx0dGhpcy5jbGVhclZpc2VsKHJlbG9vcC52aXNlbCk7XHJcblx0fSwgdGhpcyk7XHJcblx0dmFyIHJldCA9IHRoaXMubW9sZWN1bGUuZmluZExvb3BzKCk7XHJcblx0dXRpbC5lYWNoKHJldC5ib25kc1RvTWFyaywgZnVuY3Rpb24gKGJpZCkge1xyXG5cdFx0dGhpcy5tYXJrQm9uZChiaWQsIDEpO1xyXG5cdH0sIHRoaXMpO1xyXG5cdHV0aWwuZWFjaChyZXQubmV3TG9vcHMsIGZ1bmN0aW9uIChsb29wSWQpIHtcclxuXHRcdHRoaXMucmVsb29wcy5zZXQobG9vcElkLCBuZXcgcm5kLlJlTG9vcCh0aGlzLm1vbGVjdWxlLmxvb3BzLmdldChsb29wSWQpKSk7XHJcblx0fSwgdGhpcyk7XHJcbn07XHJcblxyXG5ybmQuUmVTdHJ1Y3QucHJvdG90eXBlLnJlbmRlckxvb3BzID0gZnVuY3Rpb24gKClcclxue1xyXG5cdHZhciByZW5kZXIgPSB0aGlzLnJlbmRlcjtcclxuXHR2YXIgc2V0dGluZ3MgPSByZW5kZXIuc2V0dGluZ3M7XHJcblx0dmFyIHBhcGVyID0gcmVuZGVyLnBhcGVyO1xyXG5cdHZhciBtb2xlY3VsZSA9IHRoaXMubW9sZWN1bGU7XHJcblx0dGhpcy5yZWxvb3BzLmVhY2goZnVuY3Rpb24gKHJsaWQsIHJlbG9vcCl7XHJcblx0XHR2YXIgbG9vcCA9IHJlbG9vcC5sb29wO1xyXG5cdFx0cmVsb29wLmNlbnRyZSA9IG5ldyBWZWMyKCk7XHJcblx0XHRsb29wLmhicy5lYWNoKGZ1bmN0aW9uIChoYmlkKXtcclxuXHRcdFx0dmFyIGhiID0gbW9sZWN1bGUuaGFsZkJvbmRzLmdldChoYmlkKTtcclxuXHRcdFx0dmFyIGJvbmQgPSB0aGlzLmJvbmRzLmdldChoYi5iaWQpO1xyXG5cdFx0XHR2YXIgYXBvcyA9IHJlbmRlci5wcyh0aGlzLmF0b21zLmdldChoYi5iZWdpbikuYS5wcCk7XHJcblx0XHRcdGlmIChib25kLmIudHlwZSAhPSBCb25kLlBBVFRFUk4uVFlQRS5BUk9NQVRJQylcclxuXHRcdFx0XHRsb29wLmFyb21hdGljID0gZmFsc2U7XHJcblx0XHRcdHJlbG9vcC5jZW50cmUuYWRkXyhhcG9zKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdFx0bG9vcC5jb252ZXggPSB0cnVlO1xyXG5cdFx0Zm9yICh2YXIgayA9IDA7IGsgPCByZWxvb3AubG9vcC5oYnMubGVuZ3RoOyArK2spXHJcblx0XHR7XHJcblx0XHRcdHZhciBoYmEgPSBtb2xlY3VsZS5oYWxmQm9uZHMuZ2V0KGxvb3AuaGJzW2tdKTtcclxuXHRcdFx0dmFyIGhiYiA9IG1vbGVjdWxlLmhhbGZCb25kcy5nZXQobG9vcC5oYnNbKGsgKyAxKSAlIGxvb3AuaGJzLmxlbmd0aF0pO1xyXG5cdFx0XHR2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKFxyXG5cdFx0XHRWZWMyLmNyb3NzKGhiYS5kaXIsIGhiYi5kaXIpLFxyXG5cdFx0XHRWZWMyLmRvdChoYmEuZGlyLCBoYmIuZGlyKSk7XHJcblx0XHRcdGlmIChhbmdsZSA+IDApXHJcblx0XHRcdFx0bG9vcC5jb252ZXggPSBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZWxvb3AuY2VudHJlID0gcmVsb29wLmNlbnRyZS5zY2FsZWQoMS4wIC8gbG9vcC5oYnMubGVuZ3RoKTtcclxuXHRcdHJlbG9vcC5yYWRpdXMgPSAtMTtcclxuXHRcdGxvb3AuaGJzLmVhY2goZnVuY3Rpb24gKGhiaWQpe1xyXG5cdFx0XHR2YXIgaGIgPSBtb2xlY3VsZS5oYWxmQm9uZHMuZ2V0KGhiaWQpO1xyXG5cdFx0XHR2YXIgYXBvcyA9IHJlbmRlci5wcyh0aGlzLmF0b21zLmdldChoYi5iZWdpbikuYS5wcCk7XHJcblx0XHRcdHZhciBicG9zID0gcmVuZGVyLnBzKHRoaXMuYXRvbXMuZ2V0KGhiLmVuZCkuYS5wcCk7XHJcblx0XHRcdHZhciBuID0gVmVjMi5kaWZmKGJwb3MsIGFwb3MpLnJvdGF0ZVNDKDEsIDApLm5vcm1hbGl6ZWQoKTtcclxuXHRcdFx0dmFyIGRpc3QgPSBWZWMyLmRvdChWZWMyLmRpZmYoYXBvcywgcmVsb29wLmNlbnRyZSksIG4pO1xyXG5cdFx0XHRpZiAocmVsb29wLnJhZGl1cyA8IDApIHtcclxuXHRcdFx0XHRyZWxvb3AucmFkaXVzID0gZGlzdDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZWxvb3AucmFkaXVzID0gTWF0aC5taW4ocmVsb29wLnJhZGl1cywgZGlzdCk7XHJcblx0XHRcdH1cclxuXHRcdH0sIHRoaXMpO1xyXG5cdFx0cmVsb29wLnJhZGl1cyAqPSAwLjc7XHJcblx0XHRpZiAoIWxvb3AuYXJvbWF0aWMpXHJcblx0XHRcdHJldHVybjtcclxuXHRcdHZhciBwYXRoID0gbnVsbDtcclxuXHRcdGlmIChsb29wLmNvbnZleCkge1xyXG5cdFx0XHRwYXRoID0gcGFwZXIuY2lyY2xlKHJlbG9vcC5jZW50cmUueCwgcmVsb29wLmNlbnRyZS55LCByZWxvb3AucmFkaXVzKVxyXG5cdFx0XHQuYXR0cih7XHJcblx0XHRcdFx0J3N0cm9rZSc6ICcjMDAwJyxcclxuXHRcdFx0XHQnc3Ryb2tlLXdpZHRoJzogc2V0dGluZ3MubGluZVdpZHRoXHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIHBhdGhTdHIgPSAnJztcclxuXHRcdFx0Zm9yIChrID0gMDsgayA8IGxvb3AuaGJzLmxlbmd0aDsgKytrKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0aGJhID0gbW9sZWN1bGUuaGFsZkJvbmRzLmdldChsb29wLmhic1trXSk7XHJcblx0XHRcdFx0aGJiID0gbW9sZWN1bGUuaGFsZkJvbmRzLmdldChsb29wLmhic1soayArIDEpICUgbG9vcC5oYnMubGVuZ3RoXSk7XHJcblx0XHRcdFx0YW5nbGUgPSBNYXRoLmF0YW4yKFxyXG5cdFx0XHRcdFZlYzIuY3Jvc3MoaGJhLmRpciwgaGJiLmRpciksXHJcblx0XHRcdFx0VmVjMi5kb3QoaGJhLmRpciwgaGJiLmRpcikpO1xyXG5cdFx0XHRcdHZhciBoYWxmQW5nbGUgPSAoTWF0aC5QSSAtIGFuZ2xlKSAvIDI7XHJcblx0XHRcdFx0dmFyIGRpciA9IGhiYi5kaXIucm90YXRlKGhhbGZBbmdsZSk7XHJcblx0XHRcdFx0dmFyIHBpID0gcmVuZGVyLnBzKHRoaXMuYXRvbXMuZ2V0KGhiYi5iZWdpbikuYS5wcCk7XHJcblx0XHRcdFx0dmFyIHNpbiA9IE1hdGguc2luKGhhbGZBbmdsZSk7XHJcblx0XHRcdFx0dmFyIG1pblNpbiA9IDAuMTtcclxuXHRcdFx0XHRpZiAoTWF0aC5hYnMoc2luKSA8IG1pblNpbilcclxuXHRcdFx0XHRcdHNpbiA9IHNpbiAqIG1pblNpbiAvIE1hdGguYWJzKHNpbik7XHJcblx0XHRcdFx0dmFyIG9mZnNldCA9IHNldHRpbmdzLmJvbmRTcGFjZSAvIHNpbjtcclxuXHRcdFx0XHR2YXIgcWkgPSBwaS5hZGRTY2FsZWQoZGlyLCAtb2Zmc2V0KTtcclxuXHRcdFx0XHRwYXRoU3RyICs9IChrID09IDAgPyAnTScgOiAnTCcpO1xyXG5cdFx0XHRcdHBhdGhTdHIgKz0gdGZ4KHFpLngpICsgJywnICsgdGZ4KHFpLnkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHBhdGhTdHIgKz0gJ1onO1xyXG5cdFx0XHRwYXRoID0gcGFwZXIucGF0aChwYXRoU3RyKVxyXG5cdFx0XHQuYXR0cih7XHJcblx0XHRcdFx0J3N0cm9rZSc6ICcjMDAwJyxcclxuXHRcdFx0XHQnc3Ryb2tlLXdpZHRoJzogc2V0dGluZ3MubGluZVdpZHRoLFxyXG5cdFx0XHRcdCdzdHJva2UtZGFzaGFycmF5JzonLSAnXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5hZGRSZU9iamVjdFBhdGgoJ2RhdGEnLCByZWxvb3AudmlzZWwsIHBhdGgsIG51bGwsIHRydWUpO1xyXG5cdH0sIHRoaXMpO1xyXG59O1xyXG4iLCIvLyBWaXNlbCBpcyBhIHNob3J0aGFuZCBmb3IgVklTdWFsIEVMZW1lbnRcclxuLy8gSXQgY29ycmVzcG9uZHMgdG8gYSB2aXN1YWxpemF0aW9uIChpLmUuIHNldCBvZiBwYXRocykgb2YgYW4gYXRvbSBvciBhIGJvbmQuXHJcblxyXG52YXIgQm94MkFicyA9IHJlcXVpcmUoJy4uL3V0aWwvYm94MmFicycpO1xyXG52YXIgVmVjMiA9IHJlcXVpcmUoJy4uL3V0aWwvdmVjMicpO1xyXG5cclxudmFyIFZpc2VsID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuXHR0aGlzLnR5cGUgPSB0eXBlO1xyXG5cdHRoaXMucGF0aHMgPSBbXTtcclxuXHR0aGlzLmJveGVzID0gW107XHJcblx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XHJcbn07XHJcblxyXG5WaXNlbC5UWVBFID0ge1xyXG5cdCdBVE9NJzogMSxcclxuXHQnQk9ORCc6IDIsXHJcblx0J0xPT1AnOiAzLFxyXG5cdCdBUlJPVyc6IDQsXHJcblx0J1BMVVMnOiA1LFxyXG5cdCdTR1JPVVAnOiA2LFxyXG5cdCdUTVAnOiA3LCAvLyBbTUtdIFRPRE86IGRvIHdlIHN0aWxsIG5lZWQgaXQ/XHJcblx0J0ZSQUdNRU5UJzogOCxcclxuXHQnUkdST1VQJzogOSxcclxuXHQnQ0hJUkFMX0ZMQUcnOiAxMFxyXG59O1xyXG5cclxuVmlzZWwucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChwYXRoLCBiYiwgZXh0KSB7XHJcblx0dGhpcy5wYXRocy5wdXNoKHBhdGgpO1xyXG5cdGlmIChiYikge1xyXG5cdFx0dGhpcy5ib3hlcy5wdXNoKGJiKTtcclxuXHRcdHRoaXMuYm91bmRpbmdCb3ggPSB0aGlzLmJvdW5kaW5nQm94ID09IG51bGwgPyBiYiA6IEJveDJBYnMudW5pb24odGhpcy5ib3VuZGluZ0JveCwgYmIpO1xyXG5cdH1cclxuXHRpZiAoZXh0KSB7XHJcblx0XHR0aGlzLmV4dHMucHVzaChleHQpO1xyXG5cdH1cclxufTtcclxuXHJcblZpc2VsLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuXHR0aGlzLnBhdGhzID0gW107XHJcblx0dGhpcy5ib3hlcyA9IFtdO1xyXG5cdHRoaXMuZXh0cyA9IFtdO1xyXG5cdHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xyXG59O1xyXG5cclxuVmlzZWwucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uICh4LCB5KSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7ICAgIC8vIFRPRE86IHJlcGxhY2UgdG8gZGVidWcgdGltZSBhc3NlcnRcclxuXHRcdHRocm93IG5ldyBFcnJvcignT25lIHZlY3RvciBvciB0d28gc2NhbGFyIGFyZ3VtZW50cyBleHBlY3RlZCcpO1xyXG5cdH1cclxuXHRpZiAoeSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHR0aGlzLnRyYW5zbGF0ZSh4LngsIHgueSk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHZhciBkZWx0YSA9IG5ldyBWZWMyKHgsIHkpO1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBhdGhzLmxlbmd0aDsgKytpKSB7XHJcblx0XHRcdHRoaXMucGF0aHNbaV0udHJhbnNsYXRlQWJzKHgsIHkpO1xyXG5cdFx0fVxyXG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmJveGVzLmxlbmd0aDsgKytqKSB7XHJcblx0XHRcdHRoaXMuYm94ZXNbal0gPSB0aGlzLmJveGVzW2pdLnRyYW5zbGF0ZShkZWx0YSk7XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5ib3VuZGluZ0JveCAhPT0gbnVsbCkge1xyXG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gdGhpcy5ib3VuZGluZ0JveC50cmFuc2xhdGUoZGVsdGEpO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVmlzZWw7IiwidmFyIFNldCA9IHJlcXVpcmUoJy4uL3V0aWwvc2V0Jyk7XHJcbnZhciBWZWMyID0gcmVxdWlyZSgnLi4vdXRpbC92ZWMyJyk7XHJcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xyXG52YXIgb3AgPSByZXF1aXJlKCcuL29wJyk7XHJcblxyXG52YXIgU3RydWN0ID0gcmVxdWlyZSgnLi4vY2hlbS9zdHJ1Y3QnKTtcclxudmFyIEF0b20gPSByZXF1aXJlKCcuLi9jaGVtL2F0b20nKTtcclxudmFyIEJvbmQgPSByZXF1aXJlKCcuLi9jaGVtL2JvbmQnKTtcclxudmFyIFNHcm91cCA9IHJlcXVpcmUoJy4uL2NoZW0vc2dyb3VwJyk7XHJcblxyXG52YXIgdWkgPSBnbG9iYWwudWk7XHJcblxyXG4vL1xyXG4vLyBVbmRvL3JlZG8gYWN0aW9uc1xyXG4vL1xyXG5mdW5jdGlvbiBBY3Rpb24gKClcclxue1xyXG5cdHRoaXMub3BlcmF0aW9ucyA9IFtdO1xyXG59O1xyXG5cclxuQWN0aW9uLnByb3RvdHlwZS5hZGRPcCA9IGZ1bmN0aW9uIChvcGVyYXRpb24pIHtcclxuXHRpZiAoIW9wZXJhdGlvbi5pc0R1bW15KHVpLmVkaXRvcikpXHJcblx0XHR0aGlzLm9wZXJhdGlvbnMucHVzaChvcGVyYXRpb24pO1xyXG5cdHJldHVybiBvcGVyYXRpb247XHJcbn07XHJcblxyXG5BY3Rpb24ucHJvdG90eXBlLm1lcmdlV2l0aCA9IGZ1bmN0aW9uIChhY3Rpb24pXHJcbntcclxuXHR0aGlzLm9wZXJhdGlvbnMgPSB0aGlzLm9wZXJhdGlvbnMuY29uY2F0KGFjdGlvbi5vcGVyYXRpb25zKTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8vIFBlcmZvcm0gYWN0aW9uIGFuZCByZXR1cm4gaW52ZXJ0ZWQgb25lXHJcbkFjdGlvbi5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uICgpXHJcbntcclxuXHR2YXIgYWN0aW9uID0gbmV3IEFjdGlvbigpO1xyXG5cdHZhciBpZHggPSAwO1xyXG5cclxuXHR0aGlzLm9wZXJhdGlvbnMuZWFjaChmdW5jdGlvbiAob3BlcmF0aW9uKSB7XHJcblx0XHRhY3Rpb24uYWRkT3Aob3BlcmF0aW9uLnBlcmZvcm0odWkuZWRpdG9yKSk7XHJcblx0XHRpZHgrKztcclxuXHR9LCB0aGlzKTtcclxuXHJcblx0YWN0aW9uLm9wZXJhdGlvbnMucmV2ZXJzZSgpO1xyXG5cdHJldHVybiBhY3Rpb247XHJcbn07XHJcblxyXG5BY3Rpb24ucHJvdG90eXBlLmlzRHVtbXkgPSBmdW5jdGlvbiAoKVxyXG57XHJcblx0cmV0dXJuIHRoaXMub3BlcmF0aW9ucy5kZXRlY3QoZnVuY3Rpb24gKG9wZXJhdGlvbikge1xyXG5cdFx0cmV0dXJuICFvcGVyYXRpb24uaXNEdW1teSh1aS5lZGl0b3IpOyAvLyBUT0RPIFtSQl0gdGhlIGNvbmRpdGlvbiBpcyBhbHdheXMgdHJ1ZSBmb3Igb3AuKiBvcGVyYXRpb25zXHJcblx0fSwgdGhpcykgPT0gbnVsbDtcclxufTtcclxuXHJcbi8vIEFkZCBhY3Rpb24gb3BlcmF0aW9uIHRvIHJlbW92ZSBhdG9tIGZyb20gcy1ncm91cCBpZiBuZWVkZWRcclxuQWN0aW9uLnByb3RvdHlwZS5yZW1vdmVBdG9tRnJvbVNncm91cElmTmVlZGVkID0gZnVuY3Rpb24gKGlkKVxyXG57XHJcblx0dmFyIHNncm91cHMgPSB1aS5yZW5kZXIuYXRvbUdldFNHcm91cHMoaWQpO1xyXG5cclxuXHRpZiAoc2dyb3Vwcy5sZW5ndGggPiAwKVxyXG5cdHtcclxuXHRcdHNncm91cHMuZWFjaChmdW5jdGlvbiAoc2lkKVxyXG5cdFx0e1xyXG5cdFx0XHR0aGlzLmFkZE9wKG5ldyBvcC5TR3JvdXBBdG9tUmVtb3ZlKHNpZCwgaWQpKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxuLy8gQWRkIGFjdGlvbiBvcGVyYXRpb25zIHRvIHJlbW92ZSB3aG9sZSBzLWdyb3VwIGlmIG5lZWRlZFxyXG5BY3Rpb24ucHJvdG90eXBlLnJlbW92ZVNncm91cElmTmVlZGVkID0gZnVuY3Rpb24gKGF0b21zKVxyXG57XHJcblx0dmFyIFIgPSB1aS5yZW5kZXI7XHJcblx0dmFyIFJTID0gUi5jdGFiO1xyXG5cdHZhciBEUyA9IFJTLm1vbGVjdWxlO1xyXG5cdHZhciBzZ19jb3VudHMgPSBuZXcgSGFzaCgpO1xyXG5cclxuXHRhdG9tcy5lYWNoKGZ1bmN0aW9uIChpZClcclxuXHR7XHJcblx0XHR2YXIgc2dyb3VwcyA9IHVpLnJlbmRlci5hdG9tR2V0U0dyb3VwcyhpZCk7XHJcblxyXG5cdFx0c2dyb3Vwcy5lYWNoKGZ1bmN0aW9uIChzaWQpXHJcblx0XHR7XHJcblx0XHRcdHZhciBuID0gc2dfY291bnRzLmdldChzaWQpO1xyXG5cdFx0XHRpZiAoT2JqZWN0LmlzVW5kZWZpbmVkKG4pKVxyXG5cdFx0XHRcdG4gPSAxO1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0bisrO1xyXG5cdFx0XHRzZ19jb3VudHMuc2V0KHNpZCwgbik7XHJcblx0XHR9LCB0aGlzKTtcclxuXHR9LCB0aGlzKTtcclxuXHJcblx0c2dfY291bnRzLmVhY2goZnVuY3Rpb24gKHNnKVxyXG5cdHtcclxuXHRcdHZhciBzaWQgPSBwYXJzZUludChzZy5rZXkpO1xyXG5cdFx0dmFyIHNnX2F0b21zID0gdWkucmVuZGVyLnNHcm91cEdldEF0b21zKHNpZCk7XHJcblxyXG5cdFx0aWYgKHNnX2F0b21zLmxlbmd0aCA9PSBzZy52YWx1ZSlcclxuXHRcdHsgLy8gZGVsZXRlIHdob2xlIHMtZ3JvdXBcclxuXHRcdFx0dmFyIHNncm91cCA9IERTLnNncm91cHMuZ2V0KHNpZCk7XHJcblx0XHRcdHRoaXMubWVyZ2VXaXRoKHNHcm91cEF0dHJpYnV0ZUFjdGlvbihzaWQsIHNncm91cC5nZXRBdHRycygpKSk7XHJcblx0XHRcdHRoaXMuYWRkT3AobmV3IG9wLlNHcm91cFJlbW92ZUZyb21IaWVyYXJjaHkoc2lkKSk7XHJcblx0XHRcdHRoaXMuYWRkT3AobmV3IG9wLlNHcm91cERlbGV0ZShzaWQpKTtcclxuXHRcdH1cclxuXHR9LCB0aGlzKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGZyb21NdWx0aXBsZU1vdmUgKGxpc3RzLCBkKVxyXG57XHJcblx0ZCA9IG5ldyBWZWMyKGQpO1xyXG5cclxuXHR2YXIgYWN0aW9uID0gbmV3IEFjdGlvbigpO1xyXG5cdHZhciBpO1xyXG5cclxuXHR2YXIgUiA9IHVpLnJlbmRlcjtcclxuXHR2YXIgUlMgPSBSLmN0YWI7XHJcblx0dmFyIERTID0gUlMubW9sZWN1bGU7XHJcblx0dmFyIGJvbmRsaXN0ID0gW107XHJcblx0dmFyIGxvb3BzID0gU2V0LmVtcHR5KCk7XHJcblx0dmFyIGF0b21zVG9JbnZhbGlkYXRlID0gU2V0LmVtcHR5KCk7XHJcblxyXG5cdGlmIChsaXN0cy5hdG9tcykge1xyXG5cdFx0dmFyIGF0b21TZXQgPSBTZXQuZnJvbUxpc3QobGlzdHMuYXRvbXMpO1xyXG5cdFx0UlMuYm9uZHMuZWFjaChmdW5jdGlvbiAoYmlkLCBib25kKXtcclxuXHJcblx0XHRcdGlmIChTZXQuY29udGFpbnMoYXRvbVNldCwgYm9uZC5iLmJlZ2luKSAmJiBTZXQuY29udGFpbnMoYXRvbVNldCwgYm9uZC5iLmVuZCkpIHtcclxuXHRcdFx0XHRib25kbGlzdC5wdXNoKGJpZCk7XHJcblx0XHRcdFx0Ly8gYWRkIGFsbCBhZGphY2VudCBsb29wc1xyXG5cdFx0XHRcdC8vIHRob3NlIHRoYXQgYXJlIG5vdCBjb21wbGV0ZWx5IGluc2lkZSB0aGUgc3RydWN0dXJlIHdpbGwgZ2V0IHJlZHJhd24gYW55d2F5XHJcblx0XHRcdFx0dXRpbC5lYWNoKFsnaGIxJywnaGIyJ10sIGZ1bmN0aW9uIChoYil7XHJcblx0XHRcdFx0XHR2YXIgbG9vcCA9IERTLmhhbGZCb25kcy5nZXQoYm9uZC5iW2hiXSkubG9vcDtcclxuXHRcdFx0XHRcdGlmIChsb29wID49IDApXHJcblx0XHRcdFx0XHRcdFNldC5hZGQobG9vcHMsIGxvb3ApO1xyXG5cdFx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKFNldC5jb250YWlucyhhdG9tU2V0LCBib25kLmIuYmVnaW4pKVxyXG5cdFx0XHRcdFNldC5hZGQoYXRvbXNUb0ludmFsaWRhdGUsIGJvbmQuYi5iZWdpbik7XHJcblx0XHRcdGVsc2UgaWYgKFNldC5jb250YWlucyhhdG9tU2V0LCBib25kLmIuZW5kKSlcclxuXHRcdFx0XHRTZXQuYWRkKGF0b21zVG9JbnZhbGlkYXRlLCBib25kLmIuZW5kKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGJvbmRsaXN0Lmxlbmd0aDsgKytpKSB7XHJcblx0XHRcdGFjdGlvbi5hZGRPcChuZXcgb3AuQm9uZE1vdmUoYm9uZGxpc3RbaV0sIGQpKTtcclxuXHRcdH1cclxuXHRcdFNldC5lYWNoKGxvb3BzLCBmdW5jdGlvbiAobG9vcElkKXtcclxuXHRcdFx0aWYgKFJTLnJlbG9vcHMuZ2V0KGxvb3BJZCkgJiYgUlMucmVsb29wcy5nZXQobG9vcElkKS52aXNlbCkgLy8gaGFja1xyXG5cdFx0XHRcdGFjdGlvbi5hZGRPcChuZXcgb3AuTG9vcE1vdmUobG9vcElkLCBkKSk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHRcdGZvciAoaSA9IDA7IGkgPCBsaXN0cy5hdG9tcy5sZW5ndGg7ICsraSkge1xyXG5cdFx0XHR2YXIgYWlkID0gbGlzdHMuYXRvbXNbaV07XHJcblx0XHRcdGFjdGlvbi5hZGRPcChuZXcgb3AuQXRvbU1vdmUoYWlkLCBkLCAhU2V0LmNvbnRhaW5zKGF0b21zVG9JbnZhbGlkYXRlLCBhaWQpKSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRpZiAobGlzdHMucnhuQXJyb3dzKVxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxpc3RzLnJ4bkFycm93cy5sZW5ndGg7ICsraSlcclxuXHRcdFx0YWN0aW9uLmFkZE9wKG5ldyBvcC5SeG5BcnJvd01vdmUobGlzdHMucnhuQXJyb3dzW2ldLCBkLCB0cnVlKSk7XHJcblxyXG5cdGlmIChsaXN0cy5yeG5QbHVzZXMpXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgbGlzdHMucnhuUGx1c2VzLmxlbmd0aDsgKytpKVxyXG5cdFx0XHRhY3Rpb24uYWRkT3AobmV3IG9wLlJ4blBsdXNNb3ZlKGxpc3RzLnJ4blBsdXNlc1tpXSwgZCwgdHJ1ZSkpO1xyXG5cclxuXHRpZiAobGlzdHMuc2dyb3VwRGF0YSlcclxuXHRcdGZvciAoaSA9IDA7IGkgPCBsaXN0cy5zZ3JvdXBEYXRhLmxlbmd0aDsgKytpKVxyXG5cdFx0XHRhY3Rpb24uYWRkT3AobmV3IG9wLlNHcm91cERhdGFNb3ZlKGxpc3RzLnNncm91cERhdGFbaV0sIGQpKTtcclxuXHJcblx0aWYgKGxpc3RzLmNoaXJhbEZsYWdzKVxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxpc3RzLmNoaXJhbEZsYWdzLmxlbmd0aDsgKytpKVxyXG5cdFx0XHRhY3Rpb24uYWRkT3AobmV3IG9wLkNoaXJhbEZsYWdNb3ZlKGQpKTtcclxuXHJcblx0cmV0dXJuIGFjdGlvbi5wZXJmb3JtKCk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBmcm9tQXRvbXNBdHRycyAoaWRzLCBhdHRycywgcmVzZXQpXHJcbntcclxuXHR2YXIgYWN0aW9uID0gbmV3IEFjdGlvbigpO1xyXG5cdCh0eXBlb2YoaWRzKSA9PSAnbnVtYmVyJyA/IFtpZHNdIDogaWRzKS5lYWNoKGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0Zm9yICh2YXIga2V5IGluIEF0b20uYXR0cmxpc3QpIHtcclxuXHRcdFx0dmFyIHZhbHVlO1xyXG5cdFx0XHRpZiAoa2V5IGluIGF0dHJzKVxyXG5cdFx0XHRcdHZhbHVlID0gYXR0cnNba2V5XTtcclxuXHRcdFx0ZWxzZSBpZiAocmVzZXQpXHJcblx0XHRcdFx0dmFsdWUgPSBBdG9tLmF0dHJHZXREZWZhdWx0KGtleSk7XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0YWN0aW9uLmFkZE9wKG5ldyBvcC5BdG9tQXR0cihpZCwga2V5LCB2YWx1ZSkpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCFyZXNldCAmJiAnbGFiZWwnIGluIGF0dHJzICYmIGF0dHJzLmxhYmVsICE9IG51bGwgJiYgYXR0cnMubGFiZWwgIT0gJ0wjJyAmJiAhYXR0cnNbJ2F0b21MaXN0J10pIHtcclxuXHRcdFx0YWN0aW9uLmFkZE9wKG5ldyBvcC5BdG9tQXR0cihpZCwgJ2F0b21MaXN0JywgbnVsbCkpO1xyXG5cdFx0fVxyXG5cdH0sIHRoaXMpO1xyXG5cdHJldHVybiBhY3Rpb24ucGVyZm9ybSgpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gZnJvbUJvbmRBdHRycyAoaWQsIGF0dHJzLCBmbGlwLCByZXNldClcclxue1xyXG5cdHZhciBhY3Rpb24gPSBuZXcgQWN0aW9uKCk7XHJcblxyXG5cdGZvciAodmFyIGtleSBpbiBCb25kLlBBVFRFUk4uYXR0cmxpc3QpIHtcclxuXHRcdHZhciB2YWx1ZTtcclxuXHRcdGlmIChrZXkgaW4gYXR0cnMpXHJcblx0XHRcdHZhbHVlID0gYXR0cnNba2V5XTtcclxuXHRcdGVsc2UgaWYgKHJlc2V0KVxyXG5cdFx0XHR2YWx1ZSA9IEJvbmQuUEFUVEVSTi5hdHRyR2V0RGVmYXVsdChrZXkpO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdGFjdGlvbi5hZGRPcChuZXcgb3AuQm9uZEF0dHIoaWQsIGtleSwgdmFsdWUpKTtcclxuXHR9XHJcblx0aWYgKGZsaXApXHJcblx0XHRhY3Rpb24ubWVyZ2VXaXRoKHRvQm9uZEZsaXBwaW5nKGlkKSk7XHJcblx0cmV0dXJuIGFjdGlvbi5wZXJmb3JtKCk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBmcm9tU2VsZWN0ZWRCb25kc0F0dHJzIChhdHRycywgZmxpcHMpXHJcbntcclxuXHR2YXIgYWN0aW9uID0gbmV3IEFjdGlvbigpO1xyXG5cclxuXHRhdHRycyA9IG5ldyBIYXNoKGF0dHJzKTtcclxuXHJcblx0dWkuZWRpdG9yLmdldFNlbGVjdGlvbigpLmJvbmRzLmVhY2goZnVuY3Rpb24gKGlkKSB7XHJcblx0XHRhdHRycy5lYWNoKGZ1bmN0aW9uIChhdHRyKSB7XHJcblx0XHRcdGFjdGlvbi5hZGRPcChuZXcgb3AuQm9uZEF0dHIoaWQsIGF0dHIua2V5LCBhdHRyLnZhbHVlKSk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHR9LCB0aGlzKTtcclxuXHRpZiAoZmxpcHMpXHJcblx0XHRmbGlwcy5lYWNoKGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0XHRhY3Rpb24ubWVyZ2VXaXRoKHRvQm9uZEZsaXBwaW5nKGlkKSk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHRyZXR1cm4gYWN0aW9uLnBlcmZvcm0oKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGZyb21BdG9tQWRkaXRpb24gKHBvcywgYXRvbSlcclxue1xyXG5cdGF0b20gPSBPYmplY3QuY2xvbmUoYXRvbSk7XHJcblx0dmFyIGFjdGlvbiA9IG5ldyBBY3Rpb24oKTtcclxuXHRhdG9tLmZyYWdtZW50ID0gYWN0aW9uLmFkZE9wKG5ldyBvcC5GcmFnbWVudEFkZCgpLnBlcmZvcm0odWkuZWRpdG9yKSkuZnJpZDtcclxuXHRhY3Rpb24uYWRkT3AobmV3IG9wLkF0b21BZGQoYXRvbSwgcG9zKS5wZXJmb3JtKHVpLmVkaXRvcikpO1xyXG5cdHJldHVybiBhY3Rpb247XHJcbn07XHJcblxyXG5mdW5jdGlvbiBtZXJnZUZyYWdtZW50cyAoYWN0aW9uLCBmcmlkLCBmcmlkMikge1xyXG5cdGlmIChmcmlkMiAhPSBmcmlkICYmIE9iamVjdC5pc051bWJlcihmcmlkMikpIHtcclxuXHRcdHZhciByZ2lkID0gU3RydWN0LlJHcm91cC5maW5kUkdyb3VwQnlGcmFnbWVudCh1aS5yZW5kZXIuY3RhYi5tb2xlY3VsZS5yZ3JvdXBzLCBmcmlkMik7XHJcblx0XHRpZiAoIU9iamVjdC5pc1VuZGVmaW5lZChyZ2lkKSkge1xyXG5cdFx0XHRhY3Rpb24ubWVyZ2VXaXRoKGZyb21SR3JvdXBGcmFnbWVudChudWxsLCBmcmlkMikpO1xyXG5cdFx0fVxyXG5cdFx0dWkucmVuZGVyLmN0YWIubW9sZWN1bGUuYXRvbXMuZWFjaChmdW5jdGlvbiAoYWlkLCBhdG9tKSB7XHJcblx0XHRcdGlmIChhdG9tLmZyYWdtZW50ID09IGZyaWQyKSB7XHJcblx0XHRcdFx0YWN0aW9uLmFkZE9wKG5ldyBvcC5BdG9tQXR0cihhaWQsICdmcmFnbWVudCcsIGZyaWQpLnBlcmZvcm0odWkuZWRpdG9yKSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0YWN0aW9uLmFkZE9wKG5ldyBvcC5GcmFnbWVudERlbGV0ZShmcmlkMikucGVyZm9ybSh1aS5lZGl0b3IpKTtcclxuXHR9XHJcbn07XHJcblxyXG4vLyBHZXQgbmV3IGF0b20gaWQvbGFiZWwgYW5kIHBvcyBmb3IgYm9uZCBiZWluZyBhZGRlZCB0byBleGlzdGluZyBhdG9tXHJcbmZ1bmN0aW9uIGF0b21Gb3JOZXdCb25kIChpZClcclxue1xyXG5cdHZhciBuZWlnaGJvdXJzID0gW107XHJcblx0dmFyIHBvcyA9IHVpLnJlbmRlci5hdG9tR2V0UG9zKGlkKTtcclxuXHJcblx0dWkucmVuZGVyLmF0b21HZXROZWlnaGJvcnMoaWQpLmVhY2goZnVuY3Rpb24gKG5laSlcclxuXHR7XHJcblx0XHR2YXIgbmVpX3BvcyA9IHVpLnJlbmRlci5hdG9tR2V0UG9zKG5laS5haWQpO1xyXG5cclxuXHRcdGlmIChWZWMyLmRpc3QocG9zLCBuZWlfcG9zKSA8IDAuMSlcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdG5laWdoYm91cnMucHVzaCh7aWQ6IG5laS5haWQsIHY6IFZlYzIuZGlmZihuZWlfcG9zLCBwb3MpfSk7XHJcblx0fSk7XHJcblxyXG5cdG5laWdoYm91cnMuc29ydChmdW5jdGlvbiAobmVpMSwgbmVpMilcclxuXHR7XHJcblx0XHRyZXR1cm4gTWF0aC5hdGFuMihuZWkxLnYueSwgbmVpMS52LngpIC0gTWF0aC5hdGFuMihuZWkyLnYueSwgbmVpMi52LngpO1xyXG5cdH0pO1xyXG5cclxuXHR2YXIgaSwgbWF4X2kgPSAwO1xyXG5cdHZhciBhbmdsZSwgbWF4X2FuZ2xlID0gMDtcclxuXHJcblx0Ly8gVE9ETzogaW1wb3ZlIGxheW91dDogdHJlZSwgLi4uXHJcblxyXG5cdGZvciAoaSA9IDA7IGkgPCBuZWlnaGJvdXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRhbmdsZSA9IFZlYzIuYW5nbGUobmVpZ2hib3Vyc1tpXS52LCBuZWlnaGJvdXJzWyhpICsgMSkgJSBuZWlnaGJvdXJzLmxlbmd0aF0udik7XHJcblxyXG5cdFx0aWYgKGFuZ2xlIDwgMClcclxuXHRcdFx0YW5nbGUgKz0gMiAqIE1hdGguUEk7XHJcblxyXG5cdFx0aWYgKGFuZ2xlID4gbWF4X2FuZ2xlKVxyXG5cdFx0XHRtYXhfaSA9IGksIG1heF9hbmdsZSA9IGFuZ2xlO1xyXG5cdH1cclxuXHJcblx0dmFyIHYgPSBuZXcgVmVjMigxLCAwKTtcclxuXHJcblx0aWYgKG5laWdoYm91cnMubGVuZ3RoID4gMCkge1xyXG5cdFx0aWYgKG5laWdoYm91cnMubGVuZ3RoID09IDEpIHtcclxuXHRcdFx0bWF4X2FuZ2xlID0gLSg0ICogTWF0aC5QSSAvIDMpO1xyXG5cclxuXHRcdFx0Ly8gemlnLXphZ1xyXG5cdFx0XHR2YXIgbmVpID0gdWkucmVuZGVyLmF0b21HZXROZWlnaGJvcnMoaWQpWzBdO1xyXG5cdFx0XHRpZiAodWkucmVuZGVyLmF0b21HZXREZWdyZWUobmVpLmFpZCkgPiAxKSB7XHJcblx0XHRcdFx0dmFyIG5laV9uZWlnaGJvdXJzID0gW107XHJcblx0XHRcdFx0dmFyIG5laV9wb3MgPSB1aS5yZW5kZXIuYXRvbUdldFBvcyhuZWkuYWlkKTtcclxuXHRcdFx0XHR2YXIgbmVpX3YgPSBWZWMyLmRpZmYocG9zLCBuZWlfcG9zKTtcclxuXHRcdFx0XHR2YXIgbmVpX2FuZ2xlID0gTWF0aC5hdGFuMihuZWlfdi55LCBuZWlfdi54KTtcclxuXHJcblx0XHRcdFx0dWkucmVuZGVyLmF0b21HZXROZWlnaGJvcnMobmVpLmFpZCkuZWFjaChmdW5jdGlvbiAobmVpX25laSkge1xyXG5cdFx0XHRcdFx0dmFyIG5laV9uZWlfcG9zID0gdWkucmVuZGVyLmF0b21HZXRQb3MobmVpX25laS5haWQpO1xyXG5cclxuXHRcdFx0XHRcdGlmIChuZWlfbmVpLmJpZCA9PSBuZWkuYmlkIHx8IFZlYzIuZGlzdChuZWlfcG9zLCBuZWlfbmVpX3BvcykgPCAwLjEpXHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdFx0XHR2YXIgdl9kaWZmID0gVmVjMi5kaWZmKG5laV9uZWlfcG9zLCBuZWlfcG9zKTtcclxuXHRcdFx0XHRcdHZhciBhbmcgPSBNYXRoLmF0YW4yKHZfZGlmZi55LCB2X2RpZmYueCkgLSBuZWlfYW5nbGU7XHJcblxyXG5cdFx0XHRcdFx0aWYgKGFuZyA8IDApXHJcblx0XHRcdFx0XHRcdGFuZyArPSAyICogTWF0aC5QSTtcclxuXHJcblx0XHRcdFx0XHRuZWlfbmVpZ2hib3Vycy5wdXNoKGFuZyk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdFx0bmVpX25laWdoYm91cnMuc29ydChmdW5jdGlvbiAobmVpMSwgbmVpMikge1xyXG5cdFx0XHRcdFx0cmV0dXJuIG5laTEgLSBuZWkyO1xyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRpZiAobmVpX25laWdoYm91cnNbMF0gPD0gTWF0aC5QSSAqIDEuMDEgJiYgbmVpX25laWdoYm91cnNbbmVpX25laWdoYm91cnMubGVuZ3RoIC0gMV0gPD0gMS4wMSAqIE1hdGguUEkpXHJcblx0XHRcdFx0XHRtYXhfYW5nbGUgKj0gLTE7XHJcblxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0YW5nbGUgPSAobWF4X2FuZ2xlIC8gMikgKyBNYXRoLmF0YW4yKG5laWdoYm91cnNbbWF4X2ldLnYueSwgbmVpZ2hib3Vyc1ttYXhfaV0udi54KTtcclxuXHJcblx0XHR2ID0gdi5yb3RhdGUoYW5nbGUpO1xyXG5cdH1cclxuXHJcblx0di5hZGRfKHBvcyk7XHJcblxyXG5cdHZhciBhID0gdWkucmVuZGVyLmZpbmRDbG9zZXN0QXRvbSh2LCAwLjEpO1xyXG5cclxuXHRpZiAoYSA9PSBudWxsKVxyXG5cdFx0YSA9IHtsYWJlbDogJ0MnfTtcclxuXHRlbHNlXHJcblx0XHRhID0gYS5pZDtcclxuXHJcblx0cmV0dXJuIHthdG9tOiBhLCBwb3M6IHZ9O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gZnJvbUJvbmRBZGRpdGlvbiAoYm9uZCwgYmVnaW4sIGVuZCwgcG9zLCBwb3MyKVxyXG57XHJcblx0aWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHR2YXIgYXRvbSA9IGF0b21Gb3JOZXdCb25kKGJlZ2luKTtcclxuXHRcdGVuZCA9IGF0b20uYXRvbTtcclxuXHRcdHBvcyA9IGF0b20ucG9zO1xyXG5cdH1cclxuXHR2YXIgYWN0aW9uID0gbmV3IEFjdGlvbigpO1xyXG5cclxuXHR2YXIgZnJpZCA9IG51bGw7XHJcblx0aWYgKCFPYmplY3QuaXNOdW1iZXIoYmVnaW4pKSB7XHJcblx0XHRpZiAoT2JqZWN0LmlzTnVtYmVyKGVuZCkpIHtcclxuXHRcdFx0ZnJpZCA9IHVpLnJlbmRlci5hdG9tR2V0QXR0cihlbmQsICdmcmFnbWVudCcpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRlbHNlIHtcclxuXHRcdGZyaWQgPSB1aS5yZW5kZXIuYXRvbUdldEF0dHIoYmVnaW4sICdmcmFnbWVudCcpO1xyXG5cdFx0aWYgKE9iamVjdC5pc051bWJlcihlbmQpKSB7XHJcblx0XHRcdHZhciBmcmlkMiA9IHVpLnJlbmRlci5hdG9tR2V0QXR0cihlbmQsICdmcmFnbWVudCcpO1xyXG5cdFx0XHRtZXJnZUZyYWdtZW50cyhhY3Rpb24sIGZyaWQsIGZyaWQyKTtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKGZyaWQgPT0gbnVsbCkge1xyXG5cdFx0ZnJpZCA9IGFjdGlvbi5hZGRPcChuZXcgb3AuRnJhZ21lbnRBZGQoKS5wZXJmb3JtKHVpLmVkaXRvcikpLmZyaWQ7XHJcblx0fVxyXG5cclxuXHRpZiAoIU9iamVjdC5pc051bWJlcihiZWdpbikpIHtcclxuXHRcdGJlZ2luLmZyYWdtZW50ID0gZnJpZDtcclxuXHRcdGJlZ2luID0gYWN0aW9uLmFkZE9wKG5ldyBvcC5BdG9tQWRkKGJlZ2luLCBwb3MpLnBlcmZvcm0odWkuZWRpdG9yKSkuZGF0YS5haWQ7XHJcblxyXG5cdFx0cG9zID0gcG9zMjtcclxuXHR9XHJcblx0ZWxzZSB7XHJcblx0XHRpZiAodWkucmVuZGVyLmF0b21HZXRBdHRyKGJlZ2luLCAnbGFiZWwnKSA9PSAnKicpIHtcclxuXHRcdFx0YWN0aW9uLmFkZE9wKG5ldyBvcC5BdG9tQXR0cihiZWdpbiwgJ2xhYmVsJywgJ0MnKS5wZXJmb3JtKHVpLmVkaXRvcikpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblxyXG5cdGlmICghT2JqZWN0LmlzTnVtYmVyKGVuZCkpIHtcclxuXHRcdGVuZC5mcmFnbWVudCA9IGZyaWQ7XHJcblx0XHQvLyBUT0RPOiA8b3A+LmRhdGEuYWlkIGhlcmUgaXMgYSBoYWNrLCBuZWVkIGEgYmV0dGVyIHdheSB0byBhY2Nlc3MgdGhlIGlkIG9mIGEgbmV3bHkgY3JlYXRlZCBhdG9tXHJcblx0XHRlbmQgPSBhY3Rpb24uYWRkT3AobmV3IG9wLkF0b21BZGQoZW5kLCBwb3MpLnBlcmZvcm0odWkuZWRpdG9yKSkuZGF0YS5haWQ7XHJcblx0XHRpZiAoT2JqZWN0LmlzTnVtYmVyKGJlZ2luKSkge1xyXG5cdFx0XHR1aS5yZW5kZXIuYXRvbUdldFNHcm91cHMoYmVnaW4pLmVhY2goZnVuY3Rpb24gKHNpZCkge1xyXG5cdFx0XHRcdGFjdGlvbi5hZGRPcChuZXcgb3AuU0dyb3VwQXRvbUFkZChzaWQsIGVuZCkucGVyZm9ybSh1aS5lZGl0b3IpKTtcclxuXHRcdFx0fSwgdGhpcyk7XHJcblx0XHR9XHJcblx0fVxyXG5cdGVsc2Uge1xyXG5cdFx0aWYgKHVpLnJlbmRlci5hdG9tR2V0QXR0cihlbmQsICdsYWJlbCcpID09ICcqJykge1xyXG5cdFx0XHRhY3Rpb24uYWRkT3AobmV3IG9wLkF0b21BdHRyKGVuZCwgJ2xhYmVsJywgJ0MnKS5wZXJmb3JtKHVpLmVkaXRvcikpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0dmFyIGJpZCA9IGFjdGlvbi5hZGRPcChuZXcgb3AuQm9uZEFkZChiZWdpbiwgZW5kLCBib25kKS5wZXJmb3JtKHVpLmVkaXRvcikpLmRhdGEuYmlkO1xyXG5cclxuXHRhY3Rpb24ub3BlcmF0aW9ucy5yZXZlcnNlKCk7XHJcblxyXG5cdHJldHVybiBbYWN0aW9uLCBiZWdpbiwgZW5kLCBiaWRdO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gZnJvbUFycm93QWRkaXRpb24gKHBvcylcclxue1xyXG5cdHZhciBhY3Rpb24gPSBuZXcgQWN0aW9uKCk7XHJcblx0aWYgKHVpLmN0YWIucnhuQXJyb3dzLmNvdW50KCkgPCAxKSB7XHJcblx0XHRhY3Rpb24uYWRkT3AobmV3IG9wLlJ4bkFycm93QWRkKHBvcykucGVyZm9ybSh1aS5lZGl0b3IpKTtcclxuXHR9XHJcblx0cmV0dXJuIGFjdGlvbjtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGZyb21BcnJvd0RlbGV0aW9uIChpZClcclxue1xyXG5cdHZhciBhY3Rpb24gPSBuZXcgQWN0aW9uKCk7XHJcblx0YWN0aW9uLmFkZE9wKG5ldyBvcC5SeG5BcnJvd0RlbGV0ZShpZCkpO1xyXG5cdHJldHVybiBhY3Rpb24ucGVyZm9ybSgpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gZnJvbUNoaXJhbEZsYWdBZGRpdGlvbiAocG9zKVxyXG57XHJcblx0dmFyIGFjdGlvbiA9IG5ldyBBY3Rpb24oKTtcclxuXHRpZiAodWkucmVuZGVyLmN0YWIuY2hpcmFsRmxhZ3MuY291bnQoKSA8IDEpIHtcclxuXHRcdGFjdGlvbi5hZGRPcChuZXcgb3AuQ2hpcmFsRmxhZ0FkZChwb3MpLnBlcmZvcm0odWkuZWRpdG9yKSk7XHJcblx0fVxyXG5cdHJldHVybiBhY3Rpb247XHJcbn07XHJcblxyXG5mdW5jdGlvbiBmcm9tQ2hpcmFsRmxhZ0RlbGV0aW9uICgpXHJcbntcclxuXHR2YXIgYWN0aW9uID0gbmV3IEFjdGlvbigpO1xyXG5cdGFjdGlvbi5hZGRPcChuZXcgb3AuQ2hpcmFsRmxhZ0RlbGV0ZSgpKTtcclxuXHRyZXR1cm4gYWN0aW9uLnBlcmZvcm0oKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGZyb21QbHVzQWRkaXRpb24gKHBvcylcclxue1xyXG5cdHZhciBhY3Rpb24gPSBuZXcgQWN0aW9uKCk7XHJcblx0YWN0aW9uLmFkZE9wKG5ldyBvcC5SeG5QbHVzQWRkKHBvcykucGVyZm9ybSh1aS5lZGl0b3IpKTtcclxuXHRyZXR1cm4gYWN0aW9uO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gZnJvbVBsdXNEZWxldGlvbiAoaWQpXHJcbntcclxuXHR2YXIgYWN0aW9uID0gbmV3IEFjdGlvbigpO1xyXG5cdGFjdGlvbi5hZGRPcChuZXcgb3AuUnhuUGx1c0RlbGV0ZShpZCkpO1xyXG5cdHJldHVybiBhY3Rpb24ucGVyZm9ybSgpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gZnJvbUF0b21EZWxldGlvbiAoaWQpXHJcbntcclxuXHR2YXIgYWN0aW9uID0gbmV3IEFjdGlvbigpO1xyXG5cdHZhciBhdG9tc190b19yZW1vdmUgPSBuZXcgQXJyYXkoKTtcclxuXHJcblx0dmFyIGZyaWQgPSB1aS5jdGFiLmF0b21zLmdldChpZCkuZnJhZ21lbnQ7XHJcblxyXG5cdHVpLnJlbmRlci5hdG9tR2V0TmVpZ2hib3JzKGlkKS5lYWNoKGZ1bmN0aW9uIChuZWkpXHJcblx0e1xyXG5cdFx0YWN0aW9uLmFkZE9wKG5ldyBvcC5Cb25kRGVsZXRlKG5laS5iaWQpKTsvLyBbUkJdICEhXHJcblx0XHRpZiAodWkucmVuZGVyLmF0b21HZXREZWdyZWUobmVpLmFpZCkgPT0gMSlcclxuXHRcdHtcclxuXHRcdFx0aWYgKGFjdGlvbi5yZW1vdmVBdG9tRnJvbVNncm91cElmTmVlZGVkKG5laS5haWQpKVxyXG5cdFx0XHRcdGF0b21zX3RvX3JlbW92ZS5wdXNoKG5laS5haWQpO1xyXG5cclxuXHRcdFx0YWN0aW9uLmFkZE9wKG5ldyBvcC5BdG9tRGVsZXRlKG5laS5haWQpKTtcclxuXHRcdH1cclxuXHR9LCB0aGlzKTtcclxuXHJcblx0aWYgKGFjdGlvbi5yZW1vdmVBdG9tRnJvbVNncm91cElmTmVlZGVkKGlkKSlcclxuXHRcdGF0b21zX3RvX3JlbW92ZS5wdXNoKGlkKTtcclxuXHJcblx0YWN0aW9uLmFkZE9wKG5ldyBvcC5BdG9tRGVsZXRlKGlkKSk7XHJcblxyXG5cdGFjdGlvbi5yZW1vdmVTZ3JvdXBJZk5lZWRlZChhdG9tc190b19yZW1vdmUpO1xyXG5cclxuXHRhY3Rpb24gPSBhY3Rpb24ucGVyZm9ybSgpO1xyXG5cclxuXHRhY3Rpb24ubWVyZ2VXaXRoKGZyb21GcmFnbWVudFNwbGl0KGZyaWQpKTtcclxuXHJcblx0cmV0dXJuIGFjdGlvbjtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGZyb21Cb25kRGVsZXRpb24gKGlkKVxyXG57XHJcblx0dmFyIGFjdGlvbiA9IG5ldyBBY3Rpb24oKTtcclxuXHR2YXIgYm9uZCA9IHVpLmN0YWIuYm9uZHMuZ2V0KGlkKTtcclxuXHR2YXIgZnJpZCA9IHVpLmN0YWIuYXRvbXMuZ2V0KGJvbmQuYmVnaW4pLmZyYWdtZW50O1xyXG5cdHZhciBhdG9tc190b19yZW1vdmUgPSBuZXcgQXJyYXkoKTtcclxuXHJcblx0YWN0aW9uLmFkZE9wKG5ldyBvcC5Cb25kRGVsZXRlKGlkKSk7XHJcblxyXG5cdGlmICh1aS5yZW5kZXIuYXRvbUdldERlZ3JlZShib25kLmJlZ2luKSA9PSAxKVxyXG5cdHtcclxuXHRcdGlmIChhY3Rpb24ucmVtb3ZlQXRvbUZyb21TZ3JvdXBJZk5lZWRlZChib25kLmJlZ2luKSlcclxuXHRcdFx0YXRvbXNfdG9fcmVtb3ZlLnB1c2goYm9uZC5iZWdpbik7XHJcblxyXG5cdFx0YWN0aW9uLmFkZE9wKG5ldyBvcC5BdG9tRGVsZXRlKGJvbmQuYmVnaW4pKTtcclxuXHR9XHJcblxyXG5cdGlmICh1aS5yZW5kZXIuYXRvbUdldERlZ3JlZShib25kLmVuZCkgPT0gMSlcclxuXHR7XHJcblx0XHRpZiAoYWN0aW9uLnJlbW92ZUF0b21Gcm9tU2dyb3VwSWZOZWVkZWQoYm9uZC5lbmQpKVxyXG5cdFx0XHRhdG9tc190b19yZW1vdmUucHVzaChib25kLmVuZCk7XHJcblxyXG5cdFx0YWN0aW9uLmFkZE9wKG5ldyBvcC5BdG9tRGVsZXRlKGJvbmQuZW5kKSk7XHJcblx0fVxyXG5cclxuXHRhY3Rpb24ucmVtb3ZlU2dyb3VwSWZOZWVkZWQoYXRvbXNfdG9fcmVtb3ZlKTtcclxuXHJcblx0YWN0aW9uID0gYWN0aW9uLnBlcmZvcm0oKTtcclxuXHJcblx0YWN0aW9uLm1lcmdlV2l0aChmcm9tRnJhZ21lbnRTcGxpdChmcmlkKSk7XHJcblxyXG5cdHJldHVybiBhY3Rpb247XHJcbn07XHJcblxyXG5mdW5jdGlvbiBmcm9tRnJhZ21lbnRTcGxpdCAoZnJpZCkgeyAvLyBUT0RPIFtSQl0gdGhlIHRoaW5nIGlzIHRvbyB0cmlja3kgOikgbmVlZCBzb21ldGhpbmcgZWxzZSBpbiBmdXR1cmVcclxuXHR2YXIgYWN0aW9uID0gbmV3IEFjdGlvbigpO1xyXG5cdHZhciByZ2lkID0gU3RydWN0LlJHcm91cC5maW5kUkdyb3VwQnlGcmFnbWVudCh1aS5jdGFiLnJncm91cHMsIGZyaWQpO1xyXG5cdHVpLmN0YWIuYXRvbXMuZWFjaChmdW5jdGlvbiAoYWlkLCBhdG9tKSB7XHJcblx0XHRpZiAoYXRvbS5mcmFnbWVudCA9PSBmcmlkKSB7XHJcblx0XHRcdHZhciBuZXdmcmlkID0gYWN0aW9uLmFkZE9wKG5ldyBvcC5GcmFnbWVudEFkZCgpLnBlcmZvcm0odWkuZWRpdG9yKSkuZnJpZDtcclxuXHRcdFx0dmFyIHByb2Nlc3NBdG9tID0gZnVuY3Rpb24gKGFpZDEpIHtcclxuXHRcdFx0XHRhY3Rpb24uYWRkT3AobmV3IG9wLkF0b21BdHRyKGFpZDEsICdmcmFnbWVudCcsIG5ld2ZyaWQpLnBlcmZvcm0odWkuZWRpdG9yKSk7XHJcblx0XHRcdFx0dWkucmVuZGVyLmF0b21HZXROZWlnaGJvcnMoYWlkMSkuZWFjaChmdW5jdGlvbiAobmVpKSB7XHJcblx0XHRcdFx0XHRpZiAodWkuY3RhYi5hdG9tcy5nZXQobmVpLmFpZCkuZnJhZ21lbnQgPT0gZnJpZCkge1xyXG5cdFx0XHRcdFx0XHRwcm9jZXNzQXRvbShuZWkuYWlkKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fTtcclxuXHRcdFx0cHJvY2Vzc0F0b20oYWlkKTtcclxuXHRcdFx0aWYgKHJnaWQpIHtcclxuXHRcdFx0XHRhY3Rpb24ubWVyZ2VXaXRoKGZyb21SR3JvdXBGcmFnbWVudChyZ2lkLCBuZXdmcmlkKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9KTtcclxuXHRpZiAoZnJpZCAhPSAtMSkge1xyXG5cdFx0YWN0aW9uLm1lcmdlV2l0aChmcm9tUkdyb3VwRnJhZ21lbnQoMCwgZnJpZCkpO1xyXG5cdFx0YWN0aW9uLmFkZE9wKG5ldyBvcC5GcmFnbWVudERlbGV0ZShmcmlkKS5wZXJmb3JtKHVpLmVkaXRvcikpO1xyXG5cdH1cclxuXHRyZXR1cm4gYWN0aW9uO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gZnJvbUZyYWdtZW50QWRkaXRpb24gKGF0b21zLCBib25kcywgc2dyb3VwcywgcnhuQXJyb3dzLCByeG5QbHVzZXMpXHJcbntcclxuXHR2YXIgYWN0aW9uID0gbmV3IEFjdGlvbigpO1xyXG5cclxuXHQvKlxyXG4gICAgIGF0b21zLmVhY2goZnVuY3Rpb24gKGFpZClcclxuICAgICB7XHJcbiAgICAgdWkucmVuZGVyLmF0b21HZXROZWlnaGJvcnMoYWlkKS5lYWNoKGZ1bmN0aW9uIChuZWkpXHJcbiAgICAge1xyXG4gICAgIGlmICh1aS5zZWxlY3Rpb24uYm9uZHMuaW5kZXhPZihuZWkuYmlkKSA9PSAtMSlcclxuICAgICB1aS5zZWxlY3Rpb24uYm9uZHMgPSB1aS5zZWxlY3Rpb24uYm9uZHMuY29uY2F0KFtuZWkuYmlkXSk7XHJcbiAgICAgfSwgdGhpcyk7XHJcbiAgICAgfSwgdGhpcyk7XHJcbiAgICAgKi9cclxuXHJcblx0Ly8gVE9ETzogbWVyZ2UgY2xvc2UgYXRvbXMgYW5kIGJvbmRzXHJcblxyXG5cdHNncm91cHMuZWFjaChmdW5jdGlvbiAoc2lkKVxyXG5cdHtcclxuXHRcdGFjdGlvbi5hZGRPcChuZXcgb3AuU0dyb3VwUmVtb3ZlRnJvbUhpZXJhcmNoeShzaWQpKTtcclxuXHRcdGFjdGlvbi5hZGRPcChuZXcgb3AuU0dyb3VwRGVsZXRlKHNpZCkpO1xyXG5cdH0sIHRoaXMpO1xyXG5cclxuXHJcblx0Ym9uZHMuZWFjaChmdW5jdGlvbiAoYmlkKSB7XHJcblx0XHRhY3Rpb24uYWRkT3AobmV3IG9wLkJvbmREZWxldGUoYmlkKSk7XHJcblx0fSwgdGhpcyk7XHJcblxyXG5cclxuXHRhdG9tcy5lYWNoKGZ1bmN0aW9uIChhaWQpIHtcclxuXHRcdGFjdGlvbi5hZGRPcChuZXcgb3AuQXRvbURlbGV0ZShhaWQpKTtcclxuXHR9LCB0aGlzKTtcclxuXHJcblx0cnhuQXJyb3dzLmVhY2goZnVuY3Rpb24gKGlkKSB7XHJcblx0XHRhY3Rpb24uYWRkT3AobmV3IG9wLlJ4bkFycm93RGVsZXRlKGlkKSk7XHJcblx0fSwgdGhpcyk7XHJcblxyXG5cdHJ4blBsdXNlcy5lYWNoKGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0YWN0aW9uLmFkZE9wKG5ldyBvcC5SeG5QbHVzRGVsZXRlKGlkKSk7XHJcblx0fSwgdGhpcyk7XHJcblxyXG5cdGFjdGlvbi5tZXJnZVdpdGgobmV3IGZyb21GcmFnbWVudFNwbGl0KC0xKSk7XHJcblxyXG5cdHJldHVybiBhY3Rpb247XHJcbn07XHJcblxyXG5mdW5jdGlvbiBmcm9tRnJhZ21lbnREZWxldGlvbiAoc2VsZWN0aW9uKVxyXG57XHJcblx0c2VsZWN0aW9uID0gc2VsZWN0aW9uIHx8IHVpLmVkaXRvci5nZXRTZWxlY3Rpb24oKTtcclxuXHJcblx0dmFyIGFjdGlvbiA9IG5ldyBBY3Rpb24oKTtcclxuXHR2YXIgYXRvbXNfdG9fcmVtb3ZlID0gbmV3IEFycmF5KCk7XHJcblxyXG5cdHZhciBmcmlkcyA9IFtdO1xyXG5cclxuXHR2YXIgYWN0aW9uUmVtb3ZlRGF0YVNHcm91cHMgPSBuZXcgQWN0aW9uKCk7XHJcblx0aWYgKHNlbGVjdGlvbi5zZ3JvdXBEYXRhKSB7XHJcblx0XHRzZWxlY3Rpb24uc2dyb3VwRGF0YS5lYWNoKGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0XHRhY3Rpb25SZW1vdmVEYXRhU0dyb3Vwcy5tZXJnZVdpdGgoZnJvbVNncm91cERlbGV0aW9uKGlkKSk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHR9XHJcblxyXG5cdHNlbGVjdGlvbi5hdG9tcy5lYWNoKGZ1bmN0aW9uIChhaWQpXHJcblx0e1xyXG5cdFx0dWkucmVuZGVyLmF0b21HZXROZWlnaGJvcnMoYWlkKS5lYWNoKGZ1bmN0aW9uIChuZWkpXHJcblx0XHR7XHJcblx0XHRcdGlmIChzZWxlY3Rpb24uYm9uZHMuaW5kZXhPZihuZWkuYmlkKSA9PSAtMSlcclxuXHRcdFx0XHRzZWxlY3Rpb24uYm9uZHMgPSBzZWxlY3Rpb24uYm9uZHMuY29uY2F0KFtuZWkuYmlkXSk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHR9LCB0aGlzKTtcclxuXHJcblx0c2VsZWN0aW9uLmJvbmRzLmVhY2goZnVuY3Rpb24gKGJpZClcclxuXHR7XHJcblx0XHRhY3Rpb24uYWRkT3AobmV3IG9wLkJvbmREZWxldGUoYmlkKSk7XHJcblxyXG5cdFx0dmFyIGJvbmQgPSB1aS5jdGFiLmJvbmRzLmdldChiaWQpO1xyXG5cclxuXHRcdGlmIChzZWxlY3Rpb24uYXRvbXMuaW5kZXhPZihib25kLmJlZ2luKSA9PSAtMSAmJiB1aS5yZW5kZXIuYXRvbUdldERlZ3JlZShib25kLmJlZ2luKSA9PSAxKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgZnJpZDEgPSB1aS5jdGFiLmF0b21zLmdldChib25kLmJlZ2luKS5mcmFnbWVudDtcclxuXHRcdFx0aWYgKGZyaWRzLmluZGV4T2YoZnJpZDEpIDwgMClcclxuXHRcdFx0XHRmcmlkcy5wdXNoKGZyaWQxKTtcclxuXHJcblx0XHRcdGlmIChhY3Rpb24ucmVtb3ZlQXRvbUZyb21TZ3JvdXBJZk5lZWRlZChib25kLmJlZ2luKSlcclxuXHRcdFx0XHRhdG9tc190b19yZW1vdmUucHVzaChib25kLmJlZ2luKTtcclxuXHJcblx0XHRcdGFjdGlvbi5hZGRPcChuZXcgb3AuQXRvbURlbGV0ZShib25kLmJlZ2luKSk7XHJcblx0XHR9XHJcblx0XHRpZiAoc2VsZWN0aW9uLmF0b21zLmluZGV4T2YoYm9uZC5lbmQpID09IC0xICYmIHVpLnJlbmRlci5hdG9tR2V0RGVncmVlKGJvbmQuZW5kKSA9PSAxKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgZnJpZDIgPSB1aS5jdGFiLmF0b21zLmdldChib25kLmVuZCkuZnJhZ21lbnQ7XHJcblx0XHRcdGlmIChmcmlkcy5pbmRleE9mKGZyaWQyKSA8IDApXHJcblx0XHRcdFx0ZnJpZHMucHVzaChmcmlkMik7XHJcblxyXG5cdFx0XHRpZiAoYWN0aW9uLnJlbW92ZUF0b21Gcm9tU2dyb3VwSWZOZWVkZWQoYm9uZC5lbmQpKVxyXG5cdFx0XHRcdGF0b21zX3RvX3JlbW92ZS5wdXNoKGJvbmQuZW5kKTtcclxuXHJcblx0XHRcdGFjdGlvbi5hZGRPcChuZXcgb3AuQXRvbURlbGV0ZShib25kLmVuZCkpO1xyXG5cdFx0fVxyXG5cdH0sIHRoaXMpO1xyXG5cclxuXHJcblx0c2VsZWN0aW9uLmF0b21zLmVhY2goZnVuY3Rpb24gKGFpZClcclxuXHR7XHJcblx0XHR2YXIgZnJpZDMgPSB1aS5jdGFiLmF0b21zLmdldChhaWQpLmZyYWdtZW50O1xyXG5cdFx0aWYgKGZyaWRzLmluZGV4T2YoZnJpZDMpIDwgMClcclxuXHRcdFx0ZnJpZHMucHVzaChmcmlkMyk7XHJcblxyXG5cdFx0aWYgKGFjdGlvbi5yZW1vdmVBdG9tRnJvbVNncm91cElmTmVlZGVkKGFpZCkpXHJcblx0XHRcdGF0b21zX3RvX3JlbW92ZS5wdXNoKGFpZCk7XHJcblxyXG5cdFx0YWN0aW9uLmFkZE9wKG5ldyBvcC5BdG9tRGVsZXRlKGFpZCkpO1xyXG5cdH0sIHRoaXMpO1xyXG5cclxuXHRhY3Rpb24ucmVtb3ZlU2dyb3VwSWZOZWVkZWQoYXRvbXNfdG9fcmVtb3ZlKTtcclxuXHJcblx0c2VsZWN0aW9uLnJ4bkFycm93cy5lYWNoKGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0YWN0aW9uLmFkZE9wKG5ldyBvcC5SeG5BcnJvd0RlbGV0ZShpZCkpO1xyXG5cdH0sIHRoaXMpO1xyXG5cclxuXHRzZWxlY3Rpb24ucnhuUGx1c2VzLmVhY2goZnVuY3Rpb24gKGlkKSB7XHJcblx0XHRhY3Rpb24uYWRkT3AobmV3IG9wLlJ4blBsdXNEZWxldGUoaWQpKTtcclxuXHR9LCB0aGlzKTtcclxuXHJcblx0c2VsZWN0aW9uLmNoaXJhbEZsYWdzLmVhY2goZnVuY3Rpb24gKGlkKSB7XHJcblx0XHRhY3Rpb24uYWRkT3AobmV3IG9wLkNoaXJhbEZsYWdEZWxldGUoaWQpKTtcclxuXHR9LCB0aGlzKTtcclxuXHJcblx0YWN0aW9uID0gYWN0aW9uLnBlcmZvcm0oKTtcclxuXHJcblx0d2hpbGUgKGZyaWRzLmxlbmd0aCA+IDApIGFjdGlvbi5tZXJnZVdpdGgobmV3IGZyb21GcmFnbWVudFNwbGl0KGZyaWRzLnBvcCgpKSk7XHJcblxyXG5cdGFjdGlvbi5tZXJnZVdpdGgoYWN0aW9uUmVtb3ZlRGF0YVNHcm91cHMpO1xyXG5cclxuXHRyZXR1cm4gYWN0aW9uO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gZnJvbUF0b21NZXJnZSAoc3JjX2lkLCBkc3RfaWQpXHJcbntcclxuXHR2YXIgZnJhZ0FjdGlvbiA9IG5ldyBBY3Rpb24oKTtcclxuXHR2YXIgc3JjX2ZyaWQgPSB1aS5yZW5kZXIuYXRvbUdldEF0dHIoc3JjX2lkLCAnZnJhZ21lbnQnKSwgZHN0X2ZyaWQgPSB1aS5yZW5kZXIuYXRvbUdldEF0dHIoZHN0X2lkLCAnZnJhZ21lbnQnKTtcclxuXHRpZiAoc3JjX2ZyaWQgIT0gZHN0X2ZyaWQpIHtcclxuXHRcdG1lcmdlRnJhZ21lbnRzKGZyYWdBY3Rpb24sIHNyY19mcmlkLCBkc3RfZnJpZCk7XHJcblx0fVxyXG5cclxuXHR2YXIgYWN0aW9uID0gbmV3IEFjdGlvbigpO1xyXG5cclxuXHR1aS5yZW5kZXIuYXRvbUdldE5laWdoYm9ycyhzcmNfaWQpLmVhY2goZnVuY3Rpb24gKG5laSlcclxuXHR7XHJcblx0XHR2YXIgYm9uZCA9IHVpLmN0YWIuYm9uZHMuZ2V0KG5laS5iaWQpO1xyXG5cdFx0dmFyIGJlZ2luLCBlbmQ7XHJcblxyXG5cdFx0aWYgKGJvbmQuYmVnaW4gPT0gbmVpLmFpZCkge1xyXG5cdFx0XHRiZWdpbiA9IG5laS5haWQ7XHJcblx0XHRcdGVuZCA9IGRzdF9pZDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGJlZ2luID0gZHN0X2lkO1xyXG5cdFx0XHRlbmQgPSBuZWkuYWlkO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGRzdF9pZCAhPSBib25kLmJlZ2luICYmIGRzdF9pZCAhPSBib25kLmVuZCAmJiB1aS5jdGFiLmZpbmRCb25kSWQoYmVnaW4sIGVuZCkgPT0gLTEpIC8vIFRPRE86IGltcHJvdmUgdGhpc1xyXG5cdFx0e1xyXG5cdFx0XHRhY3Rpb24uYWRkT3AobmV3IG9wLkJvbmRBZGQoYmVnaW4sIGVuZCwgYm9uZCkpO1xyXG5cdFx0fVxyXG5cdFx0YWN0aW9uLmFkZE9wKG5ldyBvcC5Cb25kRGVsZXRlKG5laS5iaWQpKTtcclxuXHR9LCB0aGlzKTtcclxuXHJcblx0dmFyIGF0dHJzID0gQXRvbS5nZXRBdHRySGFzaCh1aS5jdGFiLmF0b21zLmdldChzcmNfaWQpKTtcclxuXHJcblx0aWYgKHVpLnJlbmRlci5hdG9tR2V0RGVncmVlKHNyY19pZCkgPT0gMSAmJiBhdHRycy5nZXQoJ2xhYmVsJykgPT0gJyonKVxyXG5cdFx0YXR0cnMuc2V0KCdsYWJlbCcsICdDJyk7XHJcblxyXG5cdGF0dHJzLmVhY2goZnVuY3Rpb24gKGF0dHIpIHtcclxuXHRcdGFjdGlvbi5hZGRPcChuZXcgb3AuQXRvbUF0dHIoZHN0X2lkLCBhdHRyLmtleSwgYXR0ci52YWx1ZSkpO1xyXG5cdH0sIHRoaXMpO1xyXG5cclxuXHR2YXIgc2dfY2hhbmdlZCA9IGFjdGlvbi5yZW1vdmVBdG9tRnJvbVNncm91cElmTmVlZGVkKHNyY19pZCk7XHJcblxyXG5cdGFjdGlvbi5hZGRPcChuZXcgb3AuQXRvbURlbGV0ZShzcmNfaWQpKTtcclxuXHJcblx0aWYgKHNnX2NoYW5nZWQpXHJcblx0XHRhY3Rpb24ucmVtb3ZlU2dyb3VwSWZOZWVkZWQoW3NyY19pZF0pO1xyXG5cclxuXHRyZXR1cm4gYWN0aW9uLnBlcmZvcm0oKS5tZXJnZVdpdGgoZnJhZ0FjdGlvbik7XHJcbn07XHJcblxyXG5mdW5jdGlvbiB0b0JvbmRGbGlwcGluZyAoaWQpXHJcbntcclxuXHR2YXIgYm9uZCA9IHVpLmN0YWIuYm9uZHMuZ2V0KGlkKTtcclxuXHJcblx0dmFyIGFjdGlvbiA9IG5ldyBBY3Rpb24oKTtcclxuXHRhY3Rpb24uYWRkT3AobmV3IG9wLkJvbmREZWxldGUoaWQpKTtcclxuXHRhY3Rpb24uYWRkT3AobmV3IG9wLkJvbmRBZGQoYm9uZC5lbmQsIGJvbmQuYmVnaW4sIGJvbmQpKS5kYXRhLmJpZCA9IGlkO1xyXG5cdHJldHVybiBhY3Rpb247XHJcbn07XHJcblxyXG5mdW5jdGlvbiBmcm9tQm9uZEZsaXBwaW5nIChiaWQpIHtcclxuXHRyZXR1cm4gdG9Cb25kRmxpcHBpbmcoYmlkKS5wZXJmb3JtKCk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBmcm9tVGVtcGxhdGVPbkNhbnZhcyAocG9zLCBhbmdsZSwgdGVtcGxhdGUpXHJcbntcclxuXHR2YXIgYWN0aW9uID0gbmV3IEFjdGlvbigpO1xyXG5cdHZhciBmcmFnID0gdGVtcGxhdGUubW9sZWN1bGU7XHJcblxyXG5cdHZhciBmcmFnQWN0aW9uID0gbmV3IG9wLkZyYWdtZW50QWRkKCkucGVyZm9ybSh1aS5lZGl0b3IpO1xyXG5cclxuXHR2YXIgbWFwID0ge307XHJcblxyXG5cdC8vIE9ubHkgdGVtcGxhdGUgYXRvbSBsYWJlbCBtYXR0ZXJzIGZvciBub3dcclxuXHRmcmFnLmF0b21zLmVhY2goZnVuY3Rpb24gKGFpZCwgYXRvbSkge1xyXG5cdFx0dmFyIG9wZXJhdGlvbjtcclxuXHRcdHZhciBhdHRycyA9IEF0b20uZ2V0QXR0ckhhc2goYXRvbSkudG9PYmplY3QoKTtcclxuXHRcdGF0dHJzLmZyYWdtZW50ID0gZnJhZ0FjdGlvbi5mcmlkO1xyXG5cclxuXHRcdGFjdGlvbi5hZGRPcChcclxuXHRcdFx0b3BlcmF0aW9uID0gbmV3IG9wLkF0b21BZGQoXHJcblx0XHRcdFx0YXR0cnMsXHJcblx0XHRcdFZlYzIuZGlmZihhdG9tLnBwLCB0ZW1wbGF0ZS54eTApLnJvdGF0ZShhbmdsZSkuYWRkKHBvcylcclxuXHRcdFx0KS5wZXJmb3JtKHVpLmVkaXRvcilcclxuXHRcdCk7XHJcblxyXG5cdFx0bWFwW2FpZF0gPSBvcGVyYXRpb24uZGF0YS5haWQ7XHJcblx0fSk7XHJcblxyXG5cdGZyYWcuYm9uZHMuZWFjaChmdW5jdGlvbiAoYmlkLCBib25kKSB7XHJcblx0XHRhY3Rpb24uYWRkT3AoXHJcblx0XHRuZXcgb3AuQm9uZEFkZChcclxuXHRcdFx0bWFwW2JvbmQuYmVnaW5dLFxyXG5cdFx0XHRtYXBbYm9uZC5lbmRdLFxyXG5cdFx0XHRib25kXHJcblx0XHQpLnBlcmZvcm0odWkuZWRpdG9yKVxyXG5cdFx0KTtcclxuXHR9KTtcclxuXHJcblx0YWN0aW9uLm9wZXJhdGlvbnMucmV2ZXJzZSgpO1xyXG5cdGFjdGlvbi5hZGRPcChmcmFnQWN0aW9uKTtcclxuXHJcblx0cmV0dXJuIGFjdGlvbjtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGF0b21BZGRUb1NHcm91cHMgKHNncm91cHMsIGFpZCkge1xyXG5cdHZhciBhY3Rpb24gPSBuZXcgQWN0aW9uKCk7XHJcblx0dXRpbC5lYWNoKHNncm91cHMsIGZ1bmN0aW9uIChzaWQpe1xyXG5cdFx0YWN0aW9uLmFkZE9wKG5ldyBvcC5TR3JvdXBBdG9tQWRkKHNpZCwgYWlkKS5wZXJmb3JtKHVpLmVkaXRvcikpO1xyXG5cdH0sIHRoaXMpO1xyXG5cdHJldHVybiBhY3Rpb247XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZyb21UZW1wbGF0ZU9uQXRvbSAoYWlkLCBhbmdsZSwgZXh0cmFfYm9uZCwgdGVtcGxhdGUsIGNhbGNBbmdsZSlcclxue1xyXG5cdHZhciBhY3Rpb24gPSBuZXcgQWN0aW9uKCk7XHJcblx0dmFyIGZyYWcgPSB0ZW1wbGF0ZS5tb2xlY3VsZTtcclxuXHR2YXIgUiA9IHVpLnJlbmRlcjtcclxuXHR2YXIgUlMgPSBSLmN0YWI7XHJcblx0dmFyIG1vbGVjdWxlID0gUlMubW9sZWN1bGU7XHJcblx0dmFyIGF0b20gPSBtb2xlY3VsZS5hdG9tcy5nZXQoYWlkKTtcclxuXHR2YXIgYWlkMCA9IGFpZDsgLy8gdGhlIGF0b20gdGhhdCB3YXMgY2xpY2tlZCBvblxyXG5cdHZhciBhaWQxID0gbnVsbDsgLy8gdGhlIGF0b20gb24gdGhlIG90aGVyIGVuZCBvZiB0aGUgZXh0cmEgYm9uZCwgaWYgYW55XHJcblx0dmFyIHNncm91cHMgPSB1aS5yZW5kZXIuYXRvbUdldFNHcm91cHMoYWlkKTtcclxuXHJcblx0dmFyIGZyaWQgPSBSLmF0b21HZXRBdHRyKGFpZCwgJ2ZyYWdtZW50Jyk7XHJcblxyXG5cdHZhciBtYXAgPSB7fTtcclxuXHR2YXIgeHkwID0gZnJhZy5hdG9tcy5nZXQodGVtcGxhdGUuYWlkKS5wcDtcclxuXHJcblx0aWYgKGV4dHJhX2JvbmQpIHtcclxuXHRcdC8vIGNyZWF0ZSBleHRyYSBib25kIGFmdGVyIGNsaWNrIG9uIGF0b21cclxuXHRcdGlmIChhbmdsZSA9PSBudWxsKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgbWlkZGxlX2F0b20gPSBhdG9tRm9yTmV3Qm9uZChhaWQpO1xyXG5cdFx0XHR2YXIgYWN0aW9uX3JlcyA9IGZyb21Cb25kQWRkaXRpb24oe3R5cGU6IDF9LCBhaWQsIG1pZGRsZV9hdG9tLmF0b20sIG1pZGRsZV9hdG9tLnBvcyk7XHJcblx0XHRcdGFjdGlvbiA9IGFjdGlvbl9yZXNbMF07XHJcblx0XHRcdGFjdGlvbi5vcGVyYXRpb25zLnJldmVyc2UoKTtcclxuXHRcdFx0YWlkMSA9IGFpZCA9IGFjdGlvbl9yZXNbMl07XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgb3BlcmF0aW9uO1xyXG5cclxuXHRcdFx0YWN0aW9uLmFkZE9wKFxyXG5cdFx0XHRcdG9wZXJhdGlvbiA9IG5ldyBvcC5BdG9tQWRkKFxyXG5cdFx0XHRcdHsgbGFiZWw6ICdDJywgZnJhZ21lbnQ6IGZyaWQgfSxcclxuXHRcdFx0XHQobmV3IFZlYzIoMSwgMCkpLnJvdGF0ZShhbmdsZSkuYWRkKGF0b20ucHApXHJcblx0XHRcdFx0KS5wZXJmb3JtKHVpLmVkaXRvcilcclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdGFjdGlvbi5hZGRPcChcclxuXHRcdFx0bmV3IG9wLkJvbmRBZGQoXHJcblx0XHRcdFx0YWlkLFxyXG5cdFx0XHRcdG9wZXJhdGlvbi5kYXRhLmFpZCxcclxuXHRcdFx0eyB0eXBlOiAxIH1cclxuXHRcdFx0KS5wZXJmb3JtKHVpLmVkaXRvcilcclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdGFpZDEgPSBhaWQgPSBvcGVyYXRpb24uZGF0YS5haWQ7XHJcblx0XHRcdGFjdGlvbi5tZXJnZVdpdGgoYXRvbUFkZFRvU0dyb3VwcyhzZ3JvdXBzLCBhaWQpKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYXRvbTAgPSBhdG9tO1xyXG5cdFx0YXRvbSA9IG1vbGVjdWxlLmF0b21zLmdldChhaWQpO1xyXG5cdFx0dmFyIGRlbHRhID0gY2FsY0FuZ2xlKGF0b20wLnBwLCBhdG9tLnBwKSAtIHRlbXBsYXRlLmFuZ2xlMDtcclxuXHR9IGVsc2Uge1xyXG5cdFx0aWYgKGFuZ2xlID09IG51bGwpIHtcclxuXHRcdFx0bWlkZGxlX2F0b20gPSBhdG9tRm9yTmV3Qm9uZChhaWQpO1xyXG5cdFx0XHRhbmdsZSA9IGNhbGNBbmdsZShhdG9tLnBwLCBtaWRkbGVfYXRvbS5wb3MpO1xyXG5cdFx0fVxyXG5cdFx0ZGVsdGEgPSBhbmdsZSAtIHRlbXBsYXRlLmFuZ2xlMDtcclxuXHR9XHJcblxyXG5cdGZyYWcuYXRvbXMuZWFjaChmdW5jdGlvbiAoaWQsIGEpIHtcclxuXHRcdHZhciBhdHRycyA9IEF0b20uZ2V0QXR0ckhhc2goYSkudG9PYmplY3QoKTtcclxuXHRcdGF0dHJzLmZyYWdtZW50ID0gZnJpZDtcclxuXHRcdGlmIChpZCA9PSB0ZW1wbGF0ZS5haWQpIHtcclxuXHRcdFx0YWN0aW9uLm1lcmdlV2l0aChmcm9tQXRvbXNBdHRycyhhaWQsIGF0dHJzLCB0cnVlKSk7XHJcblx0XHRcdG1hcFtpZF0gPSBhaWQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgdjtcclxuXHJcblx0XHRcdHYgPSBWZWMyLmRpZmYoYS5wcCwgeHkwKS5yb3RhdGUoZGVsdGEpLmFkZChhdG9tLnBwKTtcclxuXHJcblx0XHRcdGFjdGlvbi5hZGRPcChcclxuXHRcdFx0XHRvcGVyYXRpb24gPSBuZXcgb3AuQXRvbUFkZChcclxuXHRcdFx0XHRcdGF0dHJzLFxyXG5cdFx0XHRcdFx0dlxyXG5cdFx0XHRcdCkucGVyZm9ybSh1aS5lZGl0b3IpXHJcblx0XHRcdCk7XHJcblx0XHRcdG1hcFtpZF0gPSBvcGVyYXRpb24uZGF0YS5haWQ7XHJcblx0XHR9XHJcblx0XHRpZiAobWFwW2lkXSAtIDAgIT09IGFpZDAgLSAwICYmIG1hcFtpZF0gLSAwICE9PSBhaWQxIC0gMClcclxuXHRcdFx0YWN0aW9uLm1lcmdlV2l0aChhdG9tQWRkVG9TR3JvdXBzKHNncm91cHMsIG1hcFtpZF0pKTtcclxuXHR9KTtcclxuXHJcblx0ZnJhZy5ib25kcy5lYWNoKGZ1bmN0aW9uIChiaWQsIGJvbmQpIHtcclxuXHRcdGFjdGlvbi5hZGRPcChcclxuXHRcdG5ldyBvcC5Cb25kQWRkKFxyXG5cdFx0XHRtYXBbYm9uZC5iZWdpbl0sXHJcblx0XHRcdG1hcFtib25kLmVuZF0sXHJcblx0XHRcdGJvbmRcclxuXHRcdCkucGVyZm9ybSh1aS5lZGl0b3IpXHJcblx0XHQpO1xyXG5cdH0pO1xyXG5cclxuXHRhY3Rpb24ub3BlcmF0aW9ucy5yZXZlcnNlKCk7XHJcblxyXG5cdHJldHVybiBhY3Rpb247XHJcbn07XHJcblxyXG5mdW5jdGlvbiBmcm9tVGVtcGxhdGVPbkJvbmQgKGJpZCwgdGVtcGxhdGUsIGNhbGNBbmdsZSwgZmxpcClcclxue1xyXG5cdHZhciBhY3Rpb24gPSBuZXcgQWN0aW9uKCk7XHJcblx0dmFyIGZyYWcgPSB0ZW1wbGF0ZS5tb2xlY3VsZTtcclxuXHR2YXIgUiA9IHVpLnJlbmRlcjtcclxuXHR2YXIgUlMgPSBSLmN0YWI7XHJcblx0dmFyIG1vbGVjdWxlID0gUlMubW9sZWN1bGU7XHJcblxyXG5cdHZhciBib25kID0gbW9sZWN1bGUuYm9uZHMuZ2V0KGJpZCk7XHJcblx0dmFyIGJlZ2luID0gbW9sZWN1bGUuYXRvbXMuZ2V0KGJvbmQuYmVnaW4pO1xyXG5cdHZhciBlbmQgPSBtb2xlY3VsZS5hdG9tcy5nZXQoYm9uZC5lbmQpO1xyXG5cdHZhciBzZ3JvdXBzID0gU2V0Lmxpc3QoU2V0LmludGVyc2VjdGlvbihcclxuXHRTZXQuZnJvbUxpc3QodWkucmVuZGVyLmF0b21HZXRTR3JvdXBzKGJvbmQuYmVnaW4pKSxcclxuXHRTZXQuZnJvbUxpc3QodWkucmVuZGVyLmF0b21HZXRTR3JvdXBzKGJvbmQuZW5kKSkpKTtcclxuXHJcblx0dmFyIGZyX2JvbmQgPSBmcmFnLmJvbmRzLmdldCh0ZW1wbGF0ZS5iaWQpO1xyXG5cdHZhciBmcl9iZWdpbjtcclxuXHR2YXIgZnJfZW5kO1xyXG5cclxuXHR2YXIgZnJpZCA9IFIuYXRvbUdldEF0dHIoYm9uZC5iZWdpbiwgJ2ZyYWdtZW50Jyk7XHJcblxyXG5cdHZhciBtYXAgPSB7fTtcclxuXHJcblx0aWYgKGZsaXApIHtcclxuXHRcdGZyX2JlZ2luID0gZnJhZy5hdG9tcy5nZXQoZnJfYm9uZC5lbmQpO1xyXG5cdFx0ZnJfZW5kID0gZnJhZy5hdG9tcy5nZXQoZnJfYm9uZC5iZWdpbik7XHJcblx0XHRtYXBbZnJfYm9uZC5lbmRdID0gYm9uZC5iZWdpbjtcclxuXHRcdG1hcFtmcl9ib25kLmJlZ2luXSA9IGJvbmQuZW5kO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRmcl9iZWdpbiA9IGZyYWcuYXRvbXMuZ2V0KGZyX2JvbmQuYmVnaW4pO1xyXG5cdFx0ZnJfZW5kID0gZnJhZy5hdG9tcy5nZXQoZnJfYm9uZC5lbmQpO1xyXG5cdFx0bWFwW2ZyX2JvbmQuYmVnaW5dID0gYm9uZC5iZWdpbjtcclxuXHRcdG1hcFtmcl9ib25kLmVuZF0gPSBib25kLmVuZDtcclxuXHR9XHJcblxyXG5cdC8vIGNhbGMgYW5nbGVcclxuXHR2YXIgYW5nbGUgPSBjYWxjQW5nbGUoYmVnaW4ucHAsIGVuZC5wcCkgLSBjYWxjQW5nbGUoZnJfYmVnaW4ucHAsIGZyX2VuZC5wcCk7XHJcblx0dmFyIHNjYWxlID0gVmVjMi5kaXN0KGJlZ2luLnBwLCBlbmQucHApIC8gVmVjMi5kaXN0KGZyX2JlZ2luLnBwLCBmcl9lbmQucHApO1xyXG5cclxuXHR2YXIgeHkwID0gZnJfYmVnaW4ucHA7XHJcblxyXG5cdGZyYWcuYXRvbXMuZWFjaChmdW5jdGlvbiAoaWQsIGEpIHtcclxuXHRcdHZhciBhdHRycyA9IEF0b20uZ2V0QXR0ckhhc2goYSkudG9PYmplY3QoKTtcclxuXHRcdGF0dHJzLmZyYWdtZW50ID0gZnJpZDtcclxuXHRcdGlmIChpZCA9PSBmcl9ib25kLmJlZ2luIHx8IGlkID09IGZyX2JvbmQuZW5kKSB7XHJcblx0XHRcdGFjdGlvbi5tZXJnZVdpdGgoZnJvbUF0b21zQXR0cnMobWFwW2lkXSwgYXR0cnMsIHRydWUpKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB2O1xyXG5cclxuXHRcdHYgPSBWZWMyLmRpZmYoYS5wcCwgZnJfYmVnaW4ucHApLnJvdGF0ZShhbmdsZSkuc2NhbGVkKHNjYWxlKS5hZGQoYmVnaW4ucHApO1xyXG5cclxuXHRcdHZhciBtZXJnZV9hID0gUi5maW5kQ2xvc2VzdEF0b20odiwgMC4xKTtcclxuXHJcblx0XHRpZiAobWVyZ2VfYSA9PSBudWxsKSB7XHJcblx0XHRcdHZhciBvcGVyYXRpb247XHJcblx0XHRcdGFjdGlvbi5hZGRPcChcclxuXHRcdFx0XHRvcGVyYXRpb24gPSBuZXcgb3AuQXRvbUFkZChcclxuXHRcdFx0XHRcdGF0dHJzLFxyXG5cdFx0XHRcdFx0dlxyXG5cdFx0XHRcdCkucGVyZm9ybSh1aS5lZGl0b3IpXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0XHRtYXBbaWRdID0gb3BlcmF0aW9uLmRhdGEuYWlkO1xyXG5cdFx0XHRhY3Rpb24ubWVyZ2VXaXRoKGF0b21BZGRUb1NHcm91cHMoc2dyb3VwcywgbWFwW2lkXSkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWFwW2lkXSA9IG1lcmdlX2EuaWQ7XHJcblx0XHRcdGFjdGlvbi5tZXJnZVdpdGgoZnJvbUF0b21zQXR0cnMobWFwW2lkXSwgYXR0cnMsIHRydWUpKTtcclxuXHRcdFx0Ly8gVE9ETyBbUkJdIG5lZWQgdG8gbWVyZ2UgZnJhZ21lbnRzP1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHRmcmFnLmJvbmRzLmVhY2goZnVuY3Rpb24gKGlkLCBib25kKSB7XHJcblx0XHR2YXIgZXhpc3RfaWQgPSBtb2xlY3VsZS5maW5kQm9uZElkKG1hcFtib25kLmJlZ2luXSwgbWFwW2JvbmQuZW5kXSk7XHJcblx0XHRpZiAoZXhpc3RfaWQgPT0gLTEpIHtcclxuXHRcdFx0YWN0aW9uLmFkZE9wKFxyXG5cdFx0XHRuZXcgb3AuQm9uZEFkZChcclxuXHRcdFx0XHRtYXBbYm9uZC5iZWdpbl0sXHJcblx0XHRcdFx0bWFwW2JvbmQuZW5kXSxcclxuXHRcdFx0XHRib25kXHJcblx0XHRcdCkucGVyZm9ybSh1aS5lZGl0b3IpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGFjdGlvbi5tZXJnZVdpdGgoZnJvbUJvbmRBdHRycyhleGlzdF9pZCwgZnJfYm9uZCwgZmFsc2UsIHRydWUpKTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0YWN0aW9uLm9wZXJhdGlvbnMucmV2ZXJzZSgpO1xyXG5cclxuXHRyZXR1cm4gYWN0aW9uO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmcm9tQ2hhaW4gKHAwLCB2LCBuU2VjdCwgYXRvbV9pZClcclxue1xyXG5cdHZhciBhbmdsZSA9IE1hdGguUEkgLyA2O1xyXG5cdHZhciBkeCA9IE1hdGguY29zKGFuZ2xlKSwgZHkgPSBNYXRoLnNpbihhbmdsZSk7XHJcblxyXG5cdHZhciBhY3Rpb24gPSBuZXcgQWN0aW9uKCk7XHJcblxyXG5cdHZhciBmcmlkO1xyXG5cdGlmIChhdG9tX2lkICE9IG51bGwpIHtcclxuXHRcdGZyaWQgPSB1aS5yZW5kZXIuYXRvbUdldEF0dHIoYXRvbV9pZCwgJ2ZyYWdtZW50Jyk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGZyaWQgPSBhY3Rpb24uYWRkT3AobmV3IG9wLkZyYWdtZW50QWRkKCkucGVyZm9ybSh1aS5lZGl0b3IpKS5mcmlkO1xyXG5cdH1cclxuXHJcblx0dmFyIGlkMCA9IC0xO1xyXG5cdGlmIChhdG9tX2lkICE9IG51bGwpIHtcclxuXHRcdGlkMCA9IGF0b21faWQ7XHJcblx0fSBlbHNlIHtcclxuXHRcdGlkMCA9IGFjdGlvbi5hZGRPcChuZXcgb3AuQXRvbUFkZCh7bGFiZWw6ICdDJywgZnJhZ21lbnQ6IGZyaWR9LCBwMCkucGVyZm9ybSh1aS5lZGl0b3IpKS5kYXRhLmFpZDtcclxuXHR9XHJcblxyXG5cdGFjdGlvbi5vcGVyYXRpb25zLnJldmVyc2UoKTtcclxuXHJcblx0blNlY3QudGltZXMoZnVuY3Rpb24gKGkpIHtcclxuXHRcdHZhciBwb3MgPSBuZXcgVmVjMihkeCAqIChpICsgMSksIGkgJiAxID8gMCA6IGR5KS5yb3RhdGUodikuYWRkKHAwKTtcclxuXHJcblx0XHR2YXIgYSA9IHVpLnJlbmRlci5maW5kQ2xvc2VzdEF0b20ocG9zLCAwLjEpO1xyXG5cclxuXHRcdHZhciByZXQgPSBmcm9tQm9uZEFkZGl0aW9uKHt9LCBpZDAsIGEgPyBhLmlkIDoge30sIHBvcyk7XHJcblx0XHRhY3Rpb24gPSByZXRbMF0ubWVyZ2VXaXRoKGFjdGlvbik7XHJcblx0XHRpZDAgPSByZXRbMl07XHJcblx0fSwgdGhpcyk7XHJcblxyXG5cdHJldHVybiBhY3Rpb247XHJcbn07XHJcblxyXG5mdW5jdGlvbiBmcm9tTmV3Q2FudmFzIChjdGFiKVxyXG57XHJcblx0dmFyIGFjdGlvbiA9IG5ldyBBY3Rpb24oKTtcclxuXHJcblx0YWN0aW9uLmFkZE9wKG5ldyBvcC5DYW52YXNMb2FkKGN0YWIpKTtcclxuXHRyZXR1cm4gYWN0aW9uLnBlcmZvcm0oKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGZyb21TZ3JvdXBUeXBlIChpZCwgdHlwZSlcclxue1xyXG5cdHZhciBSID0gdWkucmVuZGVyO1xyXG5cdHZhciBjdXJfdHlwZSA9IFIuc0dyb3VwR2V0VHlwZShpZCk7XHJcblx0aWYgKHR5cGUgJiYgdHlwZSAhPSBjdXJfdHlwZSkge1xyXG5cdFx0dmFyIGF0b21zID0gdXRpbC5hcnJheShSLnNHcm91cEdldEF0b21zKGlkKSk7XHJcblx0XHR2YXIgYXR0cnMgPSBSLnNHcm91cEdldEF0dHJzKGlkKTtcclxuXHRcdHZhciBhY3Rpb25EZWxldGlvbiA9IGZyb21TZ3JvdXBEZWxldGlvbihpZCk7IC8vIFtNS10gb3JkZXIgb2YgZXhlY3V0aW9uIGlzIGltcG9ydGFudCwgZmlyc3QgZGVsZXRlIHRoZW4gcmVjcmVhdGVcclxuXHRcdHZhciBhY3Rpb25BZGRpdGlvbiA9IGZyb21TZ3JvdXBBZGRpdGlvbih0eXBlLCBhdG9tcywgYXR0cnMsIGlkKTtcclxuXHRcdHJldHVybiBhY3Rpb25BZGRpdGlvbi5tZXJnZVdpdGgoYWN0aW9uRGVsZXRpb24pOyAvLyB0aGUgYWN0aW9ucyBhcmUgYWxyZWFkeSBwZXJmb3JtZWQgYW5kIHJldmVyc2VkLCBzbyB3ZSBtZXJnZSB0aGVtIGJhY2t3YXJkc1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IEFjdGlvbigpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gZnJvbVNncm91cEF0dHJzIChpZCwgYXR0cnMpXHJcbntcclxuXHR2YXIgYWN0aW9uID0gbmV3IEFjdGlvbigpO1xyXG5cdHZhciBSID0gdWkucmVuZGVyO1xyXG5cdHZhciBSUyA9IFIuY3RhYjtcclxuXHR2YXIgc2cgPSBSUy5zZ3JvdXBzLmdldChpZCkuaXRlbTtcclxuXHJcblx0bmV3IEhhc2goYXR0cnMpLmVhY2goZnVuY3Rpb24gKGF0dHIpIHtcclxuXHRcdGFjdGlvbi5hZGRPcChuZXcgb3AuU0dyb3VwQXR0cihpZCwgYXR0ci5rZXksIGF0dHIudmFsdWUpKTtcclxuXHR9LCB0aGlzKTtcclxuXHJcblx0cmV0dXJuIGFjdGlvbi5wZXJmb3JtKCk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBzR3JvdXBBdHRyaWJ1dGVBY3Rpb24gKGlkLCBhdHRycylcclxue1xyXG5cdHZhciBhY3Rpb24gPSBuZXcgQWN0aW9uKCk7XHJcblxyXG5cdG5ldyBIYXNoKGF0dHJzKS5lYWNoKGZ1bmN0aW9uIChhdHRyKSB7IC8vIHN0b3JlIHRoZSBhdHRyaWJ1dGUgYXNzaWdubWVudFxyXG5cdFx0YWN0aW9uLmFkZE9wKG5ldyBvcC5TR3JvdXBBdHRyKGlkLCBhdHRyLmtleSwgYXR0ci52YWx1ZSkpO1xyXG5cdH0sIHRoaXMpO1xyXG5cclxuXHRyZXR1cm4gYWN0aW9uO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gZnJvbVNncm91cERlbGV0aW9uIChpZClcclxue1xyXG5cdHZhciBhY3Rpb24gPSBuZXcgQWN0aW9uKCk7XHJcblx0dmFyIFIgPSB1aS5yZW5kZXI7XHJcblx0dmFyIFJTID0gUi5jdGFiO1xyXG5cdHZhciBEUyA9IFJTLm1vbGVjdWxlO1xyXG5cclxuXHRpZiAodWkucmVuZGVyLnNHcm91cEdldFR5cGUoaWQpID09ICdTUlUnKSB7XHJcblx0XHR1aS5yZW5kZXIuc0dyb3Vwc0ZpbmRDcm9zc0JvbmRzKCk7XHJcblx0XHR2YXIgbmVpX2F0b21zID0gdWkucmVuZGVyLnNHcm91cEdldE5laWdoYm9yQXRvbXMoaWQpO1xyXG5cclxuXHRcdG5laV9hdG9tcy5lYWNoKGZ1bmN0aW9uIChhaWQpIHtcclxuXHRcdFx0aWYgKHVpLnJlbmRlci5hdG9tR2V0QXR0cihhaWQsICdsYWJlbCcpID09ICcqJykge1xyXG5cdFx0XHRcdGFjdGlvbi5hZGRPcChuZXcgb3AuQXRvbUF0dHIoYWlkLCAnbGFiZWwnLCAnQycpKTtcclxuXHRcdFx0fVxyXG5cdFx0fSwgdGhpcyk7XHJcblx0fVxyXG5cclxuXHR2YXIgc2cgPSBEUy5zZ3JvdXBzLmdldChpZCk7XHJcblx0dmFyIGF0b21zID0gU0dyb3VwLmdldEF0b21zKERTLCBzZyk7XHJcblx0dmFyIGF0dHJzID0gc2cuZ2V0QXR0cnMoKTtcclxuXHRhY3Rpb24uYWRkT3AobmV3IG9wLlNHcm91cFJlbW92ZUZyb21IaWVyYXJjaHkoaWQpKTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGF0b21zLmxlbmd0aDsgKytpKSB7XHJcblx0XHRhY3Rpb24uYWRkT3AobmV3IG9wLlNHcm91cEF0b21SZW1vdmUoaWQsIGF0b21zW2ldKSk7XHJcblx0fVxyXG5cdGFjdGlvbi5hZGRPcChuZXcgb3AuU0dyb3VwRGVsZXRlKGlkKSk7XHJcblxyXG5cdGFjdGlvbiA9IGFjdGlvbi5wZXJmb3JtKCk7XHJcblxyXG5cdGFjdGlvbi5tZXJnZVdpdGgoc0dyb3VwQXR0cmlidXRlQWN0aW9uKGlkLCBhdHRycykpO1xyXG5cclxuXHRyZXR1cm4gYWN0aW9uO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gZnJvbVNncm91cEFkZGl0aW9uICh0eXBlLCBhdG9tcywgYXR0cnMsIHNnaWQsIHBwKVxyXG57XHJcblx0dmFyIGFjdGlvbiA9IG5ldyBBY3Rpb24oKTtcclxuXHR2YXIgaTtcclxuXHJcblx0Ly8gVE9ETzogc2hvdWQgdGhlIGlkIGJlIGdlbmVyYXRlZCB3aGVuIE9wU0dyb3VwQ3JlYXRlIGlzIGV4ZWN1dGVkP1xyXG5cdC8vICAgICAgaWYgeWVzLCBob3cgdG8gcGFzcyBpdCB0byB0aGUgZm9sbG93aW5nIG9wZXJhdGlvbnM/XHJcblx0c2dpZCA9IHNnaWQgLSAwID09PSBzZ2lkID8gc2dpZCA6IHVpLnJlbmRlci5jdGFiLm1vbGVjdWxlLnNncm91cHMubmV3SWQoKTtcclxuXHJcblx0YWN0aW9uLmFkZE9wKG5ldyBvcC5TR3JvdXBDcmVhdGUoc2dpZCwgdHlwZSwgcHApKTtcclxuXHRmb3IgKGkgPSAwOyBpIDwgYXRvbXMubGVuZ3RoOyBpKyspXHJcblx0XHRhY3Rpb24uYWRkT3AobmV3IG9wLlNHcm91cEF0b21BZGQoc2dpZCwgYXRvbXNbaV0pKTtcclxuXHRhY3Rpb24uYWRkT3AobmV3IG9wLlNHcm91cEFkZFRvSGllcmFyY2h5KHNnaWQpKTtcclxuXHJcblx0YWN0aW9uID0gYWN0aW9uLnBlcmZvcm0oKTtcclxuXHJcblx0aWYgKHR5cGUgPT0gJ1NSVScpIHtcclxuXHRcdHVpLnJlbmRlci5zR3JvdXBzRmluZENyb3NzQm9uZHMoKTtcclxuXHRcdHZhciBhc3Rlcmlza19hY3Rpb24gPSBuZXcgQWN0aW9uKCk7XHJcblx0XHR1aS5yZW5kZXIuc0dyb3VwR2V0TmVpZ2hib3JBdG9tcyhzZ2lkKS5lYWNoKGZ1bmN0aW9uIChhaWQpIHtcclxuXHRcdFx0aWYgKHVpLnJlbmRlci5hdG9tR2V0RGVncmVlKGFpZCkgPT0gMSAmJiB1aS5yZW5kZXIuYXRvbUlzUGxhaW5DYXJib24oYWlkKSkge1xyXG5cdFx0XHRcdGFzdGVyaXNrX2FjdGlvbi5hZGRPcChuZXcgb3AuQXRvbUF0dHIoYWlkLCAnbGFiZWwnLCAnKicpKTtcclxuXHRcdFx0fVxyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0YXN0ZXJpc2tfYWN0aW9uID0gYXN0ZXJpc2tfYWN0aW9uLnBlcmZvcm0oKTtcclxuXHRcdGFzdGVyaXNrX2FjdGlvbi5tZXJnZVdpdGgoYWN0aW9uKTtcclxuXHRcdGFjdGlvbiA9IGFzdGVyaXNrX2FjdGlvbjtcclxuXHR9XHJcblxyXG5cdHJldHVybiBmcm9tU2dyb3VwQXR0cnMoc2dpZCwgYXR0cnMpLm1lcmdlV2l0aChhY3Rpb24pO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gZnJvbVJHcm91cEF0dHJzIChpZCwgYXR0cnMpIHtcclxuXHR2YXIgYWN0aW9uID0gbmV3IEFjdGlvbigpO1xyXG5cdG5ldyBIYXNoKGF0dHJzKS5lYWNoKGZ1bmN0aW9uIChhdHRyKSB7XHJcblx0XHRhY3Rpb24uYWRkT3AobmV3IG9wLlJHcm91cEF0dHIoaWQsIGF0dHIua2V5LCBhdHRyLnZhbHVlKSk7XHJcblx0fSwgdGhpcyk7XHJcblx0cmV0dXJuIGFjdGlvbi5wZXJmb3JtKCk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBmcm9tUkdyb3VwRnJhZ21lbnQgKHJnaWROZXcsIGZyaWQpIHtcclxuXHR2YXIgYWN0aW9uID0gbmV3IEFjdGlvbigpO1xyXG5cdGFjdGlvbi5hZGRPcChuZXcgb3AuUkdyb3VwRnJhZ21lbnQocmdpZE5ldywgZnJpZCkpO1xyXG5cdHJldHVybiBhY3Rpb24ucGVyZm9ybSgpO1xyXG59O1xyXG5cclxuLy8gU2hvdWxkIGl0IGJlIG5hbWVkIHN0cnVjdENlbnRlcj9cclxuZnVuY3Rpb24gZ2V0QW5jaG9yUG9zaXRpb24oY2xpcGJvYXJkKSB7XHJcblx0aWYgKGNsaXBib2FyZC5hdG9tcy5sZW5ndGgpIHtcclxuXHRcdHZhciB4bWluID0gMWU1MCwgeW1pbiA9IHhtaW4sIHhtYXggPSAteG1pbiwgeW1heCA9IC15bWluO1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwYm9hcmQuYXRvbXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0eG1pbiA9IE1hdGgubWluKHhtaW4sIGNsaXBib2FyZC5hdG9tc1tpXS5wcC54KTtcclxuXHRcdFx0eW1pbiA9IE1hdGgubWluKHltaW4sIGNsaXBib2FyZC5hdG9tc1tpXS5wcC55KTtcclxuXHRcdFx0eG1heCA9IE1hdGgubWF4KHhtYXgsIGNsaXBib2FyZC5hdG9tc1tpXS5wcC54KTtcclxuXHRcdFx0eW1heCA9IE1hdGgubWF4KHltYXgsIGNsaXBib2FyZC5hdG9tc1tpXS5wcC55KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgVmVjMigoeG1pbiArIHhtYXgpIC8gMiwgKHltaW4gKyB5bWF4KSAvIDIpOyAvLyBUT0RPOiBjaGVja1xyXG5cdH0gZWxzZSBpZiAoY2xpcGJvYXJkLnJ4bkFycm93cy5sZW5ndGgpIHtcclxuXHRcdHJldHVybiBjbGlwYm9hcmQucnhuQXJyb3dzWzBdLnBwO1xyXG5cdH0gZWxzZSBpZiAoY2xpcGJvYXJkLnJ4blBsdXNlcy5sZW5ndGgpIHtcclxuXHRcdHJldHVybiBjbGlwYm9hcmQucnhuUGx1c2VzWzBdLnBwO1xyXG5cdH0gZWxzZSBpZiAoY2xpcGJvYXJkLmNoaXJhbEZsYWdzLmxlbmd0aCkge1xyXG5cdFx0cmV0dXJuIGNsaXBib2FyZC5jaGlyYWxGbGFnc1swXS5wcDtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG59XHJcblxyXG4vLyBUT0RPOiBtZXJnZSB0byBiZWxsb3dcclxuZnVuY3Rpb24gc3RydWN0MkNsaXBib2FyZChzdHJ1Y3QpIHtcclxuXHRjb25zb2xlLmFzc2VydCghc3RydWN0LmlzQmxhbmsoKSwgJ0VtcHR5IHN0cnVjdCcpO1xyXG5cclxuXHR2YXIgc2VsZWN0aW9uID0ge1xyXG5cdFx0YXRvbXM6IHN0cnVjdC5hdG9tcy5rZXlzKCksXHJcblx0XHRib25kczogc3RydWN0LmJvbmRzLmtleXMoKSxcclxuXHRcdHJ4bkFycm93czogc3RydWN0LnJ4bkFycm93cy5rZXlzKCksXHJcblx0XHRyeG5QbHVzZXM6IHN0cnVjdC5yeG5QbHVzZXMua2V5cygpXHJcblx0fTtcclxuXHJcblx0dmFyIGNsaXBib2FyZCA9IHtcclxuXHRcdGF0b21zOiBbXSxcclxuXHRcdGJvbmRzOiBbXSxcclxuXHRcdHNncm91cHM6IFtdLFxyXG5cdFx0cnhuQXJyb3dzOiBbXSxcclxuXHRcdHJ4blBsdXNlczogW10sXHJcblx0XHRjaGlyYWxGbGFnczogW10sXHJcblx0XHRyZ21hcDoge30sXHJcblx0XHRyZ3JvdXBzOiB7fVxyXG5cdH07XHJcblxyXG5cdHZhciBtYXBwaW5nID0ge307XHJcblx0c2VsZWN0aW9uLmF0b21zLmVhY2goZnVuY3Rpb24gKGlkKVxyXG5cdHtcclxuXHRcdHZhciBuZXdfYXRvbSA9IG5ldyBBdG9tKHN0cnVjdC5hdG9tcy5nZXQoaWQpKTtcclxuXHRcdG5ld19hdG9tLnBvcyA9IG5ld19hdG9tLnBwO1xyXG5cdFx0bWFwcGluZ1tpZF0gPSBjbGlwYm9hcmQuYXRvbXMucHVzaChuZXcgQXRvbShuZXdfYXRvbSkpIC0gMTtcclxuXHR9KTtcclxuXHJcblx0c2VsZWN0aW9uLmJvbmRzLmVhY2goZnVuY3Rpb24gKGlkKVxyXG5cdHtcclxuXHRcdHZhciBuZXdfYm9uZCA9IG5ldyBCb25kKHN0cnVjdC5ib25kcy5nZXQoaWQpKTtcclxuXHRcdG5ld19ib25kLmJlZ2luID0gbWFwcGluZ1tuZXdfYm9uZC5iZWdpbl07XHJcblx0XHRuZXdfYm9uZC5lbmQgPSBtYXBwaW5nW25ld19ib25kLmVuZF07XHJcblx0XHRjbGlwYm9hcmQuYm9uZHMucHVzaChuZXcgQm9uZChuZXdfYm9uZCkpO1xyXG5cdH0pO1xyXG5cclxuXHR2YXIgc2dyb3VwX2xpc3QgPSBzdHJ1Y3QuZ2V0U0dyb3Vwc0luQXRvbVNldChzZWxlY3Rpb24uYXRvbXMpO1xyXG5cclxuXHR1dGlsLmVhY2goc2dyb3VwX2xpc3QsIGZ1bmN0aW9uIChzaWQpe1xyXG5cdFx0dmFyIHNncm91cCA9IHN0cnVjdC5zZ3JvdXBzLmdldChzaWQpO1xyXG5cdFx0dmFyIHNnQXRvbXMgPSBTR3JvdXAuZ2V0QXRvbXMoc3RydWN0LCBzZ3JvdXApO1xyXG5cdFx0dmFyIHNncm91cF9pbmZvID0ge1xyXG5cdFx0XHR0eXBlOiBzZ3JvdXAudHlwZSxcclxuXHRcdFx0YXR0cnM6IHNncm91cC5nZXRBdHRycygpLFxyXG5cdFx0XHRhdG9tczogdXRpbC5hcnJheShzZ0F0b21zKSxcclxuXHRcdFx0cHA6IHNncm91cC5wcFxyXG5cdFx0fTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHNncm91cF9pbmZvLmF0b21zLmxlbmd0aDsgaSsrKVxyXG5cdFx0XHRzZ3JvdXBfaW5mby5hdG9tc1tpXSA9IG1hcHBpbmdbc2dyb3VwX2luZm8uYXRvbXNbaV1dO1xyXG5cclxuXHRcdGNsaXBib2FyZC5zZ3JvdXBzLnB1c2goc2dyb3VwX2luZm8pO1xyXG5cdH0sIHRoaXMpO1xyXG5cclxuXHRzZWxlY3Rpb24ucnhuQXJyb3dzLmVhY2goZnVuY3Rpb24gKGlkKVxyXG5cdHtcclxuXHRcdHZhciBhcnJvdyA9IG5ldyBTdHJ1Y3QuUnhuQXJyb3coc3RydWN0LnJ4bkFycm93cy5nZXQoaWQpKTtcclxuXHRcdGFycm93LnBvcyA9IGFycm93LnBwO1xyXG5cdFx0Y2xpcGJvYXJkLnJ4bkFycm93cy5wdXNoKGFycm93KTtcclxuXHR9KTtcclxuXHJcblx0c2VsZWN0aW9uLnJ4blBsdXNlcy5lYWNoKGZ1bmN0aW9uIChpZClcclxuXHR7XHJcblx0XHR2YXIgcGx1cyA9IG5ldyBTdHJ1Y3QuUnhuUGx1cyhzdHJ1Y3QucnhuUGx1c2VzLmdldChpZCkpO1xyXG5cdFx0cGx1cy5wb3MgPSBwbHVzLnBwO1xyXG5cdFx0Y2xpcGJvYXJkLnJ4blBsdXNlcy5wdXNoKHBsdXMpO1xyXG5cdH0pO1xyXG5cclxuXHQvLyByLWdyb3Vwc1xyXG5cdHZhciBhdG9tRnJhZ21lbnRzID0ge307XHJcblx0dmFyIGZyYWdtZW50cyA9IFNldC5lbXB0eSgpO1xyXG5cdHNlbGVjdGlvbi5hdG9tcy5lYWNoKGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0dmFyIGF0b20gPSBzdHJ1Y3QuYXRvbXMuZ2V0KGlkKTtcclxuXHRcdHZhciBmcmFnID0gYXRvbS5mcmFnbWVudDtcclxuXHRcdGF0b21GcmFnbWVudHNbaWRdID0gZnJhZztcclxuXHRcdFNldC5hZGQoZnJhZ21lbnRzLCBmcmFnKTtcclxuXHR9KTtcclxuXHJcblx0dmFyIHJnaWRzID0gU2V0LmVtcHR5KCk7XHJcblx0U2V0LmVhY2goZnJhZ21lbnRzLCBmdW5jdGlvbiAoZnJpZCl7XHJcblx0XHR2YXIgYXRvbXMgPSBTdHJ1Y3QuRnJhZ21lbnQuZ2V0QXRvbXMoc3RydWN0LCBmcmlkKTtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXRvbXMubGVuZ3RoOyArK2kpXHJcblx0XHRcdGlmICghU2V0LmNvbnRhaW5zKGF0b21GcmFnbWVudHMsIGF0b21zW2ldKSlcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHR2YXIgcmdpZCA9IFN0cnVjdC5SR3JvdXAuZmluZFJHcm91cEJ5RnJhZ21lbnQoc3RydWN0LnJncm91cHMsIGZyaWQpO1xyXG5cdFx0Y2xpcGJvYXJkLnJnbWFwW2ZyaWRdID0gcmdpZDtcclxuXHRcdFNldC5hZGQocmdpZHMsIHJnaWQpO1xyXG5cdH0sIHRoaXMpO1xyXG5cclxuXHRTZXQuZWFjaChyZ2lkcywgZnVuY3Rpb24gKGlkKXtcclxuXHRcdGNsaXBib2FyZC5yZ3JvdXBzW2lkXSA9IHN0cnVjdC5yZ3JvdXBzLmdldChpZCkuZ2V0QXR0cnMoKTtcclxuXHR9LCB0aGlzKTtcclxuXHJcblx0cmV0dXJuIGNsaXBib2FyZDtcclxufVxyXG5cclxuZnVuY3Rpb24gZnJvbVBhc3RlIChzdHJ1Y3QsIHBvaW50KSB7XHJcblx0dmFyIGNsaXBib2FyZCA9IHN0cnVjdDJDbGlwYm9hcmQoc3RydWN0KTtcclxuXHR2YXIgb2Zmc2V0ID0gcG9pbnQgPyBWZWMyLmRpZmYocG9pbnQsIGdldEFuY2hvclBvc2l0aW9uKGNsaXBib2FyZCkpIDogbmV3IFZlYzIoKTtcclxuXHR2YXIgYWN0aW9uID0gbmV3IEFjdGlvbigpLCBhbWFwID0ge30sIGZtYXAgPSB7fTtcclxuXHQvLyBhdG9tc1xyXG5cdGZvciAodmFyIGFpZCA9IDA7IGFpZCA8IGNsaXBib2FyZC5hdG9tcy5sZW5ndGg7IGFpZCsrKSB7XHJcblx0XHR2YXIgYXRvbSA9IE9iamVjdC5jbG9uZShjbGlwYm9hcmQuYXRvbXNbYWlkXSk7XHJcblx0XHRpZiAoIShhdG9tLmZyYWdtZW50IGluIGZtYXApKSB7XHJcblx0XHRcdGZtYXBbYXRvbS5mcmFnbWVudF0gPSBhY3Rpb24uYWRkT3AobmV3IG9wLkZyYWdtZW50QWRkKCkucGVyZm9ybSh1aS5lZGl0b3IpKS5mcmlkO1xyXG5cdFx0fVxyXG5cdFx0YXRvbS5mcmFnbWVudCA9IGZtYXBbYXRvbS5mcmFnbWVudF07XHJcblx0XHRhbWFwW2FpZF0gPSBhY3Rpb24uYWRkT3AobmV3IG9wLkF0b21BZGQoYXRvbSwgYXRvbS5wcC5hZGQob2Zmc2V0KSkucGVyZm9ybSh1aS5lZGl0b3IpKS5kYXRhLmFpZDtcclxuXHR9XHJcblxyXG5cdHZhciByZ25ldyA9IFtdO1xyXG5cdGZvciAodmFyIHJnaWQgaW4gY2xpcGJvYXJkLnJncm91cHMpIHtcclxuXHRcdGlmICghdWkuY3RhYi5yZ3JvdXBzLmhhcyhyZ2lkKSkge1xyXG5cdFx0XHRyZ25ldy5wdXNoKHJnaWQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gYXNzaWduIGZyYWdtZW50cyB0byByLWdyb3Vwc1xyXG5cdGZvciAodmFyIGZyaWQgaW4gY2xpcGJvYXJkLnJnbWFwKSB7XHJcblx0XHRhY3Rpb24uYWRkT3AobmV3IG9wLlJHcm91cEZyYWdtZW50KGNsaXBib2FyZC5yZ21hcFtmcmlkXSwgZm1hcFtmcmlkXSkucGVyZm9ybSh1aS5lZGl0b3IpKTtcclxuXHR9XHJcblxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcmduZXcubGVuZ3RoOyArK2kpIHtcclxuXHRcdGFjdGlvbi5tZXJnZVdpdGgoZnJvbVJHcm91cEF0dHJzKHJnbmV3W2ldLCBjbGlwYm9hcmQucmdyb3Vwc1tyZ25ld1tpXV0pKTtcclxuXHR9XHJcblxyXG5cdC8vYm9uZHNcclxuXHRmb3IgKHZhciBiaWQgPSAwOyBiaWQgPCBjbGlwYm9hcmQuYm9uZHMubGVuZ3RoOyBiaWQrKykge1xyXG5cdFx0dmFyIGJvbmQgPSBPYmplY3QuY2xvbmUoY2xpcGJvYXJkLmJvbmRzW2JpZF0pO1xyXG5cdFx0YWN0aW9uLmFkZE9wKG5ldyBvcC5Cb25kQWRkKGFtYXBbYm9uZC5iZWdpbl0sIGFtYXBbYm9uZC5lbmRdLCBib25kKS5wZXJmb3JtKHVpLmVkaXRvcikpO1xyXG5cdH1cclxuXHQvL3Nncm91cHNcclxuXHRmb3IgKHZhciBzZ2lkID0gMDsgc2dpZCA8IGNsaXBib2FyZC5zZ3JvdXBzLmxlbmd0aDsgc2dpZCsrKSB7XHJcblx0XHR2YXIgc2dyb3VwX2luZm8gPSBjbGlwYm9hcmQuc2dyb3Vwc1tzZ2lkXTtcclxuXHRcdHZhciBhdG9tcyA9IHNncm91cF9pbmZvLmF0b21zO1xyXG5cdFx0dmFyIHNnYXRvbXMgPSBbXTtcclxuXHRcdGZvciAodmFyIHNnYWlkID0gMDsgc2dhaWQgPCBhdG9tcy5sZW5ndGg7IHNnYWlkKyspIHtcclxuXHRcdFx0c2dhdG9tcy5wdXNoKGFtYXBbYXRvbXNbc2dhaWRdXSk7XHJcblx0XHR9XHJcblx0XHR2YXIgbmV3c2dpZCA9IHVpLnJlbmRlci5jdGFiLm1vbGVjdWxlLnNncm91cHMubmV3SWQoKTtcclxuXHRcdHZhciBzZ2FjdGlvbiA9IGZyb21TZ3JvdXBBZGRpdGlvbihzZ3JvdXBfaW5mby50eXBlLCBzZ2F0b21zLCBzZ3JvdXBfaW5mby5hdHRycywgbmV3c2dpZCwgc2dyb3VwX2luZm8ucHAgPyBzZ3JvdXBfaW5mby5wcC5hZGQob2Zmc2V0KSA6IG51bGwpO1xyXG5cdFx0Zm9yICh2YXIgaW9wID0gc2dhY3Rpb24ub3BlcmF0aW9ucy5sZW5ndGggLSAxOyBpb3AgPj0gMDsgaW9wLS0pIHtcclxuXHRcdFx0YWN0aW9uLmFkZE9wKHNnYWN0aW9uLm9wZXJhdGlvbnNbaW9wXSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdC8vcmVhY3Rpb24gYXJyb3dzXHJcblx0aWYgKHVpLmVkaXRvci5yZW5kZXIuY3RhYi5yeG5BcnJvd3MuY291bnQoKSA8IDEpIHtcclxuXHRcdGZvciAodmFyIHJhaWQgPSAwOyByYWlkIDwgY2xpcGJvYXJkLnJ4bkFycm93cy5sZW5ndGg7IHJhaWQrKykge1xyXG5cdFx0XHRhY3Rpb24uYWRkT3AobmV3IG9wLlJ4bkFycm93QWRkKGNsaXBib2FyZC5yeG5BcnJvd3NbcmFpZF0ucHAuYWRkKG9mZnNldCkpLnBlcmZvcm0odWkuZWRpdG9yKSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdC8vcmVhY3Rpb24gcGx1c2VzXHJcblx0Zm9yICh2YXIgcnBpZCA9IDA7IHJwaWQgPCBjbGlwYm9hcmQucnhuUGx1c2VzLmxlbmd0aDsgcnBpZCsrKSB7XHJcblx0XHRhY3Rpb24uYWRkT3AobmV3IG9wLlJ4blBsdXNBZGQoY2xpcGJvYXJkLnJ4blBsdXNlc1tycGlkXS5wcC5hZGQob2Zmc2V0KSkucGVyZm9ybSh1aS5lZGl0b3IpKTtcclxuXHR9XHJcblx0Ly90aGF0cyBhbGxcclxuXHRhY3Rpb24ub3BlcmF0aW9ucy5yZXZlcnNlKCk7XHJcblx0cmV0dXJuIGFjdGlvbjtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGZyb21GbGlwIChvYmplY3RzLCBmbGlwKSB7XHJcblx0dmFyIHJlbmRlciA9IHVpLnJlbmRlcjtcclxuXHR2YXIgY3RhYiA9IHJlbmRlci5jdGFiO1xyXG5cdHZhciBtb2xlY3VsZSA9IGN0YWIubW9sZWN1bGU7XHJcblxyXG5cdHZhciBhY3Rpb24gPSBuZXcgQWN0aW9uKCk7XHJcblx0dmFyIGk7XHJcblx0dmFyIGZpZHMgPSB7fTtcclxuXHJcblx0aWYgKG9iamVjdHMuYXRvbXMpIHtcclxuXHRcdGZvciAoaSA9IDA7IGkgPCBvYmplY3RzLmF0b21zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBhaWQgPSBvYmplY3RzLmF0b21zW2ldO1xyXG5cdFx0XHR2YXIgYXRvbSA9IG1vbGVjdWxlLmF0b21zLmdldChhaWQpO1xyXG5cdFx0XHRpZiAoIShhdG9tLmZyYWdtZW50IGluIGZpZHMpKSB7XHJcblx0XHRcdFx0Zmlkc1thdG9tLmZyYWdtZW50XSA9IFthaWRdO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGZpZHNbYXRvbS5mcmFnbWVudF0ucHVzaChhaWQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0ZmlkcyA9IG5ldyBIYXNoKGZpZHMpO1xyXG5cclxuXHRcdGlmIChmaWRzLmRldGVjdChmdW5jdGlvbiAoZnJhZykge1xyXG5cdFx0XHRyZXR1cm4gIVNldC5lcShtb2xlY3VsZS5nZXRGcmFnbWVudElkcyhmcmFnWzBdKSwgU2V0LmZyb21MaXN0KGZyYWdbMV0pKTtcclxuXHRcdH0pKSB7XHJcblx0XHRcdHJldHVybiBhY3Rpb247IC8vIGVtcHR5IGFjdGlvblxyXG5cdFx0fVxyXG5cclxuXHRcdGZpZHMuZWFjaChmdW5jdGlvbiAoZnJhZykge1xyXG5cdFx0XHR2YXIgZnJhZ21lbnQgPSBTZXQuZnJvbUxpc3QoZnJhZ1sxXSk7XHJcblx0XHRcdC8vdmFyIHgxID0gMTAwNTAwLCB4MiA9IC0xMDA1MDAsIHkxID0gMTAwNTAwLCB5MiA9IC0xMDA1MDA7XHJcblx0XHRcdHZhciBiYm94ID0gbW9sZWN1bGUuZ2V0Q29vcmRCb3VuZGluZ0JveChmcmFnbWVudCk7XHJcblxyXG5cdFx0XHRTZXQuZWFjaChmcmFnbWVudCwgZnVuY3Rpb24gKGFpZCkge1xyXG5cdFx0XHRcdHZhciBhdG9tID0gbW9sZWN1bGUuYXRvbXMuZ2V0KGFpZCk7XHJcblx0XHRcdFx0dmFyIGQgPSBuZXcgVmVjMigpO1xyXG5cclxuXHRcdFx0XHRpZiAoZmxpcCA9PSAnaG9yaXpvbnRhbCcpIHtcclxuXHRcdFx0XHRcdGQueCA9IGJib3gubWluLnggKyBiYm94Lm1heC54IC0gMiAqIGF0b20ucHAueDtcclxuXHRcdFx0XHR9IGVsc2UgeyAvLyAndmVydGljYWwnXHJcblx0XHRcdFx0XHRkLnkgPSBiYm94Lm1pbi55ICsgYmJveC5tYXgueSAtIDIgKiBhdG9tLnBwLnk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRhY3Rpb24uYWRkT3AobmV3IG9wLkF0b21Nb3ZlKGFpZCwgZCkpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmIChvYmplY3RzLmJvbmRzKSB7XHJcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBvYmplY3RzLmJvbmRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0dmFyIGJpZCA9IG9iamVjdHMuYm9uZHNbaV07XHJcblx0XHRcdFx0dmFyIGJvbmQgPSBtb2xlY3VsZS5ib25kcy5nZXQoYmlkKTtcclxuXHJcblx0XHRcdFx0aWYgKGJvbmQudHlwZSA9PSBCb25kLlBBVFRFUk4uVFlQRS5TSU5HTEUpIHtcclxuXHRcdFx0XHRcdGlmIChib25kLnN0ZXJlbyA9PSBCb25kLlBBVFRFUk4uU1RFUkVPLlVQKSB7XHJcblx0XHRcdFx0XHRcdGFjdGlvbi5hZGRPcChuZXcgb3AuQm9uZEF0dHIoYmlkLCAnc3RlcmVvJywgQm9uZC5QQVRURVJOLlNURVJFTy5ET1dOKSk7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGJvbmQuc3RlcmVvID09IEJvbmQuUEFUVEVSTi5TVEVSRU8uRE9XTikge1xyXG5cdFx0XHRcdFx0XHRhY3Rpb24uYWRkT3AobmV3IG9wLkJvbmRBdHRyKGJpZCwgJ3N0ZXJlbycsIEJvbmQuUEFUVEVSTi5TVEVSRU8uVVApKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBhY3Rpb24ucGVyZm9ybSgpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gZnJvbVJvdGF0ZSAob2JqZWN0cywgcG9zLCBhbmdsZSkge1xyXG5cdHZhciByZW5kZXIgPSB1aS5yZW5kZXI7XHJcblx0dmFyIGN0YWIgPSByZW5kZXIuY3RhYjtcclxuXHR2YXIgbW9sZWN1bGUgPSBjdGFiLm1vbGVjdWxlO1xyXG5cclxuXHR2YXIgYWN0aW9uID0gbmV3IEFjdGlvbigpO1xyXG5cdHZhciBpO1xyXG5cdHZhciBmaWRzID0ge307XHJcblxyXG5cdGZ1bmN0aW9uIHJvdGF0ZURlbHRhKHYpXHJcblx0e1xyXG5cdFx0dmFyIHYxID0gdi5zdWIocG9zKTtcclxuXHRcdHYxID0gdjEucm90YXRlKGFuZ2xlKTtcclxuXHRcdHYxLmFkZF8ocG9zKTtcclxuXHRcdHJldHVybiB2MS5zdWIodik7XHJcblx0fVxyXG5cclxuXHRpZiAob2JqZWN0cy5hdG9tcykge1xyXG5cdFx0b2JqZWN0cy5hdG9tcy5lYWNoKGZ1bmN0aW9uIChhaWQpIHtcclxuXHRcdFx0dmFyIGF0b20gPSBtb2xlY3VsZS5hdG9tcy5nZXQoYWlkKTtcclxuXHRcdFx0YWN0aW9uLmFkZE9wKG5ldyBvcC5BdG9tTW92ZShhaWQsIHJvdGF0ZURlbHRhKGF0b20ucHApKSk7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdGlmIChvYmplY3RzLnJ4bkFycm93cykge1xyXG5cdFx0b2JqZWN0cy5yeG5BcnJvd3MuZWFjaChmdW5jdGlvbiAoYWlkKSB7XHJcblx0XHRcdHZhciBhcnJvdyA9IG1vbGVjdWxlLnJ4bkFycm93cy5nZXQoYWlkKTtcclxuXHRcdFx0YWN0aW9uLmFkZE9wKG5ldyBvcC5SeG5BcnJvd01vdmUoYWlkLCByb3RhdGVEZWx0YShhcnJvdy5wcCkpKTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0aWYgKG9iamVjdHMucnhuUGx1c2VzKSB7XHJcblx0XHRvYmplY3RzLnJ4blBsdXNlcy5lYWNoKGZ1bmN0aW9uIChwaWQpIHtcclxuXHRcdFx0dmFyIHBsdXMgPSBtb2xlY3VsZS5yeG5QbHVzZXMuZ2V0KHBpZCk7XHJcblx0XHRcdGFjdGlvbi5hZGRPcChuZXcgb3AuUnhuUGx1c01vdmUocGlkLCByb3RhdGVEZWx0YShwbHVzLnBwKSkpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRpZiAob2JqZWN0cy5zZ3JvdXBEYXRhKSB7XHJcblx0XHRvYmplY3RzLnNncm91cERhdGEuZWFjaChmdW5jdGlvbiAoZGlkKSB7XHJcblx0XHRcdHZhciBkYXRhID0gbW9sZWN1bGUuc2dyb3Vwcy5nZXQoZGlkKTtcclxuXHRcdFx0YWN0aW9uLmFkZE9wKG5ldyBvcC5TR3JvdXBEYXRhTW92ZShkaWQsIHJvdGF0ZURlbHRhKGRhdGEucHApKSk7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdGlmIChvYmplY3RzLmNoaXJhbEZsYWdzKSB7XHJcblx0XHRvYmplY3RzLmNoaXJhbEZsYWdzLmVhY2goZnVuY3Rpb24gKGZpZCkge1xyXG5cdFx0XHR2YXIgZmxhZyA9IG1vbGVjdWxlLmNoaXJhbEZsYWdzLmdldChmaWQpO1xyXG5cdFx0XHRhY3Rpb24uYWRkT3AobmV3IG9wLkNoaXJhbEZsYWdNb3ZlKGZpZCwgcm90YXRlRGVsdGEoZmxhZy5wcCkpKTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGFjdGlvbi5wZXJmb3JtKCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHV0aWwuZXh0ZW5kKEFjdGlvbiwge1xyXG5cdGZyb21NdWx0aXBsZU1vdmU6IGZyb21NdWx0aXBsZU1vdmUsXHJcblx0ZnJvbUF0b21BZGRpdGlvbjogZnJvbUF0b21BZGRpdGlvbixcclxuXHRmcm9tQXJyb3dBZGRpdGlvbjogZnJvbUFycm93QWRkaXRpb24sXHJcblx0ZnJvbUFycm93RGVsZXRpb246IGZyb21BcnJvd0RlbGV0aW9uLFxyXG5cdGZyb21DaGlyYWxGbGFnRGVsZXRpb246IGZyb21DaGlyYWxGbGFnRGVsZXRpb24sXHJcblx0ZnJvbVBsdXNBZGRpdGlvbjogZnJvbVBsdXNBZGRpdGlvbixcclxuXHRmcm9tUGx1c0RlbGV0aW9uOiBmcm9tUGx1c0RlbGV0aW9uLFxyXG5cdGZyb21BdG9tRGVsZXRpb246IGZyb21BdG9tRGVsZXRpb24sXHJcblx0ZnJvbUJvbmREZWxldGlvbjogZnJvbUJvbmREZWxldGlvbixcclxuXHRmcm9tRnJhZ21lbnREZWxldGlvbjogZnJvbUZyYWdtZW50RGVsZXRpb24sXHJcblx0ZnJvbUF0b21NZXJnZTogZnJvbUF0b21NZXJnZSxcclxuXHRmcm9tQm9uZEZsaXBwaW5nOiBmcm9tQm9uZEZsaXBwaW5nLFxyXG5cdGZyb21UZW1wbGF0ZU9uQ2FudmFzOiBmcm9tVGVtcGxhdGVPbkNhbnZhcyxcclxuXHRmcm9tVGVtcGxhdGVPbkF0b206IGZyb21UZW1wbGF0ZU9uQXRvbSxcclxuXHRmcm9tVGVtcGxhdGVPbkJvbmQ6IGZyb21UZW1wbGF0ZU9uQm9uZCxcclxuXHRmcm9tQXRvbXNBdHRyczogZnJvbUF0b21zQXR0cnMsXHJcblx0ZnJvbUJvbmRBdHRyczogZnJvbUJvbmRBdHRycyxcclxuXHRmcm9tQ2hhaW46IGZyb21DaGFpbixcclxuXHRmcm9tQm9uZEFkZGl0aW9uOiBmcm9tQm9uZEFkZGl0aW9uLFxyXG5cdGZyb21OZXdDYW52YXM6IGZyb21OZXdDYW52YXMsXHJcblx0ZnJvbVNncm91cFR5cGU6IGZyb21TZ3JvdXBUeXBlLFxyXG5cdGZyb21TZ3JvdXBEZWxldGlvbjogZnJvbVNncm91cERlbGV0aW9uLFxyXG5cdGZyb21TZ3JvdXBBdHRyczogZnJvbVNncm91cEF0dHJzLFxyXG5cdGZyb21SR3JvdXBGcmFnbWVudDogZnJvbVJHcm91cEZyYWdtZW50LFxyXG5cdGZyb21QYXN0ZTogZnJvbVBhc3RlLFxyXG5cdGZyb21SR3JvdXBBdHRyczogZnJvbVJHcm91cEF0dHJzLFxyXG5cdGZyb21TZ3JvdXBBZGRpdGlvbjogZnJvbVNncm91cEFkZGl0aW9uLFxyXG5cdGZyb21GbGlwOiBmcm9tRmxpcCxcclxuXHRmcm9tUm90YXRlOiBmcm9tUm90YXRlXHJcbn0pO1xyXG4iLCJ2YXIga2V5bWFnZSA9IHJlcXVpcmUoJ2tleW1hZ2UnKTtcclxudmFyIGVsZW1lbnQgPSByZXF1aXJlKCcuLi8uLi9jaGVtL2VsZW1lbnQnKTtcclxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XHJcbnZhciBBY3Rpb24gPSByZXF1aXJlKCcuLi9hY3Rpb24nKTtcclxuXHJcbnZhciB1aSA9IGdsb2JhbC51aTtcclxuXHJcbmZ1bmN0aW9uIGluaXREaWFsb2dzICgpIHtcclxuXHQvLyBMYWJlbCBpbnB1dCBldmVudHNcclxuXHQkKCdpbnB1dF9sYWJlbCcpLm9ic2VydmUoJ2JsdXInLCBmdW5jdGlvbiAoKSB7XHJcblx0XHRrZXltYWdlLnNldFNjb3BlKCdlZGl0b3InKTtcclxuXHRcdHRoaXMuaGlkZSgpO1xyXG5cdH0pO1xyXG5cdCQoJ2lucHV0X2xhYmVsJykub2JzZXJ2ZSgna2V5cHJlc3MnLCBvbktleVByZXNzX0lucHV0TGFiZWwpO1xyXG5cdCQoJ2lucHV0X2xhYmVsJykub2JzZXJ2ZSgna2V5dXAnLCBvbktleVVwX0lucHV0TGFiZWwpO1xyXG5cclxuXHQvLyBBdG9tIHByb3BlcnRpZXMgZGlhbG9nIGV2ZW50c1xyXG5cdCQoJ2F0b21fbGFiZWwnKS5vYnNlcnZlKCdjaGFuZ2UnLCBvbkNoYW5nZV9BdG9tTGFiZWwpO1xyXG5cdCQoJ2F0b21fY2hhcmdlJykub2JzZXJ2ZSgnY2hhbmdlJywgb25DaGFuZ2VfQXRvbUNoYXJnZSk7XHJcblx0JCgnYXRvbV9pc290b3BlJykub2JzZXJ2ZSgnY2hhbmdlJywgb25DaGFuZ2VfQXRvbUlzb3RvcGUpO1xyXG5cdCQoJ2F0b21fdmFsZW5jZScpLm9ic2VydmUoJ2NoYW5nZScsIG9uQ2hhbmdlX0F0b21WYWxlbmNlKTtcclxuXHQkKCdhdG9tX3Byb3BfY2FuY2VsJykub2JzZXJ2ZSgnY2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcblx0XHR1aS5oaWRlRGlhbG9nKCdhdG9tX3Byb3BlcnRpZXMnKTtcclxuXHR9KTtcclxuXHQkKCdhdG9tX3Byb3Bfb2snKS5vYnNlcnZlKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuXHRcdGFwcGx5QXRvbVByb3BlcnRpZXMoKTtcclxuXHR9KTtcclxuXHQkKCdib25kX3Byb3BfY2FuY2VsJykub2JzZXJ2ZSgnY2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcblx0XHR1aS5oaWRlRGlhbG9nKCdib25kX3Byb3BlcnRpZXMnKTtcclxuXHR9KTtcclxuXHQkKCdib25kX3Byb3Bfb2snKS5vYnNlcnZlKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuXHRcdGFwcGx5Qm9uZFByb3BlcnRpZXMoKTtcclxuXHR9KTtcclxufTtcclxuXHJcbi8vXHJcbi8vIEF0b20gYXR0YWNobWVudCBwb2ludHMgZGlhbG9nXHJcbi8vXHJcbmZ1bmN0aW9uIHNob3dBdG9tQXR0YWNobWVudFBvaW50cyAocGFyYW1zKSB7XHJcblx0JCgnYXRvbV9hcDEnKS5jaGVja2VkID0gKChwYXJhbXMuc2VsZWN0aW9uIHx8IDApICYgMSkgPiAwO1xyXG5cdCQoJ2F0b21fYXAyJykuY2hlY2tlZCA9ICgocGFyYW1zLnNlbGVjdGlvbiB8fCAwKSAmIDIpID4gMDtcclxuXHR1aS5zaG93RGlhbG9nKCdhdG9tX2F0dHBvaW50cycpO1xyXG5cdHZhciBfb25PayA9IG5ldyBFdmVudC5IYW5kbGVyKCdhdG9tX2F0dHBvaW50c19vaycsICdjbGljaycsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKCkge1xyXG5cdFx0X29uT2suc3RvcCgpO1xyXG5cdFx0X29uQ2FuY2VsLnN0b3AoKTtcclxuXHRcdHVpLmhpZGVEaWFsb2coJ2F0b21fYXR0cG9pbnRzJyk7XHJcblx0XHRpZiAoJ29uT2snIGluIHBhcmFtcykge1xyXG5cdFx0XHRwYXJhbXMub25PaygoJCgnYXRvbV9hcDEnKS5jaGVja2VkID8gMSA6IDApICsgKCQoJ2F0b21fYXAyJykuY2hlY2tlZCA/IDIgOiAwKSk7XHJcblx0XHR9XHJcblx0fSkuc3RhcnQoKTtcclxuXHR2YXIgX29uQ2FuY2VsID0gbmV3IEV2ZW50LkhhbmRsZXIoJ2F0b21fYXR0cG9pbnRzX2NhbmNlbCcsICdjbGljaycsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKCkge1xyXG5cdFx0X29uT2suc3RvcCgpO1xyXG5cdFx0X29uQ2FuY2VsLnN0b3AoKTtcclxuXHRcdHVpLmhpZGVEaWFsb2coJ2F0b21fYXR0cG9pbnRzJyk7XHJcblx0XHRpZiAoJ29uQ2FuY2VsJyBpbiBwYXJhbXMpIHtcclxuXHRcdFx0cGFyYW1zLm9uQ2FuY2VsKCk7XHJcblx0XHR9XHJcblx0fSkuc3RhcnQoKTtcclxuXHQkKCdhdG9tX2F0dHBvaW50c19vaycpLmZvY3VzKCk7XHJcbn07XHJcblxyXG4vL1xyXG4vLyBBdG9tIHByb3BlcnRpZXMgZGlhbG9nXHJcbi8vXHJcbmZ1bmN0aW9uIHNob3dBdG9tUHJvcGVydGllcyAoaWQpIHtcclxuXHQkKCdhdG9tX3Byb3BlcnRpZXMnKS5hdG9tX2lkID0gaWQ7XHJcblx0JCgnYXRvbV9sYWJlbCcpLnZhbHVlID0gdWkucmVuZGVyLmF0b21HZXRBdHRyKGlkLCAnbGFiZWwnKTtcclxuXHRvbkNoYW5nZV9BdG9tTGFiZWwuY2FsbCgkKCdhdG9tX2xhYmVsJykpO1xyXG5cdHZhciB2YWx1ZSA9IHVpLnJlbmRlci5hdG9tR2V0QXR0cihpZCwgJ2NoYXJnZScpIC0gMDtcclxuXHQkKCdhdG9tX2NoYXJnZScpLnZhbHVlID0gKHZhbHVlID09IDAgPyAnJyA6IHZhbHVlKTtcclxuXHR2YWx1ZSA9IHVpLnJlbmRlci5hdG9tR2V0QXR0cihpZCwgJ2lzb3RvcGUnKSAtIDA7XHJcblx0JCgnYXRvbV9pc290b3BlJykudmFsdWUgPSAodmFsdWUgPT0gMCA/ICcnIDogdmFsdWUpO1xyXG5cdHZhbHVlID0gdWkucmVuZGVyLmF0b21HZXRBdHRyKGlkLCAnZXhwbGljaXRWYWxlbmNlJykgLSAwO1xyXG5cdCQoJ2F0b21fdmFsZW5jZScpLnZhbHVlID0gdmFsdWUgPCAwID8gJycgOiB2YWx1ZTtcclxuXHQkKCdhdG9tX3JhZGljYWwnKS52YWx1ZSA9IHVpLnJlbmRlci5hdG9tR2V0QXR0cihpZCwgJ3JhZGljYWwnKTtcclxuXHJcblx0JCgnYXRvbV9pbnZlcnNpb24nKS52YWx1ZSA9IHVpLnJlbmRlci5hdG9tR2V0QXR0cihpZCwgJ2ludlJldCcpO1xyXG5cdCQoJ2F0b21fZXhhY3RjaGFuZ2UnKS52YWx1ZSA9IHVpLnJlbmRlci5hdG9tR2V0QXR0cihpZCwgJ2V4YWN0Q2hhbmdlRmxhZycpID8gMSA6IDA7XHJcblx0JCgnYXRvbV9yaW5nY291bnQnKS52YWx1ZSA9IHVpLnJlbmRlci5hdG9tR2V0QXR0cihpZCwgJ3JpbmdCb25kQ291bnQnKTtcclxuXHQkKCdhdG9tX3N1YnN0aXR1dGlvbicpLnZhbHVlID0gdWkucmVuZGVyLmF0b21HZXRBdHRyKGlkLCAnc3Vic3RpdHV0aW9uQ291bnQnKTtcclxuXHQkKCdhdG9tX3Vuc2F0dXJhdGlvbicpLnZhbHVlID0gdWkucmVuZGVyLmF0b21HZXRBdHRyKGlkLCAndW5zYXR1cmF0ZWRBdG9tJyk7XHJcblx0JCgnYXRvbV9oY291bnQnKS52YWx1ZSA9IHVpLnJlbmRlci5hdG9tR2V0QXR0cihpZCwgJ2hDb3VudCcpO1xyXG5cclxuXHR1aS5zaG93RGlhbG9nKCdhdG9tX3Byb3BlcnRpZXMnKTtcclxuXHQkKCdhdG9tX2xhYmVsJykuYWN0aXZhdGUoKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGFwcGx5QXRvbVByb3BlcnRpZXMgKCkge1xyXG5cdHVpLmhpZGVEaWFsb2coJ2F0b21fcHJvcGVydGllcycpO1xyXG5cclxuXHR2YXIgaWQgPSAkKCdhdG9tX3Byb3BlcnRpZXMnKS5hdG9tX2lkO1xyXG5cclxuXHR1aS5hZGRVbmRvQWN0aW9uKEFjdGlvbi5mcm9tQXRvbXNBdHRycyhpZCxcclxuXHR7XHJcblx0XHRsYWJlbDogJCgnYXRvbV9sYWJlbCcpLnZhbHVlLFxyXG5cdFx0Y2hhcmdlOiAkKCdhdG9tX2NoYXJnZScpLnZhbHVlID09ICcnID8gMCA6IHBhcnNlSW50KCQoJ2F0b21fY2hhcmdlJykudmFsdWUsIDEwKSxcclxuXHRcdGlzb3RvcGU6ICQoJ2F0b21faXNvdG9wZScpLnZhbHVlID09ICcnID8gMCA6IHBhcnNlSW50KCQoJ2F0b21faXNvdG9wZScpLnZhbHVlLCAxMCksXHJcblx0XHRleHBsaWNpdFZhbGVuY2U6ICQoJ2F0b21fdmFsZW5jZScpLnZhbHVlID09ICcnID8gLTEgOiBwYXJzZUludCgkKCdhdG9tX3ZhbGVuY2UnKS52YWx1ZSwgMTApLFxyXG5cdFx0cmFkaWNhbDogcGFyc2VJbnQoJCgnYXRvbV9yYWRpY2FsJykudmFsdWUsIDEwKSxcclxuXHRcdC8vIHJlYWN0aW9uIGZsYWdzXHJcblx0XHRpbnZSZXQ6IHBhcnNlSW50KCQoJ2F0b21faW52ZXJzaW9uJykudmFsdWUsIDEwKSxcclxuXHRcdGV4YWN0Q2hhbmdlRmxhZzogcGFyc2VJbnQoJCgnYXRvbV9leGFjdGNoYW5nZScpLnZhbHVlLCAxMCkgPyB0cnVlIDogZmFsc2UsXHJcblx0XHQvLyBxdWVyeSBmbGFnc1xyXG5cdFx0cmluZ0JvbmRDb3VudDogcGFyc2VJbnQoJCgnYXRvbV9yaW5nY291bnQnKS52YWx1ZSwgMTApLFxyXG5cdFx0c3Vic3RpdHV0aW9uQ291bnQ6IHBhcnNlSW50KCQoJ2F0b21fc3Vic3RpdHV0aW9uJykudmFsdWUsIDEwKSxcclxuXHRcdHVuc2F0dXJhdGVkQXRvbTogcGFyc2VJbnQoJCgnYXRvbV91bnNhdHVyYXRpb24nKS52YWx1ZSwgMTApLFxyXG5cdFx0aENvdW50OiBwYXJzZUludCgkKCdhdG9tX2hjb3VudCcpLnZhbHVlLCAxMClcclxuXHR9KSwgdHJ1ZSk7XHJcblxyXG5cdHVpLnJlbmRlci51cGRhdGUoKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIG9uQ2hhbmdlX0F0b21MYWJlbCAoKSB7XHJcblx0dGhpcy52YWx1ZSA9IHRoaXMudmFsdWUuc3RyaXAoKS5jYXBpdGFsaXplKCk7XHJcblxyXG5cdHZhciBlbGVtID0gZWxlbWVudC5nZXRFbGVtZW50QnlMYWJlbCh0aGlzLnZhbHVlKTtcclxuXHJcblx0aWYgKFxyXG5cdFx0ZWxlbSA9PSBudWxsICYmIHRoaXMudmFsdWUgIT09ICdBJyAmJlxyXG5cdHRoaXMudmFsdWUgIT09ICcqJyAmJiB0aGlzLnZhbHVlICE9PSAnUScgJiYgdGhpcy52YWx1ZSAhPT0gJ1gnICYmXHJcblx0dGhpcy52YWx1ZSAhPT0gJ1InXHJcblx0KSB7XHJcblx0XHR0aGlzLnZhbHVlID0gdWkucmVuZGVyLmF0b21HZXRBdHRyKCQoJ2F0b21fcHJvcGVydGllcycpLmF0b21faWQsICdsYWJlbCcpO1xyXG5cclxuXHRcdGlmICh0aGlzLnZhbHVlICE9PSAnQScgJiYgdGhpcy52YWx1ZSAhPT0gJyonKSB7XHJcblx0XHRcdGVsZW0gPSBlbGVtZW50LmdldEVsZW1lbnRCeUxhYmVsKHRoaXMudmFsdWUpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0aWYgKHRoaXMudmFsdWUgPT0gJ0EnIHx8IHRoaXMudmFsdWUgPT0gJyonKSB7XHJcblx0XHQkKCdhdG9tX251bWJlcicpLnZhbHVlID0gJ2FueSc7XHJcblx0fSBlbHNlIGlmICghZWxlbSkge1xyXG5cdFx0JCgnYXRvbV9udW1iZXInKS52YWx1ZSA9ICcnO1xyXG5cdH0gZWxzZSB7XHJcblx0XHQkKCdhdG9tX251bWJlcicpLnZhbHVlID0gZWxlbS50b1N0cmluZygpO1xyXG5cdH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIG9uQ2hhbmdlX0F0b21DaGFyZ2UgKCkge1xyXG5cdGlmICh0aGlzLnZhbHVlLnN0cmlwKCkgPT09ICcnIHx8IHRoaXMudmFsdWUgPT0gJzAnKSB7XHJcblx0XHR0aGlzLnZhbHVlID0gJyc7XHJcblx0fSBlbHNlIGlmICh0aGlzLnZhbHVlLm1hdGNoKC9eWzEtOV1bMC05XXswLDF9Wy0rXSQvKSkge1xyXG5cdFx0dGhpcy52YWx1ZSA9ICh0aGlzLnZhbHVlLmVuZHNXaXRoKCctJykgPyAnLScgOiAnJykgKyB0aGlzLnZhbHVlLnN1YnN0cigwLCB0aGlzLnZhbHVlLmxlbmd0aCAtIDEpO1xyXG5cdH0gZWxzZSBpZiAoIXRoaXMudmFsdWUubWF0Y2goL15bKy1dP1sxLTldWzAtOV17MCwxfSQvKSkge1xyXG5cdFx0dGhpcy52YWx1ZSA9IHVpLnJlbmRlci5hdG9tR2V0QXR0cigkKCdhdG9tX3Byb3BlcnRpZXMnKS5hdG9tX2lkLCAnY2hhcmdlJyk7XHJcblx0fVxyXG59O1xyXG5cclxuZnVuY3Rpb24gb25DaGFuZ2VfQXRvbUlzb3RvcGUgKCkge1xyXG5cdGlmICh0aGlzLnZhbHVlID09IHV0aWwuZ2V0RWxlbWVudFRleHRDb250ZW50KCQoJ2F0b21fbnVtYmVyJykpIHx8IHRoaXMudmFsdWUuc3RyaXAoKSA9PSAnJyB8fCB0aGlzLnZhbHVlID09ICcwJykge1xyXG5cdFx0dGhpcy52YWx1ZSA9ICcnO1xyXG5cdH0gZWxzZSBpZiAoIXRoaXMudmFsdWUubWF0Y2goL15bMS05XVswLTldezAsMn0kLykpIHtcclxuXHRcdHRoaXMudmFsdWUgPSB1aS5yZW5kZXIuYXRvbUdldEF0dHIoJCgnYXRvbV9wcm9wZXJ0aWVzJykuYXRvbV9pZCwgJ2lzb3RvcGUnKTtcclxuXHR9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBvbkNoYW5nZV9BdG9tVmFsZW5jZSAoKSB7XHJcblx0LypcclxuICAgICBpZiAodGhpcy52YWx1ZS5zdHJpcCgpID09ICcnKVxyXG4gICAgIHRoaXMudmFsdWUgPSAnJztcclxuICAgICBlbHNlIGlmICghdGhpcy52YWx1ZS5tYXRjaCgvXlswLTldJC8pKVxyXG4gICAgIHRoaXMudmFsdWUgPSB1aS5yZW5kZXIuYXRvbUdldEF0dHIoJCgnYXRvbV9wcm9wZXJ0aWVzJykuYXRvbV9pZCwgJ3ZhbGVuY2UnKTtcclxuICAgICAqL1xyXG59O1xyXG5cclxuLy9cclxuLy8gQm9uZCBwcm9wZXJ0aWVzIGRpYWxvZ1xyXG4vL1xyXG5mdW5jdGlvbiBzaG93Qm9uZFByb3BlcnRpZXMgKGlkKSB7XHJcblx0dmFyIGJvbmQ7XHJcblx0JCgnYm9uZF9wcm9wZXJ0aWVzJykuYm9uZF9pZCA9IGlkO1xyXG5cclxuXHR2YXIgdHlwZSA9IHVpLnJlbmRlci5ib25kR2V0QXR0cihpZCwgJ3R5cGUnKTtcclxuXHR2YXIgc3RlcmVvID0gdWkucmVuZGVyLmJvbmRHZXRBdHRyKGlkLCAnc3RlcmVvJyk7XHJcblxyXG5cdGZvciAoYm9uZCBpbiB1aS5ib25kVHlwZU1hcCkge1xyXG5cdFx0aWYgKHVpLmJvbmRUeXBlTWFwW2JvbmRdLnR5cGUgPT0gdHlwZSAmJiB1aS5ib25kVHlwZU1hcFtib25kXS5zdGVyZW8gPT0gc3RlcmVvKSB7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0JCgnYm9uZF90eXBlJykudmFsdWUgPSBib25kO1xyXG5cdCQoJ2JvbmRfdG9wb2xvZ3knKS52YWx1ZSA9IHVpLnJlbmRlci5ib25kR2V0QXR0cihpZCwgJ3RvcG9sb2d5JykgfHwgMDtcclxuXHQkKCdib25kX2NlbnRlcicpLnZhbHVlID0gdWkucmVuZGVyLmJvbmRHZXRBdHRyKGlkLCAncmVhY3RpbmdDZW50ZXJTdGF0dXMnKSB8fCAwO1xyXG5cclxuXHR1aS5zaG93RGlhbG9nKCdib25kX3Byb3BlcnRpZXMnKTtcclxuXHQkKCdib25kX3R5cGUnKS5hY3RpdmF0ZSgpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gYXBwbHlCb25kUHJvcGVydGllcyAoKSB7XHJcblx0dWkuaGlkZURpYWxvZygnYm9uZF9wcm9wZXJ0aWVzJyk7XHJcblxyXG5cdHZhciBpZCA9ICQoJ2JvbmRfcHJvcGVydGllcycpLmJvbmRfaWQ7XHJcblx0dmFyIGJvbmQgPSBPYmplY3QuY2xvbmUodWkuYm9uZFR5cGVNYXBbJCgnYm9uZF90eXBlJykudmFsdWVdKTtcclxuXHJcblx0Ym9uZC50b3BvbG9neSA9IHBhcnNlSW50KCQoJ2JvbmRfdG9wb2xvZ3knKS52YWx1ZSwgMTApO1xyXG5cdGJvbmQucmVhY3RpbmdDZW50ZXJTdGF0dXMgPSBwYXJzZUludCgkKCdib25kX2NlbnRlcicpLnZhbHVlLCAxMCk7XHJcblxyXG5cdHVpLmFkZFVuZG9BY3Rpb24oQWN0aW9uLmZyb21Cb25kQXR0cnMoaWQsIGJvbmQpLCB0cnVlKTtcclxuXHJcblx0dWkucmVuZGVyLnVwZGF0ZSgpO1xyXG59O1xyXG5cclxuLy9cclxuLy8gUmVhY3Rpb24gYXV0by1tYXBwaW5nXHJcbi8vXHJcblxyXG5mdW5jdGlvbiBzaG93QXV0b21hcFByb3BlcnRpZXMgKHBhcmFtcykge1xyXG5cdHVpLnNob3dEaWFsb2coJ2F1dG9tYXBfcHJvcGVydGllcycpO1xyXG5cdHZhciBfb25PaztcclxuXHR2YXIgX29uQ2FuY2VsO1xyXG5cclxuXHRfb25PayA9IG5ldyBFdmVudC5IYW5kbGVyKCdhdXRvbWFwX29rJywgJ2NsaWNrJywgdW5kZWZpbmVkLCBmdW5jdGlvbiAoKSB7XHJcblx0XHRfb25Pay5zdG9wKCk7XHJcblx0XHRfb25DYW5jZWwuc3RvcCgpO1xyXG5cdFx0aWYgKHBhcmFtcyAmJiAnb25PaycgaW4gcGFyYW1zKSBwYXJhbXNbJ29uT2snXSgkKCdhdXRvbWFwX21vZGUnKS52YWx1ZSk7XHJcblx0XHR1aS5oaWRlRGlhbG9nKCdhdXRvbWFwX3Byb3BlcnRpZXMnKTtcclxuXHR9KS5zdGFydCgpO1xyXG5cclxuXHRfb25DYW5jZWwgPSBuZXcgRXZlbnQuSGFuZGxlcignYXV0b21hcF9jYW5jZWwnLCAnY2xpY2snLCB1bmRlZmluZWQsIGZ1bmN0aW9uICgpIHtcclxuXHRcdF9vbk9rLnN0b3AoKTtcclxuXHRcdF9vbkNhbmNlbC5zdG9wKCk7XHJcblx0XHR1aS5oaWRlRGlhbG9nKCdhdXRvbWFwX3Byb3BlcnRpZXMnKTtcclxuXHRcdGlmIChwYXJhbXMgJiYgJ29uQ2FuY2VsJyBpbiBwYXJhbXMpIHBhcmFtc1snb25DYW5jZWwnXSgpO1xyXG5cdH0pLnN0YXJ0KCk7XHJcblxyXG5cdCQoJ2F1dG9tYXBfbW9kZScpLmFjdGl2YXRlKCk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBzaG93UkxvZ2ljVGFibGUgKGFyZ3MpIHtcclxuXHR2YXIgcGFyYW1zID0gYXJncyB8fCB7fTtcclxuXHRwYXJhbXMucmxvZ2ljID0gcGFyYW1zLnJsb2dpYyB8fCB7fTtcclxuXHQkKCdybG9naWNfb2NjdXJyZW5jZScpLnZhbHVlID0gcGFyYW1zLnJsb2dpYy5vY2N1cnJlbmNlIHx8ICc+MCc7XHJcblx0JCgncmxvZ2ljX3Jlc3RoJykudmFsdWUgPSBwYXJhbXMucmxvZ2ljLnJlc3RoID8gJzEnIDogJzAnO1xyXG5cdHZhciBpZk9wdEh0bWwgPSAnPG9wdGlvbiB2YWx1ZT1cIjBcIj5BbHdheXM8L29wdGlvbj4nO1xyXG5cdGZvciAodmFyIHIgPSAxOyByIDw9IDMyOyByKyspIHtcclxuXHRcdGlmIChyICE9IHBhcmFtcy5yZ2lkICYmIChwYXJhbXMucmdtYXNrICYgKDEgPDwgKHIgLSAxKSkpICE9IDApIHtcclxuXHRcdFx0aWZPcHRIdG1sICs9ICc8b3B0aW9uIHZhbHVlPVwiJyArIHIgKyAnXCI+SUYgUicgKyBwYXJhbXMucmdpZCArICcgVEhFTiBSJyArIHIgKyAnPC9vcHRpb24+JztcclxuXHRcdH1cclxuXHR9XHJcblx0JCgncmxvZ2ljX2lmJykub3V0ZXJIVE1MID0gJzxzZWxlY3QgaWQ9XCJybG9naWNfaWZcIj4nICsgaWZPcHRIdG1sICsgJzwvc2VsZWN0Pic7IC8vIFtSQl0gdGhhdHMgdHJpY2t5IGJlY2F1c2UgSUU4IGZhaWxzIHRvIHNldCBpbm5lckhUTUxcclxuXHQkKCdybG9naWNfaWYnKS52YWx1ZSA9IHBhcmFtcy5ybG9naWMuaWZ0aGVuO1xyXG5cdHVpLnNob3dEaWFsb2coJ3Jsb2dpY190YWJsZScpO1xyXG5cclxuXHR2YXIgX29uT2sgPSBuZXcgRXZlbnQuSGFuZGxlcigncmxvZ2ljX29rJywgJ2NsaWNrJywgdW5kZWZpbmVkLCBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcmVzdWx0ID0ge1xyXG5cdFx0XHQnb2NjdXJyZW5jZSc6ICQoJ3Jsb2dpY19vY2N1cnJlbmNlJykudmFsdWVcclxuXHRcdFx0LnJlcGxhY2UoL1xccyovZywgJycpLnJlcGxhY2UoLywrL2csICcsJykucmVwbGFjZSgvXiwvLCAnJykucmVwbGFjZSgvLCQvLCAnJyksXHJcblx0XHRcdCdyZXN0aCc6ICQoJ3Jsb2dpY19yZXN0aCcpLnZhbHVlID09ICcxJyxcclxuXHRcdFx0J2lmdGhlbic6IHBhcnNlSW50KCQoJ3Jsb2dpY19pZicpLnZhbHVlLCAxMClcclxuXHRcdH07XHJcblx0XHRpZiAoIXBhcmFtcyB8fCAhKCdvbk9rJyBpbiBwYXJhbXMpIHx8IHBhcmFtcy5vbk9rKHJlc3VsdCkpIHtcclxuXHRcdFx0X29uT2suc3RvcCgpO1xyXG5cdFx0XHRfb25DYW5jZWwuc3RvcCgpO1xyXG5cdFx0XHR1aS5oaWRlRGlhbG9nKCdybG9naWNfdGFibGUnKTtcclxuXHRcdH1cclxuXHR9KS5zdGFydCgpO1xyXG5cdHZhciBfb25DYW5jZWwgPSBuZXcgRXZlbnQuSGFuZGxlcigncmxvZ2ljX2NhbmNlbCcsICdjbGljaycsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKCkge1xyXG5cdFx0X29uT2suc3RvcCgpO1xyXG5cdFx0X29uQ2FuY2VsLnN0b3AoKTtcclxuXHRcdHVpLmhpZGVEaWFsb2coJ3Jsb2dpY190YWJsZScpO1xyXG5cdFx0aWYgKHBhcmFtcyAmJiAnb25DYW5jZWwnIGluIHBhcmFtcykgcGFyYW1zWydvbkNhbmNlbCddKCk7XHJcblx0fSkuc3RhcnQoKTtcclxuXHJcblx0JCgncmxvZ2ljX29jY3VycmVuY2UnKS5hY3RpdmF0ZSgpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gb25LZXlQcmVzc19EaWFsb2cgKGV2ZW50KVxyXG57XHJcblx0dXRpbC5zdG9wRXZlbnRQcm9wYWdhdGlvbihldmVudCk7XHJcblx0aWYgKGV2ZW50LmtleUNvZGUgPT09IDI3KSB7XHJcblx0XHR1aS5oaWRlRGlhbG9nKHRoaXMuaWQpO1xyXG5cdFx0cmV0dXJuIHV0aWwucHJldmVudERlZmF1bHQoZXZlbnQpO1xyXG5cdH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIG9uS2V5UHJlc3NfSW5wdXRMYWJlbCAoZXZlbnQpXHJcbntcclxuXHR1dGlsLnN0b3BFdmVudFByb3BhZ2F0aW9uKGV2ZW50KTtcclxuXHRpZiAoZXZlbnQua2V5Q29kZSA9PSAxMykge1xyXG5cdFx0a2V5bWFnZS5zZXRTY29wZSgnZWRpdG9yJyk7XHJcblx0XHR0aGlzLmhpZGUoKTtcclxuXHJcblx0XHR2YXIgbGFiZWwgPSAnJztcclxuXHRcdHZhciBjaGFyZ2UgPSAwO1xyXG5cdFx0dmFyIHZhbHVlX2FyciA9IHRoaXMudmFsdWUudG9BcnJheSgpO1xyXG5cclxuXHRcdGlmICh0aGlzLnZhbHVlID09ICcqJykge1xyXG5cdFx0XHRsYWJlbCA9ICdBJztcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYgKHRoaXMudmFsdWUubWF0Y2goL15bKl1bMS05XT9bKy1dJC9pKSkge1xyXG5cdFx0XHRsYWJlbCA9ICdBJztcclxuXHJcblx0XHRcdGlmICh0aGlzLnZhbHVlLmxlbmd0aCA9PSAyKVxyXG5cdFx0XHRcdGNoYXJnZSA9IDE7XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHRjaGFyZ2UgPSBwYXJzZUludCh2YWx1ZV9hcnJbMV0pO1xyXG5cclxuXHRcdFx0aWYgKHZhbHVlX2FyclsyXSA9PSAnLScpXHJcblx0XHRcdFx0Y2hhcmdlICo9IC0xO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZiAodGhpcy52YWx1ZS5tYXRjaCgvXltBLVpdezEsMn0kL2kpKSB7XHJcblx0XHRcdGxhYmVsID0gdGhpcy52YWx1ZS5jYXBpdGFsaXplKCk7XHJcblx0XHR9XHJcblx0XHRlbHNlIGlmICh0aGlzLnZhbHVlLm1hdGNoKC9eW0EtWl17MSwyfVswXVsrLV0/JC9pKSkge1xyXG5cdFx0XHRpZiAodGhpcy52YWx1ZS5tYXRjaCgvXltBLVpdezJ9L2kpKVxyXG5cdFx0XHRcdGxhYmVsID0gdGhpcy52YWx1ZS5zdWJzdHIoMCwgMikuY2FwaXRhbGl6ZSgpO1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0bGFiZWwgPSB2YWx1ZV9hcnJbMF0uY2FwaXRhbGl6ZSgpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZiAodGhpcy52YWx1ZS5tYXRjaCgvXltBLVpdezEsMn1bMS05XT9bKy1dJC9pKSkge1xyXG5cdFx0XHRpZiAodGhpcy52YWx1ZS5tYXRjaCgvXltBLVpdezJ9L2kpKVxyXG5cdFx0XHRcdGxhYmVsID0gdGhpcy52YWx1ZS5zdWJzdHIoMCwgMikuY2FwaXRhbGl6ZSgpO1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0bGFiZWwgPSB2YWx1ZV9hcnJbMF0uY2FwaXRhbGl6ZSgpO1xyXG5cclxuXHRcdFx0dmFyIG1hdGNoID0gdGhpcy52YWx1ZS5tYXRjaCgvWzAtOV0vaSk7XHJcblxyXG5cdFx0XHRpZiAobWF0Y2ggIT0gbnVsbClcclxuXHRcdFx0XHRjaGFyZ2UgPSBwYXJzZUludChtYXRjaFswXSk7XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHRjaGFyZ2UgPSAxO1xyXG5cclxuXHRcdFx0aWYgKHZhbHVlX2Fyclt0aGlzLnZhbHVlLmxlbmd0aCAtIDFdID09ICctJylcclxuXHRcdFx0XHRjaGFyZ2UgKj0gLTE7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGxhYmVsID09ICdBJyB8fCBsYWJlbCA9PSAnUScgfHwgbGFiZWwgPT0gJ1gnIHx8IGxhYmVsID09ICdSJyB8fCBlbGVtZW50LmdldEVsZW1lbnRCeUxhYmVsKGxhYmVsKSAhPSBudWxsKSB7XHJcblx0XHRcdHVpLmFkZFVuZG9BY3Rpb24oQWN0aW9uLmZyb21BdG9tc0F0dHJzKHRoaXMuYXRvbV9pZCwge2xhYmVsOiBsYWJlbCwgY2hhcmdlOiBjaGFyZ2V9KSwgdHJ1ZSk7XHJcblx0XHRcdHVpLnJlbmRlci51cGRhdGUoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB1dGlsLnByZXZlbnREZWZhdWx0KGV2ZW50KTtcclxuXHR9XHJcblx0aWYgKGV2ZW50LmtleUNvZGUgPT0gMjcpIHtcclxuXHRcdHRoaXMuaGlkZSgpO1xyXG5cdFx0a2V5bWFnZS5zZXRTY29wZSgnZWRpdG9yJyk7XHJcblx0XHRyZXR1cm4gdXRpbC5wcmV2ZW50RGVmYXVsdChldmVudCk7XHJcblx0fVxyXG59O1xyXG5cclxuZnVuY3Rpb24gb25LZXlVcF9JbnB1dExhYmVsIChldmVudClcclxue1xyXG5cdHV0aWwuc3RvcEV2ZW50UHJvcGFnYXRpb24oZXZlbnQpO1xyXG5cdGlmIChldmVudC5rZXlDb2RlID09IDI3KSB7XHJcblx0XHR0aGlzLmhpZGUoKTtcclxuXHRcdGtleW1hZ2Uuc2V0U2NvcGUoJ2VkaXRvcicpO1xyXG5cdFx0cmV0dXJuIHV0aWwucHJldmVudERlZmF1bHQoZXZlbnQpO1xyXG5cdH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIHNob3dMYWJlbEVkaXRvciAoYWlkKVxyXG57XHJcblx0Ly8gVE9ETzogUkI6IHRvIGJlIHJlZmFjdG9yZWQgbGF0ZXIsIG5lZWQgdG8gYXR0YWNoL2RldGFjaCBsaXN0ZW5lcnMgaGVyZSBhcyBhbm9uLWZ1bmN0aW9ucywgbm90IG9uIGdsb2JhbCBzY29wZSAob25LZXlQcmVzc19JbnB1dExhYmVsLCBvbkJsdXIsIGV0YylcclxuXHR2YXIgaW5wdXRfZWwgPSAkKCdpbnB1dF9sYWJlbCcpO1xyXG5cdGtleW1hZ2Uuc2V0U2NvcGUoJ2xhYmVsJyk7XHJcblxyXG5cdHZhciBvZmZzZXQgPSBNYXRoLm1pbig3ICogdWkucmVuZGVyLnpvb20sIDE2KTtcclxuXHJcblx0aW5wdXRfZWwuYXRvbV9pZCA9IGFpZDtcclxuXHRpbnB1dF9lbC52YWx1ZSA9IHVpLnJlbmRlci5hdG9tR2V0QXR0cihhaWQsICdsYWJlbCcpO1xyXG5cdGlucHV0X2VsLnN0eWxlLmZvbnRTaXplID0gb2Zmc2V0ICogMiArICdweCc7XHJcblxyXG5cdGlucHV0X2VsLnNob3coKTtcclxuXHJcblx0dmFyIGF0b21fcG9zID0gdWkucmVuZGVyLm9iajJ2aWV3KHVpLnJlbmRlci5hdG9tR2V0UG9zKGFpZCkpO1xyXG5cdC8vIFRPRE86IHNvbWUgb3RoZXIgd2F5IHRvIGhhbmRsZSBwb3NcclxuXHQvL3ZhciBvZmZzZXRfY2xpZW50ID0gdWkuY2xpZW50X2FyZWEuY3VtdWxhdGl2ZU9mZnNldCgpO1xyXG5cdHZhciBvZmZzZXRfY2xpZW50ID0ge2xlZnQ6IDAsIHRvcDogMH07XHJcblx0dmFyIG9mZnNldF9wYXJlbnQgPSBFbGVtZW50LmN1bXVsYXRpdmVPZmZzZXQoaW5wdXRfZWwub2Zmc2V0UGFyZW50KTtcclxuXHR2YXIgZCA9IDA7IC8vIFRPRE86IGZpeC9NYXRoLmNlaWwoNCAqIHVpLmFibCgpIC8gMTAwKTtcclxuXHRpbnB1dF9lbC5zdHlsZS5sZWZ0ID0gKGF0b21fcG9zLnggKyBvZmZzZXRfY2xpZW50LmxlZnQgLSBvZmZzZXRfcGFyZW50LmxlZnQgLSBvZmZzZXQgLSBkKSArICdweCc7XHJcblx0aW5wdXRfZWwuc3R5bGUudG9wID0gKGF0b21fcG9zLnkgKyBvZmZzZXRfY2xpZW50LnRvcCAtIG9mZnNldF9wYXJlbnQudG9wIC0gb2Zmc2V0IC0gZCkgKyAncHgnO1xyXG5cclxuXHRpbnB1dF9lbC5hY3RpdmF0ZSgpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0aW5pdERpYWxvZ3M6IGluaXREaWFsb2dzLFxyXG5cdHNob3dBdG9tQXR0YWNobWVudFBvaW50czogc2hvd0F0b21BdHRhY2htZW50UG9pbnRzLFxyXG5cdHNob3dBdG9tUHJvcGVydGllczogc2hvd0F0b21Qcm9wZXJ0aWVzLFxyXG5cdHNob3dCb25kUHJvcGVydGllczogc2hvd0JvbmRQcm9wZXJ0aWVzLFxyXG5cdHNob3dBdXRvbWFwUHJvcGVydGllczogc2hvd0F1dG9tYXBQcm9wZXJ0aWVzLFxyXG5cdHNob3dSTG9naWNUYWJsZTogc2hvd1JMb2dpY1RhYmxlLFxyXG5cdHNob3dMYWJlbEVkaXRvcjogc2hvd0xhYmVsRWRpdG9yXHJcbn07XHJcbiIsInZhciBQcm9taXNlID0gcmVxdWlyZSgncHJvbWlzZS1wb2x5ZmlsbCcpO1xyXG4vLyB2YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJyk7XHJcblxyXG52YXIgdWkgPSBnbG9iYWwudWk7XHJcblxyXG5mdW5jdGlvbiBkaWFsb2cgKHBhcmFtcykge1xyXG5cdHZhciBkbGcgPSB1aS5zaG93RGlhbG9nKCdvcGVuLWZpbGUnKTtcclxuXHR2YXIgb2tCdXR0b24gPSBkbGcuc2VsZWN0KCdpbnB1dFt2YWx1ZT1PS10nKVswXTtcclxuXHR2YXIgdGV4dElucHV0ID0gZGxnLnNlbGVjdCgndGV4dGFyZWEnKVswXTtcclxuXHR2YXIgZmlsZUlucHV0ID0gZGxnLnNlbGVjdCgnaW5wdXRbdHlwZT1maWxlXScpWzBdO1xyXG5cdHZhciBmcmFnbWVudElucHV0ID0gZGxnLnNlbGVjdCgnaW5wdXRbbmFtZT1mcmFnbWVudF0nKVswXTtcclxuXHR2YXIgcmVhZEZpbGU7XHJcblx0dmFyIGhhbmRsZXJzID0gW107XHJcblxyXG5cdGhhbmRsZXJzWzBdID0gZGxnLm9uKCdjbGljaycsICdpbnB1dFt0eXBlPWJ1dHRvbl0nLCBmdW5jdGlvbiAoXywgYnV0dG9uKSB7XHJcblx0XHRoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoKSB7IGguc3RvcCgpOyB9KTtcclxuXHRcdHVpLmhpZGVEaWFsb2coJ29wZW4tZmlsZScpO1xyXG5cclxuXHRcdHZhciBrZXkgPSAnb24nICsgYnV0dG9uLnZhbHVlLmNhcGl0YWxpemUoKTtcclxuXHRcdGlmIChwYXJhbXMgJiYga2V5IGluIHBhcmFtcykge1xyXG5cdFx0XHQvLyBUT0RPOiBnZW5lcmFsaXplIHRvIGZvcm0gc2VyaWFsaXphdGlvblxyXG5cdFx0XHRwYXJhbXNba2V5XSh7XHJcblx0XHRcdFx0ZnJhZ21lbnQ6IGZyYWdtZW50SW5wdXQuY2hlY2tlZCxcclxuXHRcdFx0XHR2YWx1ZTogdGV4dElucHV0LnZhbHVlXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHRoYW5kbGVyc1sxXSA9IGZpbGVJbnB1dC5vbignY2hhbmdlJywgZnVuY3Rpb24gKF8sIGlucHV0KSB7XHJcblx0XHRjb25zb2xlLmFzc2VydChyZWFkRmlsZSwgJ05vIHZhbGlkIGZpbGUgb3BlbmVyJyk7XHJcblx0XHRpZiAoaW5wdXQuZmlsZXMubGVuZ3RoKSB7XHJcblx0XHRcdGRsZy5zZWxlY3QoJ2lucHV0JykuZWFjaChmdW5jdGlvbiAoZWwpIHtcclxuXHRcdFx0XHRlbC5kaXNhYmxlZCA9IHRydWU7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRyZWFkRmlsZShpbnB1dC5maWxlc1swXSkudGhlbihmdW5jdGlvbiAoY29udGVudCkge1xyXG5cdFx0XHRcdHRleHRJbnB1dC52YWx1ZSA9IGNvbnRlbnQ7XHJcblx0XHRcdFx0ZGxnLnNlbGVjdCgnaW5wdXQnKS5lYWNoKGZ1bmN0aW9uIChlbCkge1xyXG5cdFx0XHRcdFx0ZWwuZGlzYWJsZWQgPSBmYWxzZTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSwgdWkuZWNobyk7XHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdGhhbmRsZXJzWzJdID0gdGV4dElucHV0Lm9uKCdpbnB1dCcsIGZ1bmN0aW9uIChfLCBpbnB1dCkge1xyXG5cdFx0dmFyIHRleHQgPSB0ZXh0SW5wdXQudmFsdWUudHJpbSgpO1xyXG5cdFx0b2tCdXR0b24uZGlzYWJsZWQgPSAhdGV4dDtcclxuXHR9KTtcclxuXHJcblx0dGV4dElucHV0LnZhbHVlID0gJyc7XHJcblx0ZnJhZ21lbnRJbnB1dC5jaGVja2VkID0gZmFsc2U7XHJcblx0b2tCdXR0b24uZGlzYWJsZWQgPSB0cnVlO1xyXG5cclxuXHRmaWxlSW5wdXQuZGlzYWJsZWQgPSB0cnVlO1xyXG5cdGZpbGVJbnB1dC5wYXJlbnROb2RlLmFkZENsYXNzTmFtZSgnZGlzYWJsZWQnKTtcclxuXHRmaWxlT3BlbmVyKCkudGhlbihmdW5jdGlvbiAoZikge1xyXG5cdFx0cmVhZEZpbGUgPSBmO1xyXG5cdFx0ZmlsZUlucHV0LmRpc2FibGVkID0gZmFsc2U7XHJcblx0XHRmaWxlSW5wdXQucGFyZW50Tm9kZS5yZW1vdmVDbGFzc05hbWUoJ2Rpc2FibGVkJyk7XHJcblx0fSk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBmaWxlT3BlbmVyICgpIHtcclxuXHRmdW5jdGlvbiB0aHJvdWdoRmlsZVJlYWRlcihmaWxlKSB7XHJcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG5cdFx0XHR2YXIgcmQgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG5cdFx0XHRyZC5vbmxvYWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuXHRcdFx0XHRyZXNvbHZlKGV2ZW50LnRhcmdldC5yZXN1bHQpO1xyXG5cdFx0XHR9O1xyXG5cdFx0XHRyZC5vbmVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0XHRcdFx0cmVqZWN0KGV2ZW50KTtcclxuXHRcdFx0fTtcclxuXHRcdFx0cmQucmVhZEFzVGV4dChmaWxlLCAnVVRGLTgnKTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHRmdW5jdGlvbiB0aHJvdWdoRmlsZVN5c3RlbU9iamVjdChmc28sIGZpbGUpIHtcclxuXHRcdC8vIElFOSBhbmQgYmVsb3dcclxuXHRcdHZhciBmZCA9ICBmc28uT3BlblRleHRGaWxlKGZpbGUubmFtZSwgMSksXHJcblx0XHRjb250ZW50ID0gZmQuUmVhZEFsbCgpO1xyXG5cdFx0ZmQuQ2xvc2UoKTtcclxuXHRcdHJldHVybiBjb250ZW50O1xyXG5cdH1cclxuXHRmdW5jdGlvbiB0aHJvdWdoRm9ybTJJZnJhbWVQb3N0aW5nKGZpbGUpIHtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuXHRcdC8vIFRPRE86IHJlZmFjdG9yIHJldHVyblxyXG5cdFx0aWYgKGdsb2JhbC5GaWxlUmVhZGVyKVxyXG5cdFx0XHRyZXR1cm4gcmVzb2x2ZSh0aHJvdWdoRmlsZVJlYWRlcik7XHJcblxyXG5cdFx0aWYgKGdsb2JhbC5BY3RpdmVYT2JqZWN0KSB7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0dmFyIGZzbyA9IG5ldyBnbG9iYWwuQWN0aXZlWE9iamVjdCgnU2NyaXB0aW5nLkZpbGVTeXN0ZW1PYmplY3QnKTtcclxuXHRcdFx0XHRyZXR1cm4gcmVzb2x2ZShmdW5jdGlvbiAoZmlsZSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aHJvdWdoRmlsZVN5c3RlbU9iamVjdChmc28sIGZpbGUpKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAodWkuc3RhbmRhbG9uZSlcclxuXHRcdFx0cmV0dXJuIHJlamVjdCgnU3RhbmRhbG9uZSBtb2RlIScpO1xyXG5cdFx0cmV0dXJuIHJlc29sdmUodGhyb3VnaEZvcm0ySWZyYW1lUG9zdGluZyk7XHJcblx0fSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxvYWRIb29rKCkge1xyXG5cdC8vIENhbGxlZCBmcm9tIGlmcmFtZSdzICdvbmxvYWQnXHJcbn1cclxuXHJcbi8vIGJhc2ljYWx5IGhhY2sgdG8gZXhwb3J0IGp1c3QgdGhlIGRpYWxvZyBmdW5jXHJcbmRpYWxvZy5sb2FkSG9vayA9IGxvYWRIb29rO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGRpYWxvZztcclxuIiwidmFyIFByb21pc2UgPSByZXF1aXJlKCdwcm9taXNlLXBvbHlmaWxsJyk7XHJcbnZhciBmcyA9IHJlcXVpcmUoJ2ZpbGVzYXZlci5qcycpO1xyXG5cclxudmFyIG1vbGZpbGUgPSByZXF1aXJlKCcuLi8uLi9jaGVtL21vbGZpbGUnKTtcclxudmFyIHNtaWxlcyA9IHJlcXVpcmUoJy4uLy4uL2NoZW0vc21pbGVzJyk7XHJcblxyXG52YXIgdWkgPSBnbG9iYWwudWk7XHJcblxyXG5mdW5jdGlvbiBzYXZlRGlhbG9nIChwYXJhbXMsIHNlcnZlcikge1xyXG5cdHZhciBkbGcgPSB1aS5zaG93RGlhbG9nKCdzYXZlLWZpbGUnKSxcclxuXHRvdXRwdXQgPSBkbGcuc2VsZWN0KCd0ZXh0YXJlYScpWzBdLFxyXG5cdGZvcm1hdElucHV0ID0gZGxnLnNlbGVjdCgnc2VsZWN0JylbMF0sXHJcblx0c2F2ZUJ1dHRvbiA9IGRsZy5zZWxlY3QoJy5zYXZlJylbMF0sXHJcblx0c2F2ZUZpbGUsXHJcblx0aGFuZGxlcnMgPSBbXTtcclxuXHJcblx0ZnVuY3Rpb24gb3V0cHV0TW9sZWN1bGUodGV4dCwgZm9ybWF0KSB7XHJcblx0XHRmb3JtYXQgPSBmb3JtYXQgfHwgJ21vbCc7XHJcblx0XHRvdXRwdXQudmFsdWUgPSB0ZXh0O1xyXG5cdFx0b3V0cHV0LmNsYXNzTmFtZSA9IGZvcm1hdDtcclxuXHRcdG91dHB1dC5hY3RpdmF0ZSgpO1xyXG5cdH1cclxuXHJcblx0aGFuZGxlcnNbMF0gPSBkbGcub24oJ2NsaWNrJywgJ2lucHV0W3R5cGU9YnV0dG9uXScsIGZ1bmN0aW9uIChfLCBidXR0b24pIHtcclxuXHRcdGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGgpIHsgaC5zdG9wKCk7IH0pO1xyXG5cdFx0dWkuaGlkZURpYWxvZygnc2F2ZS1maWxlJyk7XHJcblxyXG5cdFx0dmFyIGtleSA9ICdvbicgKyBidXR0b24udmFsdWUuY2FwaXRhbGl6ZSgpO1xyXG5cdFx0aWYgKHBhcmFtcyAmJiBrZXkgaW4gcGFyYW1zKSB7XHJcblx0XHRcdHBhcmFtc1trZXldKHt9KTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0aGFuZGxlcnNbMV0gPSBmb3JtYXRJbnB1dC5vbignY2hhbmdlJywgZnVuY3Rpb24gKF8sIGlucHV0KSB7XHJcblx0XHR2YXIgZm9ybWF0ID0gZm9ybWF0SW5wdXQudmFsdWU7XHJcblx0XHRjb252ZXJ0TW9sZWN1bGUoc2VydmVyLCBwYXJhbXMubW9sZWN1bGUsIGZvcm1hdCkudGhlbihmdW5jdGlvbiAocmVzKSB7XHJcblx0XHRcdG91dHB1dE1vbGVjdWxlKHJlcywgZm9ybWF0KTtcclxuXHRcdH0sIHVpLmVjaG8pO1xyXG5cdH0pO1xyXG5cclxuXHRoYW5kbGVyc1syXSA9IHNhdmVCdXR0b24ub24oJ2NsaWNrJywgZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0XHRpZiAoc2F2ZUZpbGUpIHtcclxuXHRcdFx0c2F2ZUZpbGUob3V0cHV0LnZhbHVlLCBmb3JtYXRJbnB1dC52YWx1ZSk7XHJcblx0XHRcdGRsZy5zZWxlY3QoJ2lucHV0W3R5cGU9YnV0dG9uXScpWzBdLmNsaWNrKCk7XHJcblx0XHR9XHJcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdH0pO1xyXG5cclxuXHRvdXRwdXRNb2xlY3VsZShtb2xmaWxlLnN0cmluZ2lmeShwYXJhbXMubW9sZWN1bGUpKTtcclxuXHRzYXZlQnV0dG9uLmFkZENsYXNzTmFtZSgnZGlzYWJsZWQnKTtcclxuXHRmaWxlU2F2ZXIoc2VydmVyKS50aGVuKGZ1bmN0aW9uIChmKSB7XHJcblx0XHRzYXZlRmlsZSA9IGY7XHJcblx0XHRzYXZlQnV0dG9uLnJlbW92ZUNsYXNzTmFtZSgnZGlzYWJsZWQnKTtcclxuXHR9KTtcclxuXHRmb3JtYXRJbnB1dC5zZWxlY3QoJ1t2YWx1ZT1pbmNoaV0nKVswXS5kaXNhYmxlZCA9IHVpLnN0YW5kYWxvbmU7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBmaWxlU2F2ZXIgKHNlcnZlcikge1xyXG5cdHZhciBtaW1lbWFwID0ge1xyXG5cdFx0J3NtaSc6ICdjaGVtaWNhbC94LWRheWxpZ2h0LXNtaWxlcycsXHJcblx0XHQnbW9sJzogJ2NoZW1pY2FsL3gtbWRsLW1vbGZpbGUnLFxyXG5cdFx0J3J4bic6ICdjaGVtaWNhbC94LW1kbC1yeG5maWxlJyxcclxuXHRcdCdpbmNoaSc6ICdjaGVtaWNhbC94LWluY2hpJ1xyXG5cdH07XHJcblx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuXHRcdGlmIChnbG9iYWwuQmxvYiAmJiBmcy5zYXZlQXMpXHJcblx0XHRcdHJlc29sdmUoZnVuY3Rpb24gKGRhdGEsIHR5cGUpIHtcclxuXHRcdFx0XHRpZiAodHlwZSA9PSAnbW9sJyAmJiBkYXRhLmluZGV4T2YoJyRSWE4nKSA9PSAwKVxyXG5cdFx0XHRcdFx0dHlwZSA9ICdyeG4nO1xyXG5cdFx0XHRcdGNvbnNvbGUuYXNzZXJ0KG1pbWVtYXBbdHlwZV0sICdVbmtub3duIGNoZW1pY2FsIGZpbGUgdHlwZScpO1xyXG5cdFx0XHRcdHZhciBibG9iID0gbmV3IEJsb2IoW2RhdGFdLCB7dHlwZTogbWltZW1hcFt0eXBlXSB9KTtcclxuXHRcdFx0XHRmcy5zYXZlQXMoYmxvYiwgJ2tldGNoZXIuJyArIHR5cGUpO1xyXG5cdFx0XHR9KTtcclxuXHRcdGVsc2UgaWYgKHVpLnN0YW5kYWxvbmUpXHJcblx0XHRcdHJlamVjdCgnU3RhbmRhbG9uZSBtb2RlIScpO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRyZXNvbHZlKGZ1bmN0aW9uIChkYXRhLCB0eXBlKSB7XHJcblx0XHRcdFx0c2VydmVyLnNhdmUoe2ZpbGVkYXRhOiBbdHlwZSwgZGF0YV0uam9pbignXFxuJyl9KTtcclxuXHRcdFx0fSk7XHJcblx0fSk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBjb252ZXJ0TW9sZWN1bGUgKHNlcnZlciwgbW9sZWN1bGUsIGZvcm1hdCkge1xyXG5cdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcblx0XHR2YXIgbW9sZGF0YSA9IG1vbGZpbGUuc3RyaW5naWZ5KG1vbGVjdWxlKTtcclxuXHRcdGlmIChmb3JtYXQgPT0gJ21vbCcpIHtcclxuXHRcdFx0cmVzb2x2ZShtb2xkYXRhKTtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYgKGZvcm1hdCA9PSAnc21pJykge1xyXG5cdFx0XHRyZXNvbHZlKHNtaWxlcy5zdHJpbmdpZnkobW9sZWN1bGUpKTtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYgKGZvcm1hdCA9PSAnaW5jaGknKSB7XHJcblx0XHRcdGlmICh1aS5zdGFuZGFsb25lKVxyXG5cdFx0XHRcdHRocm93IEVycm9yKCdJbkNoSSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBzdGFuZGFsb25lIG1vZGUnKTtcclxuXHJcblx0XHRcdGlmIChtb2xlY3VsZS5yZ3JvdXBzLmNvdW50KCkgIT09IDApXHJcblx0XHRcdFx0dWkuZWNobygnUi1ncm91cCBmcmFnbWVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgZGlzY2FyZGVkJyk7XHJcblx0XHRcdG1vbGVjdWxlID0gbW9sZWN1bGUuZ2V0U2NhZmZvbGQoKTtcclxuXHRcdFx0aWYgKG1vbGVjdWxlLmF0b21zLmNvdW50KCkgPT09IDApXHJcblx0XHRcdFx0cmVzb2x2ZSgnJyk7XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdG1vbGVjdWxlID0gbW9sZWN1bGUuY2xvbmUoKTtcclxuXHRcdFx0XHRtb2xlY3VsZS5zZ3JvdXBzLmVhY2goZnVuY3Rpb24gKHNnaWQsIHNnKSB7XHJcblx0XHRcdFx0XHQvLyA/IE5vdCBzdXJlIHdlIHNob3VsZCBjaGVjayBpdCBjbGllbnQgc2lkZVxyXG5cdFx0XHRcdFx0aWYgKHNnLnR5cGUgIT0gJ01VTCcgJiYgIS9eSU5ESUdPXy4rX0RFU0MkL2kudGVzdChzZy5kYXRhLmZpZWxkTmFtZSkpXHJcblx0XHRcdFx0XHRcdHRocm93IEVycm9yKCdJbkNoaSBkYXRhIGZvcm1hdCBkb2VzblxcJ3Qgc3VwcG9ydCBzLWdyb3VwcycpO1xyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRyZXNvbHZlKHNlcnZlci5pbmNoaSh7IG1vbGRhdGE6IG1vbGRhdGEgfSkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gc2F2ZURpYWxvZztcclxuIiwidmFyIHVpID0gZ2xvYmFsLnVpO1xyXG5cclxuZnVuY3Rpb24gZGlhbG9nIChuYW1lLCBwYXJhbXMpIHtcclxuXHR2YXIgZGxnID0gdWkuc2hvd0RpYWxvZyhuYW1lKTtcclxuXHR2YXIgb2tCdXR0b24gPSBkbGcuc2VsZWN0KCdpbnB1dFt2YWx1ZT1PS10nKVswXTtcclxuXHR2YXIgbW9kZSA9IHBhcmFtcy5tb2RlIHx8ICdzaW5nbGUnO1xyXG5cdHZhciBoYW5kbGVycyA9IFtdO1xyXG5cclxuXHRmdW5jdGlvbiBzZXRTZWxlY3RlZCh2YWx1ZXMpIHtcclxuXHRcdGRsZy5zZWxlY3QoJy5zZWxlY3RlZCcpLmVhY2goZnVuY3Rpb24gKGJ1dHRvbikge1xyXG5cdFx0XHRidXR0b24ucmVtb3ZlQ2xhc3NOYW1lKCdzZWxlY3RlZCcpO1xyXG5cdFx0fSk7XHJcblx0XHRpZiAodmFsdWVzKSB7XHJcblx0XHRcdGRsZy5zZWxlY3QoJ2J1dHRvbicpLmVhY2goZnVuY3Rpb24gKGJ1dHRvbikge1xyXG5cdFx0XHRcdHZhciB2YWx1ZSA9IGJ1dHRvbi52YWx1ZSB8fCBidXR0b24udGV4dENvbnRlbnQgfHwgYnV0dG9uLmlubmVyVGV4dDtcclxuXHRcdFx0XHRpZiAodmFsdWVzLmluZGV4T2YodmFsdWUpID49IDApIHtcclxuXHRcdFx0XHRcdGJ1dHRvbi5hZGRDbGFzc05hbWUoJ3NlbGVjdGVkJyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSBpZiAocGFyYW1zLnJlcXVpcmVkKSB7XHJcblx0XHRcdG9rQnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldFNlbGVjdGVkKCkge1xyXG5cdFx0dmFyIHZhbHVlcyA9IFtdO1xyXG5cdFx0ZGxnLnNlbGVjdCgnLnNlbGVjdGVkJykuZWFjaChmdW5jdGlvbiAoYnV0dG9uKSB7XHJcblx0XHRcdHZhciB2YWx1ZSA9IGJ1dHRvbi52YWx1ZSB8fCBidXR0b24udGV4dENvbnRlbnQgfHwgYnV0dG9uLmlubmVyVGV4dDtcclxuXHRcdFx0dmFsdWVzLnB1c2godmFsdWUpO1xyXG5cdFx0fSk7XHJcblx0XHRyZXR1cm4gdmFsdWVzO1xyXG5cdH1cclxuXHJcblx0aGFuZGxlcnNbMF0gPSBkbGcub24oJ2NsaWNrJywgJ2lucHV0W3R5cGU9YnV0dG9uXScsIGZ1bmN0aW9uIChfLCBidXR0b24pIHtcclxuXHRcdGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGgpIHsgaC5zdG9wKCk7IH0pO1xyXG5cdFx0dWkuaGlkZURpYWxvZyhuYW1lKTtcclxuXHJcblx0XHR2YXIga2V5ID0gJ29uJyArIGJ1dHRvbi52YWx1ZS5jYXBpdGFsaXplKCk7XHJcblxyXG5cdFx0Y29uc29sZS5hc3NlcnQoa2V5ICE9ICdvbk9rJyB8fCAhcGFyYW1zLnJlcXVpcmVkIHx8XHJcblx0XHQgICAgICAgICAgICAgICBnZXRTZWxlY3RlZCgpLmxlbmd0aCAhPSAwLFxyXG5cdFx0ICAgICAgICAgICAgICAgJ05vIGVsZW1lbnRzIHNlbGVjdGVkJyk7XHJcblx0XHRpZiAocGFyYW1zICYmIGtleSBpbiBwYXJhbXMpIHtcclxuXHRcdFx0cGFyYW1zW2tleV0oe1xyXG5cdFx0XHRcdG1vZGU6IG1vZGUsXHJcblx0XHRcdFx0dmFsdWVzOiBnZXRTZWxlY3RlZCgpXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHRoYW5kbGVyc1sxXSA9IGRsZy5vbignY2xpY2snLCAnYnV0dG9uJywgZnVuY3Rpb24gKGV2ZW50LCBidXR0b24pIHtcclxuXHRcdGlmIChtb2RlID09PSAnc2luZ2xlJykge1xyXG5cdFx0XHRpZiAoIWJ1dHRvbi5oYXNDbGFzc05hbWUoJ3NlbGVjdGVkJykpIHtcclxuXHRcdFx0XHRzZXRTZWxlY3RlZChudWxsKTtcclxuXHRcdFx0fSBlbHNlIGlmIChwYXJhbXMucmVxdWlyZWQpIHtcclxuXHRcdFx0XHRva0J1dHRvbi5jbGljaygpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0YnV0dG9uLnRvZ2dsZUNsYXNzTmFtZSgnc2VsZWN0ZWQnKTtcclxuXHRcdGlmIChwYXJhbXMucmVxdWlyZWQpIHtcclxuXHRcdFx0b2tCdXR0b24uZGlzYWJsZWQgPSBkbGcuc2VsZWN0KCcuc2VsZWN0ZWQnKS5sZW5ndGggPT09IDA7XHJcblx0XHR9XHJcblx0XHRldmVudC5zdG9wKCk7XHJcblx0fSk7XHJcblxyXG5cdGhhbmRsZXJzWzJdID0gZGxnLm9uKCdjbGljaycsICdpbnB1dFtuYW1lPW1vZGVdJywgZnVuY3Rpb24gKF8sIHJhZGlvKSB7XHJcblx0XHRpZiAocmFkaW8udmFsdWUgIT0gbW9kZSkge1xyXG5cdFx0XHRpZiAocmFkaW8udmFsdWUgPT0gJ3NpbmdsZScpIHtcclxuXHRcdFx0XHRzZXRTZWxlY3RlZChudWxsKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRtb2RlID0gcmFkaW8udmFsdWU7XHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdHNldFNlbGVjdGVkKHBhcmFtcy52YWx1ZXMpO1xyXG5cdGRsZy5zZWxlY3QoJ2lucHV0W25hbWU9bW9kZV0nKS5lYWNoKGZ1bmN0aW9uIChyYWRpbykge1xyXG5cdFx0aWYgKHJhZGlvLnZhbHVlID09IG1vZGUpIHtcclxuXHRcdFx0cmFkaW8uY2hlY2tlZCA9IHRydWU7XHJcblx0XHR9XHJcblx0fSk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZGlhbG9nO1xyXG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcclxuXHJcbnZhciB1aSA9IGdsb2JhbC51aTtcclxuXHJcbmZ1bmN0aW9uIGRpYWxvZyAocGFyYW1zKSB7XHJcblx0dmFyIGRsZyA9IHVpLnNob3dEaWFsb2coJ3Nncm91cF9zcGVjaWFsJyk7XHJcblx0dmFyIGNhY2hlID0ge307XHJcblx0dmFyIGhhbmRsZXJzID0gW107XHJcblxyXG5cdGNvbnNvbGUuYXNzZXJ0KCFwYXJhbXMudHlwZSB8fCBwYXJhbXMudHlwZSA9PSAnREFUJyk7XHJcblx0Y29uc29sZS5hc3NlcnQoIXBhcmFtcy50eXBlIHx8IHBhcmFtcy5hdHRycy5maWVsZE5hbWUpO1xyXG5cclxuXHR2YXIgY29udGV4dCA9IHBhcmFtcy50eXBlICYmIG1hdGNoQ29udGV4dChwYXJhbXMuYXR0cnMuZmllbGROYW1lLCBwYXJhbXMuYXR0cnMuZmllbGRWYWx1ZSkgfHxcclxuXHRcdCAgICAgICAgICBwYXJhbXMuY29udGV4dCB8fCAnRnJhZ21lbnQnO1xyXG5cdHNldENvbnRleHQoY29udGV4dCwgY2FjaGUsIHRydWUpO1xyXG5cdGlmIChwYXJhbXMuYXR0cnMuZmllbGROYW1lKVxyXG5cdFx0c2V0RmllbGQocGFyYW1zLmF0dHJzLmZpZWxkTmFtZSwgY2FjaGUsIHRydWUpO1xyXG5cclxuXHQkKCdzZ3JvdXBfc3BlY2lhbF92YWx1ZScpLnZhbHVlID0gcGFyYW1zLmF0dHJzLmZpZWxkVmFsdWU7XHJcblx0aWYgKHBhcmFtcy5hdHRycy5hdHRhY2hlZClcclxuXHRcdCQoJ3Nncm91cF9zcGVjaWFsX2F0dGFjaGVkJykuY2hlY2tlZCA9IHRydWU7XHJcblx0ZWxzZSBpZiAocGFyYW1zLmF0dHJzLmFic29sdXRlKVxyXG5cdFx0JCgnc2dyb3VwX3NwZWNpYWxfYWJzb2x1dGUnKS5jaGVja2VkID0gdHJ1ZTtcclxuXHRlbHNlXHJcblx0XHQkKCdzZ3JvdXBfc3BlY2lhbF9yZWxhdGl2ZScpLmNoZWNrZWQgPSB0cnVlO1xyXG5cclxuXHRoYW5kbGVyc1swXSA9IGRsZy5vbignY2xpY2snLCAnaW5wdXRbdHlwZT1idXR0b25dJywgZnVuY3Rpb24gKF8sIGJ1dHRvbikge1xyXG5cdFx0dmFyIGtleSA9ICdvbicgKyBidXR0b24udmFsdWUuY2FwaXRhbGl6ZSgpO1xyXG5cdFx0dmFyIHJlcyA9IGtleSAhPSAnb25PaycgfHwgZ2V0VmFsaWRhdGVBdHRycygpO1xyXG5cdFx0aWYgKHJlcykge1xyXG5cdFx0XHRoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoKSB7IGguc3RvcCgpOyB9KTtcclxuXHRcdFx0dWkuaGlkZURpYWxvZygnc2dyb3VwX3NwZWNpYWwnKTtcclxuXHRcdFx0aWYgKGtleSBpbiBwYXJhbXMgJiYgcmVzKVxyXG5cdFx0XHRcdHBhcmFtc1trZXldKHJlcyk7XHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdGhhbmRsZXJzWzFdID0gZGxnLm9uKCdjaGFuZ2UnLCAnc2VsZWN0JywgZnVuY3Rpb24gKF8sIHNlbGVjdCkge1xyXG5cdFx0aWYgKHNlbGVjdC5pZCA9PSAnc2dyb3VwX2NvbnRleHQnKVxyXG5cdFx0XHRzZXRDb250ZXh0KCQoJ3Nncm91cF9jb250ZXh0JykudmFsdWUsIGNhY2hlKTtcclxuXHRcdGlmIChzZWxlY3QuaWQgPT0gJ3Nncm91cF9zcGVjaWFsX25hbWUnKVxyXG5cdFx0XHRzZXRGaWVsZCgkKCdzZ3JvdXBfc3BlY2lhbF9uYW1lJykudmFsdWUsIGNhY2hlKTtcclxuXHR9KTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGdldFZhbGlkYXRlQXR0cnMoKSB7XHJcblx0dmFyIGF0dHJzID0ge1xyXG5cdFx0bXVsOiBudWxsLFxyXG5cdFx0Y29ubmVjdGl2aXR5OiAnJyxcclxuXHRcdG5hbWU6ICcnLFxyXG5cdFx0c3Vic2NyaXB0OiAnJ1xyXG5cdH07XHJcblxyXG5cdGF0dHJzLmZpZWxkTmFtZSA9ICQoJ3Nncm91cF9zcGVjaWFsX25hbWUnKS52YWx1ZS5zdHJpcCgpO1xyXG5cdGF0dHJzLmZpZWxkVmFsdWUgPSAkKCdzZ3JvdXBfc3BlY2lhbF92YWx1ZScpLnZhbHVlLnN0cmlwKCk7XHJcblx0YXR0cnMuYWJzb2x1dGUgPSAkKCdzZ3JvdXBfc3BlY2lhbF9hYnNvbHV0ZScpLmNoZWNrZWQ7XHJcblx0YXR0cnMuYXR0YWNoZWQgPSAkKCdzZ3JvdXBfc3BlY2lhbF9hdHRhY2hlZCcpLmNoZWNrZWQ7XHJcblxyXG5cdGlmIChhdHRycy5maWVsZFZhbHVlID09ICcnKSB7XHJcblx0XHRhbGVydCgnUGxlYXNlLCBzcGVjaWZ5IGRhdGEgZmllbGQgdmFsdWUuJyk7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblxyXG5cdHJldHVybiB7IHR5cGU6ICdEQVQnLFxyXG5cdCAgICAgICAgIGF0dHJzOiBhdHRycyB9O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gc2V0Q29udGV4dChjb250ZXh0LCBjYWNoZSwgZm9yY2UpIHtcclxuXHRjb25zb2xlLmluZm8oJ3NldCBjb250ZXh0OicsIGNvbnRleHQsIGNhY2hlKTtcclxuXHRjb25zb2xlLmFzc2VydChjYWNoZS5jb250ZXh0IHx8IGZvcmNlLCAnRmllbGQgc2V0dXAgc2hvdWxkIGJlIGZvcmNlZCcpO1xyXG5cdGlmIChmb3JjZSB8fCBjb250ZXh0ICE9IGNhY2hlLmNvbnRleHQubmFtZSkge1xyXG5cdFx0Y2FjaGUuY29udGV4dCA9IHV0aWwuZmluZChzcGVjaWFsX2Nob2ljZXMsIGZ1bmN0aW9uIChvcHQpIHtcclxuXHRcdFx0cmV0dXJuIG9wdC5uYW1lID09IGNvbnRleHQ7XHJcblx0XHR9KTtcclxuXHRcdGNvbnNvbGUuYXNzZXJ0KGNhY2hlLmNvbnRleHQsICdDYW5cXCd0IGZpbmQgc3VjaCBjb250ZXh0Jyk7XHJcblx0XHR2YXIgc3RyID0gY2FjaGUuY29udGV4dC52YWx1ZS5yZWR1Y2UoZnVuY3Rpb24gKHJlcywgb3B0KSB7XHJcblx0XHRcdHJldHVybiByZXMgKyAnPG9wdGlvbiB2YWx1ZT1cIicgKyBvcHQubmFtZSArICdcIj4nICsgb3B0Lm5hbWUgKyBcIjwvb3B0aW9uPlwiO1xyXG5cdFx0fSwgJycpO1xyXG5cdFx0JCgnc2dyb3VwX3NwZWNpYWxfbmFtZScpLnVwZGF0ZShzdHIpO1xyXG5cdFx0c2V0RmllbGQoY2FjaGUuY29udGV4dC52YWx1ZVswXS5uYW1lLCBjYWNoZSwgdHJ1ZSk7XHJcblx0XHRpZiAoZm9yY2UpXHJcblx0XHRcdCQoJ3Nncm91cF9jb250ZXh0JykudmFsdWUgPSBjb250ZXh0O1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gc2V0RmllbGQoZmllbGQsIGNhY2hlLCBmb3JjZSkge1xyXG5cdGNvbnNvbGUuaW5mbygnc2V0IGZpZWxkOicsIGZpZWxkLCBjYWNoZSk7XHJcblx0Y29uc29sZS5hc3NlcnQoY2FjaGUuZmllbGQgfHwgZm9yY2UsICdGaWVsZCBzZXR1cCBzaG91bGQgYmUgZm9yY2VkJyk7XHJcblx0aWYgKGZpZWxkIHx8IGZpZWxkICE9IGNhY2hlLmZpZWxkLm5hbWUpIHtcclxuXHRcdGNhY2hlLmZpZWxkID0gdXRpbC5maW5kKGNhY2hlLmNvbnRleHQudmFsdWUsIGZ1bmN0aW9uIChvcHQpIHtcclxuXHRcdFx0cmV0dXJuIG9wdC5uYW1lID09IGZpZWxkO1xyXG5cdFx0fSk7XHJcblx0XHRjb25zb2xlLmFzc2VydChjYWNoZS5maWVsZCwgJ0NhblxcJ3QgZmluZCBzdWNoIGZpZWxkJyk7XHJcblx0XHRpZiAoIWNhY2hlLmZpZWxkLnZhbHVlKVxyXG5cdFx0XHQkKCdzZ3JvdXBfc3BlY2lhbF92YWx1ZScpLm91dGVySFRNTCA9ICc8dGV4dGFyZWEgaWQ9XCJzZ3JvdXBfc3BlY2lhbF92YWx1ZVwiPjwvdGV4dGFyZWE+JztcclxuXHRcdGVsc2Uge1xyXG5cdFx0XHR2YXIgc3RyID0gY2FjaGUuZmllbGQudmFsdWUucmVkdWNlKGZ1bmN0aW9uIChyZXMsIG9wdCkge1xyXG5cdFx0XHRcdHJldHVybiByZXMgKyAnPG9wdGlvbiB2YWx1ZT1cIicgKyBvcHQgKyAnXCI+JyArIG9wdCArIFwiPC9vcHRpb24+XCI7XHJcblx0XHRcdH0sICcnKTtcclxuXHRcdFx0JCgnc2dyb3VwX3NwZWNpYWxfdmFsdWUnKS5vdXRlckhUTUwgPSAnPHNlbGVjdCBzaXplPVwiMTBcIiBpZD1cInNncm91cF9zcGVjaWFsX3ZhbHVlXCI+JyArIHN0ciArICc8L3NlbGVjdD4nO1xyXG5cdFx0fVxyXG5cdFx0JCgnc2dyb3VwX3NwZWNpYWxfbmFtZScpLnZhbHVlID0gZmllbGQ7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBtYXRjaENvbnRleHQoZmllbGQsIHZhbHVlKSB7XHJcblx0Y29uc29sZS5pbmZvKCdzZWFyY2g6JywgdXRpbC51bmljb2RlTGl0ZXJhbChmaWVsZCksIHV0aWwudW5pY29kZUxpdGVyYWwodmFsdWUpKTtcclxuXHR2YXIgYyA9IHV0aWwuZmluZChzcGVjaWFsX2Nob2ljZXMsIGZ1bmN0aW9uKGMpIHtcclxuXHRcdHZhciBmID0gdXRpbC5maW5kKGMudmFsdWUsIGZ1bmN0aW9uKGYpIHtcclxuXHRcdFx0cmV0dXJuIGYubmFtZSA9PSBmaWVsZDtcclxuXHRcdH0pO1xyXG5cdFx0aWYgKCFmKVxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRyZXR1cm4gIXZhbHVlIHx8ICFmLnZhbHVlIHx8ICEhdXRpbC5maW5kKGYudmFsdWUsIGZ1bmN0aW9uKHYpIHtcclxuXHRcdFx0cmV0dXJuIHYgPT0gdmFsdWU7XHJcblx0XHR9KTtcclxuXHR9KTtcclxuXHRyZXR1cm4gYyAmJiBjLm5hbWU7XHJcbn1cclxuXHJcbnZhciBzcGVjaWFsX2Nob2ljZXMgPSBbXHJcblx0eyBuYW1lOiAnRnJhZ21lbnQnLFxyXG5cdCAgdmFsdWU6IFtcclxuXHRcdCAgeyBuYW1lOiAnTURMQkdfRlJBR01FTlRfU1RFUkVPJyxcclxuXHRcdCAgICB2YWx1ZTogW1xyXG5cdFx0XHQnYWJzJyxcclxuXHRcdFx0JygrKS1lbmFudGlvbWVyJyxcclxuXHRcdFx0JygtKS1lbmFudGlvbWVyJyxcclxuXHRcdFx0J3N0ZXJpYycsXHJcblx0XHRcdCdyZWwnLFxyXG5cdFx0XHQnUihhKScsXHJcblx0XHRcdCdTKGEpJyxcclxuXHRcdFx0J1IocCknLFxyXG5cdFx0XHQnUyhwKSdcclxuXHRcdCAgICBdfSxcclxuXHRcdCAgeyBuYW1lOiAnTURMQkdfRlJBR01FTlRfQ09FRkZJQ0lFTlQnLFxyXG5cdFx0ICAgIHZhbHVlOiBudWxsfSxcclxuXHRcdCAgeyBuYW1lOiAnTURMQkdfRlJBR01FTlRfQ0hBUkdFJyxcclxuXHRcdCAgICB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0ICB7IG5hbWU6ICdNRExCR19GUkFHTUVOVF9SQURJQ0FMUycsXHJcblx0XHQgICAgdmFsdWU6IG51bGwgfSxcclxuXHRdfSxcclxuXHR7IG5hbWU6ICdTaW5nbGUgQm9uZCcsXHJcblx0ICB2YWx1ZTogW1xyXG5cdFx0ICB7IG5hbWU6ICdNRExCR19TVEVSRU9fS0VZJyxcclxuXHRcdCAgICB2YWx1ZTogW1xyXG5cdFx0XHQnZXJ5dGhybycsXHJcblx0XHRcdCd0aHJlbycsXHJcblx0XHRcdCdhbHBoYScsXHJcblx0XHRcdCdiZXRhJyxcclxuXHRcdFx0J2VuZG8nLFxyXG5cdFx0XHQnZXhvJyxcclxuXHRcdFx0J2FudGknLFxyXG5cdFx0XHQnc3luJyxcclxuXHRcdFx0J0VDTCcsXHJcblx0XHRcdCdTVEcnXHJcblx0XHQgICAgXX0sXHJcblx0XHQgIHsgbmFtZTogJ01ETEJHX0JPTkRfS0VZJyxcclxuXHRcdCAgICB2YWx1ZTogW1xyXG5cdFx0XHQgICAgJ1ZhbHVlPTQnXHJcblx0XHQgICAgXX0sXHJcblx0XX0sXHJcblx0eyBuYW1lOiAnQXRvbScsXHJcblx0ICB2YWx1ZTogW1xyXG5cdFx0ICB7IG5hbWU6ICdNRExCR19TVEVSRU9fS0VZJyxcclxuXHRcdCAgICB2YWx1ZTogW1xyXG5cdFx0XHQnUlMnLFxyXG5cdFx0XHQnU1InLFxyXG5cdFx0XHQnUC0zJyxcclxuXHRcdFx0J1AtMy1QSScsXHJcblx0XHRcdCdTUC00JyxcclxuXHRcdFx0J1NQLTQtUEknLFxyXG5cdFx0XHQnVC00JyxcclxuXHRcdFx0J1QtNC1QSScsXHJcblx0XHRcdCdTUC01JyxcclxuXHRcdFx0J1NQLTUtUEknLFxyXG5cdFx0XHQnVEItNScsXHJcblx0XHRcdCdUQi01LVBJJyxcclxuXHRcdFx0J09DLTYnLFxyXG5cdFx0XHQnVEItNS1QSScsXHJcblx0XHRcdCdUUC02JyxcclxuXHRcdFx0J1BCLTcnLFxyXG5cdFx0XHQnQ1UtOCcsXHJcblx0XHRcdCdTQS04JyxcclxuXHRcdFx0J0RELTgnLFxyXG5cdFx0XHQnSEItOScsXHJcblx0XHRcdCdUUFMtOScsXHJcblx0XHRcdCdIQi05J1xyXG5cdFx0XX1cclxuXHRdfSxcclxuXHR7IG5hbWU6ICdHcm91cCcsXHJcblx0ICB2YWx1ZTogW1xyXG5cdFx0ICB7IG5hbWU6ICdNRExCR19TVEVSRU9fS0VZJyxcclxuXHRcdCAgICB2YWx1ZTogW1xyXG5cdFx0XHQnY2lzJyxcclxuXHRcdFx0J3RyYW5zJ1xyXG5cdFx0ICAgIF19XHJcblx0ICBdfVxyXG5dO1xyXG5cclxuZGlhbG9nLm1hdGNoID0gZnVuY3Rpb24gKHBhcmFtcykge1xyXG5cdHJldHVybiAhcGFyYW1zLnR5cGUgfHxcclxuXHRcdHBhcmFtcy50eXBlID09ICdEQVQnICYmICEhbWF0Y2hDb250ZXh0KHBhcmFtcy5hdHRycy5maWVsZE5hbWUsIHBhcmFtcy5hdHRycy5maWVsZFZhbHVlKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZGlhbG9nO1xyXG4iLCIvLyBUT0RPOiBleGNsdWRlIGZyb20gbm8tZ3JvdXBzIGJ1aWxkXHJcbnZhciB1aSA9IGdsb2JhbC51aTtcclxuXHJcbmZ1bmN0aW9uIGRpYWxvZyAocGFyYW1zKSB7XHJcblx0dmFyIGRsZyA9IHVpLnNob3dEaWFsb2coJ3Nncm91cF9wcm9wZXJ0aWVzJyk7XHJcblx0dmFyIHR5cGUgPSBwYXJhbXMudHlwZSB8fCAnR0VOJztcclxuXHJcblx0JCgnc2dyb3VwX3R5cGUnKS52YWx1ZSA9IHR5cGU7XHJcblx0JCgnc2dyb3VwX3R5cGUnKS5hY3RpdmF0ZSgpO1xyXG5cdG9uQ2hhbmdlX1NHcm91cFR5cGUuY2FsbCgkKCdzZ3JvdXBfdHlwZScpKTtcclxuXHJcblx0c3dpdGNoICh0eXBlKSB7XHJcblx0Y2FzZSAnU1JVJzpcclxuXHRcdCQoJ3Nncm91cF9jb25uZWN0aW9uJykudmFsdWUgPSBwYXJhbXMuYXR0cnMuY29ubmVjdGl2aXR5O1xyXG5cdFx0JCgnc2dyb3VwX2xhYmVsJykudmFsdWUgPSBwYXJhbXMuYXR0cnMuc3Vic2NyaXB0O1xyXG5cdFx0YnJlYWs7XHJcblx0Y2FzZSAnTVVMJzpcclxuXHRcdCQoJ3Nncm91cF9sYWJlbCcpLnZhbHVlID0gcGFyYW1zLmF0dHJzLm11bDtcclxuXHRcdGJyZWFrO1xyXG5cdGNhc2UgJ1NVUCc6XHJcblx0XHQkKCdzZ3JvdXBfbGFiZWwnKS52YWx1ZSA9IHBhcmFtcy5hdHRycy5uYW1lO1xyXG5cdFx0YnJlYWs7XHJcblx0Y2FzZSAnREFUJzpcclxuXHRcdCQoJ3Nncm91cF9maWVsZF9uYW1lJykudmFsdWUgPSBwYXJhbXMuYXR0cnMuZmllbGROYW1lO1xyXG5cdFx0JCgnc2dyb3VwX2ZpZWxkX3ZhbHVlJykudmFsdWUgPSBwYXJhbXMuYXR0cnMuZmllbGRWYWx1ZTtcclxuXHRcdGlmIChwYXJhbXMuYXR0cnMuYXR0YWNoZWQpXHJcblx0XHRcdCQoJ3Nncm91cF9wb3NfYXR0YWNoZWQnKS5jaGVja2VkID0gdHJ1ZTtcclxuXHRcdGVsc2UgaWYgKHBhcmFtcy5hdHRycy5hYnNvbHV0ZSlcclxuXHRcdFx0JCgnc2dyb3VwX3Bvc19hYnNvbHV0ZScpLmNoZWNrZWQgPSB0cnVlO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHQkKCdzZ3JvdXBfcG9zX3JlbGF0aXZlJykuY2hlY2tlZCA9IHRydWU7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0ZGVmYXVsdDpcclxuXHRcdFx0YnJlYWs7XHJcblx0fVxyXG5cclxuXHRpZiAodHlwZSAhPSAnREFUJykge1xyXG5cdFx0JCgnc2dyb3VwX2ZpZWxkX25hbWUnKS52YWx1ZSA9ICcnO1xyXG5cdFx0JCgnc2dyb3VwX2ZpZWxkX3ZhbHVlJykudmFsdWUgPSAnJztcclxuXHR9XHJcblxyXG5cdHZhciBoYW5kbGVycyA9IFtdO1xyXG5cdGhhbmRsZXJzWzBdID0gZGxnLm9uKCdjbGljaycsICdpbnB1dFt0eXBlPWJ1dHRvbl0nLCBmdW5jdGlvbiAoXywgYnV0dG9uKSB7XHJcblx0XHR2YXIga2V5ID0gJ29uJyArIGJ1dHRvbi52YWx1ZS5jYXBpdGFsaXplKCk7XHJcblx0XHR2YXIgcmVzID0ga2V5ICE9ICdvbk9rJyB8fCBnZXRWYWxpZGF0ZUF0dHJzKCk7XHJcblx0XHRpZiAocmVzKSB7XHJcblx0XHRcdGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGgpIHsgaC5zdG9wKCk7IH0pO1xyXG5cdFx0XHR1aS5oaWRlRGlhbG9nKCdzZ3JvdXBfcHJvcGVydGllcycpO1xyXG5cdFx0XHRpZiAoa2V5IGluIHBhcmFtcyAmJiByZXMpXHJcblx0XHRcdFx0cGFyYW1zW2tleV0ocmVzKTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0aGFuZGxlcnNbMV0gPSAkKCdzZ3JvdXBfdHlwZScpLm9uKCdjaGFuZ2UnLCBvbkNoYW5nZV9TR3JvdXBUeXBlKTtcclxuXHRoYW5kbGVyc1syXSA9ICQoJ3Nncm91cF9sYWJlbCcpLm9uKCdjaGFuZ2UnLCBvbkNoYW5nZV9TR3JvdXBMYWJlbCk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBnZXRWYWxpZGF0ZUF0dHJzKCkge1xyXG5cdHZhciB0eXBlID0gJCgnc2dyb3VwX3R5cGUnKS52YWx1ZTtcclxuXHR2YXIgYXR0cnMgPSB7XHJcblx0XHRtdWw6IG51bGwsXHJcblx0XHRjb25uZWN0aXZpdHk6ICcnLFxyXG5cdFx0bmFtZTogJycsXHJcblx0XHRzdWJzY3JpcHQ6ICcnLFxyXG5cdFx0ZmllbGROYW1lOiAnJyxcclxuXHRcdGZpZWxkVmFsdWU6ICcnLFxyXG5cdFx0YXR0YWNoZWQ6IGZhbHNlLFxyXG5cdFx0YWJzb2x1dGU6IGZhbHNlXHJcblx0fTtcclxuXHJcblx0c3dpdGNoICh0eXBlKSB7XHJcblx0Y2FzZSAnU1JVJzpcclxuXHRcdGF0dHJzLmNvbm5lY3Rpdml0eSA9ICQoJ3Nncm91cF9jb25uZWN0aW9uJykudmFsdWUuc3RyaXAoKTtcclxuXHRcdGF0dHJzLnN1YnNjcmlwdCA9ICQoJ3Nncm91cF9sYWJlbCcpLnZhbHVlLnN0cmlwKCk7XHJcblx0XHRpZiAoYXR0cnMuc3Vic2NyaXB0Lmxlbmd0aCAhPSAxIHx8ICFhdHRycy5zdWJzY3JpcHQubWF0Y2goL15bYS16QS1aXSQvKSkge1xyXG5cdFx0XHRhbGVydChhdHRycy5zdWJzY3JpcHQubGVuZ3RoID8gJ1NSVSBzdWJzY3JpcHQgc2hvdWxkIGNvbnNpc3Qgb2YgYSBzaW5nbGUgbGV0dGVyLicgOiAnUGxlYXNlIHByb3ZpZGUgYW4gU1JVIHN1YnNjcmlwdC4nKTtcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblx0XHRicmVhaztcclxuXHRjYXNlICdNVUwnOlxyXG5cdFx0YXR0cnMubXVsID0gcGFyc2VJbnQoJCgnc2dyb3VwX2xhYmVsJykudmFsdWUpO1xyXG5cdFx0YnJlYWs7XHJcblx0Y2FzZSAnU1VQJzpcclxuXHRcdGF0dHJzLm5hbWUgPSAkKCdzZ3JvdXBfbGFiZWwnKS52YWx1ZS5zdHJpcCgpO1xyXG5cdFx0aWYgKCFhdHRycy5uYW1lKSB7XHJcblx0XHRcdGFsZXJ0KCdQbGVhc2UgcHJvdmlkZSBhIG5hbWUgZm9yIHRoZSBzdXBlcmF0b20uJyk7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cdFx0YnJlYWs7XHJcblx0Y2FzZSAnREFUJzpcclxuXHRcdGF0dHJzLmZpZWxkTmFtZSA9ICQoJ3Nncm91cF9maWVsZF9uYW1lJykudmFsdWUuc3RyaXAoKTtcclxuXHRcdGF0dHJzLmZpZWxkVmFsdWUgPSAkKCdzZ3JvdXBfZmllbGRfdmFsdWUnKS52YWx1ZS5zdHJpcCgpO1xyXG5cdFx0YXR0cnMuYWJzb2x1dGUgPSAkKCdzZ3JvdXBfcG9zX2Fic29sdXRlJykuY2hlY2tlZDtcclxuXHRcdGF0dHJzLmF0dGFjaGVkID0gJCgnc2dyb3VwX3Bvc19hdHRhY2hlZCcpLmNoZWNrZWQ7XHJcblxyXG5cdFx0aWYgKGF0dHJzLmZpZWxkTmFtZSA9PSAnJyB8fCBhdHRycy5maWVsZFZhbHVlID09ICcnKSB7XHJcblx0XHRcdGFsZXJ0KCdQbGVhc2UsIHNwZWNpZnkgZGF0YSBmaWVsZCBuYW1lIGFuZCB2YWx1ZS4nKTtcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblx0XHRicmVhaztcclxuXHR9XHJcblx0cmV0dXJuIHsgdHlwZTogdHlwZSxcclxuXHQgICAgICAgICBhdHRyczogYXR0cnMgfTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIG9uQ2hhbmdlX1NHcm91cExhYmVsICgpXHJcbntcclxuXHRpZiAoJCgnc2dyb3VwX3R5cGUnKS52YWx1ZSA9PSAnTVVMJyAmJiAhdGhpcy52YWx1ZS5tYXRjaCgvXlsxLTldWzAtOV17MCwyfSQvKSlcclxuXHRcdHRoaXMudmFsdWUgPSAnMSc7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBvbkNoYW5nZV9TR3JvdXBUeXBlICgpXHJcbntcclxuXHR2YXIgdHlwZSA9ICQoJ3Nncm91cF90eXBlJykudmFsdWU7XHJcblx0aWYgKHR5cGUgPT0gJ0RBVCcpIHtcclxuXHRcdCQkKCcjc2dyb3VwX3Byb3BlcnRpZXMgLmJhc2UnKVswXS5oaWRlKCk7XHJcblx0XHQkJCgnI3Nncm91cF9wcm9wZXJ0aWVzIC5kYXRhJylbMF0uc2hvdygpO1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHQkJCgnI3Nncm91cF9wcm9wZXJ0aWVzIC5iYXNlJylbMF0uc2hvdygpO1xyXG5cdCQkKCcjc2dyb3VwX3Byb3BlcnRpZXMgLmRhdGEnKVswXS5oaWRlKCk7XHJcblxyXG5cdCQoJ3Nncm91cF9sYWJlbCcpLmRpc2FibGVkID0gKHR5cGUgIT0gJ1NSVScpICYmICh0eXBlICE9ICdNVUwnKSAmJiAodHlwZSAhPSAnU1VQJyk7XHJcblx0JCgnc2dyb3VwX2Nvbm5lY3Rpb24nKS5kaXNhYmxlZCA9ICh0eXBlICE9ICdTUlUnKTtcclxuXHJcblx0aWYgKHR5cGUgPT0gJ01VTCcgJiYgISQoJ3Nncm91cF9sYWJlbCcpLnZhbHVlLm1hdGNoKC9eWzEtOV1bMC05XXswLDJ9JC8pKVxyXG5cdFx0JCgnc2dyb3VwX2xhYmVsJykudmFsdWUgPSAnMSc7XHJcblx0ZWxzZSBpZiAodHlwZSA9PSAnU1JVJylcclxuXHRcdCQoJ3Nncm91cF9sYWJlbCcpLnZhbHVlID0gJ24nO1xyXG5cdGVsc2UgaWYgKHR5cGUgPT0gJ0dFTicgfHwgdHlwZSA9PSAnU1VQJylcclxuXHRcdCQoJ3Nncm91cF9sYWJlbCcpLnZhbHVlID0gJyc7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZGlhbG9nO1xyXG4iLCJ2YXIgUHJvbWlzZSA9IHJlcXVpcmUoJ3Byb21pc2UtcG9seWZpbGwnKTtcclxucmVxdWlyZSgnLi4vLi4vcm5kJyk7XHJcblxyXG52YXIgYWpheCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvYWpheC5qcycpO1xyXG52YXIgbW9sZmlsZSA9IHJlcXVpcmUoJy4uLy4uL2NoZW0vbW9sZmlsZScpO1xyXG5cclxudmFyIHVpID0gZ2xvYmFsLnVpO1xyXG52YXIgcm5kID0gZ2xvYmFsLnJuZDtcclxuXHJcbi8vIFRPRE86IG1vdmUgdG8gTW9sZmlsZVxyXG5mdW5jdGlvbiBwYXJzZVNkZiAoc2RmKSB7XHJcblx0dmFyIGl0ZW1zID0gc2RmLnNwbGl0KC9eWyRdWyRdWyRdWyRdJC9tKTtcclxuXHR2YXIgcGFyc2VkID0gW107XHJcblxyXG5cdGl0ZW1zLmVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcclxuXHRcdGl0ZW0gPSBpdGVtLnJlcGxhY2UoL1xcci9nLCAnJyk7XHJcblx0XHRpdGVtID0gaXRlbS5zdHJpcCgpO1xyXG5cdFx0dmFyIGVuZF9pZHggPSBpdGVtLmluZGV4T2YoJ00gIEVORCcpO1xyXG5cclxuXHRcdGlmIChlbmRfaWR4ID09IC0xKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaXBhcnNlZCA9IHt9O1xyXG5cclxuXHRcdGlwYXJzZWQubW9sZmlsZSA9IGl0ZW0uc3Vic3RyaW5nKDAsIGVuZF9pZHggKyA2KTtcclxuXHRcdGlwYXJzZWQubmFtZSA9IGl0ZW0uc3Vic3RyaW5nKDAsIGl0ZW0uaW5kZXhPZignXFxuJykpLnN0cmlwKCk7XHJcblx0XHRpdGVtID0gaXRlbS5zdWJzdHIoZW5kX2lkeCArIDcpLnN0cmlwKCk7XHJcblxyXG5cdFx0dmFyIGVudHJpZXMgPSBpdGVtLnNwbGl0KC9eJC9tKTtcclxuXHJcblx0XHRlbnRyaWVzLmVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XHJcblx0XHRcdGVudHJ5ID0gZW50cnkuc3RyaXAoKTtcclxuXHRcdFx0aWYgKCFlbnRyeS5zdGFydHNXaXRoKCc+IDwnKSkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgbGluZXMgPSBlbnRyeS5zcGxpdCgnXFxuJyk7XHJcblx0XHRcdHZhciBmaWVsZCA9IGxpbmVzWzBdLnN0cmlwKCkuc3Vic3RyaW5nKDMsIGxpbmVzWzBdLmxhc3RJbmRleE9mKCc+JykpLnN0cmlwKCk7XHJcblxyXG5cdFx0XHRpcGFyc2VkW2ZpZWxkXSA9IHBhcnNlSW50KGxpbmVzWzFdLnN0cmlwKCkpIHx8IGxpbmVzWzFdLnN0cmlwKCk7XHJcblx0XHR9KTtcclxuXHRcdHBhcnNlZC5wdXNoKGlwYXJzZWQpO1xyXG5cdH0pO1xyXG5cclxuXHRyZXR1cm4gcGFyc2VkO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmZXRjaFRlbXBsYXRlQ3VzdG9tIChiYXNlX3VybCkge1xyXG5cdHJldHVybiBhamF4KGJhc2VfdXJsICsgJ3RlbXBsYXRlcy5zZGYnKS50aGVuKGZ1bmN0aW9uICh4aHIpIHtcclxuXHRcdC8vaGVhZGVyczoge0FjY2VwdDogJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSd9XHJcblx0XHR2YXIgaXRlbXMgPSBwYXJzZVNkZih4aHIucmVzcG9uc2VUZXh0KTtcclxuXHJcblx0XHR2YXIgdGVtcGxhdGVzID0gW107XHJcblx0XHR2YXIgaSA9IDA7XHJcblx0XHRpdGVtcy5lYWNoKGZ1bmN0aW9uIChpdGVtKSB7XHJcblx0XHRcdHRlbXBsYXRlcy5wdXNoKHtcclxuXHRcdFx0XHRuYW1lOiAoaXRlbS5uYW1lIHx8ICgnY3VzdG9tdGVtcGxhdGUgJyArICgrK2kpKSkuY2FwaXRhbGl6ZSgpLFxyXG5cdFx0XHRcdG1vbGZpbGU6IGl0ZW0ubW9sZmlsZSxcclxuXHRcdFx0XHRhaWQ6IChpdGVtLmF0b21pZCB8fCAxKSAtIDEsXHJcblx0XHRcdFx0YmlkOiAoaXRlbS5ib25kaWQgfHwgMSkgLSAxXHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIHRlbXBsYXRlcztcclxuXHR9KTtcclxufTtcclxuXHJcbnZhciBjdXN0b21fdGVtcGxhdGVzO1xyXG5mdW5jdGlvbiBpbml0VGVtcGxhdGVDdXN0b20gKGVsLCBiYXNlX3VybCkge1xyXG5cdHJldHVybiBmZXRjaFRlbXBsYXRlQ3VzdG9tKGJhc2VfdXJsKS50aGVuKGZ1bmN0aW9uICh0ZW1wbGF0ZXMpIHtcclxuXHRcdGN1c3RvbV90ZW1wbGF0ZXMgPSB0ZW1wbGF0ZXM7XHJcblx0XHRyZXR1cm4gZWFjaEFzeW5jKHRlbXBsYXRlcywgZnVuY3Rpb24gKHRtcGwsIF8pIHtcclxuXHRcdFx0dmFyIGxpID0gIG5ldyBFbGVtZW50KCdsaScpO1xyXG5cdFx0XHRsaS50aXRsZSA9IHRtcGwubmFtZTtcclxuXHRcdFx0ZWwuaW5zZXJ0KHsgYm90dG9tOiBsaSB9KTtcclxuXHRcdFx0dmFyIG1vbCA9IG1vbGZpbGUucGFyc2UodG1wbC5tb2xmaWxlKSxcclxuXHRcdFx0cmVuZGVyID0gbmV3IHJuZC5SZW5kZXIobGksIDAsIHtcclxuXHRcdFx0XHQnYXV0b1NjYWxlJzogdHJ1ZSxcclxuXHRcdFx0XHQnYXV0b1NjYWxlTWFyZ2luJzogMCxcclxuXHRcdFx0XHQvLydkZWJ1Zyc6IHRydWUsXHJcblx0XHRcdFx0J2lnbm9yZU1vdXNlRXZlbnRzJzogdHJ1ZSxcclxuXHRcdFx0XHQnaGlkZUNoaXJhbEZsYWcnOiB0cnVlLFxyXG5cdFx0XHRcdCdtYXhCb25kTGVuZ3RoJzogMzBcclxuXHRcdFx0fSk7XHJcblx0XHRcdHJlbmRlci5zZXRNb2xlY3VsZShtb2wpO1xyXG5cdFx0XHRyZW5kZXIudXBkYXRlKCk7XHJcblx0XHR9LCA1MCk7XHJcblx0fSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVhY2hBc3luYyhsaXN0LCBwcm9jZXNzLCB0aW1lR2FwLCBzdGFydFRpbWVHYXApIHtcclxuXHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuXHRcdHZhciBpID0gMDtcclxuXHRcdHZhciBuID0gbGlzdC5sZW5ndGg7XHJcblx0XHRmdW5jdGlvbiBpdGVyYXRlKCkge1xyXG5cdFx0XHRpZiAoaSA8IG4pIHtcclxuXHRcdFx0XHRwcm9jZXNzKGxpc3RbaV0sIGkrKyk7XHJcblx0XHRcdFx0c2V0VGltZW91dChpdGVyYXRlLCB0aW1lR2FwKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXNvbHZlKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHNldFRpbWVvdXQoaXRlcmF0ZSwgc3RhcnRUaW1lR2FwIHx8IHRpbWVHYXApO1xyXG5cdH0pO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gZGlhbG9nIChiYXNlX3VybCwgcGFyYW1zKSB7XHJcblx0dmFyIGRsZyA9IHVpLnNob3dEaWFsb2coJ2N1c3RvbV90ZW1wbGF0ZXMnKSxcclxuXHRzZWxlY3RlZExpID0gZGxnLnNlbGVjdCgnLnNlbGVjdGVkJylbMF0sXHJcblx0b2tCdXR0b24gPSBkbGcuc2VsZWN0KCdbdmFsdWU9T0tdJylbMF0sXHJcblx0dWwgPSBkbGcuc2VsZWN0KCd1bCcpWzBdO1xyXG5cclxuXHRpZiAodWwuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7IC8vIGZpcnN0IHRpbWVcclxuXHRcdCQoJ2xvYWRpbmcnKS5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcblx0XHRkbGcuYWRkQ2xhc3NOYW1lKCdsb2FkaW5nJyk7XHJcblx0XHR2YXIgbG9hZGluZyA9IGluaXRUZW1wbGF0ZUN1c3RvbSh1bCwgYmFzZV91cmwpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG5cdFx0XHQkKCdsb2FkaW5nJykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuXHRcdFx0ZGxnLnJlbW92ZUNsYXNzTmFtZSgnbG9hZGluZycpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0bG9hZGluZy50aGVuKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0b2tCdXR0b24uZGlzYWJsZWQgPSB0cnVlO1xyXG5cdFx0XHRkbGcub24oJ2NsaWNrJywgJ2xpJywgZnVuY3Rpb24gKF8sIGxpKSB7XHJcblx0XHRcdFx0aWYgKHNlbGVjdGVkTGkgPT0gbGkpXHJcblx0XHRcdFx0XHRva0J1dHRvbi5jbGljaygpO1xyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYgKHNlbGVjdGVkTGkpXHJcblx0XHRcdFx0XHRcdHNlbGVjdGVkTGkucmVtb3ZlQ2xhc3NOYW1lKCdzZWxlY3RlZCcpO1xyXG5cdFx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0XHRva0J1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0bGkuYWRkQ2xhc3NOYW1lKCdzZWxlY3RlZCcpO1xyXG5cdFx0XHRcdFx0c2VsZWN0ZWRMaSA9IGxpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHRcdGRsZy5vbignY2xpY2snLCAnaW5wdXQnLCBmdW5jdGlvbiAoXywgaW5wdXQpIHtcclxuXHRcdFx0XHR2YXIgbW9kZSA9IGlucHV0LnZhbHVlLFxyXG5cdFx0XHRcdGtleSA9ICdvbicgKyBpbnB1dC52YWx1ZS5jYXBpdGFsaXplKCksXHJcblx0XHRcdFx0cmVzO1xyXG5cdFx0XHRcdGlmIChtb2RlID09ICdPSycpIHtcclxuXHRcdFx0XHRcdGNvbnNvbGUuYXNzZXJ0KHNlbGVjdGVkTGksICdObyBlbGVtZW50IHNlbGVjdGVkJyk7XHJcblx0XHRcdFx0XHR2YXIgaW5kID0gc2VsZWN0ZWRMaS5wcmV2aW91c1NpYmxpbmdzKCkuc2l6ZSgpO1xyXG5cdFx0XHRcdFx0cmVzID0gY3VzdG9tX3RlbXBsYXRlc1tpbmRdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR1aS5oaWRlRGlhbG9nKCdjdXN0b21fdGVtcGxhdGVzJyk7XHJcblx0XHRcdFx0aWYgKHBhcmFtcyAmJiBrZXkgaW4gcGFyYW1zKVxyXG5cdFx0XHRcdFx0cGFyYW1zW2tleV0ocmVzKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHR9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGRpYWxvZztcclxuIiwidmFyIHVpID0gZ2xvYmFsLnVpID0ge307XHJcblxyXG5yZXF1aXJlKCcuLi9ybmQnKTtcclxuXHJcbnZhciBybmQgPSBnbG9iYWwucm5kO1xyXG5cclxudmFyIFByb21pc2UgPSByZXF1aXJlKCdwcm9taXNlLXBvbHlmaWxsJyk7XHJcbnZhciBrZXltYWdlID0gcmVxdWlyZSgna2V5bWFnZScpO1xyXG5cclxudmFyIFNldCA9IHJlcXVpcmUoJy4uL3V0aWwvc2V0Jyk7XHJcbnZhciBWZWMyID0gcmVxdWlyZSgnLi4vdXRpbC92ZWMyJyk7XHJcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xyXG52YXIgQWN0aW9uID0gcmVxdWlyZSgnLi9hY3Rpb24uanMnKTtcclxuXHJcbnZhciB0ZW1wbGF0ZXMgPSByZXF1aXJlKCcuL3RlbXBsYXRlcycpO1xyXG5cclxudmFyIGVsZW1lbnQgPSByZXF1aXJlKCcuLi9jaGVtL2VsZW1lbnQnKTtcclxudmFyIFN0cnVjdCA9IHJlcXVpcmUoJy4uL2NoZW0vc3RydWN0Jyk7XHJcbnZhciBBdG9tID0gcmVxdWlyZSgnLi4vY2hlbS9hdG9tJyk7XHJcbnZhciBCb25kID0gcmVxdWlyZSgnLi4vY2hlbS9ib25kJyk7XHJcbnZhciBtb2xmaWxlID0gcmVxdWlyZSgnLi4vY2hlbS9tb2xmaWxlJyk7XHJcbnZhciBzbWlsZXMgPSByZXF1aXJlKCcuLi9jaGVtL3NtaWxlcycpO1xyXG52YXIgU0dyb3VwID0gcmVxdWlyZSgnLi4vY2hlbS9zZ3JvdXAnKTtcclxuXHJcbnZhciBFZGl0b3IgPSByZXF1aXJlKCcuLi9ybmQvZWRpdG9yJyk7XHJcblxyXG52YXIgb3BlbkRpYWxvZyA9IHJlcXVpcmUoJy4vZGlhbG9nL29wZW4uanMnKTtcclxudmFyIHNhdmVEaWFsb2cgPSByZXF1aXJlKCcuL2RpYWxvZy9zYXZlLmpzJyk7XHJcbnZhciBzZWxlY3REaWFsb2cgPSByZXF1aXJlKCcuL2RpYWxvZy9zZWxlY3QnKTtcclxudmFyIHRlbXBsYXRlc0RpYWxvZyA9IHJlcXVpcmUoJy4vZGlhbG9nL3RlbXBsYXRlcycpO1xyXG52YXIgc2dyb3VwRGlhbG9nID0gcmVxdWlyZSgnLi9kaWFsb2cvc2dyb3VwJyk7XHJcbnZhciBzZ3JvdXBTcGVjaWFsRGlhbG9nID0gcmVxdWlyZSgnLi9kaWFsb2cvc2dyb3VwLXNwZWNpYWwnKTtcclxudmFyIG9ic29sZXRlID0gcmVxdWlyZSgnLi9kaWFsb2cvb2Jzb2xldGUnKTtcclxuXHJcbnZhciBTQ0FMRSA9IDQwOyAgLy8gY29uc3RcclxudmFyIEhJU1RPUllfTEVOR1RIID0gMzI7XHJcblxyXG52YXIgdW5kb1N0YWNrID0gW107XHJcbnZhciByZWRvU3RhY2sgPSBbXTtcclxuXHJcbnZhciBrZXRjaGVyV2luZG93O1xyXG52YXIgdG9vbGJhcjtcclxudmFyIGxhc3RTZWxlY3RlZDtcclxudmFyIGNsaWVudEFyZWEgPSBudWxsO1xyXG52YXIgZHJvcGRvd25PcGVuZWQ7XHJcbnZhciB6c3BPYmo7XHJcbnZhciBzZXJ2ZXI7XHJcblxyXG52YXIgc2VydmVyQWN0aW9ucyA9IFsnY2xlYW51cCcsICdhcm9tJywgJ2RlYXJvbScsICdjYWxjLWNpcCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICdyZWFjdGlvbi1hdXRvbWFwJywgJ3RlbXBsYXRlLWN1c3RvbSddO1xyXG52YXIgY2xpcEFjdGlvbnMgPSBbJ2N1dCcsICdjb3B5JywgJ3Bhc3RlJ107XHJcblxyXG5mdW5jdGlvbiBpbml0IChvcHRpb25zLCBhcGlTZXJ2ZXIpIHtcclxuXHRrZXRjaGVyV2luZG93ID0gJCQoJ1tyb2xlPWFwcGxpY2F0aW9uXScpWzBdIHx8ICQkKCdib2R5JylbMF07XHJcblx0dG9vbGJhciA9IGtldGNoZXJXaW5kb3cuc2VsZWN0KCdbcm9sZT10b29sYmFyXScpWzBdO1xyXG5cdGNsaWVudEFyZWEgPSAkKCdjYW52YXMnKTtcclxuXHRzZXJ2ZXIgPSBhcGlTZXJ2ZXI7XHJcblxyXG5cdHVwZGF0ZVNlcnZlckJ1dHRvbnMoKTtcclxuXHRpZiAoc2VydmVyKSB7IC8vICYmIFsnaHR0cDonLCAnaHR0cHM6J10uaW5kZXhPZih3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wpID49IDApIHtcclxuXHRcdC8vIGRvbid0IHRyeSB0byBrbm9jayBpZiB0aGUgZmlsZSBpcyBvcGVuZWQgbG9jYWxseSAoXCJmaWxlOlwiIHByb3RvY29sKVxyXG5cdFx0Ly8gVE9ETzogY2hlY2sgd2hlbiB0aGlzIGlzIG5lc2Vzc2FyeVxyXG5cdFx0c2VydmVyLmtub2Nrbm9jaygpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xyXG5cdFx0XHR1aS5zdGFuZGFsb25lID0gZmFsc2U7XHJcblx0XHRcdHVwZGF0ZVNlcnZlckJ1dHRvbnMoKTtcclxuXHRcdH0sIGZ1bmN0aW9uICh2YWwpIHtcclxuXHRcdFx0ZG9jdW1lbnQudGl0bGUgKz0gJyAoc3RhbmRhbG9uZSknO1xyXG5cdFx0XHQvLyBUT0RPOiBlY2hvIGluc3RlYWRcclxuXHRcdH0pLnRoZW4oZnVuY3Rpb24gKCkge1xyXG5cdFx0XHQvLyBUT0RPOiBtb3ZlIGl0IG91dCB0aGVyZSBhcyBzZXJ2ZXIgaW5jYXBzdWxhdGVzXHJcblx0XHRcdC8vIHN0YW5kYWxvbmVcclxuXHRcdFx0aWYgKG9wdGlvbnMubW9sKSB7XHJcblx0XHRcdFx0bG9hZE1vbGVjdWxlKG9wdGlvbnMubW9sKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRvYnNvbGV0ZS5pbml0RGlhbG9ncygpO1xyXG5cclxuXHQvLyBCdXR0b24gZXZlbnRzXHJcblx0dmFyIGtleU1hcCA9IHt9O1xyXG5cdHRvb2xiYXIuc2VsZWN0KCdidXR0b24nKS5lYWNoKGZ1bmN0aW9uIChlbCkge1xyXG5cdFx0Ly8gd2luZG93LnN0YXR1cyBvbmhvdmVyP1xyXG5cdFx0dmFyIGNhcHRpb24gPSAgZWwudGV4dENvbnRlbnQgfHwgZWwuaW5uZXJUZXh0O1xyXG5cdFx0dmFyIGtkID0gZWwuZGF0YXNldCA/IGVsLmRhdGFzZXQua2V5cyA6IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1rZXlzJyk7XHJcblx0XHRpZiAoIWtkKVxyXG5cdFx0XHRlbC50aXRsZSA9IGVsLnRpdGxlIHx8IGNhcHRpb247XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0dmFyIGtleXMgPSBrZC5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gcy5zdHJpcCgpOyB9KTtcclxuXHRcdFx0dmFyIG1rID0gc2hvcnRjdXRTdHIoa2V5c1swXSk7XHJcblx0XHRcdHZhciBhY3Rpb24gPSBlbC5wYXJlbnROb2RlLmlkO1xyXG5cdFx0XHRlbC50aXRsZSA9IChlbC50aXRsZSB8fCBjYXB0aW9uKSArICcgKCcgKyBtayArICcpJztcclxuXHRcdFx0ZWwuaW5uZXJIVE1MICs9ICcgPGtiZD4nICsgbWsgKyAnPC9rYmQ+JztcclxuXHJcblx0XHRcdGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2IpIHtcclxuXHRcdFx0XHR2YXIgbmsgPSBrYi50b0xvd2VyQ2FzZSgpO1xyXG5cdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KGtleU1hcFtua10pKVxyXG5cdFx0XHRcdCAgICBrZXlNYXBbbmtdLnB1c2goYWN0aW9uKTtcclxuXHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRrZXlNYXBbbmtdID0gW2FjdGlvbl07XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cdGtleU1hcCA9IHV0aWwuZXh0ZW5kKGtleU1hcCwge1xyXG5cdFx0J2EnOiBbJ2F0b20tYW55J10sXHJcblx0XHQnZGVmbW9kLWEnOiBbJ3NlbGVjdC1hbGwnXSxcclxuXHRcdCdkZWZtb2Qtc2hpZnQtYSc6IFsnZGVzZWxlY3QtYWxsJ10sXHJcblx0XHQnY3RybC1hbHQtcic6IFsnZm9yY2UtdXBkYXRlJ11cclxuXHR9KTtcclxuXHJcblx0T2JqZWN0LmtleXMoa2V5TWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuXHRcdGtleW1hZ2UoJ2VkaXRvcicsIGtleSwga2V5TWFwW2tleV0ubGVuZ3RoID09IDEgPyBmdW5jdGlvbiAoZXZlbnQpIHtcclxuXHRcdFx0Ly8gVE9ETzogaGFuZGxlIGRpc2FibGVkXHJcblx0XHRcdHZhciBhY3Rpb24gPSBrZXlNYXBba2V5XVswXTtcclxuXHRcdFx0aWYgKGNsaXBBY3Rpb25zLmluZGV4T2YoYWN0aW9uKSA9PSAtMSkge1xyXG5cdFx0XHRcdC8vIGVsc2UgZGVsZWdhdGUgdG8gY2xpcGFyZWFcclxuXHRcdFx0XHRzZWxlY3RBY3Rpb24oa2V5TWFwW2tleV1bMF0pO1xyXG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdH1cclxuXHRcdH0gOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGNvbnNvbGUuaW5mbygnYWN0aW9ucycsIGtleU1hcFtrZXldKTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG5cdGtleW1hZ2Uuc2V0U2NvcGUoJ2VkaXRvcicpO1xyXG5cclxuXHR0b29sYmFyLnNlbGVjdCgnbGknKS5lYWNoKGZ1bmN0aW9uIChlbCkge1xyXG5cdFx0ZWwub24oJ2NsaWNrJywgZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0XHRcdGlmIChldmVudC50YXJnZXQudGFnTmFtZSA9PSAnQlVUVE9OJyAmJlxyXG5cdFx0XHQgICAgZXZlbnQudGFyZ2V0LnBhcmVudE5vZGUgPT0gdGhpcykge1xyXG5cdFx0XHRcdGlmICghdGhpcy5oYXNDbGFzc05hbWUoJ3NlbGVjdGVkJykpIHtcclxuXHRcdFx0XHRcdGV2ZW50LnN0b3AoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0c2VsZWN0QWN0aW9uKHRoaXMuaWQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoaGlkZUJsdXJyZWRDb250cm9scygpKSB7XHJcblx0XHRcdFx0ZXZlbnQuc3RvcCgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKHRoaXMuZ2V0U3R5bGUoJ292ZXJmbG93JykgPT0gJ2hpZGRlbicpIHtcclxuXHRcdFx0XHR0aGlzLmFkZENsYXNzTmFtZSgnb3BlbmVkJyk7XHJcblx0XHRcdFx0ZHJvcGRvd25PcGVuZWQgPSB0aGlzO1xyXG5cdFx0XHRcdGV2ZW50LnN0b3AoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fSk7XHJcblxyXG5cdGluaXRDbGlwYXJlYShrZXRjaGVyV2luZG93KTtcclxuXHRpbml0Wm9vbSgpO1xyXG5cdHVwZGF0ZUhpc3RvcnlCdXR0b25zKCk7XHJcblxyXG5cdGNsaWVudEFyZWEub24oJ3Njcm9sbCcsIG9uU2Nyb2xsX0NsaWVudEFyZWEpO1xyXG5cdGNsaWVudEFyZWEub24oJ21vdXNlZG93bicsIGZ1bmN0aW9uICgpIHtcclxuXHRcdGtleW1hZ2Uuc2V0U2NvcGUoJ2VkaXRvcicpO1xyXG5cdH0pO1xyXG5cclxuXHQvLyBJbml0IHJlbmRlcmVyXHJcblx0dmFyIG9wdHMgPSBuZXcgcm5kLlJlbmRlck9wdGlvbnMob3B0aW9ucyk7XHJcblx0b3B0cy5hdG9tQ29sb3JpbmcgPSB0cnVlO1xyXG5cdHVpLnJlbmRlciA9ICBuZXcgcm5kLlJlbmRlcihjbGllbnRBcmVhLCBTQ0FMRSwgb3B0cyk7XHJcblx0dWkuZWRpdG9yID0gbmV3IEVkaXRvcih1aS5yZW5kZXIpO1xyXG5cclxuXHR1aS5yZW5kZXIub25DYW52YXNPZmZzZXRDaGFuZ2VkID0gb25PZmZzZXRDaGFuZ2VkO1xyXG5cclxuXHRzZWxlY3RBY3Rpb24oJ3NlbGVjdC1sYXNzbycpO1xyXG5cdHNldFNjcm9sbE9mZnNldCgwLCAwKTtcclxuXHJcblx0dWkucmVuZGVyLnNldE1vbGVjdWxlKHVpLmN0YWIpO1xyXG5cdHVpLnJlbmRlci51cGRhdGUoKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIHNob3J0Y3V0U3RyKGtleSkge1xyXG5cdHZhciBpc01hYyA9IG5hdmlnYXRvci5wbGF0Zm9ybS50b1VwcGVyQ2FzZSgpLmluZGV4T2YoJ01BQycpID49IDA7XHJcblx0cmV0dXJuIGtleS5yZXBsYWNlKC9EZWZtb2QvZywgaXNNYWMgPyAn4oyYJyA6ICdDdHJsJylcclxuXHRcdCAgICAgIC5yZXBsYWNlKC8tKD8hJCkvZywgJysnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc3ViRWwgKGlkKSB7XHJcblx0cmV0dXJuICQoaWQpLmNoaWxkcmVuWzBdO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gaGlkZUJsdXJyZWRDb250cm9scyAoKSB7XHJcblx0aWYgKCFkcm9wZG93bk9wZW5lZCkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0ZHJvcGRvd25PcGVuZWQucmVtb3ZlQ2xhc3NOYW1lKCdvcGVuZWQnKTtcclxuXHR2YXIgc2VsID0gZHJvcGRvd25PcGVuZWQuc2VsZWN0KCcuc2VsZWN0ZWQnKTtcclxuXHRpZiAoc2VsLmxlbmd0aCA9PSAxKSB7XHJcblx0XHQvL3ZhciBpbmRleCA9IHNlbFswXS5wcmV2aW91c1NpYmxpbmdzKCkuc2l6ZSgpO1xyXG5cdFx0dmFyIG1lbnUgPSBzdWJFbChkcm9wZG93bk9wZW5lZCk7XHJcblx0XHRtZW51LnN0eWxlLm1hcmdpblRvcCA9ICgtc2VsWzBdLm9mZnNldFRvcCArIG1lbnUub2Zmc2V0VG9wKSArICdweCc7XHJcblx0fVxyXG5cclxuXHQvLyBGSVg6IFF1aWNrIGZpeCBvZiBDaHJvbWUgKFdlYmtpdCBwcm9iYWJseSkgYm94LXNoYWRvd1xyXG5cdC8vIHJlcGFpbnQgYnVnOiBodHRwOi8vYml0Lmx5LzFpaVNNZ3lcclxuXHQvLyBuZWVkcyBpbnZlc3RpZ2F0aW9uLCBwZXJmb3JtYW5jZVxyXG5cdGNsaWVudEFyZWEuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xyXG5cdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG5cdFx0Y2xpZW50QXJlYS5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xyXG5cdH0sIDApO1xyXG5cdC8vID8/IHVpLnJlbmRlci51cGRhdGUodHJ1ZSk7XHJcblx0Ly8gRU5EXHJcblx0ZHJvcGRvd25PcGVuZWQgPSBudWxsO1xyXG5cdHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gc2VsZWN0QWN0aW9uIChhY3Rpb24pIHtcclxuXHQvLyBUT0RPOiBsYXN0U2VsZWN0ZWQgLT4gcHJldnRvb2xfaWRcclxuXHRhY3Rpb24gPSBhY3Rpb24gfHwgbGFzdFNlbGVjdGVkO1xyXG5cdHZhciBlbCA9ICQoYWN0aW9uKTtcclxuXHR2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHRjb25zb2xlLmFzc2VydChhY3Rpb24uc3RhcnRzV2l0aCwgJ2lkIGlzIG5vdCBhIHN0cmluZycsIGFjdGlvbik7XHJcblxyXG5cdGlmIChjbGlwQWN0aW9ucy5pbmRleE9mKGFjdGlvbikgIT0gLTEgJiYgYXJncy5sZW5ndGggPT0gMClcclxuXHRcdHJldHVybiBkZWxlZ2F0ZUNsaXBhcmVhKGFjdGlvbik7XHJcblxyXG5cdC8vIFRPRE86IHJlZmFjdG9yICFlbCAtIGNhc2Ugd2hlbiB0aGVyZSBhcmUgbm8gc3VjaCBpZFxyXG5cdGlmICghZWwgfHwgIXN1YkVsKGVsKS5kaXNhYmxlZCkge1xyXG5cdFx0YXJncy51bnNoaWZ0KGFjdGlvbik7XHJcblx0XHR2YXIgdG9vbCA9IG1hcFRvb2wuYXBwbHkobnVsbCwgYXJncyk7XHJcblx0XHRpZiAodG9vbCBpbnN0YW5jZW9mIEVkaXRvci5FZGl0b3JUb29sKSB7XHJcblx0XHRcdHZhciBvbGRlbCA9IHRvb2xiYXIuc2VsZWN0KCcuc2VsZWN0ZWQnKVswXTtcclxuXHRcdFx0Ly9jb25zb2xlLmFzc2VydCghbGFzdFNlbGVjdGVkIHx8IG9sZGVsLFxyXG5cdFx0XHQvLyAgICAgICAgICAgICAgIFwiTm8gbGFzdCBtb2RlIHNlbGVjdGVkIVwiKTtcclxuXHJcblx0XHRcdGlmIChlbCAhPSBvbGRlbCB8fCAhZWwpIHsgLy8gdG9vbCBjYW5jZWxpbmcgbmVlZGVkIHdoZW4gZGlhbG9nIG9wZW5zXHJcblx0XHRcdFx0Ly8gaWYgZWwuc2VsZWN0ZWQgbm90IGNoYW5nZWRcclxuXHRcdFx0XHRpZiAodWkucmVuZGVyLmN1cnJlbnRfdG9vbCkge1xyXG5cdFx0XHRcdFx0dWkucmVuZGVyLmN1cnJlbnRfdG9vbC5PbkNhbmNlbCgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR1aS5yZW5kZXIuY3VycmVudF90b29sID0gdG9vbDtcclxuXHJcblx0XHRcdFx0aWYgKGFjdGlvbi5zdGFydHNXaXRoKCdzZWxlY3QtJykpIHtcclxuXHRcdFx0XHRcdGxhc3RTZWxlY3RlZCA9IGFjdGlvbjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKGVsKSB7XHJcblx0XHRcdFx0XHRlbC5hZGRDbGFzc05hbWUoJ3NlbGVjdGVkJyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChvbGRlbCkge1xyXG5cdFx0XHRcdFx0b2xkZWwucmVtb3ZlQ2xhc3NOYW1lKCdzZWxlY3RlZCcpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRvb2w7XHJcblx0fVxyXG5cdHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gZGVsZWdhdGVDbGlwYXJlYShhY3Rpb24pIHtcclxuXHR2YXIgZW5hYmxlZCA9IGRvY3VtZW50LnF1ZXJ5Q29tbWFuZFN1cHBvcnRlZChhY3Rpb24pO1xyXG5cdGlmIChlbmFibGVkKSB0cnkge1xyXG5cdFx0ZG9jdW1lbnQuZXhlY0NvbW1hbmQoYWN0aW9uKTtcclxuXHR9IGNhdGNoIChleCkge1xyXG5cdFx0Ly8gRkYgPCA0MVxyXG5cdFx0ZW5hYmxlZCA9IGZhbHNlO1xyXG5cdH1cclxuXHRpZiAoIWVuYWJsZWQpIHtcclxuXHRcdHZhciBlbCA9IHN1YkVsKGFjdGlvbik7XHJcblx0XHR2YXIga2V5ID0gZWwuZGF0YXNldCA/IGVsLmRhdGFzZXQua2V5cyA6IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1rZXlzJyk7XHJcblx0XHRlY2hvKCdUaGVzZSBhY3Rpb24gaXMgdW5hdmFpbGJsZSB2aWEgbWVudS5cXG4nICtcclxuXHRcdCAgICAgJ0luc3RlYWQsIHVzZSAnICsgc2hvcnRjdXRTdHIoa2V5KSArICcgdG8gJyArIGFjdGlvbiArICcuJyk7XHJcblx0fVxyXG5cdHJldHVybiBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbml0Q2xpcGFyZWEocGFyZW50KSB7XHJcblx0dmFyIGNsaXBhcmVhID0gbmV3IEVsZW1lbnQoJ2lucHV0JywgeyB0eXBlOiAndGV4dCcsICdjbGFzcyc6ICdjbGlwYXJlYScsIGF1dG9mb2N1czogdHJ1ZX0pO1xyXG5cdHZhciBpZUNiID0gd2luZG93LmNsaXBib2FyZERhdGE7XHJcblx0dmFyIHBhc3RlRm9ybWF0cyA9IFtcclxuXHRcdCdjaGVtaWNhbC94LW1kbC1tb2xmaWxlJyxcclxuXHRcdCdjaGVtaWNhbC94LW1kbC1yeG5maWxlJyxcclxuXHRcdCdjaGVtaWNhbC94LWNtbCcsXHJcblx0XHQndGV4dC9wbGFpbicsXHJcblx0XHQnY2hlbWljYWwveC1kYXlsaWdodC1zbWlsZXMnLFxyXG5cdFx0J2NoZW1pY2FsL3gtaW5jaGknXHJcblx0XTtcclxuXHR2YXIgYXV0b2ZvY3VzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRpZiAoa2V5bWFnZS5nZXRTY29wZSgpID09ICdlZGl0b3InKSB7XHJcblx0XHRcdGNsaXBhcmVhLnZhbHVlID0gJyAnO1xyXG5cdFx0XHRjbGlwYXJlYS5mb2N1cygpO1xyXG5cdFx0XHRjbGlwYXJlYS5zZWxlY3QoKTtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fTtcclxuXHR2YXIgY29weUN1dCA9IGZ1bmN0aW9uIChzdHJ1Y3QsIGNiKSB7XHJcblx0XHR2YXIgbW9sZGF0YSA9IG1vbGZpbGUuc3RyaW5naWZ5KHN0cnVjdCk7XHJcblx0XHRpZiAoIWNiICYmIGllQ2IpIHtcclxuXHRcdFx0aWVDYi5zZXREYXRhKCd0ZXh0JywgbW9sZGF0YSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjYi5zZXREYXRhKCd0ZXh0L3BsYWluJywgbW9sZGF0YSk7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0Y2Iuc2V0RGF0YSghc3RydWN0LmlzUmVhY3Rpb24gP1xyXG5cdFx0XHRcdCAgICAgICAgICAgJ2NoZW1pY2FsL3gtbWRsLW1vbGZpbGUnOiAnY2hlbWljYWwveC1tZGwtcnhuZmlsZScsXHJcblx0XHRcdFx0ICAgICAgICAgICBtb2xkYXRhKTtcclxuXHRcdFx0XHRjYi5zZXREYXRhKCdjaGVtaWNhbC94LWRheWxpZ2h0LXNtaWxlcycsXHJcblx0XHRcdFx0ICAgICAgICAgICBzbWlsZXMuc3RyaW5naWZ5KHN0cnVjdCkpO1xyXG5cdFx0XHR9IGNhdGNoIChleCkge1xyXG5cdFx0XHRcdGNvbnNvbGUuaW5mbygnQ291bGQgbm90IHdyaXRlIGV4YWN0IHR5cGUnLCBleCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cdHZhciBwYXN0ZSA9IGZ1bmN0aW9uIChjYikge1xyXG5cdFx0dmFyIGRhdGEgPSAnJztcclxuXHRcdGlmICghY2IgJiYgaWVDYikge1xyXG5cdFx0XHRkYXRhID0gaWVDYi5nZXREYXRhKCd0ZXh0Jyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBhc3RlRm9ybWF0cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdGRhdGEgPSBjYi5nZXREYXRhKHBhc3RlRm9ybWF0c1tpXSk7XHJcblx0XHRcdFx0aWYgKGRhdGEpXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Y29uc29sZS5pbmZvKCdwYXN0ZScsIGkgPj0gMCAmJiBwYXN0ZUZvcm1hdHNbaV0sIGRhdGEuc2xpY2UoMCwgNTApLCAnLi4nKTtcclxuXHRcdHJldHVybiBkYXRhO1xyXG5cdH07XHJcblxyXG5cdHBhcmVudC5pbnNlcnQoY2xpcGFyZWEpO1xyXG5cdHBhcmVudC5vbignbW91c2V1cCcsIGF1dG9mb2N1cyk7XHJcblxyXG5cdC8vID8gZXZlbnRzIHNob3VsZCBiZSBhdHRhY2hlZCB0byBkb2N1bWVudFxyXG5cdFsnY29weScsICdjdXQnXS5mb3JFYWNoKGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuXHRcdHBhcmVudC5vbihhY3Rpb24sIGZ1bmN0aW9uIChldmVudCkge1xyXG5cdFx0XHRpZiAoYXV0b2ZvY3VzKCkpIHtcclxuXHRcdFx0XHR2YXIgc3RydWN0ID0gc2VsZWN0QWN0aW9uKGFjdGlvbiwgdHJ1ZSk7XHJcblx0XHRcdFx0aWYgKHN0cnVjdClcclxuXHRcdFx0XHRcdGNvcHlDdXQoc3RydWN0LCBldmVudC5jbGlwYm9hcmREYXRhKTtcclxuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9KTtcclxuXHRwYXJlbnQub24oJ3Bhc3RlJywgZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0XHRpZiAoYXV0b2ZvY3VzKCkpIHtcclxuXHRcdFx0dmFyIGRhdGEgPSBwYXN0ZShldmVudC5jbGlwYm9hcmREYXRhKTtcclxuXHRcdFx0aWYgKGRhdGEpXHJcblx0XHRcdFx0bG9hZEZyYWdtZW50KGRhdGEpO1xyXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVDbGlwYm9hcmRCdXR0b25zICgpIHtcclxuXHRzdWJFbCgnY29weScpLmRpc2FibGVkID0gc3ViRWwoJ2N1dCcpLmRpc2FibGVkID0gIXVpLmVkaXRvci5oYXNTZWxlY3Rpb24odHJ1ZSk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVIaXN0b3J5QnV0dG9ucyAoKSB7XHJcblx0c3ViRWwoJ3VuZG8nKS5kaXNhYmxlZCA9ICh1bmRvU3RhY2subGVuZ3RoID09IDApO1xyXG5cdHN1YkVsKCdyZWRvJykuZGlzYWJsZWQgPSAocmVkb1N0YWNrLmxlbmd0aCA9PSAwKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZVNlcnZlckJ1dHRvbnMgKCkge1xyXG5cdHNlcnZlckFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYWN0aW9uKSB7XHJcblx0XHRzdWJFbChhY3Rpb24pLmRpc2FibGVkID0gdWkuc3RhbmRhbG9uZTtcclxuXHR9KTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zaXRpb25FbmRFdmVudCAoKSB7XHJcblx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHJhbnNpdGlvblRlc3QnKSxcclxuXHR0cmFuc0VuZEV2ZW50TmFtZXMgPSB7XHJcblx0XHQnV2Via2l0VHJhbnNpdGlvbic6ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcclxuXHRcdCdNb3pUcmFuc2l0aW9uJzogJ3RyYW5zaXRpb25lbmQnLFxyXG5cdFx0J09UcmFuc2l0aW9uJzogJ29UcmFuc2l0aW9uRW5kIG90cmFuc2l0aW9uZW5kJyxcclxuXHRcdCd0cmFuc2l0aW9uJzogJ3RyYW5zaXRpb25lbmQnXHJcblx0fSxcclxuXHRuYW1lO1xyXG5cdGZvciAobmFtZSBpbiB0cmFuc0VuZEV2ZW50TmFtZXMpIHtcclxuXHRcdGlmIChlbC5zdHlsZVtuYW1lXSAhPT0gdW5kZWZpbmVkKVxyXG5cdFx0XHRyZXR1cm4gdHJhbnNFbmRFdmVudE5hbWVzW25hbWVdO1xyXG5cdH1cclxuXHRyZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBhbmltYXRlVG9nZ2xlIChlbCwgY2FsbGJhY2spIHtcclxuXHRrZXRjaGVyV2luZG93LmFkZENsYXNzTmFtZSgnYW5pbWF0ZScpO1xyXG5cdHZhciB0cmFuc2l0aW9uRW5kID0gdHJhbnNpdGlvbkVuZEV2ZW50KCksXHJcblx0YW5pbWF0ZVN0b3AgPSBmdW5jdGlvbiAoY2IpIHtcclxuXHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRjYiAmJiBjYigpO1xyXG5cdFx0XHRrZXRjaGVyV2luZG93LnJlbW92ZUNsYXNzTmFtZSgnYW5pbWF0ZScpO1xyXG5cdFx0fSwgMCk7XHJcblx0fTtcclxuXHJcblx0aWYgKCFjYWxsYmFjayB8fCAhdHJhbnNpdGlvbkVuZCkge1xyXG5cdFx0YW5pbWF0ZVN0b3AoY2FsbGJhY2spO1xyXG5cdFx0XHRjYWxsYmFjayB8fCBlbCgpO1xyXG5cdH1cclxuXHRlbHNlIHtcclxuXHRcdHZhciBmaXJlT25lID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRhbmltYXRlU3RvcChjYWxsYmFjayk7XHJcblx0XHRcdGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZCwgZmlyZU9uZSwgZmFsc2UpO1xyXG5cdFx0fTtcclxuXHRcdGVsLmFkZEV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZCwgZmlyZU9uZSwgZmFsc2UpO1xyXG5cdH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIHNob3dEaWFsb2cgKG5hbWUpIHtcclxuXHR2YXIgZGlhbG9nID0gJChuYW1lKTtcclxuXHRrZXltYWdlLnNldFNjb3BlKCdkaWFsb2cnKTtcclxuXHRhbmltYXRlVG9nZ2xlKGZ1bmN0aW9uICgpIHtcclxuXHRcdCQkKCcub3ZlcmxheScpWzBdLnNob3coKTtcclxuXHRcdC8vIGRpYWxvZy5zaG93KCk7XHJcblx0XHRkaWFsb2cuc3R5bGUuZGlzcGxheSA9ICcnO1xyXG5cdH0pO1xyXG5cdHJldHVybiBkaWFsb2c7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBoaWRlRGlhbG9nIChuYW1lKSB7XHJcblx0dmFyIGNvdmVyID0gJCQoJy5vdmVybGF5JylbMF07XHJcblx0YW5pbWF0ZVRvZ2dsZShjb3ZlciwgZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gJChuYW1lKS5oaWRlKCk7XHJcblx0XHQkKG5hbWUpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcblx0XHRjb3Zlci5oaWRlKCk7XHJcblx0XHRrZXltYWdlLnNldFNjb3BlKCdlZGl0b3InKTtcclxuXHR9KTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIHNob3dFbGVtVGFibGUgKHBhcmFtcykge1xyXG5cdHBhcmFtcy5yZXF1aXJlZCA9IHRydWU7XHJcblx0c2VsZWN0RGlhbG9nKCdlbGVtLXRhYmxlJywgcGFyYW1zKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIHNob3dSR3JvdXBUYWJsZSAocGFyYW1zKSB7XHJcblx0c2VsZWN0RGlhbG9nKCdyZ3JvdXAtdGFibGUnLCBwYXJhbXMpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gc2hvd1JlYUdlbmVyaWNzVGFibGUgKHBhcmFtcykge1xyXG5cdHBhcmFtcy5yZXF1aXJlZCA9IHRydWU7XHJcblx0c2VsZWN0RGlhbG9nKCdnZW5lcmljcy10YWJsZScsIHBhcmFtcyk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBlY2hvIChtZXNzYWdlKSB7XHJcblx0Ly8gVE9ETzogbWFrZSBzcGVjaWFsIGFyZWEgZm9yIG1lc3NhZ2VzXHJcblx0YWxlcnQobWVzc2FnZSk7XHJcbn07XHJcblxyXG4vL1xyXG4vLyBNYWluIHNlY3Rpb25cclxuLy9cclxuZnVuY3Rpb24gdXBkYXRlTW9sZWN1bGUgKG1vbCkge1xyXG5cdGlmICh0eXBlb2YobW9sKSA9PSAndW5kZWZpbmVkJyB8fCBtb2wgPT0gbnVsbClcclxuXHRcdHJldHVybjtcclxuXHJcblx0dWkuZWRpdG9yLmRlc2VsZWN0QWxsKCk7XHJcblx0YWRkVW5kb0FjdGlvbihBY3Rpb24uZnJvbU5ld0NhbnZhcyhtb2wpKTtcclxuXHRzaG93RGlhbG9nKCdsb2FkaW5nJyk7XHJcblx0Ly8gc2V0VGltZW91dChmdW5jdGlvbiAoKVxyXG5cdC8vIHtcclxuXHR0cnkge1xyXG5cdFx0dWkucmVuZGVyLm9uUmVzaXplKCk7IC8vIFRPRE86IHRoaXMgbWV0aG9kcyBzaG91bGQgYmUgY2FsbGVkIGluIHRoZSByZXNpemUtZXZlbnQgaGFuZGxlclxyXG5cdFx0dWkucmVuZGVyLnVwZGF0ZSgpO1xyXG5cdFx0c2V0Wm9vbUNlbnRlcmVkKG51bGwsIHVpLnJlbmRlci5nZXRTdHJ1Y3RDZW50ZXIoKSk7XHJcblx0fVxyXG5cdGNhdGNoIChlcikge1xyXG5cdFx0YWxlcnQoZXIubWVzc2FnZSk7XHJcblx0fVxyXG5cdGZpbmFsbHkge1xyXG5cdFx0aGlkZURpYWxvZygnbG9hZGluZycpO1xyXG5cdH1cclxuLy8gICAgfSwgNTApO1xyXG59O1xyXG5cclxuXHJcbmZ1bmN0aW9uIGFkZFVuZG9BY3Rpb24gKGFjdGlvbiwgY2hlY2tfZHVtbXkpXHJcbntcclxuXHRpZiAoYWN0aW9uID09IG51bGwpXHJcblx0XHRyZXR1cm47XHJcblxyXG5cdGlmIChjaGVja19kdW1teSAhPSB0cnVlIHx8ICFhY3Rpb24uaXNEdW1teSgpKVxyXG5cdHtcclxuXHRcdHVuZG9TdGFjay5wdXNoKGFjdGlvbik7XHJcblx0XHRyZWRvU3RhY2suY2xlYXIoKTtcclxuXHRcdGlmICh1bmRvU3RhY2subGVuZ3RoID4gSElTVE9SWV9MRU5HVEgpXHJcblx0XHRcdHVuZG9TdGFjay5zcGxpY2UoMCwgMSk7XHJcblx0XHR1cGRhdGVIaXN0b3J5QnV0dG9ucygpO1xyXG5cdH1cclxufTtcclxuXHJcbi8vXHJcbi8vIE5ldyBkb2N1bWVudFxyXG4vL1xyXG5mdW5jdGlvbiBvbkNsaWNrX05ld0ZpbGUgKClcclxue1xyXG5cdHNlbGVjdEFjdGlvbihudWxsKTtcclxuXHJcblx0aWYgKCF1aS5jdGFiLmlzQmxhbmsoKSkge1xyXG5cdFx0YWRkVW5kb0FjdGlvbihBY3Rpb24uZnJvbU5ld0NhbnZhcyhuZXcgU3RydWN0KCkpKTtcclxuXHRcdHVpLnJlbmRlci51cGRhdGUoKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9uQ2xpY2tfT3BlbkZpbGUgKClcclxue1xyXG5cdG9wZW5EaWFsb2coe1xyXG5cdFx0b25PazogZnVuY3Rpb24gKHJlcykge1xyXG5cdFx0XHRpZiAocmVzLmZyYWdtZW50KVxyXG5cdFx0XHRcdGxvYWRGcmFnbWVudChyZXMudmFsdWUsIHRydWUpO1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0bG9hZE1vbGVjdWxlKHJlcy52YWx1ZSwgdHJ1ZSk7XHJcblx0XHR9XHJcblx0fSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9uQ2xpY2tfU2F2ZUZpbGUgKClcclxue1xyXG5cdHNhdmVEaWFsb2coe21vbGVjdWxlOiB1aS5jdGFifSwgc2VydmVyKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXJvbWF0aXplKG1vbCwgYXJvbSlcclxue1xyXG5cdG1vbCA9IG1vbC5jbG9uZSgpO1xyXG5cdHZhciBpbXBsaWNpdFJlYWN0aW9uID0gbW9sLmFkZFJ4bkFycm93SWZOZWNlc3NhcnkoKTtcclxuXHR2YXIgbW9sX3N0cmluZyA9IG1vbGZpbGUuc3RyaW5naWZ5KG1vbCk7XHJcblxyXG5cdGlmICghdWkuc3RhbmRhbG9uZSkge1xyXG5cdFx0dmFyIG1ldGhvZCA9IGFyb20gPyAnYXJvbWF0aXplJyA6ICdkZWFyb21hdGl6ZScsXHJcblx0XHRyZXF1ZXN0ID0gc2VydmVyW21ldGhvZF0oe21vbGRhdGE6IG1vbF9zdHJpbmd9KTtcclxuXHRcdHJlcXVlc3QudGhlbihmdW5jdGlvbiAoZGF0YSkge1xyXG5cdFx0XHR2YXIgcmVzbW9sID0gcGFyc2VNYXlCZUNvcnJ1cHRlZENURmlsZShkYXRhKTtcclxuXHRcdFx0aWYgKGltcGxpY2l0UmVhY3Rpb24pXHJcblx0XHRcdFx0cmVzbW9sLnJ4bkFycm93cy5jbGVhcigpO1xyXG5cdFx0XHR1cGRhdGVNb2xlY3VsZShyZXNtb2wpO1xyXG5cdFx0fSwgZWNobyk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcignQXJvbWF0aXphdGlvbiBhbmQgZGVhcm9tYXRpemF0aW9uIGFyZSBub3Qgc3VwcG9ydGVkIGluIHRoZSBzdGFuZGFsb25lIG1vZGUuJyk7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gVE9ETzogbWVyZ2Ugd2l0aCBhcm9tL2RlYXJvbSArIHNwaW5uZXJcclxuZnVuY3Rpb24gY2FsY3VsYXRlQ2lwKCkge1xyXG5cdHV0aWwuYXNzZXJ0KCF1aS5zdGFuZGFsb25lLCAnQ2FuXFwndCBjYWxjdWxhdGUgaW4gc3RhbmRhbG9uZSBtb2RlIScpOyAvLyBpdCdzIGFzc2VydCBlcnJvciBub3dcclxuXHR2YXIgbW9sID0gdWkuY3RhYi5jbG9uZSgpO1xyXG5cdHZhciBpbXBsaWNpdFJlYWN0aW9uID0gbW9sLmFkZFJ4bkFycm93SWZOZWNlc3NhcnkoKTtcclxuXHR2YXIgbW9sX3N0cmluZyA9IG1vbGZpbGUuc3RyaW5naWZ5KG1vbCk7XHJcblxyXG5cdHZhciByZXF1ZXN0ID0gc2VydmVyLmNhbGN1bGF0ZUNpcCh7bW9sZGF0YTogbW9sX3N0cmluZ30pO1xyXG5cdHJlcXVlc3QudGhlbihmdW5jdGlvbiAoZGF0YSkge1xyXG5cdFx0dmFyIHJlc21vbCA9IHBhcnNlTWF5QmVDb3JydXB0ZWRDVEZpbGUoZGF0YSk7XHJcblx0XHRpZiAoaW1wbGljaXRSZWFjdGlvbilcclxuXHRcdFx0cmVzbW9sLnJ4bkFycm93cy5jbGVhcigpO1xyXG5cdFx0dXBkYXRlTW9sZWN1bGUocmVzbW9sKTtcclxuXHR9KS50aGVuKG51bGwsIGVjaG8pO1xyXG59O1xyXG5cclxuLy9cclxuLy8gWm9vbSBzZWN0aW9uXHJcbi8vXHJcbmZ1bmN0aW9uIGluaXRab29tKCkge1xyXG5cdHZhciB6b29tU2VsZWN0ID0gc3ViRWwoJ3pvb20tbGlzdCcpO1xyXG5cdHpvb21TZWxlY3Qub24oJ2ZvY3VzJywgZnVuY3Rpb24gKCkge1xyXG5cdFx0a2V5bWFnZS5wdXNoU2NvcGUoJ3pvb20nKTtcclxuXHR9KTtcclxuXHR6b29tU2VsZWN0Lm9uKCdibHVyJywgZnVuY3Rpb24gKCkge1xyXG5cdFx0a2V5bWFnZS5wb3BTY29wZSgnem9vbScpO1xyXG5cdH0pO1xyXG5cdHpvb21TZWxlY3Qub24oJ2NoYW5nZScsIHVwZGF0ZVpvb20pO1xyXG5cdHVwZGF0ZVpvb20odHJ1ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9uQ2xpY2tfWm9vbUluICgpIHtcclxuXHRzdWJFbCgnem9vbS1saXN0Jykuc2VsZWN0ZWRJbmRleCsrO1xyXG5cdHVwZGF0ZVpvb20oKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIG9uQ2xpY2tfWm9vbU91dCAoKSB7XHJcblx0c3ViRWwoJ3pvb20tbGlzdCcpLnNlbGVjdGVkSW5kZXgtLTtcclxuXHR1cGRhdGVab29tKCk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVab29tIChub1JlZnJlc2gpIHtcclxuXHR2YXIgem9vbVNlbGVjdCA9IHN1YkVsKCd6b29tLWxpc3QnKTtcclxuXHR2YXIgaSA9IHpvb21TZWxlY3Quc2VsZWN0ZWRJbmRleCxcclxuXHQgICAgbGVuID0gem9vbVNlbGVjdC5sZW5ndGg7XHJcblx0Y29uc29sZS5hc3NlcnQoMCA8PSBpICYmIGkgPCBsZW4sICdab29tIG91dCBvZiByYW5nZScpO1xyXG5cclxuXHRzdWJFbCgnem9vbS1pbicpLmRpc2FibGVkID0gKGkgPT0gbGVuIC0gMSk7XHJcblx0c3ViRWwoJ3pvb20tb3V0JykuZGlzYWJsZWQgPSAoaSA9PSAwKTtcclxuXHJcblx0dmFyIHZhbHVlID0gcGFyc2VGbG9hdCh6b29tU2VsZWN0Lm9wdGlvbnNbaV0uaW5uZXJIVE1MKSAvIDEwMDtcclxuXHQvLyBUT0RPOiByZW1vdmUgdGhpcyBzaGl0ICh1c2VkIGluIHJuZC5SZW5kZXIgZ3V0c1xyXG5cdC8vIG9ubHkgaW4gZGlhbG9nL2NyYXAgYW5kIHJlbmRlciBvbmUgdGltZVxyXG5cdHVpLnpvb20gPSB2YWx1ZTtcclxuXHRpZiAoIW5vUmVmcmVzaCkge1xyXG5cdFx0c2V0Wm9vbUNlbnRlcmVkKHZhbHVlLFxyXG5cdFx0ICAgICAgICAgICAgICAgIHVpLnJlbmRlci5nZXRTdHJ1Y3RDZW50ZXIodWkuZWRpdG9yLmdldFNlbGVjdGlvbigpKSk7XHJcblx0XHR1aS5yZW5kZXIudXBkYXRlKCk7XHJcblx0fVxyXG59O1xyXG5cclxuZnVuY3Rpb24gc2V0Wm9vbVJlZ3VsYXIgKHpvb20pIHtcclxuXHQvL21yOiBwcmV2ZGVudCB1bmJvdW5kZWQgem9vbWluZ1xyXG5cdC8vYmVnaW5cclxuXHRpZiAoem9vbSA8IDAuMSB8fCB6b29tID4gMTApXHJcblx0XHRyZXR1cm47XHJcblx0Ly9lbmRcclxuXHR1aS56b29tID0gem9vbTtcclxuXHR1aS5yZW5kZXIuc2V0Wm9vbSh1aS56b29tKTtcclxuXHQvLyB3aGVuIHNjYWxpbmcgdGhlIGNhbnZhcyBkb3duIGl0IG1heSBoYXBwZW4gdGhhdCB0aGUgc2NhbGVkIGNhbnZhcyBpcyBzbWFsbGVyIHRoYW4gdGhlIHZpZXcgd2luZG93XHJcblx0Ly8gZG9uJ3QgZm9yZ2V0IHRvIGNhbGwgc2V0U2Nyb2xsT2Zmc2V0IGFmdGVyIHpvb21pbmcgKG9yIHVzZSBleHRlbmRDYW52YXMgZGlyZWN0bHkpXHJcbn07XHJcblxyXG4vLyBnZXQgdGhlIHNpemUgb2YgdGhlIHZpZXcgd2luZG93IGluIHBpeGVsc1xyXG5mdW5jdGlvbiBnZXRWaWV3U3ogKCkge1xyXG5cdHJldHVybiBuZXcgVmVjMih1aS5yZW5kZXIudmlld1N6KTtcclxufTtcclxuXHJcbi8vIGMgaXMgYSBwb2ludCBpbiBzY2FsZWQgY29vcmRpbmF0ZXMsIHdoaWNoIHdpbGwgYmUgcG9zaXRpb25lZCBpbiB0aGUgY2VudGVyIG9mIHRoZSB2aWV3IGFyZWEgYWZ0ZXIgem9vbWluZ1xyXG5mdW5jdGlvbiBzZXRab29tQ2VudGVyZWQgKHpvb20sIGMpIHtcclxuXHRpZiAoIWMpXHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NlbnRlciBwb2ludCBub3Qgc3BlY2lmaWVkJyk7XHJcblx0aWYgKHpvb20pIHtcclxuXHRcdHNldFpvb21SZWd1bGFyKHpvb20pO1xyXG5cdH1cclxuXHRzZXRTY3JvbGxPZmZzZXQoMCwgMCk7XHJcblx0dmFyIHNwID0gdWkucmVuZGVyLm9iajJ2aWV3KGMpLnN1Yih1aS5yZW5kZXIudmlld1N6LnNjYWxlZCgwLjUpKTtcclxuXHRzZXRTY3JvbGxPZmZzZXQoc3AueCwgc3AueSk7XHJcbn07XHJcblxyXG4vLyBzZXQgdGhlIHJlZmVyZW5jZSBwb2ludCBmb3IgdGhlIFwic3RhdGljIHBvaW50XCIgem9vbSAoaW4gb2JqZWN0IGNvb3JkaW5hdGVzKVxyXG5mdW5jdGlvbiBzZXRab29tU3RhdGljUG9pbnRJbml0IChzKSB7XHJcblx0enNwT2JqID0gbmV3IFZlYzIocyk7XHJcbn07XHJcblxyXG4vLyB2cCBpcyB0aGUgcG9pbnQgd2hlcmUgdGhlIHJlZmVyZW5jZSBwb2ludCBzaG91bGQgbm93IGJlIChpbiB2aWV3IGNvb3JkaW5hdGVzKVxyXG5mdW5jdGlvbiBzZXRab29tU3RhdGljUG9pbnQgKHpvb20sIHZwKSB7XHJcblx0c2V0Wm9vbVJlZ3VsYXIoem9vbSk7XHJcblx0c2V0U2Nyb2xsT2Zmc2V0KDAsIDApO1xyXG5cdHZhciBhdnAgPSB1aS5yZW5kZXIub2JqMnZpZXcoenNwT2JqKTtcclxuXHR2YXIgc28gPSBhdnAuc3ViKHZwKTtcclxuXHRzZXRTY3JvbGxPZmZzZXQoc28ueCwgc28ueSk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBzZXRTY3JvbGxPZmZzZXQgKHgsIHkpIHtcclxuXHR2YXIgY3ggPSBjbGllbnRBcmVhLmNsaWVudFdpZHRoO1xyXG5cdHZhciBjeSA9IGNsaWVudEFyZWEuY2xpZW50SGVpZ2h0O1xyXG5cdHVpLnJlbmRlci5leHRlbmRDYW52YXMoeCwgeSwgY3ggKyB4LCBjeSArIHkpO1xyXG5cdGNsaWVudEFyZWEuc2Nyb2xsTGVmdCA9IHg7XHJcblx0Y2xpZW50QXJlYS5zY3JvbGxUb3AgPSB5O1xyXG5cdHNjcm9sbExlZnQgPSBjbGllbnRBcmVhLnNjcm9sbExlZnQ7IC8vIFRPRE86IHN0b3JlIGRyYWcgcG9zaXRpb24gaW4gc2NhbGVkIHN5c3RlbXNcclxuXHRzY3JvbGxUb3AgPSBjbGllbnRBcmVhLnNjcm9sbFRvcDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIHNldFNjcm9sbE9mZnNldFJlbCAoZHgsIGR5KSB7XHJcblx0c2V0U2Nyb2xsT2Zmc2V0KGNsaWVudEFyZWEuc2Nyb2xsTGVmdCArIGR4LCBjbGllbnRBcmVhLnNjcm9sbFRvcCArIGR5KTtcclxufTtcclxuXHJcbi8vXHJcbi8vIEF1dG9tYXRpYyBsYXlvdXRcclxuLy9cclxuZnVuY3Rpb24gb25DbGlja19DbGVhblVwICgpXHJcbntcclxuXHR2YXIgYXRvbXMgPSB1dGlsLmFycmF5KHVpLmVkaXRvci5nZXRTZWxlY3Rpb24odHJ1ZSkuYXRvbXMpO1xyXG5cdHZhciBzZWxlY3RpdmUgPSBhdG9tcy5sZW5ndGggPiAwO1xyXG5cdGlmIChzZWxlY3RpdmUpIHtcclxuXHRcdHZhciBhdG9tU2V0ID0gU2V0LmZyb21MaXN0KGF0b21zKTtcclxuXHRcdHZhciBhdG9tU2V0RXh0ZW5kZWQgPSBTZXQuZW1wdHkoKTtcclxuXHRcdHVpLmN0YWIubG9vcHMuZWFjaChmdW5jdGlvbiAobGlkLCBsb29wKSB7XHJcblx0XHRcdC8vIGlmIHNlbGVjdGlvbiBjb250YWlucyBhbnkgb2YgdGhlIGF0b21zIGluIHRoaXMgbG9vcCwgYWRkIGFsbCB0aGUgYXRvbXMgaW4gdGhlIGxvb3AgdG8gc2VsZWN0aW9uXHJcblx0XHRcdGlmICh1dGlsLmZpbmRJbmRleChsb29wLmhicywgZnVuY3Rpb24gKGhiaWQpIHtcclxuXHRcdFx0XHRyZXR1cm4gU2V0LmNvbnRhaW5zKGF0b21TZXQsIHVpLmN0YWIuaGFsZkJvbmRzLmdldChoYmlkKS5iZWdpbik7XHJcblx0XHRcdH0pID49IDApXHJcblx0XHRcdFx0dXRpbC5lYWNoKGxvb3AuaGJzLCBmdW5jdGlvbiAoaGJpZCkge1xyXG5cdFx0XHRcdFx0U2V0LmFkZChhdG9tU2V0RXh0ZW5kZWQsIHVpLmN0YWIuaGFsZkJvbmRzLmdldChoYmlkKS5iZWdpbik7XHJcblx0XHRcdFx0fSwgdGhpcyk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHRcdFNldC5tZXJnZUluKGF0b21TZXRFeHRlbmRlZCwgYXRvbVNldCk7XHJcblx0XHRhdG9tcyA9IFNldC5saXN0KGF0b21TZXRFeHRlbmRlZCk7XHJcblx0fVxyXG5cdHVpLmVkaXRvci5kZXNlbGVjdEFsbCgpO1xyXG5cdHRyeSB7XHJcblx0XHR2YXIgYWlkTWFwID0ge307XHJcblx0XHR2YXIgbW9sID0gdWkuY3RhYi5jbG9uZShudWxsLCBudWxsLCBmYWxzZSwgYWlkTWFwKTtcclxuXHRcdGlmIChzZWxlY3RpdmUpIHtcclxuXHRcdFx0dXRpbC5lYWNoKGF0b21zLCBmdW5jdGlvbiAoYWlkKXtcclxuXHRcdFx0XHRhaWQgPSBhaWRNYXBbYWlkXTtcclxuXHRcdFx0XHR2YXIgZHNnID0gbmV3IFNHcm91cCgnREFUJyk7XHJcblx0XHRcdFx0dmFyIGRzZ2lkID0gbW9sLnNncm91cHMuYWRkKGRzZyk7XHJcblx0XHRcdFx0ZHNnLmlkID0gZHNnaWQ7XHJcblx0XHRcdFx0ZHNnLnBwID0gbmV3IFZlYzIoKTtcclxuXHRcdFx0XHRkc2cuZGF0YS5maWVsZE5hbWUgPSAnX2tldGNoZXJfc2VsZWN0aXZlX2xheW91dCc7XHJcblx0XHRcdFx0ZHNnLmRhdGEuZmllbGRWYWx1ZSA9ICcxJztcclxuXHRcdFx0XHRtb2wuYXRvbUFkZFRvU0dyb3VwKGRzZ2lkLCBhaWQpO1xyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdH1cclxuXHRcdHZhciBpbXBsaWNpdFJlYWN0aW9uID0gbW9sLmFkZFJ4bkFycm93SWZOZWNlc3NhcnkoKTtcclxuXHRcdHZhciByZXEgPSBzZXJ2ZXIubGF5b3V0KHtcclxuXHRcdFx0bW9sZGF0YTogbW9sZmlsZS5zdHJpbmdpZnkobW9sKVxyXG5cdFx0fSwgc2VsZWN0aXZlID8geydzZWxlY3RpdmUnOiAxfSA6IG51bGwpO1xyXG5cdFx0cmVxLnRoZW4oZnVuY3Rpb24gKHJlcykge1xyXG5cdFx0XHR2YXIgc3RydWN0ID0gcGFyc2VNYXlCZUNvcnJ1cHRlZENURmlsZShyZXMpO1xyXG5cdFx0XHRpZiAoaW1wbGljaXRSZWFjdGlvbilcclxuXHRcdFx0XHRzdHJ1Y3QucnhuQXJyb3dzLmNsZWFyKCk7XHJcblx0XHRcdHVwZGF0ZU1vbGVjdWxlKHN0cnVjdCk7XHJcblx0XHR9KTtcclxuXHR9IGNhdGNoIChlcikge1xyXG5cdFx0XHRhbGVydCgnRVJST1I6ICcgKyBlci5tZXNzYWdlKTsgLy8gVE9ETyBbUkJdID8/PyBnbG9iYWwgcmUtZmFjdG9yaW5nIG5lZWRlZCBvbiBlcnJvci1yZXBvcnRpbmdcclxuXHRcdH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIG9uQ2xpY2tfQXJvbWF0aXplICgpXHJcbntcclxuXHR0cnkge1xyXG5cdFx0YXJvbWF0aXplKHVpLmN0YWIsIHRydWUpO1xyXG5cdH0gY2F0Y2ggKGVyKSB7XHJcblx0XHRhbGVydCgnTW9sZmlsZTogJyArIGVyLm1lc3NhZ2UpO1xyXG5cdH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIG9uQ2xpY2tfRGVhcm9tYXRpemUgKClcclxue1xyXG5cdHRyeSB7XHJcblx0XHRhcm9tYXRpemUodWkuY3RhYiwgZmFsc2UpO1xyXG5cdH0gY2F0Y2ggKGVyKSB7XHJcblx0XHRhbGVydCgnTW9sZmlsZTogJyArIGVyLm1lc3NhZ2UpO1xyXG5cdH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIG9uQ2xpY2tfQXV0b21hcCAoKSB7XHJcblx0b2Jzb2xldGUuc2hvd0F1dG9tYXBQcm9wZXJ0aWVzKHtcclxuXHRcdG9uT2s6IGZ1bmN0aW9uIChtb2RlKSB7XHJcblx0XHRcdHZhciBtb2wgPSB1aS5jdGFiO1xyXG5cdFx0XHR2YXIgaW1wbGljaXRSZWFjdGlvbiA9IG1vbC5hZGRSeG5BcnJvd0lmTmVjZXNzYXJ5KCk7XHJcblx0XHRcdGlmIChtb2wucnhuQXJyb3dzLmNvdW50KCkgPT0gMCkge1xyXG5cdFx0XHRcdGVjaG8oJ0F1dG8tTWFwcGluZyBjYW4gb25seSBiZSBhcHBsaWVkIHRvIHJlYWN0aW9ucycpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgbW9sZGF0YSA9IG1vbGZpbGUuc3RyaW5naWZ5KG1vbCwgeyBpZ25vcmVFcnJvcnM6IHRydWUgfSksXHJcblx0XHRcdHJlcXVlc3QgPSBzZXJ2ZXIuYXV0b21hcCh7XHJcblx0XHRcdFx0bW9sZGF0YTogbW9sZGF0YSxcclxuXHRcdFx0XHRtb2RlOiBtb2RlXHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0cmVxdWVzdC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcclxuXHRcdFx0XHR2YXIgbW9sID0gcGFyc2VNYXlCZUNvcnJ1cHRlZENURmlsZShyZXMpO1xyXG5cdFx0XHRcdGlmIChpbXBsaWNpdFJlYWN0aW9uKSB7XHJcblx0XHRcdFx0XHRtb2wucnhuQXJyb3dzLmNsZWFyKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8qXHJcbiAgICAgICAgICAgICAgICAgdmFyIGFhbSA9IHBhcnNlQ1RGaWxlKHJlcy5yZXNwb25zZVRleHQpO1xyXG4gICAgICAgICAgICAgICAgIHZhciBhY3Rpb24gPSBuZXcgQWN0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgZm9yICh2YXIgYWlkID0gYWFtLmF0b21zLmNvdW50KCkgLSAxOyBhaWQgPj0gMDsgYWlkLS0pIHtcclxuICAgICAgICAgICAgICAgICBhY3Rpb24ubWVyZ2VXaXRoKEFjdGlvbi5mcm9tQXRvbUF0dHJzKGFpZCwgeyBhYW0gOiBhYW0uYXRvbXMuZ2V0KGFpZCkuYWFtIH0pKTtcclxuICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgYWRkVW5kb0FjdGlvbihhY3Rpb24sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICovXHJcblx0XHRcdFx0dXBkYXRlTW9sZWN1bGUobW9sKTtcclxuXHRcdFx0XHQvKlxyXG4gICAgICAgICAgICAgICAgIHVpLnJlbmRlci51cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAqL1xyXG5cclxuXHRcdFx0fSwgZWNobyk7XHJcblx0XHR9XHJcblx0fSk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBsb2FkTW9sZWN1bGUgKG1vbCwgY2hlY2tFbXB0eUxpbmUpIHtcclxuXHRyZXR1cm4gZ2V0U3RydWN0KG1vbCxcclxuXHQgICAgICAgICAgICAgICAgIGNoZWNrRW1wdHlMaW5lKS50aGVuKHVwZGF0ZU1vbGVjdWxlLCBmdW5jdGlvbiAoZXJyKSB7XHJcblx0XHQgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RvIERTOicsIGVycik7XHJcblx0ICAgICAgICAgICAgICAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gbG9hZEZyYWdtZW50IChtb2wsIGNoZWNrRW1wdHlMaW5lKSB7XHJcblx0cmV0dXJuIGdldFN0cnVjdChtb2wsIGNoZWNrRW1wdHlMaW5lKS50aGVuKGZ1bmN0aW9uIChzdHJ1Y3QpIHtcclxuXHRcdHN0cnVjdC5yZXNjYWxlKCk7XHJcblx0XHRzZWxlY3RBY3Rpb24oJ3Bhc3RlJywgc3RydWN0KTtcclxuXHR9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ3Vlc3NUeXBlKG1vbCwgc3RyaWN0KSB7XHJcblx0Ly8gTWltaWMgSW5kaWdvL21vbGVjdWxlX2F1dG9fbG9hZGVyLmNwcCBhcyBtdWNoIGFzIHBvc3NpYmxlXHJcblx0dmFyIG1vbFN0ciA9IG1vbC50cmltKCk7XHJcblx0dmFyIG1vbE1hdGNoID0gbW9sU3RyLm1hdGNoKC9eKE0gIEVORHxcXCRFTkQgTU9MKSQvbSk7XHJcblx0aWYgKG1vbE1hdGNoKSB7XHJcblx0XHR2YXIgZW5kID0gbW9sTWF0Y2guaW5kZXggKyBtb2xNYXRjaFswXS5sZW5ndGg7XHJcblx0XHRpZiAoZW5kID09IG1vbFN0ci5sZW5ndGggfHxcclxuXHRcdCAgICBtb2xTdHIuc2xpY2UoZW5kLCBlbmQgKyAyMCkuc2VhcmNoKC9eXFwkKE1PTHxFTkQgQ1RBQikkL20pICE9IC0xKVxyXG5cdFx0XHRyZXR1cm4gJ21vbCc7XHJcblx0fVxyXG5cdGlmIChtb2xTdHJbMF0gPT0gJzwnICYmIG1vbFN0ci5pbmRleE9mKCc8bW9sZWN1bGUnKSAhPSAtMSlcclxuXHRcdHJldHVybiAnY21sJztcclxuXHRpZiAobW9sU3RyLnNsaWNlKDAsIDUpID09ICdJbkNoSScpXHJcblx0XHRyZXR1cm4gJ2luY2hpJztcclxuXHRpZiAobW9sU3RyLmluZGV4T2YoJ1xcbicpID09IC0xKVxyXG5cdFx0cmV0dXJuICdzbWlsZXMnO1xyXG5cdC8vIE1vbGZpbGUgYnkgZGVmYXVsdCBhcyBJbmRpZ28gZG9lc1xyXG5cdHJldHVybiBzdHJpY3QgPyBudWxsIDogJ21vbCc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFN0cnVjdChtb2wsIGNoZWNrRW1wdHlMaW5lKSB7XHJcblx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuXHRcdHZhciB0eXBlID0gZ3Vlc3NUeXBlKG1vbCk7XHJcblx0XHRpZiAodHlwZSA9PSAnbW9sJykge1xyXG5cdFx0XHR2YXIgc3RydWN0ID0gcGFyc2VNYXlCZUNvcnJ1cHRlZENURmlsZShtb2wsXHJcblx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRW1wdHlMaW5lKTtcclxuXHRcdFx0cmVzb2x2ZShzdHJ1Y3QpO1xyXG5cdFx0fSBlbHNlIGlmICh1aS5zdGFuZGFsb25lKVxyXG5cdFx0XHR0aHJvdyB0eXBlID8gdHlwZS50b1VwcGVyQ2FzZSgpIDogJ0Zvcm1hdCcgK1xyXG5cdFx0XHQgICAgICAnIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYSBzdGFuZGFsb25lIG1vZGUuJztcclxuXHRcdGVsc2Uge1xyXG5cdFx0XHR2YXIgcmVxID0gKHR5cGUgPT0gJ3NtaWxlcycpID9cclxuXHRcdFx0ICAgIHNlcnZlci5sYXlvdXRfc21pbGVzKG51bGwsIHtzbWlsZXM6IG1vbC50cmltKCl9KSA6XHJcblx0XHRcdCAgICBzZXJ2ZXIubW9sZmlsZSh7bW9sZGF0YTogbW9sfSk7XHJcblx0XHRcdHJlc29sdmUocmVxLnRoZW4oZnVuY3Rpb24gKHJlcykge1xyXG5cdFx0XHRcdHJldHVybiBwYXJzZU1heUJlQ29ycnVwdGVkQ1RGaWxlKHJlcyk7XHJcblx0XHRcdH0pKTtcclxuXHRcdH1cclxuXHR9KTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIHBhZ2UyY2FudmFzMiAocG9zKVxyXG57XHJcblx0dmFyIG9mZnNldCA9IGNsaWVudEFyZWEuY3VtdWxhdGl2ZU9mZnNldCgpO1xyXG5cdHJldHVybiBuZXcgVmVjMihwb3MucGFnZVggLSBvZmZzZXQubGVmdCwgcG9zLnBhZ2VZIC0gb2Zmc2V0LnRvcCk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBwYWdlMm9iaiAocGFnZVBvcylcclxue1xyXG5cdHJldHVybiB1aS5yZW5kZXIudmlldzJvYmoocGFnZTJjYW52YXMyKHBhZ2VQb3MpKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIHNjcm9sbFBvcyAoKVxyXG57XHJcblx0cmV0dXJuIG5ldyBWZWMyKGNsaWVudEFyZWEuc2Nyb2xsTGVmdCwgY2xpZW50QXJlYS5zY3JvbGxUb3ApO1xyXG59O1xyXG5cclxuLy9cclxuLy8gU2Nyb2xsaW5nXHJcbi8vXHJcbnZhciBzY3JvbGxMZWZ0ID0gbnVsbDtcclxudmFyIHNjcm9sbFRvcCA9IG51bGw7XHJcblxyXG5mdW5jdGlvbiBvblNjcm9sbF9DbGllbnRBcmVhIChldmVudClcclxue1xyXG5cdC8vICEgRElBTE9HIE1FXHJcblx0Ly8gaWYgKCQoJ2lucHV0X2xhYmVsJykudmlzaWJsZSgpKVxyXG5cdC8vICAgICAgJCgnaW5wdXRfbGFiZWwnKS5oaWRlKCk7XHJcblxyXG5cdHNjcm9sbExlZnQgPSBjbGllbnRBcmVhLnNjcm9sbExlZnQ7XHJcblx0c2Nyb2xsVG9wID0gY2xpZW50QXJlYS5zY3JvbGxUb3A7XHJcblxyXG5cdHV0aWwuc3RvcEV2ZW50UHJvcGFnYXRpb24oZXZlbnQpO1xyXG59O1xyXG5cclxuLy9cclxuLy8gQ2FudmFzIHNpemVcclxuLy9cclxuZnVuY3Rpb24gb25PZmZzZXRDaGFuZ2VkIChuZXdPZmZzZXQsIG9sZE9mZnNldClcclxue1xyXG5cdGlmIChvbGRPZmZzZXQgPT0gbnVsbClcclxuXHRcdHJldHVybjtcclxuXHJcblx0dmFyIGRlbHRhID0gbmV3IFZlYzIobmV3T2Zmc2V0LnggLSBvbGRPZmZzZXQueCwgbmV3T2Zmc2V0LnkgLSBvbGRPZmZzZXQueSk7XHJcblxyXG5cdGNsaWVudEFyZWEuc2Nyb2xsTGVmdCArPSBkZWx0YS54O1xyXG5cdGNsaWVudEFyZWEuc2Nyb2xsVG9wICs9IGRlbHRhLnk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiByZW1vdmVTZWxlY3RlZCAoKVxyXG57XHJcblx0YWRkVW5kb0FjdGlvbihBY3Rpb24uZnJvbUZyYWdtZW50RGVsZXRpb24oKSk7XHJcblx0dWkuZWRpdG9yLmRlc2VsZWN0QWxsKCk7XHJcblx0dWkucmVuZGVyLnVwZGF0ZSgpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gdW5kbyAoKVxyXG57XHJcblx0aWYgKHVpLnJlbmRlci5jdXJyZW50X3Rvb2wpXHJcblx0XHR1aS5yZW5kZXIuY3VycmVudF90b29sLk9uQ2FuY2VsKCk7XHJcblxyXG5cdHVpLmVkaXRvci5kZXNlbGVjdEFsbCgpO1xyXG5cdHJlZG9TdGFjay5wdXNoKHVuZG9TdGFjay5wb3AoKS5wZXJmb3JtKCkpO1xyXG5cdHVpLnJlbmRlci51cGRhdGUoKTtcclxuXHR1cGRhdGVIaXN0b3J5QnV0dG9ucygpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gcmVkbyAoKVxyXG57XHJcblx0aWYgKHVpLnJlbmRlci5jdXJyZW50X3Rvb2wpXHJcblx0XHR1aS5yZW5kZXIuY3VycmVudF90b29sLk9uQ2FuY2VsKCk7XHJcblxyXG5cdHVpLmVkaXRvci5kZXNlbGVjdEFsbCgpO1xyXG5cdHVuZG9TdGFjay5wdXNoKHJlZG9TdGFjay5wb3AoKS5wZXJmb3JtKCkpO1xyXG5cdHVpLnJlbmRlci51cGRhdGUoKTtcclxuXHR1cGRhdGVIaXN0b3J5QnV0dG9ucygpO1xyXG59O1xyXG5cclxudmFyIGN1cnJlbnRfZWxlbXRhYmxlX3Byb3BzID0gbnVsbDtcclxuZnVuY3Rpb24gb25DbGlja19FbGVtVGFibGVCdXR0b24gKClcclxue1xyXG5cdHNob3dFbGVtVGFibGUoe1xyXG5cdFx0b25PazogZnVuY3Rpb24gKHJlcykge1xyXG5cdFx0XHR2YXIgcHJvcHM7XHJcblx0XHRcdGlmIChyZXMubW9kZSA9PSAnc2luZ2xlJylcclxuXHRcdFx0XHRwcm9wcyA9IHtcclxuXHRcdFx0XHRcdGxhYmVsOiBlbGVtZW50LmdldChyZXMudmFsdWVzWzBdKS5sYWJlbFxyXG5cdFx0XHRcdH07XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHRwcm9wcyA9IHtcclxuXHRcdFx0XHRcdGxhYmVsOiAnTCMnLFxyXG5cdFx0XHRcdFx0YXRvbUxpc3Q6IG5ldyBBdG9tLkxpc3Qoe1xyXG5cdFx0XHRcdFx0XHRub3RMaXN0OiByZXMubW9kZSA9PSAnbm90LWxpc3QnLFxyXG5cdFx0XHRcdFx0XHRpZHM6IHJlcy52YWx1ZXNcclxuXHRcdFx0XHRcdH0pXHJcblx0XHRcdFx0fTtcclxuXHRcdFx0Y3VycmVudF9lbGVtdGFibGVfcHJvcHMgPSBwcm9wcztcclxuXHRcdFx0c2VsZWN0QWN0aW9uKCdhdG9tLXRhYmxlJyk7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSxcclxuXHRcdG9uQ2FuY2VsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdC8vdWkuZWxlbV90YWJsZV9vYmoucmVzdG9yZSgpO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG59O1xyXG5cclxudmFyIGN1cnJlbnRfcmVhZ2VuZXJpY3MgPSBudWxsO1xyXG5mdW5jdGlvbiBvbkNsaWNrX1JlYUdlbmVyaWNzVGFibGVCdXR0b24gKClcclxue1xyXG5cdHNob3dSZWFHZW5lcmljc1RhYmxlKHtcclxuXHRcdG9uT2s6IGZ1bmN0aW9uIChyZXMpIHtcclxuXHRcdFx0Y3VycmVudF9yZWFnZW5lcmljcyA9IHtsYWJlbDogcmVzLnZhbHVlc1swXX07XHJcblx0XHRcdHNlbGVjdEFjdGlvbignYXRvbS1yZWFnZW5lcmljcycpO1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHR9KTtcclxufTtcclxuXHJcbi8vIFRPRE86IHJlbW92ZSB0aGlzIGNyYXAgKHF1aWNrIGhhY2sgdG8gcGFzcyBwYXJhbWV0ciB0byBzZWxlY3RBY3Rpb24pXHJcbnZhciBjdXJyZW50X3RlbXBsYXRlX2N1c3RvbSA9IG51bGw7XHJcbmZ1bmN0aW9uIG9uQ2xpY2tfVGVtcGxhdGVDdXN0b20gKCkge1xyXG5cdHRlbXBsYXRlc0RpYWxvZygnJywge1xyXG5cdFx0b25PazogZnVuY3Rpb24gKHRtcGwpIHtcclxuXHRcdFx0Y3VycmVudF90ZW1wbGF0ZV9jdXN0b20gPSB0bXBsO1xyXG5cdFx0XHRzZWxlY3RBY3Rpb24oJ3RlbXBsYXRlLWN1c3RvbS1zZWxlY3QnKTtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblx0fSk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBzaG93U2dyb3VwRGlhbG9nKHBhcmFtcykge1xyXG5cdGlmIChmYWxzZSAmJiBzZ3JvdXBTcGVjaWFsRGlhbG9nLm1hdGNoKHBhcmFtcykpXHJcblx0XHRyZXR1cm4gc2dyb3VwU3BlY2lhbERpYWxvZyhwYXJhbXMpO1xyXG5cdHJldHVybiBzZ3JvdXBEaWFsb2cocGFyYW1zKTtcclxufTtcclxuXHJcbi8vIHRyeSB0byByZWNvbnN0cnVjdCBtb2xmaWxlIHN0cmluZyBpbnN0ZWFkIHBhcnNpbmcgbXVsdGlwbGUgdGltZXNcclxuLy8gVE9ETzogbW92ZSB0aGlzIGxvZ2ljIHRvIE1vbGZpbGVcclxuZnVuY3Rpb24gcGFyc2VNYXlCZUNvcnJ1cHRlZENURmlsZSAobW9sLCBjaGVja0VtcHR5TGluZSkge1xyXG5cdHZhciBsaW5lcyA9IHV0aWwuc3BsaXROZXdsaW5lcyhtb2wpO1xyXG5cdHRyeSB7XHJcblx0XHRyZXR1cm4gbW9sZmlsZS5wYXJzZShsaW5lcyk7XHJcblx0fSBjYXRjaCAoZXgpIHtcclxuXHRcdGlmIChjaGVja0VtcHR5TGluZSkge1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdC8vIGNoZWNrIHdoZXRoZXIgdGhlcmUncyBhbiBleHRyYSBlbXB0eSBsaW5lIG9uIHRvcFxyXG5cdFx0XHRcdC8vIHRoaXMgb2Z0ZW4gaGFwcGVucyB3aGVuIG1vbGZpbGUgdGV4dCBpcyBwYXN0ZWQgaW50byB0aGUgZGlhbG9nIHdpbmRvd1xyXG5cdFx0XHRcdHJldHVybiBtb2xmaWxlLnBhcnNlKGxpbmVzLnNsaWNlKDEpKTtcclxuXHRcdFx0fSBjYXRjaCAoZXgxKSB7XHJcblx0XHRcdH1cclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHQvLyBjaGVjayBmb3IgYSBtaXNzaW5nIGZpcnN0IGxpbmVcclxuXHRcdFx0XHQvLyB0aGlzIHNvbWV0aW1lcyBoYXBwZW5zIHdoZW4gcGFzdGluZ1xyXG5cdFx0XHRcdHJldHVybiBtb2xmaWxlLnBhcnNlKFsnJ10uY29uY2F0KGxpbmVzKSk7XHJcblx0XHRcdH0gY2F0Y2ggKGV4Mikge1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHR0aHJvdyBleDtcclxuXHR9XHJcbn07XHJcblxyXG52YXIgYWN0aW9uTWFwID0ge1xyXG5cdCduZXcnOiBvbkNsaWNrX05ld0ZpbGUsXHJcblx0J29wZW4nOiBvbkNsaWNrX09wZW5GaWxlLFxyXG5cdCdzYXZlJzogb25DbGlja19TYXZlRmlsZSxcclxuXHQndW5kbyc6IHVuZG8sXHJcblx0J3JlZG8nOiByZWRvLFxyXG5cdCd6b29tLWluJzogb25DbGlja19ab29tSW4sXHJcblx0J3pvb20tb3V0Jzogb25DbGlja19ab29tT3V0LFxyXG5cdCdjbGVhbnVwJzogb25DbGlja19DbGVhblVwLFxyXG5cdCdhcm9tJzogb25DbGlja19Bcm9tYXRpemUsXHJcblx0J2RlYXJvbSc6IG9uQ2xpY2tfRGVhcm9tYXRpemUsXHJcblx0J3BlcmlvZC10YWJsZSc6IG9uQ2xpY2tfRWxlbVRhYmxlQnV0dG9uLFxyXG5cdCdnZW5lcmljLWdyb3Vwcyc6IG9uQ2xpY2tfUmVhR2VuZXJpY3NUYWJsZUJ1dHRvbixcclxuXHQndGVtcGxhdGUtY3VzdG9tJzogb25DbGlja19UZW1wbGF0ZUN1c3RvbSxcclxuXHQnY3V0JzogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHN0cnVjdCA9IHVpLmVkaXRvci5nZXRTZWxlY3Rpb25TdHJ1Y3QoKTtcclxuXHRcdHJlbW92ZVNlbGVjdGVkKCk7XHJcblx0XHRyZXR1cm4gc3RydWN0LmlzQmxhbmsoKSA/IG51bGwgOiBzdHJ1Y3Q7XHJcblx0fSxcclxuXHQnY29weSc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBzdHJ1Y3QgPSB1aS5lZGl0b3IuZ2V0U2VsZWN0aW9uU3RydWN0KCk7XHJcblx0XHR1aS5lZGl0b3IuZGVzZWxlY3RBbGwoKTtcclxuXHRcdHJldHVybiBzdHJ1Y3QuaXNCbGFuaygpID8gbnVsbCA6IHN0cnVjdDtcclxuXHR9LFxyXG5cdCdwYXN0ZSc6IGZ1bmN0aW9uIChzdHJ1Y3QpIHtcclxuXHRcdGlmIChzdHJ1Y3QuaXNCbGFuaygpKVxyXG5cdFx0XHR0aHJvdyAnTm90IGEgdmFsaWQgc3RydWN0dXJlIHRvIHBhc3RlJztcclxuXHRcdHVpLmVkaXRvci5kZXNlbGVjdEFsbCgpO1xyXG5cdFx0cmV0dXJuIG5ldyBFZGl0b3IuUGFzdGVUb29sKHVpLmVkaXRvciwgc3RydWN0KTtcclxuXHR9LFxyXG5cdCdpbmZvJzogZnVuY3Rpb24gKGVsKSB7XHJcblx0XHRzaG93RGlhbG9nKCdhYm91dF9kaWFsb2cnKTtcclxuXHR9LFxyXG5cdCdzZWxlY3QtYWxsJzogZnVuY3Rpb24gKCkge1xyXG5cdFx0dWkuZWRpdG9yLnNlbGVjdEFsbCgpO1xyXG5cdH0sXHJcblx0J2Rlc2VsZWN0LWFsbCc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHVpLmVkaXRvci5kZXNlbGVjdEFsbCgpO1xyXG5cdH0sXHJcblx0J2ZvcmNlLXVwZGF0ZSc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIG9yaWdpbmFsOiBmb3IgZGV2IHB1cnBvc2VzXHJcblx0XHR1aS5yZW5kZXIudXBkYXRlKHRydWUpO1xyXG5cdH0sXHJcblx0J3JlYWN0aW9uLWF1dG9tYXAnOiBvbkNsaWNrX0F1dG9tYXAsXHJcblx0J2NhbGMtY2lwJzogY2FsY3VsYXRlQ2lwXHJcbn07XHJcblxyXG4vLyBUT0RPOiByZXdyaXRlIGRlY2xhcmF0aXZlbHksIG1lcmdlIHRvIGFjdGlvbk1hcFxyXG5mdW5jdGlvbiBtYXBUb29sIChpZCkge1xyXG5cclxuXHRjb25zb2xlLmFzc2VydChpZCwgJ1RoZSBudWxsIHRvb2wnKTtcclxuXHJcblx0dmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcblx0aWYgKGFjdGlvbk1hcFtpZF0pXHJcblx0XHRyZXR1cm4gYWN0aW9uTWFwW2lkXS5hcHBseShudWxsLCBhcmdzKTtcclxuXHQvLyBzcGVjaWFsIGNhc2VzXHJcblx0aWYgKHVpLmVkaXRvci5oYXNTZWxlY3Rpb24oKSkge1xyXG5cdFx0aWYgKGlkID09ICdlcmFzZScpIHtcclxuXHRcdFx0cmVtb3ZlU2VsZWN0ZWQoKTtcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblx0XHQvLyBCSzogVE9ETzogYWRkIHRoaXMgYWJpbGl0eSB0byBtYXNzLWNoYW5nZSBhdG9tIGxhYmVscyB0byB0aGUga2V5Ym9hcmQgaGFuZGxlclxyXG5cdFx0aWYgKGlkLnN0YXJ0c1dpdGgoJ2F0b20tJykpIHtcclxuXHRcdFx0YWRkVW5kb0FjdGlvbihBY3Rpb24uZnJvbUF0b21zQXR0cnModWkuZWRpdG9yLmdldFNlbGVjdGlvbigpLmF0b21zLCBhdG9tTGFiZWwoaWQpKSwgdHJ1ZSk7XHJcblx0XHRcdHVpLnJlbmRlci51cGRhdGUoKTtcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGlkLnN0YXJ0c1dpdGgoJ3RyYW5zZm9ybS1mbGlwJykpIHtcclxuXHRcdFx0YWRkVW5kb0FjdGlvbihBY3Rpb24uZnJvbUZsaXAodWkuZWRpdG9yLmdldFNlbGVjdGlvbigpLFxyXG5cdFx0XHRcdGlkLmVuZHNXaXRoKCdoJykgPyAnaG9yaXpvbnRhbCcgOlxyXG5cdFx0XHRcdFx0J3ZlcnRpY2FsJyksXHJcblx0XHRcdFx0dHJ1ZSk7XHJcblx0XHRcdHVpLnJlbmRlci51cGRhdGUoKTtcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0LyogQks6IFRPRE86IGFkZCB0aGlzIGFiaWxpdHkgdG8gY2hhbmdlIHRoZSBib25kIHVuZGVyIGN1cnNvciB0byB0aGUgZWRpdG9yIHRvb2xcclxuICAgICAgICAgZWxzZSBpZiAobW9kZS5zdGFydHNXaXRoKCdib25kXycpKSB7XHJcbiAgICAgICAgIHZhciBjQm9uZCA9IHVpLnJlbmRlci5maW5kQ2xvc2VzdEJvbmQocGFnZTJvYmoodWkuY3Vyc29yUG9zKSk7XHJcbiAgICAgICAgIGlmIChjQm9uZCkge1xyXG4gICAgICAgICBhZGRVbmRvQWN0aW9uKEFjdGlvbi5mcm9tQm9uZEF0dHJzKGNCb25kLmlkLCB7IHR5cGU6IGJvbmRUeXBlKG1vZGUpLnR5cGUsIHN0ZXJlbzogQm9uZC5QQVRURVJOLlNURVJFTy5OT05FIH0pLCB0cnVlKTtcclxuICAgICAgICAgdWkucmVuZGVyLnVwZGF0ZSgpO1xyXG4gICAgICAgICByZXR1cm47XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgfSAqL1xyXG5cdH1cclxuXHJcblx0aWYgKGlkICE9ICd0cmFuc2Zvcm0tcm90YXRlJylcclxuXHRcdHVpLmVkaXRvci5kZXNlbGVjdEFsbCgpO1xyXG5cclxuXHRpZiAoaWQgPT0gJ3NlbGVjdC1sYXNzbycpIHtcclxuXHRcdHJldHVybiBuZXcgRWRpdG9yLkxhc3NvVG9vbCh1aS5lZGl0b3IsIDApO1xyXG5cdH0gZWxzZSBpZiAoaWQgPT0gJ3NlbGVjdC1yZWN0YW5nbGUnKSB7XHJcblx0XHRyZXR1cm4gbmV3IEVkaXRvci5MYXNzb1Rvb2wodWkuZWRpdG9yLCAxKTtcclxuXHR9IGVsc2UgaWYgKGlkID09ICdzZWxlY3QtZnJhZ21lbnQnKSB7XHJcblx0XHRyZXR1cm4gbmV3IEVkaXRvci5MYXNzb1Rvb2wodWkuZWRpdG9yLCAxLCB0cnVlKTtcclxuXHR9IGVsc2UgaWYgKGlkID09ICdlcmFzZScpIHtcclxuXHRcdHJldHVybiBuZXcgRWRpdG9yLkVyYXNlclRvb2wodWkuZWRpdG9yLCAxKTsgLy8gVE9ETyBsYXN0IHNlbGVjdG9yIG1vZGUgaXMgYmV0dGVyXHJcblx0fSBlbHNlIGlmIChpZC5zdGFydHNXaXRoKCdhdG9tLScpKSB7XHJcblx0XHRyZXR1cm4gbmV3IEVkaXRvci5BdG9tVG9vbCh1aS5lZGl0b3IsIGF0b21MYWJlbChpZCkpO1xyXG5cdH0gZWxzZSBpZiAoaWQuc3RhcnRzV2l0aCgnYm9uZC0nKSkge1xyXG5cdFx0cmV0dXJuIG5ldyBFZGl0b3IuQm9uZFRvb2wodWkuZWRpdG9yLCBib25kVHlwZShpZCkpO1xyXG5cdH0gZWxzZSBpZiAoaWQgPT0gJ2NoYWluJykge1xyXG5cdFx0cmV0dXJuIG5ldyBFZGl0b3IuQ2hhaW5Ub29sKHVpLmVkaXRvcik7XHJcblx0fSBlbHNlIGlmIChpZC5zdGFydHNXaXRoKCd0ZW1wbGF0ZS1jdXN0b20nKSkge1xyXG5cdFx0cmV0dXJuIG5ldyBFZGl0b3IuVGVtcGxhdGVUb29sKHVpLmVkaXRvciwgY3VycmVudF90ZW1wbGF0ZV9jdXN0b20pO1xyXG5cdH0gZWxzZSBpZiAoaWQuc3RhcnRzV2l0aCgndGVtcGxhdGUnKSkge1xyXG5cdFx0cmV0dXJuIG5ldyBFZGl0b3IuVGVtcGxhdGVUb29sKHVpLmVkaXRvciwgdGVtcGxhdGVzW3BhcnNlSW50KGlkLnNwbGl0KCctJylbMV0pXSk7XHJcblx0fSBlbHNlIGlmIChpZCA9PSAnY2hhcmdlLXBsdXMnKSB7XHJcblx0XHRyZXR1cm4gbmV3IEVkaXRvci5DaGFyZ2VUb29sKHVpLmVkaXRvciwgMSk7XHJcblx0fSBlbHNlIGlmIChpZCA9PSAnY2hhcmdlLW1pbnVzJykge1xyXG5cdFx0cmV0dXJuIG5ldyBFZGl0b3IuQ2hhcmdlVG9vbCh1aS5lZGl0b3IsIC0xKTtcclxuXHR9IGVsc2UgaWYgKGlkID09ICdzZ3JvdXAnKSB7XHJcblx0XHRyZXR1cm4gbmV3IEVkaXRvci5TR3JvdXBUb29sKHVpLmVkaXRvcik7XHJcblx0fSBlbHNlIGlmIChpZCA9PSAncmVhY3Rpb24tYXJyb3cnKSB7XHJcblx0XHRyZXR1cm4gbmV3IEVkaXRvci5SZWFjdGlvbkFycm93VG9vbCh1aS5lZGl0b3IpO1xyXG5cdH0gZWxzZSBpZiAoaWQgPT0gJ3JlYWN0aW9uLXBsdXMnKSB7XHJcblx0XHRyZXR1cm4gbmV3IEVkaXRvci5SZWFjdGlvblBsdXNUb29sKHVpLmVkaXRvcik7XHJcblx0fSBlbHNlIGlmIChpZCA9PSAncmVhY3Rpb24tbWFwJykge1xyXG5cdFx0cmV0dXJuIG5ldyBFZGl0b3IuUmVhY3Rpb25NYXBUb29sKHVpLmVkaXRvcik7XHJcblx0fSBlbHNlIGlmIChpZCA9PSAncmVhY3Rpb24tdW5tYXAnKSB7XHJcblx0XHRyZXR1cm4gbmV3IEVkaXRvci5SZWFjdGlvblVubWFwVG9vbCh1aS5lZGl0b3IpO1xyXG5cdH0gZWxzZSBpZiAoaWQgPT0gJ3Jncm91cC1sYWJlbCcpIHtcclxuXHRcdHJldHVybiBuZXcgRWRpdG9yLlJHcm91cEF0b21Ub29sKHVpLmVkaXRvcik7XHJcblx0fSBlbHNlIGlmIChpZCA9PSAncmdyb3VwLWZyYWdtZW50Jykge1xyXG5cdFx0cmV0dXJuIG5ldyBFZGl0b3IuUkdyb3VwRnJhZ21lbnRUb29sKHVpLmVkaXRvcik7XHJcblx0fSBlbHNlIGlmIChpZCA9PSAncmdyb3VwLWF0dHBvaW50cycpIHtcclxuXHRcdHJldHVybiBuZXcgRWRpdG9yLkFQb2ludFRvb2wodWkuZWRpdG9yKTtcclxuXHR9IGVsc2UgaWYgKGlkLnN0YXJ0c1dpdGgoJ3RyYW5zZm9ybS1yb3RhdGUnKSkge1xyXG5cdFx0cmV0dXJuIG5ldyBFZGl0b3IuUm90YXRlVG9vbCh1aS5lZGl0b3IpO1xyXG5cdH1cclxuXHRyZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbi8vIFRPRE86IHJlbW92ZS4gb25seSBpbiBvYnNvbGV0ZSBkaWFsb2dzXHJcbnZhciBib25kVHlwZU1hcCA9IHtcclxuXHQnc2luZ2xlJzoge3R5cGU6IDEsIHN0ZXJlbzogQm9uZC5QQVRURVJOLlNURVJFTy5OT05FfSxcclxuXHQndXAnOiB7dHlwZTogMSwgc3RlcmVvOiBCb25kLlBBVFRFUk4uU1RFUkVPLlVQfSxcclxuXHQnZG93bic6IHt0eXBlOiAxLCBzdGVyZW86IEJvbmQuUEFUVEVSTi5TVEVSRU8uRE9XTn0sXHJcblx0J3VwZG93bic6IHt0eXBlOiAxLCBzdGVyZW86IEJvbmQuUEFUVEVSTi5TVEVSRU8uRUlUSEVSfSxcclxuXHQnZG91YmxlJzoge3R5cGU6IDIsIHN0ZXJlbzogQm9uZC5QQVRURVJOLlNURVJFTy5OT05FfSxcclxuXHQnY3Jvc3NlZCc6IHt0eXBlOiAyLCBzdGVyZW86IEJvbmQuUEFUVEVSTi5TVEVSRU8uQ0lTX1RSQU5TfSxcclxuXHQndHJpcGxlJzoge3R5cGU6IDMsIHN0ZXJlbzogQm9uZC5QQVRURVJOLlNURVJFTy5OT05FfSxcclxuXHQnYXJvbWF0aWMnOiB7dHlwZTogNCwgc3RlcmVvOiBCb25kLlBBVFRFUk4uU1RFUkVPLk5PTkV9LFxyXG5cdCdzaW5nbGVkb3VibGUnOiB7dHlwZTogNSwgc3RlcmVvOiBCb25kLlBBVFRFUk4uU1RFUkVPLk5PTkV9LFxyXG5cdCdzaW5nbGVhcm9tYXRpYyc6IHt0eXBlOiA2LCBzdGVyZW86IEJvbmQuUEFUVEVSTi5TVEVSRU8uTk9ORX0sXHJcblx0J2RvdWJsZWFyb21hdGljJzoge3R5cGU6IDcsIHN0ZXJlbzogQm9uZC5QQVRURVJOLlNURVJFTy5OT05FfSxcclxuXHQnYW55JzogIHt0eXBlOiA4LCBzdGVyZW86IEJvbmQuUEFUVEVSTi5TVEVSRU8uTk9ORX1cclxufTtcclxuXHJcbmZ1bmN0aW9uIGJvbmRUeXBlIChtb2RlKVxyXG57XHJcblx0dmFyIHR5cGVfc3RyID0gbW9kZS5zdWJzdHIoNSk7XHJcblx0cmV0dXJuIGJvbmRUeXBlTWFwW3R5cGVfc3RyXTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGF0b21MYWJlbCAobW9kZSkge1xyXG5cdHZhciBsYWJlbCA9IG1vZGUuc3Vic3RyKDUpO1xyXG5cdHN3aXRjaCAobGFiZWwpIHtcclxuXHRjYXNlICd0YWJsZSc6XHJcblx0XHRyZXR1cm4gY3VycmVudF9lbGVtdGFibGVfcHJvcHM7XHJcblx0Y2FzZSAncmVhZ2VuZXJpY3MnOlxyXG5cdFx0cmV0dXJuIGN1cnJlbnRfcmVhZ2VuZXJpY3M7XHJcblx0Y2FzZSAnYW55JzpcclxuXHRcdHJldHVybiB7bGFiZWw6J0EnfTtcclxuXHRkZWZhdWx0OlxyXG5cdFx0bGFiZWwgPSBsYWJlbC5jYXBpdGFsaXplKCk7XHJcblx0XHRjb25zb2xlLmFzc2VydChlbGVtZW50LmdldEVsZW1lbnRCeUxhYmVsKGxhYmVsKSxcclxuXHRcdCAgICAgICAgICAgICAgXCJObyBzdWNoIGF0b20gZXhpc3RcIik7XHJcblx0XHRyZXR1cm4ge2xhYmVsOiBsYWJlbH07XHJcblx0fVxyXG59O1xyXG5cclxuZnVuY3Rpb24gY2xlYW4gKCkge1xyXG5cdC8vIGxhdHRlciBpZiAoaW5pdGlhbGl6ZWQpXHJcblx0QWN0aW9uLmZyb21OZXdDYW52YXMobmV3IFN0cnVjdCgpKTtcclxuXHR1aS5yZW5kZXIudXBkYXRlKCk7XHJcblx0dW5kb1N0YWNrLmNsZWFyKCk7XHJcblx0cmVkb1N0YWNrLmNsZWFyKCk7XHJcblx0dXBkYXRlSGlzdG9yeUJ1dHRvbnMoKTtcclxuXHRzZWxlY3RBY3Rpb24obnVsbCk7XHJcbn1cclxuXHJcbi8vIFRoZSBleHBvc2UgZ3V0cyB0d28gd2F5XHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cdGluaXQ6IGluaXQsXHJcblx0Y2xlYW46IGNsZWFuLFxyXG5cdGxvYWRNb2xlY3VsZTogbG9hZE1vbGVjdWxlLFxyXG5cdGxvYWRGcmFnbWVudDogbG9hZEZyYWdtZW50XHJcbn07XHJcblxyXG51dGlsLmV4dGVuZCh1aSwgbW9kdWxlLmV4cG9ydHMpO1xyXG5cclxudXRpbC5leHRlbmQodWksIHtcclxuXHRzdGFuZGFsb25lOiB0cnVlLFxyXG5cdGN0YWI6IG5ldyBTdHJ1Y3QoKSxcclxuXHRyZW5kZXI6IG51bGwsXHJcblx0ZWRpdG9yOiBudWxsLFxyXG5cclxuXHRoaWRlQmx1cnJlZENvbnRyb2xzOiBoaWRlQmx1cnJlZENvbnRyb2xzLFxyXG5cdHVwZGF0ZUNsaXBib2FyZEJ1dHRvbnM6IHVwZGF0ZUNsaXBib2FyZEJ1dHRvbnMsXHJcblx0c2VsZWN0QWN0aW9uOiBzZWxlY3RBY3Rpb24sXHJcblx0YWRkVW5kb0FjdGlvbjogYWRkVW5kb0FjdGlvbixcclxuXHJcblx0Ly8gVE9ETzogcmVtb3ZlIG1lIGFzIHdlIGdldCBiZXR0ZXIgc2VydmVyIEFQSVxyXG5cdGxvYWRNb2xlY3VsZUZyb21GaWxlOiBvcGVuRGlhbG9nLmxvYWRIb29rLFxyXG5cclxuXHRlY2hvOiBlY2hvLFxyXG5cdHNob3dEaWFsb2c6IHNob3dEaWFsb2csXHJcblx0aGlkZURpYWxvZzogaGlkZURpYWxvZyxcclxuXHRib25kVHlwZU1hcDogYm9uZFR5cGVNYXAsXHJcblxyXG5cdC8vIFRPRE86IG1vdmUgc2Nocm9vbC96b29tIG1hY2hpbmVyeSB0byByZW5kZXJcclxuXHR6b29tOiAxLjAsXHJcblx0c2V0Wm9vbVN0YXRpY1BvaW50SW5pdDogc2V0Wm9vbVN0YXRpY1BvaW50SW5pdCxcclxuXHRzZXRab29tU3RhdGljUG9pbnQ6IHNldFpvb21TdGF0aWNQb2ludCxcclxuXHRwYWdlMmNhbnZhczI6IHBhZ2UyY2FudmFzMixcclxuXHRzY3JvbGxQb3M6IHNjcm9sbFBvcyxcclxuXHRwYWdlMm9iajogcGFnZTJvYmosXHJcblxyXG5cdC8vIFRPRE86IHNlYXJjaCBhIHdheSB0byBwYXNzIGRpYWxvZ3MgdG8gZWRpdG9yXHJcblx0c2hvd1NHcm91cFByb3BlcnRpZXM6IHNob3dTZ3JvdXBEaWFsb2csXHJcblx0c2hvd1JHcm91cFRhYmxlOiBzaG93Ukdyb3VwVGFibGUsXHJcblx0c2hvd0VsZW1UYWJsZTogc2hvd0VsZW1UYWJsZSxcclxuXHRzaG93UmVhR2VuZXJpY3NUYWJsZTogc2hvd1JlYUdlbmVyaWNzVGFibGUsXHJcblx0c2hvd0F0b21BdHRhY2htZW50UG9pbnRzOiBvYnNvbGV0ZS5zaG93QXRvbUF0dGFjaG1lbnRQb2ludHMsXHJcblx0c2hvd0F0b21Qcm9wZXJ0aWVzOiBvYnNvbGV0ZS5zaG93QXRvbVByb3BlcnRpZXMsXHJcblx0c2hvd0JvbmRQcm9wZXJ0aWVzOiBvYnNvbGV0ZS5zaG93Qm9uZFByb3BlcnRpZXMsXHJcblx0c2hvd1JMb2dpY1RhYmxlOiBvYnNvbGV0ZS5zaG93UkxvZ2ljVGFibGUsXHJcblx0c2hvd0xhYmVsRWRpdG9yOiBvYnNvbGV0ZS5zaG93TGFiZWxFZGl0b3JcclxufSk7XHJcbiIsInZhciBWZWMyID0gcmVxdWlyZSgnLi4vdXRpbC92ZWMyJyk7XHJcbnZhciBTZXQgPSByZXF1aXJlKCcuLi91dGlsL3NldCcpO1xyXG5cclxudmFyIFN0cnVjdCA9IHJlcXVpcmUoJy4uL2NoZW0vc3RydWN0Jyk7XHJcbnZhciBBdG9tID0gcmVxdWlyZSgnLi4vY2hlbS9hdG9tJyk7XHJcbnZhciBCb25kID0gcmVxdWlyZSgnLi4vY2hlbS9ib25kJyk7XHJcbnZhciBTR3JvdXAgPSByZXF1aXJlKCcuLi9jaGVtL3Nncm91cCcpO1xyXG5cclxucmVxdWlyZSgnLi4vcm5kJyk7XHJcblxyXG52YXIgdWkgPSBnbG9iYWwudWk7XHJcbnZhciBybmQgPSBnbG9iYWwucm5kO1xyXG5cclxuZnVuY3Rpb24gQmFzZSAoKSB7XHJcblx0dGhpcy50eXBlID0gJ09wQmFzZSc7XHJcblxyXG5cdC8vIGFzc2VydCBoZXJlP1xyXG5cdHRoaXMuX2V4ZWN1dGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ09wZXJhdGlvbi5fZXhlY3V0ZSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xyXG5cdH07XHJcblx0dGhpcy5faW52ZXJ0ID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdPcGVyYXRpb24uX2ludmVydCgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xyXG5cdH07XHJcblxyXG5cdHRoaXMucGVyZm9ybSA9IGZ1bmN0aW9uIChlZGl0b3IpIHtcclxuXHRcdHRoaXMuX2V4ZWN1dGUoZWRpdG9yKTtcclxuXHRcdGlmICghdGhpcy5fX2ludmVydGVkKSB7XHJcblx0XHRcdHRoaXMuX19pbnZlcnRlZCA9IHRoaXMuX2ludmVydCgpO1xyXG5cdFx0XHR0aGlzLl9faW52ZXJ0ZWQuX19pbnZlcnRlZCA9IHRoaXM7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5fX2ludmVydGVkO1xyXG5cdH07XHJcblx0dGhpcy5pc0R1bW15ID0gZnVuY3Rpb24gKGVkaXRvcikge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2lzRHVtbXkgPyB0aGlzLl9pc0R1bW15KGVkaXRvcikgOiBmYWxzZTtcclxuXHR9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBBdG9tQWRkIChhdG9tLCBwb3MpIHtcclxuXHR0aGlzLmRhdGEgPSB7IGFpZDogbnVsbCwgYXRvbTogYXRvbSwgcG9zOiBwb3MgfTtcclxuXHR0aGlzLl9leGVjdXRlID0gZnVuY3Rpb24gKGVkaXRvcikge1xyXG5cdFx0dmFyIFIgPSBlZGl0b3IucmVuZGVyLCBSUyA9IFIuY3RhYiwgRFMgPSBSUy5tb2xlY3VsZTtcclxuXHRcdHZhciBwcCA9IHt9O1xyXG5cdFx0aWYgKHRoaXMuZGF0YS5hdG9tKVxyXG5cdFx0XHRmb3IgKHZhciBwIGluIHRoaXMuZGF0YS5hdG9tKVxyXG5cdFx0XHRcdHBwW3BdID0gdGhpcy5kYXRhLmF0b21bcF07XHJcblx0XHRwcC5sYWJlbCA9IHBwLmxhYmVsIHx8ICdDJztcclxuXHRcdGlmICghT2JqZWN0LmlzTnVtYmVyKHRoaXMuZGF0YS5haWQpKSB7XHJcblx0XHRcdHRoaXMuZGF0YS5haWQgPSBEUy5hdG9tcy5hZGQobmV3IEF0b20ocHApKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdERTLmF0b21zLnNldCh0aGlzLmRhdGEuYWlkLCBuZXcgQXRvbShwcCkpO1xyXG5cdFx0fVxyXG5cdFx0UlMubm90aWZ5QXRvbUFkZGVkKHRoaXMuZGF0YS5haWQpO1xyXG5cdFx0RFMuX2F0b21TZXRQb3ModGhpcy5kYXRhLmFpZCwgbmV3IFZlYzIodGhpcy5kYXRhLnBvcykpO1xyXG5cdH07XHJcblx0dGhpcy5faW52ZXJ0ID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHJldCA9IG5ldyBBdG9tRGVsZXRlKCk7XHJcblx0XHRyZXQuZGF0YSA9IHRoaXMuZGF0YTtcclxuXHRcdHJldHVybiByZXQ7XHJcblx0fTtcclxufTtcclxuQXRvbUFkZC5wcm90b3R5cGUgPSBuZXcgQmFzZSgpO1xyXG5cclxuZnVuY3Rpb24gQXRvbURlbGV0ZSAoYWlkKSB7XHJcblx0dGhpcy5kYXRhID0geyBhaWQ6IGFpZCwgYXRvbTogbnVsbCwgcG9zOiBudWxsIH07XHJcblx0dGhpcy5fZXhlY3V0ZSA9IGZ1bmN0aW9uIChlZGl0b3IpIHtcclxuXHRcdHZhciBSID0gZWRpdG9yLnJlbmRlciwgUlMgPSBSLmN0YWIsIERTID0gUlMubW9sZWN1bGU7XHJcblx0XHRpZiAoIXRoaXMuZGF0YS5hdG9tKSB7XHJcblx0XHRcdHRoaXMuZGF0YS5hdG9tID0gRFMuYXRvbXMuZ2V0KHRoaXMuZGF0YS5haWQpO1xyXG5cdFx0XHR0aGlzLmRhdGEucG9zID0gUi5hdG9tR2V0UG9zKHRoaXMuZGF0YS5haWQpO1xyXG5cdFx0fVxyXG5cdFx0UlMubm90aWZ5QXRvbVJlbW92ZWQodGhpcy5kYXRhLmFpZCk7XHJcblx0XHREUy5hdG9tcy5yZW1vdmUodGhpcy5kYXRhLmFpZCk7XHJcblx0fTtcclxuXHR0aGlzLl9pbnZlcnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcmV0ID0gbmV3IEF0b21BZGQoKTtcclxuXHRcdHJldC5kYXRhID0gdGhpcy5kYXRhO1xyXG5cdFx0cmV0dXJuIHJldDtcclxuXHR9O1xyXG59O1xyXG5BdG9tRGVsZXRlLnByb3RvdHlwZSA9IG5ldyBCYXNlKCk7XHJcblxyXG5mdW5jdGlvbiBBdG9tQXR0ciAoYWlkLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XHJcblx0dGhpcy5kYXRhID0geyBhaWQ6IGFpZCwgYXR0cmlidXRlOiBhdHRyaWJ1dGUsIHZhbHVlOiB2YWx1ZSB9O1xyXG5cdHRoaXMuZGF0YTIgPSBudWxsO1xyXG5cdHRoaXMuX2V4ZWN1dGUgPSBmdW5jdGlvbiAoZWRpdG9yKSB7XHJcblx0XHR2YXIgYXRvbSA9IGVkaXRvci5yZW5kZXIuY3RhYi5tb2xlY3VsZS5hdG9tcy5nZXQodGhpcy5kYXRhLmFpZCk7XHJcblx0XHRpZiAoIXRoaXMuZGF0YTIpIHtcclxuXHRcdFx0dGhpcy5kYXRhMiA9IHsgYWlkOiB0aGlzLmRhdGEuYWlkLCBhdHRyaWJ1dGU6IHRoaXMuZGF0YS5hdHRyaWJ1dGUsIHZhbHVlOiBhdG9tW3RoaXMuZGF0YS5hdHRyaWJ1dGVdIH07XHJcblx0XHR9XHJcblx0XHRhdG9tW3RoaXMuZGF0YS5hdHRyaWJ1dGVdID0gdGhpcy5kYXRhLnZhbHVlO1xyXG5cdFx0ZWRpdG9yLnJlbmRlci5pbnZhbGlkYXRlQXRvbSh0aGlzLmRhdGEuYWlkKTtcclxuXHR9O1xyXG5cdHRoaXMuX2lzRHVtbXkgPSBmdW5jdGlvbiAoZWRpdG9yKSB7XHJcblx0XHRyZXR1cm4gZWRpdG9yLnJlbmRlci5jdGFiLm1vbGVjdWxlLmF0b21zLmdldCh0aGlzLmRhdGEuYWlkKVt0aGlzLmRhdGEuYXR0cmlidXRlXSA9PSB0aGlzLmRhdGEudmFsdWU7XHJcblx0fTtcclxuXHR0aGlzLl9pbnZlcnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcmV0ID0gbmV3IEF0b21BdHRyKCk7XHJcblx0XHRyZXQuZGF0YSA9IHRoaXMuZGF0YTI7XHJcblx0XHRyZXQuZGF0YTIgPSB0aGlzLmRhdGE7cmV0dXJuIHJldDtcclxuXHR9O1xyXG59O1xyXG5BdG9tQXR0ci5wcm90b3R5cGUgPSBuZXcgQmFzZSgpO1xyXG5cclxuZnVuY3Rpb24gQXRvbU1vdmUgKGFpZCwgZCwgbm9pbnZhbGlkYXRlKSB7XHJcblx0dGhpcy5kYXRhID0ge2FpZDogYWlkLCBkOiBkLCBub2ludmFsaWRhdGU6IG5vaW52YWxpZGF0ZX07XHJcblx0dGhpcy5fZXhlY3V0ZSA9IGZ1bmN0aW9uIChlZGl0b3IpIHtcclxuXHRcdHZhciBSID0gZWRpdG9yLnJlbmRlcjtcclxuXHRcdHZhciBSUyA9IFIuY3RhYjtcclxuXHRcdHZhciBEUyA9IFJTLm1vbGVjdWxlO1xyXG5cdFx0dmFyIGFpZCA9IHRoaXMuZGF0YS5haWQ7XHJcblx0XHR2YXIgZCA9IHRoaXMuZGF0YS5kO1xyXG5cdFx0RFMuYXRvbXMuZ2V0KGFpZCkucHAuYWRkXyhkKTtcclxuXHRcdFJTLmF0b21zLmdldChhaWQpLnZpc2VsLnRyYW5zbGF0ZShSLnBzKGQpKTtcclxuXHRcdHRoaXMuZGF0YS5kID0gZC5uZWdhdGVkKCk7XHJcblx0XHRpZiAoIXRoaXMuZGF0YS5ub2ludmFsaWRhdGUpXHJcblx0XHRcdFIuaW52YWxpZGF0ZUF0b20oYWlkLCAxKTtcclxuXHR9O1xyXG5cdHRoaXMuX2lzRHVtbXkgPSBmdW5jdGlvbiAoZWRpdG9yKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5kYXRhLmQueCA9PSAwICYmIHRoaXMuZGF0YS5kLnkgPT0gMDtcclxuXHR9O1xyXG5cdHRoaXMuX2ludmVydCA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciByZXQgPSBuZXcgQXRvbU1vdmUoKTtcclxuXHRcdHJldC5kYXRhID0gdGhpcy5kYXRhO1xyXG5cdFx0cmV0dXJuIHJldDtcclxuXHR9O1xyXG59O1xyXG5BdG9tTW92ZS5wcm90b3R5cGUgPSBuZXcgQmFzZSgpO1xyXG5cclxuZnVuY3Rpb24gQm9uZE1vdmUgKGJpZCwgZCkge1xyXG5cdHRoaXMuZGF0YSA9IHtiaWQ6IGJpZCwgZDogZH07XHJcblx0dGhpcy5fZXhlY3V0ZSA9IGZ1bmN0aW9uIChlZGl0b3IpIHtcclxuXHRcdHZhciBSID0gZWRpdG9yLnJlbmRlcjtcclxuXHRcdHZhciBSUyA9IFIuY3RhYjtcclxuXHRcdFJTLmJvbmRzLmdldCh0aGlzLmRhdGEuYmlkKS52aXNlbC50cmFuc2xhdGUoUi5wcyh0aGlzLmRhdGEuZCkpO1xyXG5cdFx0dGhpcy5kYXRhLmQgPSB0aGlzLmRhdGEuZC5uZWdhdGVkKCk7XHJcblx0fTtcclxuXHR0aGlzLl9pbnZlcnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcmV0ID0gbmV3IEJvbmRNb3ZlKCk7XHJcblx0XHRyZXQuZGF0YSA9IHRoaXMuZGF0YTtcclxuXHRcdHJldHVybiByZXQ7XHJcblx0fTtcclxufTtcclxuQm9uZE1vdmUucHJvdG90eXBlID0gbmV3IEJhc2UoKTtcclxuXHJcbmZ1bmN0aW9uIExvb3BNb3ZlIChpZCwgZCkge1xyXG5cdHRoaXMuZGF0YSA9IHtpZDogaWQsIGQ6IGR9O1xyXG5cdHRoaXMuX2V4ZWN1dGUgPSBmdW5jdGlvbiAoZWRpdG9yKSB7XHJcblx0XHR2YXIgUiA9IGVkaXRvci5yZW5kZXI7XHJcblx0XHR2YXIgUlMgPSBSLmN0YWI7XHJcblx0XHQvLyBub3Qgc3VyZSBpZiB0aGVyZSBzaG91bGQgYmUgYW4gYWN0aW9uIHRvIG1vdmUgYSBsb29wIGluIHRoZSBmaXJzdCBwbGFjZVxyXG5cdFx0Ly8gYnV0IHdlIGhhdmUgdG8gc29tZWhvdyBtb3ZlIHRoZSBhcm9tYXRpYyByaW5nLCB3aGljaCBpcyBhc3NvY2lhdGVkIHdpdGggdGhlIGxvb3AsIHJhdGhlciB0aGFuIHdpdGggYW55IG9mIHRoZSBib25kc1xyXG5cdFx0aWYgKFJTLnJlbG9vcHMuZ2V0KHRoaXMuZGF0YS5pZCkgJiYgUlMucmVsb29wcy5nZXQodGhpcy5kYXRhLmlkKS52aXNlbClcclxuXHRcdFx0UlMucmVsb29wcy5nZXQodGhpcy5kYXRhLmlkKS52aXNlbC50cmFuc2xhdGUoUi5wcyh0aGlzLmRhdGEuZCkpO1xyXG5cdFx0dGhpcy5kYXRhLmQgPSB0aGlzLmRhdGEuZC5uZWdhdGVkKCk7XHJcblx0fTtcclxuXHR0aGlzLl9pbnZlcnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcmV0ID0gbmV3IExvb3BNb3ZlKCk7XHJcblx0XHRyZXQuZGF0YSA9IHRoaXMuZGF0YTtcclxuXHRcdHJldHVybiByZXQ7XHJcblx0fTtcclxufTtcclxuTG9vcE1vdmUucHJvdG90eXBlID0gbmV3IEJhc2UoKTtcclxuXHJcbmZ1bmN0aW9uIFNHcm91cEF0b21BZGQgKHNnaWQsIGFpZCkge1xyXG5cdHRoaXMudHlwZSA9ICdPcFNHcm91cEF0b21BZGQnO1xyXG5cdHRoaXMuZGF0YSA9IHsnYWlkJzogYWlkLCAnc2dpZCc6IHNnaWR9O1xyXG5cdHRoaXMuX2V4ZWN1dGUgPSBmdW5jdGlvbiAoZWRpdG9yKSB7XHJcblx0XHR2YXIgUiA9IGVkaXRvci5yZW5kZXIsIFJTID0gUi5jdGFiLCBEUyA9IFJTLm1vbGVjdWxlO1xyXG5cdFx0dmFyIGFpZCA9IHRoaXMuZGF0YS5haWQ7XHJcblx0XHR2YXIgc2dpZCA9IHRoaXMuZGF0YS5zZ2lkO1xyXG5cdFx0dmFyIGF0b20gPSBEUy5hdG9tcy5nZXQoYWlkKTtcclxuXHRcdHZhciBzZyA9IERTLnNncm91cHMuZ2V0KHNnaWQpO1xyXG5cdFx0aWYgKHNnLmF0b21zLmluZGV4T2YoYWlkKSA+PSAwKVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzYW1lIGF0b20gY2Fubm90IGJlIGFkZGVkIHRvIGFuIFMtZ3JvdXAgbW9yZSB0aGFuIG9uY2UnKTtcclxuXHRcdGlmICghYXRvbSlcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdPcFNHcm91cEF0b21BZGQ6IEF0b20gJyArIGFpZCArICcgbm90IGZvdW5kJyk7XHJcblx0XHREUy5hdG9tQWRkVG9TR3JvdXAoc2dpZCwgYWlkKTtcclxuXHRcdFIuaW52YWxpZGF0ZUF0b20oYWlkKTtcclxuXHR9O1xyXG5cdHRoaXMuX2ludmVydCA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciByZXQgPSBuZXcgU0dyb3VwQXRvbVJlbW92ZSgpO1xyXG5cdFx0cmV0LmRhdGEgPSB0aGlzLmRhdGE7XHJcblx0XHRyZXR1cm4gcmV0O1xyXG5cdH07XHJcbn07XHJcblNHcm91cEF0b21BZGQucHJvdG90eXBlID0gbmV3IEJhc2UoKTtcclxuXHJcbmZ1bmN0aW9uIFNHcm91cEF0b21SZW1vdmUgKHNnaWQsIGFpZCkge1xyXG5cdHRoaXMudHlwZSA9ICdPcFNHcm91cEF0b21SZW1vdmUnO1xyXG5cdHRoaXMuZGF0YSA9IHsnYWlkJzogYWlkLCAnc2dpZCc6IHNnaWR9O1xyXG5cdHRoaXMuX2V4ZWN1dGUgPSBmdW5jdGlvbiAoZWRpdG9yKSB7XHJcblx0XHR2YXIgYWlkID0gdGhpcy5kYXRhLmFpZDtcclxuXHRcdHZhciBzZ2lkID0gdGhpcy5kYXRhLnNnaWQ7XHJcblx0XHR2YXIgUiA9IGVkaXRvci5yZW5kZXIsIFJTID0gUi5jdGFiLCBEUyA9IFJTLm1vbGVjdWxlO1xyXG5cdFx0dmFyIGF0b20gPSBEUy5hdG9tcy5nZXQoYWlkKTtcclxuXHRcdHZhciBzZyA9IERTLnNncm91cHMuZ2V0KHNnaWQpO1xyXG5cdFx0U0dyb3VwLnJlbW92ZUF0b20oc2csIGFpZCk7XHJcblx0XHRTZXQucmVtb3ZlKGF0b20uc2dzLCBzZ2lkKTtcclxuXHRcdFIuaW52YWxpZGF0ZUF0b20oYWlkKTtcclxuXHR9O1xyXG5cdHRoaXMuX2ludmVydCA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciByZXQgPSBuZXcgU0dyb3VwQXRvbUFkZCgpO1xyXG5cdFx0cmV0LmRhdGEgPSB0aGlzLmRhdGE7XHJcblx0XHRyZXR1cm4gcmV0O1xyXG5cdH07XHJcbn07XHJcblNHcm91cEF0b21SZW1vdmUucHJvdG90eXBlID0gbmV3IEJhc2UoKTtcclxuXHJcbmZ1bmN0aW9uIFNHcm91cEF0dHIgKHNnaWQsIGF0dHIsIHZhbHVlKSB7XHJcblx0dGhpcy50eXBlID0gJ09wU0dyb3VwQXR0cic7XHJcblx0dGhpcy5kYXRhID0ge3NnaWQ6IHNnaWQsIGF0dHI6IGF0dHIsIHZhbHVlOiB2YWx1ZX07XHJcblx0dGhpcy5fZXhlY3V0ZSA9IGZ1bmN0aW9uIChlZGl0b3IpIHtcclxuXHRcdHZhciBSID0gZWRpdG9yLnJlbmRlciwgUlMgPSBSLmN0YWIsIERTID0gUlMubW9sZWN1bGU7XHJcblx0XHR2YXIgc2dpZCA9IHRoaXMuZGF0YS5zZ2lkO1xyXG5cdFx0dmFyIHNnID0gRFMuc2dyb3Vwcy5nZXQoc2dpZCk7XHJcblx0XHRpZiAoc2cudHlwZSA9PSAnREFUJyAmJiBSUy5zZ3JvdXBEYXRhLmhhcyhzZ2lkKSkgeyAvLyBjbGVhbiB0aGUgc3R1ZmYgaGVyZSwgZWxzZSBpdCBtaWdodCBiZSBsZWZ0IGJlaGluZCBpZiB0aGUgc2dyb3VwcyBpcyBzZXQgdG8gXCJhdHRhY2hlZFwiXHJcblx0XHRcdFJTLmNsZWFyVmlzZWwoUlMuc2dyb3VwRGF0YS5nZXQoc2dpZCkudmlzZWwpO1xyXG5cdFx0XHRSUy5zZ3JvdXBEYXRhLnVuc2V0KHNnaWQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZGF0YS52YWx1ZSA9IHNnLnNldEF0dHIodGhpcy5kYXRhLmF0dHIsIHRoaXMuZGF0YS52YWx1ZSk7XHJcblx0fTtcclxuXHR0aGlzLl9pbnZlcnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcmV0ID0gbmV3IFNHcm91cEF0dHIoKTtcclxuXHRcdHJldC5kYXRhID0gdGhpcy5kYXRhO1xyXG5cdFx0cmV0dXJuIHJldDtcclxuXHR9O1xyXG59O1xyXG5TR3JvdXBBdHRyLnByb3RvdHlwZSA9IG5ldyBCYXNlKCk7XHJcblxyXG5mdW5jdGlvbiBTR3JvdXBDcmVhdGUgKHNnaWQsIHR5cGUsIHBwKSB7XHJcblx0dGhpcy50eXBlID0gJ09wU0dyb3VwQ3JlYXRlJztcclxuXHR0aGlzLmRhdGEgPSB7J3NnaWQnOiBzZ2lkLCAndHlwZSc6IHR5cGUsICdwcCc6IHBwfTtcclxuXHR0aGlzLl9leGVjdXRlID0gZnVuY3Rpb24gKGVkaXRvcikge1xyXG5cdFx0dmFyIFIgPSBlZGl0b3IucmVuZGVyLCBSUyA9IFIuY3RhYiwgRFMgPSBSUy5tb2xlY3VsZTtcclxuXHRcdHZhciBzZyA9IG5ldyBTR3JvdXAodGhpcy5kYXRhLnR5cGUpO1xyXG5cdFx0dmFyIHNnaWQgPSB0aGlzLmRhdGEuc2dpZDtcclxuXHRcdHNnLmlkID0gc2dpZDtcclxuXHRcdERTLnNncm91cHMuc2V0KHNnaWQsIHNnKTtcclxuXHRcdGlmICh0aGlzLmRhdGEucHApIHtcclxuXHRcdFx0RFMuc2dyb3Vwcy5nZXQoc2dpZCkucHAgPSBuZXcgVmVjMih0aGlzLmRhdGEucHApO1xyXG5cdFx0fVxyXG5cdFx0UlMuc2dyb3Vwcy5zZXQoc2dpZCwgbmV3IHJuZC5SZVNHcm91cChEUy5zZ3JvdXBzLmdldChzZ2lkKSkpO1xyXG5cdFx0dGhpcy5kYXRhLnNnaWQgPSBzZ2lkO1xyXG5cdH07XHJcblx0dGhpcy5faW52ZXJ0ID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHJldCA9IG5ldyBTR3JvdXBEZWxldGUoKTtcclxuXHRcdHJldC5kYXRhID0gdGhpcy5kYXRhO1xyXG5cdFx0cmV0dXJuIHJldDtcclxuXHR9O1xyXG59O1xyXG5TR3JvdXBDcmVhdGUucHJvdG90eXBlID0gbmV3IEJhc2UoKTtcclxuXHJcbmZ1bmN0aW9uIFNHcm91cERlbGV0ZSAoc2dpZCkge1xyXG5cdHRoaXMudHlwZSA9ICdPcFNHcm91cERlbGV0ZSc7XHJcblx0dGhpcy5kYXRhID0geydzZ2lkJzogc2dpZH07XHJcblx0dGhpcy5fZXhlY3V0ZSA9IGZ1bmN0aW9uIChlZGl0b3IpIHtcclxuXHRcdHZhciBSID0gZWRpdG9yLnJlbmRlciwgUlMgPSBSLmN0YWIsIERTID0gUlMubW9sZWN1bGU7XHJcblx0XHR2YXIgc2dpZCA9IHRoaXMuZGF0YS5zZ2lkO1xyXG5cdFx0dmFyIHNnID0gUlMuc2dyb3Vwcy5nZXQoc2dpZCk7XHJcblx0XHR0aGlzLmRhdGEudHlwZSA9IHNnLml0ZW0udHlwZTtcclxuXHRcdHRoaXMuZGF0YS5wcCA9IHNnLml0ZW0ucHA7XHJcblx0XHRpZiAoc2cuaXRlbS50eXBlID09ICdEQVQnICYmIFJTLnNncm91cERhdGEuaGFzKHNnaWQpKSB7XHJcblx0XHRcdFJTLmNsZWFyVmlzZWwoUlMuc2dyb3VwRGF0YS5nZXQoc2dpZCkudmlzZWwpO1xyXG5cdFx0XHRSUy5zZ3JvdXBEYXRhLnVuc2V0KHNnaWQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdFJTLmNsZWFyVmlzZWwoc2cudmlzZWwpO1xyXG5cdFx0aWYgKHNnLml0ZW0uYXRvbXMubGVuZ3RoICE9IDApXHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignUy1Hcm91cCBub3QgZW1wdHkhJyk7XHJcblx0XHRSUy5zZ3JvdXBzLnVuc2V0KHNnaWQpO1xyXG5cdFx0RFMuc2dyb3Vwcy5yZW1vdmUoc2dpZCk7XHJcblx0fTtcclxuXHR0aGlzLl9pbnZlcnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcmV0ID0gbmV3IFNHcm91cENyZWF0ZSgpO1xyXG5cdFx0cmV0LmRhdGEgPSB0aGlzLmRhdGE7XHJcblx0XHRyZXR1cm4gcmV0O1xyXG5cdH07XHJcbn07XHJcblNHcm91cERlbGV0ZS5wcm90b3R5cGUgPSBuZXcgQmFzZSgpO1xyXG5cclxuZnVuY3Rpb24gU0dyb3VwQWRkVG9IaWVyYXJjaHkgKHNnaWQpIHtcclxuXHR0aGlzLnR5cGUgPSAnT3BTR3JvdXBBZGRUb0hpZXJhcmNoeSc7XHJcblx0dGhpcy5kYXRhID0geydzZ2lkJzogc2dpZH07XHJcblx0dGhpcy5fZXhlY3V0ZSA9IGZ1bmN0aW9uIChlZGl0b3IpIHtcclxuXHRcdHZhciBSID0gZWRpdG9yLnJlbmRlciwgUlMgPSBSLmN0YWIsIERTID0gUlMubW9sZWN1bGU7XHJcblx0XHR2YXIgc2dpZCA9IHRoaXMuZGF0YS5zZ2lkO1xyXG5cdFx0dmFyIHJlbGF0aW9ucyA9IERTLnNHcm91cEZvcmVzdC5pbnNlcnQoc2dpZCwgdGhpcy5kYXRhLnBhcmVudCwgdGhpcy5kYXRhLmNoaWxkcmVuKTtcclxuXHRcdHRoaXMuZGF0YS5wYXJlbnQgPSByZWxhdGlvbnMucGFyZW50O1xyXG5cdFx0dGhpcy5kYXRhLmNoaWxkcmVuID0gcmVsYXRpb25zLmNoaWxkcmVuO1xyXG5cdH07XHJcblx0dGhpcy5faW52ZXJ0ID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHJldCA9IG5ldyBTR3JvdXBSZW1vdmVGcm9tSGllcmFyY2h5KCk7XHJcblx0XHRyZXQuZGF0YSA9IHRoaXMuZGF0YTtcclxuXHRcdHJldHVybiByZXQ7XHJcblx0fTtcclxufTtcclxuU0dyb3VwQWRkVG9IaWVyYXJjaHkucHJvdG90eXBlID0gbmV3IEJhc2UoKTtcclxuXHJcbmZ1bmN0aW9uIFNHcm91cFJlbW92ZUZyb21IaWVyYXJjaHkgKHNnaWQpIHtcclxuXHR0aGlzLnR5cGUgPSAnT3BTR3JvdXBSZW1vdmVGcm9tSGllcmFyY2h5JztcclxuXHR0aGlzLmRhdGEgPSB7J3NnaWQnOiBzZ2lkfTtcclxuXHR0aGlzLl9leGVjdXRlID0gZnVuY3Rpb24gKGVkaXRvcikge1xyXG5cdFx0dmFyIFIgPSBlZGl0b3IucmVuZGVyLCBSUyA9IFIuY3RhYiwgRFMgPSBSUy5tb2xlY3VsZTtcclxuXHRcdHZhciBzZ2lkID0gdGhpcy5kYXRhLnNnaWQ7XHJcblx0XHR0aGlzLmRhdGEucGFyZW50ID0gRFMuc0dyb3VwRm9yZXN0LnBhcmVudC5nZXQoc2dpZCk7XHJcblx0XHR0aGlzLmRhdGEuY2hpbGRyZW4gPSBEUy5zR3JvdXBGb3Jlc3QuY2hpbGRyZW4uZ2V0KHNnaWQpO1xyXG5cdFx0RFMuc0dyb3VwRm9yZXN0LnJlbW92ZShzZ2lkKTtcclxuXHR9O1xyXG5cdHRoaXMuX2ludmVydCA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciByZXQgPSBuZXcgU0dyb3VwQWRkVG9IaWVyYXJjaHkoKTtcclxuXHRcdHJldC5kYXRhID0gdGhpcy5kYXRhO1xyXG5cdFx0cmV0dXJuIHJldDtcclxuXHR9O1xyXG59O1xyXG5TR3JvdXBSZW1vdmVGcm9tSGllcmFyY2h5LnByb3RvdHlwZSA9IG5ldyBCYXNlKCk7XHJcblxyXG5mdW5jdGlvbiBCb25kQWRkIChiZWdpbiwgZW5kLCBib25kKSB7XHJcblx0dGhpcy5kYXRhID0geyBiaWQ6IG51bGwsIGJvbmQ6IGJvbmQsIGJlZ2luOiBiZWdpbiwgZW5kOiBlbmQgfTtcclxuXHR0aGlzLl9leGVjdXRlID0gZnVuY3Rpb24gKGVkaXRvcikge1xyXG5cdFx0dmFyIFIgPSBlZGl0b3IucmVuZGVyLCBSUyA9IFIuY3RhYiwgRFMgPSBSUy5tb2xlY3VsZTtcclxuXHRcdGlmICh0aGlzLmRhdGEuYmVnaW4gPT0gdGhpcy5kYXRhLmVuZClcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdEaXN0aW5jdCBhdG9tcyBleHBlY3RlZCcpO1xyXG5cdFx0aWYgKHJuZC5ERUJVRyAmJiB0aGlzLm1vbGVjdWxlLmNoZWNrQm9uZEV4aXN0cyh0aGlzLmRhdGEuYmVnaW4sIHRoaXMuZGF0YS5lbmQpKVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0JvbmQgYWxyZWFkeSBleGlzdHMnKTtcclxuXHJcblx0XHRSLmludmFsaWRhdGVBdG9tKHRoaXMuZGF0YS5iZWdpbiwgMSk7XHJcblx0XHRSLmludmFsaWRhdGVBdG9tKHRoaXMuZGF0YS5lbmQsIDEpO1xyXG5cclxuXHRcdHZhciBwcCA9IHt9O1xyXG5cdFx0aWYgKHRoaXMuZGF0YS5ib25kKVxyXG5cdFx0XHRmb3IgKHZhciBwIGluIHRoaXMuZGF0YS5ib25kKVxyXG5cdFx0XHRcdHBwW3BdID0gdGhpcy5kYXRhLmJvbmRbcF07XHJcblx0XHRwcC50eXBlID0gcHAudHlwZSB8fCBCb25kLlBBVFRFUk4uVFlQRS5TSU5HTEU7XHJcblx0XHRwcC5iZWdpbiA9IHRoaXMuZGF0YS5iZWdpbjtcclxuXHRcdHBwLmVuZCA9IHRoaXMuZGF0YS5lbmQ7XHJcblxyXG5cdFx0aWYgKCFPYmplY3QuaXNOdW1iZXIodGhpcy5kYXRhLmJpZCkpIHtcclxuXHRcdFx0dGhpcy5kYXRhLmJpZCA9IERTLmJvbmRzLmFkZChuZXcgQm9uZChwcCkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0RFMuYm9uZHMuc2V0KHRoaXMuZGF0YS5iaWQsIG5ldyBCb25kKHBwKSk7XHJcblx0XHR9XHJcblx0XHREUy5ib25kSW5pdEhhbGZCb25kcyh0aGlzLmRhdGEuYmlkKTtcclxuXHRcdERTLmF0b21BZGROZWlnaGJvcihEUy5ib25kcy5nZXQodGhpcy5kYXRhLmJpZCkuaGIxKTtcclxuXHRcdERTLmF0b21BZGROZWlnaGJvcihEUy5ib25kcy5nZXQodGhpcy5kYXRhLmJpZCkuaGIyKTtcclxuXHJcblx0XHRSUy5ub3RpZnlCb25kQWRkZWQodGhpcy5kYXRhLmJpZCk7XHJcblx0fTtcclxuXHR0aGlzLl9pbnZlcnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcmV0ID0gbmV3IEJvbmREZWxldGUoKTtcclxuXHRcdHJldC5kYXRhID0gdGhpcy5kYXRhO1xyXG5cdFx0cmV0dXJuIHJldDtcclxuXHR9O1xyXG59O1xyXG5Cb25kQWRkLnByb3RvdHlwZSA9IG5ldyBCYXNlKCk7XHJcblxyXG5mdW5jdGlvbiBCb25kRGVsZXRlIChiaWQpIHtcclxuXHR0aGlzLmRhdGEgPSB7IGJpZDogYmlkLCBib25kOiBudWxsLCBiZWdpbjogbnVsbCwgZW5kOiBudWxsIH07XHJcblx0dGhpcy5fZXhlY3V0ZSA9IGZ1bmN0aW9uIChlZGl0b3IpIHtcclxuXHRcdHZhciBSID0gZWRpdG9yLnJlbmRlciwgUlMgPSBSLmN0YWIsIERTID0gUlMubW9sZWN1bGU7XHJcblx0XHRpZiAoIXRoaXMuZGF0YS5ib25kKSB7XHJcblx0XHRcdHRoaXMuZGF0YS5ib25kID0gRFMuYm9uZHMuZ2V0KHRoaXMuZGF0YS5iaWQpO1xyXG5cdFx0XHR0aGlzLmRhdGEuYmVnaW4gPSB0aGlzLmRhdGEuYm9uZC5iZWdpbjtcclxuXHRcdFx0dGhpcy5kYXRhLmVuZCA9IHRoaXMuZGF0YS5ib25kLmVuZDtcclxuXHRcdH1cclxuXHJcblx0XHRSLmludmFsaWRhdGVCb25kKHRoaXMuZGF0YS5iaWQpO1xyXG5cclxuXHRcdFJTLm5vdGlmeUJvbmRSZW1vdmVkKHRoaXMuZGF0YS5iaWQpO1xyXG5cclxuXHRcdHZhciBib25kID0gRFMuYm9uZHMuZ2V0KHRoaXMuZGF0YS5iaWQpO1xyXG5cdFx0W2JvbmQuaGIxLCBib25kLmhiMl0uZWFjaChmdW5jdGlvbiAoaGJpZCkge1xyXG5cdFx0XHR2YXIgaGIgPSBEUy5oYWxmQm9uZHMuZ2V0KGhiaWQpO1xyXG5cdFx0XHR2YXIgYXRvbSA9IERTLmF0b21zLmdldChoYi5iZWdpbik7XHJcblx0XHRcdHZhciBwb3MgPSBhdG9tLm5laWdoYm9ycy5pbmRleE9mKGhiaWQpO1xyXG5cdFx0XHR2YXIgcHJldiA9IChwb3MgKyBhdG9tLm5laWdoYm9ycy5sZW5ndGggLSAxKSAlIGF0b20ubmVpZ2hib3JzLmxlbmd0aDtcclxuXHRcdFx0dmFyIG5leHQgPSAocG9zICsgMSkgJSBhdG9tLm5laWdoYm9ycy5sZW5ndGg7XHJcblx0XHRcdERTLnNldEhiTmV4dChhdG9tLm5laWdoYm9yc1twcmV2XSwgYXRvbS5uZWlnaGJvcnNbbmV4dF0pO1xyXG5cdFx0XHRhdG9tLm5laWdoYm9ycy5zcGxpY2UocG9zLCAxKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdFx0RFMuaGFsZkJvbmRzLnVuc2V0KGJvbmQuaGIxKTtcclxuXHRcdERTLmhhbGZCb25kcy51bnNldChib25kLmhiMik7XHJcblxyXG5cdFx0RFMuYm9uZHMucmVtb3ZlKHRoaXMuZGF0YS5iaWQpO1xyXG5cdH07XHJcblx0dGhpcy5faW52ZXJ0ID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHJldCA9IG5ldyBCb25kQWRkKCk7XHJcblx0XHRyZXQuZGF0YSA9IHRoaXMuZGF0YTtcclxuXHRcdHJldHVybiByZXQ7XHJcblx0fTtcclxufTtcclxuQm9uZERlbGV0ZS5wcm90b3R5cGUgPSBuZXcgQmFzZSgpO1xyXG5cclxuZnVuY3Rpb24gQm9uZEF0dHIgKGJpZCwgYXR0cmlidXRlLCB2YWx1ZSkge1xyXG5cdHRoaXMuZGF0YSA9IHsgYmlkOiBiaWQsIGF0dHJpYnV0ZTogYXR0cmlidXRlLCB2YWx1ZTogdmFsdWUgfTtcclxuXHR0aGlzLmRhdGEyID0gbnVsbDtcclxuXHR0aGlzLl9leGVjdXRlID0gZnVuY3Rpb24gKGVkaXRvcikge1xyXG5cdFx0dmFyIGJvbmQgPSBlZGl0b3IucmVuZGVyLmN0YWIubW9sZWN1bGUuYm9uZHMuZ2V0KHRoaXMuZGF0YS5iaWQpO1xyXG5cdFx0aWYgKCF0aGlzLmRhdGEyKSB7XHJcblx0XHRcdHRoaXMuZGF0YTIgPSB7IGJpZDogdGhpcy5kYXRhLmJpZCwgYXR0cmlidXRlOiB0aGlzLmRhdGEuYXR0cmlidXRlLCB2YWx1ZTogYm9uZFt0aGlzLmRhdGEuYXR0cmlidXRlXSB9O1xyXG5cdFx0fVxyXG5cclxuXHRcdGJvbmRbdGhpcy5kYXRhLmF0dHJpYnV0ZV0gPSB0aGlzLmRhdGEudmFsdWU7XHJcblxyXG5cdFx0ZWRpdG9yLnJlbmRlci5pbnZhbGlkYXRlQm9uZCh0aGlzLmRhdGEuYmlkKTtcclxuXHRcdGlmICh0aGlzLmRhdGEuYXR0cmlidXRlID09ICd0eXBlJylcclxuXHRcdFx0ZWRpdG9yLnJlbmRlci5pbnZhbGlkYXRlTG9vcCh0aGlzLmRhdGEuYmlkKTtcclxuXHR9O1xyXG5cdHRoaXMuX2lzRHVtbXkgPSBmdW5jdGlvbiAoZWRpdG9yKSB7XHJcblx0XHRyZXR1cm4gZWRpdG9yLnJlbmRlci5jdGFiLm1vbGVjdWxlLmJvbmRzLmdldCh0aGlzLmRhdGEuYmlkKVt0aGlzLmRhdGEuYXR0cmlidXRlXSA9PSB0aGlzLmRhdGEudmFsdWU7XHJcblx0fTtcclxuXHR0aGlzLl9pbnZlcnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcmV0ID0gbmV3IEJvbmRBdHRyKCk7XHJcblx0XHRyZXQuZGF0YSA9IHRoaXMuZGF0YTI7XHJcblx0XHRyZXQuZGF0YTIgPSB0aGlzLmRhdGE7XHJcblx0XHRyZXR1cm4gcmV0O1xyXG5cdH07XHJcbn07XHJcbkJvbmRBdHRyLnByb3RvdHlwZSA9IG5ldyBCYXNlKCk7XHJcblxyXG5mdW5jdGlvbiBGcmFnbWVudEFkZCAoZnJpZCkge1xyXG5cdHRoaXMuZnJpZCA9IE9iamVjdC5pc1VuZGVmaW5lZChmcmlkKSA/IG51bGwgOiBmcmlkO1xyXG5cdHRoaXMuX2V4ZWN1dGUgPSBmdW5jdGlvbiAoZWRpdG9yKSB7XHJcblx0XHR2YXIgUlMgPSBlZGl0b3IucmVuZGVyLmN0YWIsIERTID0gUlMubW9sZWN1bGU7XHJcblx0XHR2YXIgZnJhZyA9IG5ldyBTdHJ1Y3QuRnJhZ21lbnQoKTtcclxuXHRcdGlmICh0aGlzLmZyaWQgPT0gbnVsbCkge1xyXG5cdFx0XHR0aGlzLmZyaWQgPSBEUy5mcmFncy5hZGQoZnJhZyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHREUy5mcmFncy5zZXQodGhpcy5mcmlkLCBmcmFnKTtcclxuXHRcdH1cclxuXHRcdFJTLmZyYWdzLnNldCh0aGlzLmZyaWQsIG5ldyBybmQuUmVGcmFnKGZyYWcpKTsgLy8gVE9ETyBhZGQgUmVTdHJ1Y3Qubm90aWZ5RnJhZ21lbnRBZGRlZFxyXG5cdH07XHJcblx0dGhpcy5faW52ZXJ0ID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBGcmFnbWVudERlbGV0ZSh0aGlzLmZyaWQpO1xyXG5cdH07XHJcbn07XHJcbkZyYWdtZW50QWRkLnByb3RvdHlwZSA9IG5ldyBCYXNlKCk7XHJcblxyXG5mdW5jdGlvbiBGcmFnbWVudERlbGV0ZSAoZnJpZCkge1xyXG5cdHRoaXMuZnJpZCA9IGZyaWQ7XHJcblx0dGhpcy5fZXhlY3V0ZSA9IGZ1bmN0aW9uIChlZGl0b3IpIHtcclxuXHRcdHZhciBSID0gZWRpdG9yLnJlbmRlciwgUlMgPSBSLmN0YWIsIERTID0gUlMubW9sZWN1bGU7XHJcblx0XHRSLmludmFsaWRhdGVJdGVtKCdmcmFncycsIHRoaXMuZnJpZCwgMSk7XHJcblx0XHRSUy5mcmFncy51bnNldCh0aGlzLmZyaWQpO1xyXG5cdFx0RFMuZnJhZ3MucmVtb3ZlKHRoaXMuZnJpZCk7IC8vIFRPRE8gYWRkIFJlU3RydWN0Lm5vdGlmeUZyYWdtZW50UmVtb3ZlZFxyXG5cdH07XHJcblx0dGhpcy5faW52ZXJ0ID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBGcmFnbWVudEFkZCh0aGlzLmZyaWQpO1xyXG5cdH07XHJcbn07XHJcbkZyYWdtZW50RGVsZXRlLnByb3RvdHlwZSA9IG5ldyBCYXNlKCk7XHJcblxyXG5mdW5jdGlvbiBSR3JvdXBBdHRyIChyZ2lkLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XHJcblx0dGhpcy5kYXRhID0geyByZ2lkOiByZ2lkLCBhdHRyaWJ1dGU6IGF0dHJpYnV0ZSwgdmFsdWU6IHZhbHVlIH07XHJcblx0dGhpcy5kYXRhMiA9IG51bGw7XHJcblx0dGhpcy5fZXhlY3V0ZSA9IGZ1bmN0aW9uIChlZGl0b3IpIHtcclxuXHRcdHZhciByZ3AgPSBlZGl0b3IucmVuZGVyLmN0YWIubW9sZWN1bGUucmdyb3Vwcy5nZXQodGhpcy5kYXRhLnJnaWQpO1xyXG5cdFx0aWYgKCF0aGlzLmRhdGEyKSB7XHJcblx0XHRcdHRoaXMuZGF0YTIgPSB7IHJnaWQ6IHRoaXMuZGF0YS5yZ2lkLCBhdHRyaWJ1dGU6IHRoaXMuZGF0YS5hdHRyaWJ1dGUsIHZhbHVlOiByZ3BbdGhpcy5kYXRhLmF0dHJpYnV0ZV0gfTtcclxuXHRcdH1cclxuXHJcblx0XHRyZ3BbdGhpcy5kYXRhLmF0dHJpYnV0ZV0gPSB0aGlzLmRhdGEudmFsdWU7XHJcblxyXG5cdFx0ZWRpdG9yLnJlbmRlci5pbnZhbGlkYXRlSXRlbSgncmdyb3VwcycsIHRoaXMuZGF0YS5yZ2lkKTtcclxuXHR9O1xyXG5cdHRoaXMuX2lzRHVtbXkgPSBmdW5jdGlvbiAoZWRpdG9yKSB7XHJcblx0XHRyZXR1cm4gZWRpdG9yLnJlbmRlci5jdGFiLm1vbGVjdWxlLnJncm91cHMuZ2V0KHRoaXMuZGF0YS5yZ2lkKVt0aGlzLmRhdGEuYXR0cmlidXRlXSA9PSB0aGlzLmRhdGEudmFsdWU7XHJcblx0fTtcclxuXHR0aGlzLl9pbnZlcnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcmV0ID0gbmV3IFJHcm91cEF0dHIoKTtcclxuXHRcdHJldC5kYXRhID0gdGhpcy5kYXRhMjtcclxuXHRcdHJldC5kYXRhMiA9IHRoaXMuZGF0YTtcclxuXHRcdHJldHVybiByZXQ7XHJcblx0fTtcclxufTtcclxuUkdyb3VwQXR0ci5wcm90b3R5cGUgPSBuZXcgQmFzZSgpO1xyXG5cclxuZnVuY3Rpb24gUkdyb3VwRnJhZ21lbnQgKHJnaWQsIGZyaWQsIHJnKSB7XHJcblx0dGhpcy5yZ2lkX25ldyA9IHJnaWQ7XHJcblx0dGhpcy5yZ19uZXcgPSByZztcclxuXHR0aGlzLnJnaWRfb2xkID0gbnVsbDtcclxuXHR0aGlzLnJnX29sZCA9IG51bGw7XHJcblx0dGhpcy5mcmlkID0gZnJpZDtcclxuXHR0aGlzLl9leGVjdXRlID0gZnVuY3Rpb24gKGVkaXRvcikge1xyXG5cdFx0dmFyIFJTID0gZWRpdG9yLnJlbmRlci5jdGFiLCBEUyA9IFJTLm1vbGVjdWxlO1xyXG5cdFx0dGhpcy5yZ2lkX29sZCA9IHRoaXMucmdpZF9vbGQgfHwgU3RydWN0LlJHcm91cC5maW5kUkdyb3VwQnlGcmFnbWVudChEUy5yZ3JvdXBzLCB0aGlzLmZyaWQpO1xyXG5cdFx0dGhpcy5yZ19vbGQgPSAodGhpcy5yZ2lkX29sZCA/IERTLnJncm91cHMuZ2V0KHRoaXMucmdpZF9vbGQpIDogbnVsbCk7XHJcblx0XHRpZiAodGhpcy5yZ19vbGQpIHtcclxuXHRcdFx0dGhpcy5yZ19vbGQuZnJhZ3MucmVtb3ZlKHRoaXMucmdfb2xkLmZyYWdzLmtleU9mKHRoaXMuZnJpZCkpO1xyXG5cdFx0XHRSUy5jbGVhclZpc2VsKFJTLnJncm91cHMuZ2V0KHRoaXMucmdpZF9vbGQpLnZpc2VsKTtcclxuXHRcdFx0aWYgKHRoaXMucmdfb2xkLmZyYWdzLmNvdW50KCkgPT0gMCkge1xyXG5cdFx0XHRcdFJTLnJncm91cHMudW5zZXQodGhpcy5yZ2lkX29sZCk7XHJcblx0XHRcdFx0RFMucmdyb3Vwcy51bnNldCh0aGlzLnJnaWRfb2xkKTtcclxuXHRcdFx0XHRSUy5tYXJrSXRlbVJlbW92ZWQoKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRSUy5tYXJrSXRlbSgncmdyb3VwcycsIHRoaXMucmdpZF9vbGQsIDEpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5yZ2lkX25ldykge1xyXG5cdFx0XHR2YXIgcmdOZXcgPSBEUy5yZ3JvdXBzLmdldCh0aGlzLnJnaWRfbmV3KTtcclxuXHRcdFx0aWYgKCFyZ05ldykge1xyXG5cdFx0XHRcdHJnTmV3ID0gdGhpcy5yZ19uZXcgfHwgbmV3IFN0cnVjdC5SR3JvdXAoKTtcclxuXHRcdFx0XHREUy5yZ3JvdXBzLnNldCh0aGlzLnJnaWRfbmV3LCByZ05ldyk7XHJcblx0XHRcdFx0UlMucmdyb3Vwcy5zZXQodGhpcy5yZ2lkX25ldywgbmV3IHJuZC5SZVJHcm91cChyZ05ldykpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFJTLm1hcmtJdGVtKCdyZ3JvdXBzJywgdGhpcy5yZ2lkX25ldywgMSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmdOZXcuZnJhZ3MuYWRkKHRoaXMuZnJpZCk7XHJcblx0XHR9XHJcblx0fTtcclxuXHR0aGlzLl9pbnZlcnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IFJHcm91cEZyYWdtZW50KHRoaXMucmdpZF9vbGQsIHRoaXMuZnJpZCwgdGhpcy5yZ19vbGQpO1xyXG5cdH07XHJcbn07XHJcblJHcm91cEZyYWdtZW50LnByb3RvdHlwZSA9IG5ldyBCYXNlKCk7XHJcblxyXG5mdW5jdGlvbiBSeG5BcnJvd0FkZCAocG9zKSB7XHJcblx0dGhpcy5kYXRhID0geyBhcmlkOiBudWxsLCBwb3M6IHBvcyB9O1xyXG5cdHRoaXMuX2V4ZWN1dGUgPSBmdW5jdGlvbiAoZWRpdG9yKSB7XHJcblx0XHR2YXIgUiA9IGVkaXRvci5yZW5kZXIsIFJTID0gUi5jdGFiLCBEUyA9IFJTLm1vbGVjdWxlO1xyXG5cdFx0aWYgKCFPYmplY3QuaXNOdW1iZXIodGhpcy5kYXRhLmFyaWQpKSB7XHJcblx0XHRcdHRoaXMuZGF0YS5hcmlkID0gRFMucnhuQXJyb3dzLmFkZChuZXcgU3RydWN0LlJ4bkFycm93KCkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0RFMucnhuQXJyb3dzLnNldCh0aGlzLmRhdGEuYXJpZCwgbmV3IFN0cnVjdC5SeG5BcnJvdygpKTtcclxuXHRcdH1cclxuXHRcdFJTLm5vdGlmeVJ4bkFycm93QWRkZWQodGhpcy5kYXRhLmFyaWQpO1xyXG5cdFx0RFMuX3J4bkFycm93U2V0UG9zKHRoaXMuZGF0YS5hcmlkLCBuZXcgVmVjMih0aGlzLmRhdGEucG9zKSk7XHJcblxyXG5cdFx0Ui5pbnZhbGlkYXRlSXRlbSgncnhuQXJyb3dzJywgdGhpcy5kYXRhLmFyaWQsIDEpO1xyXG5cdH07XHJcblx0dGhpcy5faW52ZXJ0ID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHJldCA9IG5ldyBSeG5BcnJvd0RlbGV0ZSgpO1xyXG5cdFx0cmV0LmRhdGEgPSB0aGlzLmRhdGE7XHJcblx0XHRyZXR1cm4gcmV0O1xyXG5cdH07XHJcbn07XHJcblJ4bkFycm93QWRkLnByb3RvdHlwZSA9IG5ldyBCYXNlKCk7XHJcblxyXG5mdW5jdGlvbiBSeG5BcnJvd0RlbGV0ZSAoYXJpZCkge1xyXG5cdHRoaXMuZGF0YSA9IHsgYXJpZDogYXJpZCwgcG9zOiBudWxsIH07XHJcblx0dGhpcy5fZXhlY3V0ZSA9IGZ1bmN0aW9uIChlZGl0b3IpIHtcclxuXHRcdHZhciBSID0gZWRpdG9yLnJlbmRlciwgUlMgPSBSLmN0YWIsIERTID0gUlMubW9sZWN1bGU7XHJcblx0XHRpZiAoIXRoaXMuZGF0YS5wb3MpIHtcclxuXHRcdFx0dGhpcy5kYXRhLnBvcyA9IFIucnhuQXJyb3dHZXRQb3ModGhpcy5kYXRhLmFyaWQpO1xyXG5cdFx0fVxyXG5cdFx0UlMubm90aWZ5UnhuQXJyb3dSZW1vdmVkKHRoaXMuZGF0YS5hcmlkKTtcclxuXHRcdERTLnJ4bkFycm93cy5yZW1vdmUodGhpcy5kYXRhLmFyaWQpO1xyXG5cdH07XHJcblx0dGhpcy5faW52ZXJ0ID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHJldCA9IG5ldyBSeG5BcnJvd0FkZCgpO1xyXG5cdFx0cmV0LmRhdGEgPSB0aGlzLmRhdGE7XHJcblx0XHRyZXR1cm4gcmV0O1xyXG5cdH07XHJcbn07XHJcblJ4bkFycm93RGVsZXRlLnByb3RvdHlwZSA9IG5ldyBCYXNlKCk7XHJcblxyXG5mdW5jdGlvbiBSeG5BcnJvd01vdmUgKGlkLCBkLCBub2ludmFsaWRhdGUpIHtcclxuXHR0aGlzLmRhdGEgPSB7aWQ6IGlkLCBkOiBkLCBub2ludmFsaWRhdGU6IG5vaW52YWxpZGF0ZX07XHJcblx0dGhpcy5fZXhlY3V0ZSA9IGZ1bmN0aW9uIChlZGl0b3IpIHtcclxuXHRcdHZhciBSID0gZWRpdG9yLnJlbmRlcjtcclxuXHRcdHZhciBSUyA9IFIuY3RhYjtcclxuXHRcdHZhciBEUyA9IFJTLm1vbGVjdWxlO1xyXG5cdFx0dmFyIGlkID0gdGhpcy5kYXRhLmlkO1xyXG5cdFx0dmFyIGQgPSB0aGlzLmRhdGEuZDtcclxuXHRcdERTLnJ4bkFycm93cy5nZXQoaWQpLnBwLmFkZF8oZCk7XHJcblx0XHRSUy5yeG5BcnJvd3MuZ2V0KGlkKS52aXNlbC50cmFuc2xhdGUoUi5wcyhkKSk7XHJcblx0XHR0aGlzLmRhdGEuZCA9IGQubmVnYXRlZCgpO1xyXG5cdFx0aWYgKCF0aGlzLmRhdGEubm9pbnZhbGlkYXRlKVxyXG5cdFx0XHRlZGl0b3IucmVuZGVyLmludmFsaWRhdGVJdGVtKCdyeG5BcnJvd3MnLCBpZCwgMSk7XHJcblx0fTtcclxuXHR0aGlzLl9pbnZlcnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcmV0ID0gbmV3IFJ4bkFycm93TW92ZSgpO1xyXG5cdFx0cmV0LmRhdGEgPSB0aGlzLmRhdGE7XHJcblx0XHRyZXR1cm4gcmV0O1xyXG5cdH07XHJcbn07XHJcblJ4bkFycm93TW92ZS5wcm90b3R5cGUgPSBuZXcgQmFzZSgpO1xyXG5cclxuZnVuY3Rpb24gUnhuUGx1c0FkZCAocG9zKSB7XHJcblx0dGhpcy5kYXRhID0geyBwbGlkOiBudWxsLCBwb3M6IHBvcyB9O1xyXG5cdHRoaXMuX2V4ZWN1dGUgPSBmdW5jdGlvbiAoZWRpdG9yKSB7XHJcblx0XHR2YXIgUiA9IGVkaXRvci5yZW5kZXIsIFJTID0gUi5jdGFiLCBEUyA9IFJTLm1vbGVjdWxlO1xyXG5cdFx0aWYgKCFPYmplY3QuaXNOdW1iZXIodGhpcy5kYXRhLnBsaWQpKSB7XHJcblx0XHRcdHRoaXMuZGF0YS5wbGlkID0gRFMucnhuUGx1c2VzLmFkZChuZXcgU3RydWN0LlJ4blBsdXMoKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHREUy5yeG5QbHVzZXMuc2V0KHRoaXMuZGF0YS5wbGlkLCBuZXcgU3RydWN0LlJ4blBsdXMoKSk7XHJcblx0XHR9XHJcblx0XHRSUy5ub3RpZnlSeG5QbHVzQWRkZWQodGhpcy5kYXRhLnBsaWQpO1xyXG5cdFx0RFMuX3J4blBsdXNTZXRQb3ModGhpcy5kYXRhLnBsaWQsIG5ldyBWZWMyKHRoaXMuZGF0YS5wb3MpKTtcclxuXHJcblx0XHRSLmludmFsaWRhdGVJdGVtKCdyeG5QbHVzZXMnLCB0aGlzLmRhdGEucGxpZCwgMSk7XHJcblx0fTtcclxuXHR0aGlzLl9pbnZlcnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcmV0ID0gbmV3IFJ4blBsdXNEZWxldGUoKTtcclxuXHRcdHJldC5kYXRhID0gdGhpcy5kYXRhO1xyXG5cdFx0cmV0dXJuIHJldDtcclxuXHR9O1xyXG59O1xyXG5SeG5QbHVzQWRkLnByb3RvdHlwZSA9IG5ldyBCYXNlKCk7XHJcblxyXG5mdW5jdGlvbiBSeG5QbHVzRGVsZXRlIChwbGlkKSB7XHJcblx0dGhpcy5kYXRhID0geyBwbGlkOiBwbGlkLCBwb3M6IG51bGwgfTtcclxuXHR0aGlzLl9leGVjdXRlID0gZnVuY3Rpb24gKGVkaXRvcikge1xyXG5cdFx0dmFyIFIgPSBlZGl0b3IucmVuZGVyLCBSUyA9IFIuY3RhYiwgRFMgPSBSUy5tb2xlY3VsZTtcclxuXHRcdGlmICghdGhpcy5kYXRhLnBvcykge1xyXG5cdFx0XHR0aGlzLmRhdGEucG9zID0gUi5yeG5QbHVzR2V0UG9zKHRoaXMuZGF0YS5wbGlkKTtcclxuXHRcdH1cclxuXHRcdFJTLm5vdGlmeVJ4blBsdXNSZW1vdmVkKHRoaXMuZGF0YS5wbGlkKTtcclxuXHRcdERTLnJ4blBsdXNlcy5yZW1vdmUodGhpcy5kYXRhLnBsaWQpO1xyXG5cdH07XHJcblx0dGhpcy5faW52ZXJ0ID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHJldCA9IG5ldyBSeG5QbHVzQWRkKCk7XHJcblx0XHRyZXQuZGF0YSA9IHRoaXMuZGF0YTtcclxuXHRcdHJldHVybiByZXQ7XHJcblx0fTtcclxufTtcclxuUnhuUGx1c0RlbGV0ZS5wcm90b3R5cGUgPSBuZXcgQmFzZSgpO1xyXG5cclxuZnVuY3Rpb24gUnhuUGx1c01vdmUgKGlkLCBkLCBub2ludmFsaWRhdGUpIHtcclxuXHR0aGlzLmRhdGEgPSB7aWQ6IGlkLCBkOiBkLCBub2ludmFsaWRhdGU6IG5vaW52YWxpZGF0ZX07XHJcblx0dGhpcy5fZXhlY3V0ZSA9IGZ1bmN0aW9uIChlZGl0b3IpIHtcclxuXHRcdHZhciBSID0gZWRpdG9yLnJlbmRlcjtcclxuXHRcdHZhciBSUyA9IFIuY3RhYjtcclxuXHRcdHZhciBEUyA9IFJTLm1vbGVjdWxlO1xyXG5cdFx0dmFyIGlkID0gdGhpcy5kYXRhLmlkO1xyXG5cdFx0dmFyIGQgPSB0aGlzLmRhdGEuZDtcclxuXHRcdERTLnJ4blBsdXNlcy5nZXQoaWQpLnBwLmFkZF8oZCk7XHJcblx0XHRSUy5yeG5QbHVzZXMuZ2V0KGlkKS52aXNlbC50cmFuc2xhdGUoUi5wcyhkKSk7XHJcblx0XHR0aGlzLmRhdGEuZCA9IGQubmVnYXRlZCgpO1xyXG5cdFx0aWYgKCF0aGlzLmRhdGEubm9pbnZhbGlkYXRlKVxyXG5cdFx0XHRlZGl0b3IucmVuZGVyLmludmFsaWRhdGVJdGVtKCdyeG5QbHVzZXMnLCBpZCwgMSk7XHJcblx0fTtcclxuXHR0aGlzLl9pbnZlcnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcmV0ID0gbmV3IFJ4blBsdXNNb3ZlKCk7XHJcblx0XHRyZXQuZGF0YSA9IHRoaXMuZGF0YTtcclxuXHRcdHJldHVybiByZXQ7XHJcblx0fTtcclxufTtcclxuUnhuUGx1c01vdmUucHJvdG90eXBlID0gbmV3IEJhc2UoKTtcclxuXHJcbmZ1bmN0aW9uIFNHcm91cERhdGFNb3ZlIChpZCwgZCkge1xyXG5cdHRoaXMuZGF0YSA9IHtpZDogaWQsIGQ6IGR9O1xyXG5cdHRoaXMuX2V4ZWN1dGUgPSBmdW5jdGlvbiAoZWRpdG9yKSB7XHJcblx0XHR1aS5jdGFiLnNncm91cHMuZ2V0KHRoaXMuZGF0YS5pZCkucHAuYWRkXyh0aGlzLmRhdGEuZCk7XHJcblx0XHR0aGlzLmRhdGEuZCA9IHRoaXMuZGF0YS5kLm5lZ2F0ZWQoKTtcclxuXHRcdGVkaXRvci5yZW5kZXIuaW52YWxpZGF0ZUl0ZW0oJ3Nncm91cERhdGEnLCB0aGlzLmRhdGEuaWQsIDEpOyAvLyBbTUtdIHRoaXMgY3VycmVudGx5IGRvZXMgbm90aGluZyBzaW5jZSB0aGUgRGF0YVNHcm91cERhdGEgVmlzZWwgb25seSBjb250YWlucyB0aGUgaGlnaGxpZ2h0aW5nL3NlbGVjdGlvbiBhbmQgU0dyb3VwcyBhcmUgcmVkcmF3biBldmVyeSB0aW1lIGFueXdheVxyXG5cdH07XHJcblx0dGhpcy5faW52ZXJ0ID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHJldCA9IG5ldyBTR3JvdXBEYXRhTW92ZSgpO1xyXG5cdFx0cmV0LmRhdGEgPSB0aGlzLmRhdGE7XHJcblx0XHRyZXR1cm4gcmV0O1xyXG5cdH07XHJcbn07XHJcblNHcm91cERhdGFNb3ZlLnByb3RvdHlwZSA9IG5ldyBCYXNlKCk7XHJcblxyXG5mdW5jdGlvbiBDYW52YXNMb2FkIChjdGFiKSB7XHJcblx0dGhpcy5kYXRhID0ge2N0YWI6IGN0YWIsIG5vcmVzY2FsZTogZmFsc2V9O1xyXG5cdHRoaXMuX2V4ZWN1dGUgPSBmdW5jdGlvbiAoZWRpdG9yKSB7XHJcblx0XHR2YXIgUiA9IGVkaXRvci5yZW5kZXI7XHJcblxyXG5cdFx0Ui5jdGFiLmNsZWFyVmlzZWxzKCk7XHJcblx0XHR2YXIgb2xkQ3RhYiA9IHVpLmN0YWI7XHJcblx0XHR1aS5jdGFiID0gdGhpcy5kYXRhLmN0YWI7XHJcblx0XHRSLnNldE1vbGVjdWxlKHVpLmN0YWIsIHRoaXMuZGF0YS5ub3Jlc2NhbGUpO1xyXG5cdFx0dGhpcy5kYXRhLmN0YWIgPSBvbGRDdGFiO1xyXG5cdFx0dGhpcy5kYXRhLm5vcmVzY2FsZSA9IHRydWU7XHJcblx0fTtcclxuXHJcblx0dGhpcy5faW52ZXJ0ID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHJldCA9IG5ldyBDYW52YXNMb2FkKCk7XHJcblx0XHRyZXQuZGF0YSA9IHRoaXMuZGF0YTtcclxuXHRcdHJldHVybiByZXQ7XHJcblx0fTtcclxufTtcclxuQ2FudmFzTG9hZC5wcm90b3R5cGUgPSBuZXcgQmFzZSgpO1xyXG5cclxuZnVuY3Rpb24gQ2hpcmFsRmxhZ0FkZCAocG9zKSB7XHJcblx0dGhpcy5kYXRhID0ge3BvczogcG9zfTtcclxuXHR0aGlzLl9leGVjdXRlID0gZnVuY3Rpb24gKGVkaXRvcikge1xyXG5cdFx0dmFyIFIgPSBlZGl0b3IucmVuZGVyLCBSUyA9IFIuY3RhYiwgRFMgPSBSUy5tb2xlY3VsZTtcclxuXHRcdGlmIChSUy5jaGlyYWxGbGFncy5jb3VudCgpID4gMClcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYWRkIG1vcmUgdGhhbiBvbmUgQ2hpcmFsIGZsYWcnKTtcclxuXHRcdFJTLmNoaXJhbEZsYWdzLnNldCgwLCBuZXcgcm5kLlJlQ2hpcmFsRmxhZyhwb3MpKTtcclxuXHRcdERTLmlzQ2hpcmFsID0gdHJ1ZTtcclxuXHRcdFIuaW52YWxpZGF0ZUl0ZW0oJ2NoaXJhbEZsYWdzJywgMCwgMSk7XHJcblx0fTtcclxuXHR0aGlzLl9pbnZlcnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcmV0ID0gbmV3IENoaXJhbEZsYWdEZWxldGUoKTtcclxuXHRcdHJldC5kYXRhID0gdGhpcy5kYXRhO1xyXG5cdFx0cmV0dXJuIHJldDtcclxuXHR9O1xyXG59O1xyXG5DaGlyYWxGbGFnQWRkLnByb3RvdHlwZSA9IG5ldyBCYXNlKCk7XHJcblxyXG5mdW5jdGlvbiBDaGlyYWxGbGFnRGVsZXRlICgpIHtcclxuXHR0aGlzLmRhdGEgPSB7cG9zOiBudWxsfTtcclxuXHR0aGlzLl9leGVjdXRlID0gZnVuY3Rpb24gKGVkaXRvcikge1xyXG5cdFx0dmFyIFIgPSBlZGl0b3IucmVuZGVyLCBSUyA9IFIuY3RhYiwgRFMgPSBSUy5tb2xlY3VsZTtcclxuXHRcdGlmIChSUy5jaGlyYWxGbGFncy5jb3VudCgpIDwgMSlcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVtb3ZlIGNoaXJhbCBmbGFnJyk7XHJcblx0XHRSUy5jbGVhclZpc2VsKFJTLmNoaXJhbEZsYWdzLmdldCgwKS52aXNlbCk7XHJcblx0XHR0aGlzLmRhdGEucG9zID0gUlMuY2hpcmFsRmxhZ3MuZ2V0KDApLnBwO1xyXG5cdFx0UlMuY2hpcmFsRmxhZ3MudW5zZXQoMCk7XHJcblx0XHREUy5pc0NoaXJhbCA9IGZhbHNlO1xyXG5cdH07XHJcblx0dGhpcy5faW52ZXJ0ID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHJldCA9IG5ldyBDaGlyYWxGbGFnQWRkKHRoaXMuZGF0YS5wb3MpO1xyXG5cdFx0cmV0LmRhdGEgPSB0aGlzLmRhdGE7XHJcblx0XHRyZXR1cm4gcmV0O1xyXG5cdH07XHJcbn07XHJcbkNoaXJhbEZsYWdEZWxldGUucHJvdG90eXBlID0gbmV3IEJhc2UoKTtcclxuXHJcbmZ1bmN0aW9uIENoaXJhbEZsYWdNb3ZlIChkKSB7XHJcblx0dGhpcy5kYXRhID0ge2Q6IGR9O1xyXG5cdHRoaXMuX2V4ZWN1dGUgPSBmdW5jdGlvbiAoZWRpdG9yKSB7XHJcblx0XHR2YXIgUiA9IGVkaXRvci5yZW5kZXIsIFJTID0gUi5jdGFiO1xyXG5cdFx0UlMuY2hpcmFsRmxhZ3MuZ2V0KDApLnBwLmFkZF8odGhpcy5kYXRhLmQpO1xyXG5cdFx0dGhpcy5kYXRhLmQgPSB0aGlzLmRhdGEuZC5uZWdhdGVkKCk7XHJcblx0XHRSLmludmFsaWRhdGVJdGVtKCdjaGlyYWxGbGFncycsIDAsIDEpO1xyXG5cdH07XHJcblx0dGhpcy5faW52ZXJ0ID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHJldCA9IG5ldyBDaGlyYWxGbGFnTW92ZSgpO1xyXG5cdFx0cmV0LmRhdGEgPSB0aGlzLmRhdGE7XHJcblx0XHRyZXR1cm4gcmV0O1xyXG5cdH07XHJcbn07XHJcbkNoaXJhbEZsYWdNb3ZlLnByb3RvdHlwZSA9IG5ldyBCYXNlKCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHRBdG9tQWRkOiBBdG9tQWRkLFxyXG5cdEF0b21EZWxldGU6IEF0b21EZWxldGUsXHJcblx0QXRvbUF0dHI6IEF0b21BdHRyLFxyXG5cdEF0b21Nb3ZlOiBBdG9tTW92ZSxcclxuXHRCb25kTW92ZTogQm9uZE1vdmUsXHJcblx0TG9vcE1vdmU6IExvb3BNb3ZlLFxyXG5cdFNHcm91cEF0b21BZGQ6IFNHcm91cEF0b21BZGQsXHJcblx0U0dyb3VwQXRvbVJlbW92ZTogU0dyb3VwQXRvbVJlbW92ZSxcclxuXHRTR3JvdXBBdHRyOiBTR3JvdXBBdHRyLFxyXG5cdFNHcm91cENyZWF0ZTogU0dyb3VwQ3JlYXRlLFxyXG5cdFNHcm91cERlbGV0ZTogU0dyb3VwRGVsZXRlLFxyXG5cdFNHcm91cEFkZFRvSGllcmFyY2h5OiBTR3JvdXBBZGRUb0hpZXJhcmNoeSxcclxuXHRTR3JvdXBSZW1vdmVGcm9tSGllcmFyY2h5OiBTR3JvdXBSZW1vdmVGcm9tSGllcmFyY2h5LFxyXG5cdEJvbmRBZGQ6IEJvbmRBZGQsXHJcblx0Qm9uZERlbGV0ZTogQm9uZERlbGV0ZSxcclxuXHRCb25kQXR0cjogQm9uZEF0dHIsXHJcblx0RnJhZ21lbnRBZGQ6IEZyYWdtZW50QWRkLFxyXG5cdEZyYWdtZW50RGVsZXRlOiBGcmFnbWVudERlbGV0ZSxcclxuXHRSR3JvdXBBdHRyOiBSR3JvdXBBdHRyLFxyXG5cdFJHcm91cEZyYWdtZW50OiBSR3JvdXBGcmFnbWVudCxcclxuXHRSeG5BcnJvd0FkZDogUnhuQXJyb3dBZGQsXHJcblx0UnhuQXJyb3dEZWxldGU6IFJ4bkFycm93RGVsZXRlLFxyXG5cdFJ4bkFycm93TW92ZTogUnhuQXJyb3dNb3ZlLFxyXG5cdFJ4blBsdXNBZGQ6IFJ4blBsdXNBZGQsXHJcblx0UnhuUGx1c0RlbGV0ZTogUnhuUGx1c0RlbGV0ZSxcclxuXHRSeG5QbHVzTW92ZTogUnhuUGx1c01vdmUsXHJcblx0U0dyb3VwRGF0YU1vdmU6IFNHcm91cERhdGFNb3ZlLFxyXG5cdENhbnZhc0xvYWQ6IENhbnZhc0xvYWQsXHJcblx0Q2hpcmFsRmxhZ0FkZDogQ2hpcmFsRmxhZ0FkZCxcclxuXHRDaGlyYWxGbGFnRGVsZXRlOiBDaGlyYWxGbGFnRGVsZXRlLFxyXG5cdENoaXJhbEZsYWdNb3ZlOiBDaGlyYWxGbGFnTW92ZVxyXG59O1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFtcclxuXHR7XHJcblx0XHRuYW1lOiAnYmVuemVuZScsXHJcblx0XHRtb2xmaWxlOlxyXG5cdFx0J1xcbicgK1xyXG5cdFx0XHQnICBLZXRjaGVyIDExMTYxMjE4MzUyRCAxICAgMS4wMDAwMCAgICAgMC4wMDAwMCAgICAgMFxcbicgK1xyXG5cdFx0XHQnXFxuJyArXHJcblx0XHRcdCcgIDYgIDYgIDAgICAgIDAgIDAgICAgICAgICAgICA5OTkgVjIwMDBcXG4nICtcclxuXHRcdFx0JyAgICAwLjg2NjAgICAgMi4wMDAwICAgIDAuMDAwMCBDICAgMCAgMCAgMCAgMCAgMCAgMCAgICAgICAgMCAgMCAgMFxcbicgK1xyXG5cdFx0XHQnICAgIDEuNzMyMCAgICAxLjUwMDAgICAgMC4wMDAwIEMgICAwICAwICAwICAwICAwICAwICAgICAgICAwICAwICAwXFxuJyArXHJcblx0XHRcdCcgICAgMS43MzIwICAgIDAuNTAwMCAgICAwLjAwMDAgQyAgIDAgIDAgIDAgIDAgIDAgIDAgICAgICAgIDAgIDAgIDBcXG4nICtcclxuXHRcdFx0JyAgICAwLjg2NjAgICAgMC4wMDAwICAgIDAuMDAwMCBDICAgMCAgMCAgMCAgMCAgMCAgMCAgICAgICAgMCAgMCAgMFxcbicgK1xyXG5cdFx0XHQnICAgIDAuMDAwMCAgICAwLjUwMDAgICAgMC4wMDAwIEMgICAwICAwICAwICAwICAwICAwICAgICAgICAwICAwICAwXFxuJyArXHJcblx0XHRcdCcgICAgMC4wMDAwICAgIDEuNTAwMCAgICAwLjAwMDAgQyAgIDAgIDAgIDAgIDAgIDAgIDAgICAgICAgIDAgIDAgIDBcXG4nICtcclxuXHRcdFx0JyAgMSAgMiAgMSAgMCAgICAgMCAgMFxcbicgK1xyXG5cdFx0XHQnICAyICAzICAyICAwICAgICAwICAwXFxuJyArXHJcblx0XHRcdCcgIDMgIDQgIDEgIDAgICAgIDAgIDBcXG4nICtcclxuXHRcdFx0JyAgNCAgNSAgMiAgMCAgICAgMCAgMFxcbicgK1xyXG5cdFx0XHQnICA1ICA2ICAxICAwICAgICAwICAwXFxuJyArXHJcblx0XHRcdCcgIDYgIDEgIDIgIDAgICAgIDAgIDBcXG4nICtcclxuXHRcdFx0J00gIEVORFxcbicsXHJcblx0XHRiaWQ6IDAsXHJcblx0XHRhaWQ6IDBcclxuXHR9LFxyXG5cdHtcclxuXHRcdG5hbWU6ICdjeWNsb3BlbnRhZGllbmUnLFxyXG5cdFx0bW9sZmlsZTpcclxuXHRcdCdcXG4nICtcclxuXHRcdFx0JyAgS2V0Y2hlciAxMTE2MTIxODM1MkQgMSAgIDEuMDAwMDAgICAgIDAuMDAwMDAgICAgIDBcXG4nICtcclxuXHRcdFx0J1xcbicgK1xyXG5cdFx0XHQnICA1ICA1ICAwICAgICAwICAwICAgICAgICAgICAgOTk5IFYyMDAwXFxuJyArXHJcblx0XHRcdCcgICAgMC4wMDAwICAgIDEuNDI1NyAgICAwLjAwMDAgQyAgIDAgIDAgIDAgIDAgIDAgIDAgICAgICAgIDAgIDAgIDBcXG4nICtcclxuXHRcdFx0JyAgICAwLjgwOTAgICAgMC44Mzc5ICAgIDAuMDAwMCBDICAgMCAgMCAgMCAgMCAgMCAgMCAgICAgICAgMCAgMCAgMFxcbicgK1xyXG5cdFx0XHQnICAgIDAuNTAwMCAgIC0wLjExMzIgICAgMC4wMDAwIEMgICAwICAwICAwICAwICAwICAwICAgICAgICAwICAwICAwXFxuJyArXHJcblx0XHRcdCcgICAtMC41MDAwICAgLTAuMTEzMiAgICAwLjAwMDAgQyAgIDAgIDAgIDAgIDAgIDAgIDAgICAgICAgIDAgIDAgIDBcXG4nICtcclxuXHRcdFx0JyAgIC0wLjgwOTAgICAgMC44Mzc5ICAgIDAuMDAwMCBDICAgMCAgMCAgMCAgMCAgMCAgMCAgICAgICAgMCAgMCAgMFxcbicgK1xyXG5cdFx0XHQnICAxICAyICAxICAwICAgICAwICAwXFxuJyArXHJcblx0XHRcdCcgIDIgIDMgIDIgIDAgICAgIDAgIDBcXG4nICtcclxuXHRcdFx0JyAgMyAgNCAgMSAgMCAgICAgMCAgMFxcbicgK1xyXG5cdFx0XHQnICA0ICA1ICAyICAwICAgICAwICAwXFxuJyArXHJcblx0XHRcdCcgIDUgIDEgIDEgIDAgICAgIDAgIDBcXG4nICtcclxuXHRcdFx0J00gIEVORFxcbicsXHJcblx0XHRiaWQ6IDAsXHJcblx0XHRhaWQ6IDBcclxuXHR9LFxyXG5cdHtcclxuXHRcdG5hbWU6ICdjeWNsb2hleGFuZScsXHJcblx0XHRtb2xmaWxlOlxyXG5cdFx0J1xcbicgK1xyXG5cdFx0XHQnICBLZXRjaGVyIDExMTYxMjE4MzUyRCAxICAgMS4wMDAwMCAgICAgMC4wMDAwMCAgICAgMFxcbicgK1xyXG5cdFx0XHQnXFxuJyArXHJcblx0XHRcdCcgIDYgIDYgIDAgICAgIDAgIDAgICAgICAgICAgICA5OTkgVjIwMDBcXG4nICtcclxuXHRcdFx0JyAgICAwLjg2NjAgICAgMi4wMDAwICAgIDAuMDAwMCBDICAgMCAgMCAgMCAgMCAgMCAgMCAgICAgICAgMCAgMCAgMFxcbicgK1xyXG5cdFx0XHQnICAgIDEuNzMyMCAgICAxLjUwMDAgICAgMC4wMDAwIEMgICAwICAwICAwICAwICAwICAwICAgICAgICAwICAwICAwXFxuJyArXHJcblx0XHRcdCcgICAgMS43MzIwICAgIDAuNTAwMCAgICAwLjAwMDAgQyAgIDAgIDAgIDAgIDAgIDAgIDAgICAgICAgIDAgIDAgIDBcXG4nICtcclxuXHRcdFx0JyAgICAwLjg2NjAgICAgMC4wMDAwICAgIDAuMDAwMCBDICAgMCAgMCAgMCAgMCAgMCAgMCAgICAgICAgMCAgMCAgMFxcbicgK1xyXG5cdFx0XHQnICAgIDAuMDAwMCAgICAwLjUwMDAgICAgMC4wMDAwIEMgICAwICAwICAwICAwICAwICAwICAgICAgICAwICAwICAwXFxuJyArXHJcblx0XHRcdCcgICAgMC4wMDAwICAgIDEuNTAwMCAgICAwLjAwMDAgQyAgIDAgIDAgIDAgIDAgIDAgIDAgICAgICAgIDAgIDAgIDBcXG4nICtcclxuXHRcdFx0JyAgMSAgMiAgMSAgMCAgICAgMCAgMFxcbicgK1xyXG5cdFx0XHQnICAyICAzICAxICAwICAgICAwICAwXFxuJyArXHJcblx0XHRcdCcgIDMgIDQgIDEgIDAgICAgIDAgIDBcXG4nICtcclxuXHRcdFx0JyAgNCAgNSAgMSAgMCAgICAgMCAgMFxcbicgK1xyXG5cdFx0XHQnICA1ICA2ICAxICAwICAgICAwICAwXFxuJyArXHJcblx0XHRcdCcgIDYgIDEgIDEgIDAgICAgIDAgIDBcXG4nICtcclxuXHRcdFx0J00gIEVORFxcbicsXHJcblx0XHRiaWQ6IDAsXHJcblx0XHRhaWQ6IDBcclxuXHR9LFxyXG5cdHtcclxuXHRcdG5hbWU6ICdjeWNsb3BlbnRhbmUnLFxyXG5cdFx0bW9sZmlsZTpcclxuXHRcdCdcXG4nICtcclxuXHRcdFx0JyAgS2V0Y2hlciAxMTE2MTIxODM1MkQgMSAgIDEuMDAwMDAgICAgIDAuMDAwMDAgICAgIDBcXG4nICtcclxuXHRcdFx0J1xcbicgK1xyXG5cdFx0XHQnICA1ICA1ICAwICAgICAwICAwICAgICAgICAgICAgOTk5IFYyMDAwXFxuJyArXHJcblx0XHRcdCcgICAgMC44MDkwICAgIDEuNTM4OSAgICAwLjAwMDAgQyAgIDAgIDAgIDAgIDAgIDAgIDAgICAgICAgIDAgIDAgIDBcXG4nICtcclxuXHRcdFx0JyAgICAxLjYxODAgICAgMC45NTExICAgIDAuMDAwMCBDICAgMCAgMCAgMCAgMCAgMCAgMCAgICAgICAgMCAgMCAgMFxcbicgK1xyXG5cdFx0XHQnICAgIDEuMzA5MCAgICAwLjAwMDAgICAgMC4wMDAwIEMgICAwICAwICAwICAwICAwICAwICAgICAgICAwICAwICAwXFxuJyArXHJcblx0XHRcdCcgICAgMC4zMDkwICAgIDAuMDAwMCAgICAwLjAwMDAgQyAgIDAgIDAgIDAgIDAgIDAgIDAgICAgICAgIDAgIDAgIDBcXG4nICtcclxuXHRcdFx0JyAgICAwLjAwMDAgICAgMC45NTExICAgIDAuMDAwMCBDICAgMCAgMCAgMCAgMCAgMCAgMCAgICAgICAgMCAgMCAgMFxcbicgK1xyXG5cdFx0XHQnICAxICAyICAxICAwICAgICAwICAwXFxuJyArXHJcblx0XHRcdCcgIDIgIDMgIDEgIDAgICAgIDAgIDBcXG4nICtcclxuXHRcdFx0JyAgMyAgNCAgMSAgMCAgICAgMCAgMFxcbicgK1xyXG5cdFx0XHQnICA0ICA1ICAxICAwICAgICAwICAwXFxuJyArXHJcblx0XHRcdCcgIDUgIDEgIDEgIDAgICAgIDAgIDBcXG4nICtcclxuXHRcdFx0J00gIEVORFxcbicsXHJcblx0XHRiaWQ6IDAsXHJcblx0XHRhaWQ6IDBcclxuXHR9LFxyXG5cdHtcclxuXHRcdG5hbWU6ICdjeWNsb3Byb3BhbmUnLFxyXG5cdFx0bW9sZmlsZTpcclxuXHRcdCdcXG4nICtcclxuXHRcdFx0JyAgS2V0Y2hlciAxMTE2MTIxODM1MkQgMSAgIDEuMDAwMDAgICAgIDAuMDAwMDAgICAgIDBcXG4nICtcclxuXHRcdFx0J1xcbicgK1xyXG5cdFx0XHQnICAzICAzICAwICAgICAwICAwICAgICAgICAgICAgOTk5IFYyMDAwXFxuJyArXHJcblx0XHRcdCcgICAtMy4yMjUwICAgLTAuMjc1MCAgICAwLjAwMDAgQyAgIDAgIDAgIDAgIDAgIDAgIDAgICAgICAgIDAgIDAgIDBcXG4nICtcclxuXHRcdFx0JyAgIC0yLjIyNTAgICAtMC4yNzUwICAgIDAuMDAwMCBDICAgMCAgMCAgMCAgMCAgMCAgMCAgICAgICAgMCAgMCAgMFxcbicgK1xyXG5cdFx0XHQnICAgLTIuNzI1MCAgICAwLjU5MTAgICAgMC4wMDAwIEMgICAwICAwICAwICAwICAwICAwICAgICAgICAwICAwICAwXFxuJyArXHJcblx0XHRcdCcgIDEgIDIgIDEgIDAgICAgIDAgIDBcXG4nICtcclxuXHRcdFx0JyAgMiAgMyAgMSAgMCAgICAgMCAgMFxcbicgK1xyXG5cdFx0XHQnICAxICAzICAxICAwICAgICAwICAwXFxuJyArXHJcblx0XHRcdCdNICBFTkRcXG4nLFxyXG5cdFx0YmlkOiAwLFxyXG5cdFx0YWlkOiAwXHJcblx0fSxcclxuXHR7XHJcblx0XHRuYW1lOiAnY3ljbG9idXRhbmUnLFxyXG5cdFx0bW9sZmlsZTpcclxuXHRcdCdcXG4nICtcclxuXHRcdFx0JyAgS2V0Y2hlciAxMTE2MTIxODM1MkQgMSAgIDEuMDAwMDAgICAgIDAuMDAwMDAgICAgIDBcXG4nICtcclxuXHRcdFx0J1xcbicgK1xyXG5cdFx0XHQnICA0ICA0ICAwICAgICAwICAwICAgICAgICAgICAgOTk5IFYyMDAwXFxuJyArXHJcblx0XHRcdCcgICAtMy44MjUwICAgIDEuNTUwMCAgICAwLjAwMDAgQyAgIDAgIDAgIDAgIDAgIDAgIDAgICAgICAgIDAgIDAgIDBcXG4nICtcclxuXHRcdFx0JyAgIC0zLjgyNTAgICAgMC41NTAwICAgIDAuMDAwMCBDICAgMCAgMCAgMCAgMCAgMCAgMCAgICAgICAgMCAgMCAgMFxcbicgK1xyXG5cdFx0XHQnICAgLTIuODI1MCAgICAxLjU1MDAgICAgMC4wMDAwIEMgICAwICAwICAwICAwICAwICAwICAgICAgICAwICAwICAwXFxuJyArXHJcblx0XHRcdCcgICAtMi44MjUwICAgIDAuNTUwMCAgICAwLjAwMDAgQyAgIDAgIDAgIDAgIDAgIDAgIDAgICAgICAgIDAgIDAgIDBcXG4nICtcclxuXHRcdFx0JyAgMSAgMiAgMSAgMCAgICAgMCAgMFxcbicgK1xyXG5cdFx0XHQnICAxICAzICAxICAwICAgICAwICAwXFxuJyArXHJcblx0XHRcdCcgIDMgIDQgIDEgIDAgICAgIDAgIDBcXG4nICtcclxuXHRcdFx0JyAgNCAgMiAgMSAgMCAgICAgMCAgMFxcbicgK1xyXG5cdFx0XHQnTSAgRU5EXFxuJyxcclxuXHRcdGJpZDogMCxcclxuXHRcdGFpZDogMFxyXG5cdH0sXHJcblx0e1xyXG5cdFx0bmFtZTogJ2N5Y2xvaGVwdGFuZScsXHJcblx0XHRtb2xmaWxlOlxyXG5cdFx0J1xcbicgK1xyXG5cdFx0XHQnICBLZXRjaGVyIDExMTYxMjE4MzUyRCAxICAgMS4wMDAwMCAgICAgMC4wMDAwMCAgICAgMFxcbicgK1xyXG5cdFx0XHQnXFxuJyArXHJcblx0XHRcdCcgIDcgIDcgIDAgICAgIDAgIDAgICAgICAgICAgICA5OTkgVjIwMDBcXG4nICtcclxuXHRcdFx0JyAgICAwLjAwMDAgICAgMS42MjkzICAgIDAuMDAwMCBDICAgMCAgMCAgMCAgMCAgMCAgMCAgICAgICAgMCAgMCAgMFxcbicgK1xyXG5cdFx0XHQnICAgIDAuNzgzNSAgICAyLjI0NjUgICAgMC4wMDAwIEMgICAwICAwICAwICAwICAwICAwICAgICAgICAwICAwICAwXFxuJyArXHJcblx0XHRcdCcgICAgMS43NTU5ICAgIDIuMDI0MiAgICAwLjAwMDAgQyAgIDAgIDAgIDAgIDAgIDAgIDAgICAgICAgIDAgIDAgIDBcXG4nICtcclxuXHRcdFx0JyAgICAyLjE4OTcgICAgMS4xMjg5ICAgIDAuMDAwMCBDICAgMCAgMCAgMCAgMCAgMCAgMCAgICAgICAgMCAgMCAgMFxcbicgK1xyXG5cdFx0XHQnICAgIDAuMDAwMCAgICAwLjYyMjggICAgMC4wMDAwIEMgICAwICAwICAwICAwICAwICAwICAgICAgICAwICAwICAwXFxuJyArXHJcblx0XHRcdCcgICAgMS43NTY2ICAgIDAuMjIyNCAgICAwLjAwMDAgQyAgIDAgIDAgIDAgIDAgIDAgIDAgICAgICAgIDAgIDAgIDBcXG4nICtcclxuXHRcdFx0JyAgICAwLjc4MzUgICAgMC4wMDAwICAgIDAuMDAwMCBDICAgMCAgMCAgMCAgMCAgMCAgMCAgICAgICAgMCAgMCAgMFxcbicgK1xyXG5cdFx0XHQnICA2ICA3ICAxICAwICAgICAwICAwXFxuJyArXHJcblx0XHRcdCcgIDUgIDcgIDEgIDAgICAgIDAgIDBcXG4nICtcclxuXHRcdFx0JyAgMSAgNSAgMSAgMCAgICAgMCAgMFxcbicgK1xyXG5cdFx0XHQnICA0ICA2ICAxICAwICAgICAwICAwXFxuJyArXHJcblx0XHRcdCcgIDMgIDQgIDEgIDAgICAgIDAgIDBcXG4nICtcclxuXHRcdFx0JyAgMiAgMyAgMSAgMCAgICAgMCAgMFxcbicgK1xyXG5cdFx0XHQnICAxICAyICAxICAwICAgICAwICAwXFxuJyArXHJcblx0XHRcdCdNICBFTkRcXG4nLFxyXG5cdFx0YmlkOiAwLFxyXG5cdFx0YWlkOiAwXHJcblx0fSxcclxuXHR7XHJcblx0XHRuYW1lOiAnY3ljbG9vY3RhbmUnLFxyXG5cdFx0bW9sZmlsZTpcclxuXHRcdCdcXG4nICtcclxuXHRcdFx0JyAgS2V0Y2hlciAxMTE2MTIxODM1MkQgMSAgIDEuMDAwMDAgICAgIDAuMDAwMDAgICAgIDBcXG4nICtcclxuXHRcdFx0J1xcbicgK1xyXG5cdFx0XHQnICA4ICA4ICAwICAgICAwICAwICAgICAgICAgICAgOTk5IFYyMDAwXFxuJyArXHJcblx0XHRcdCcgICAgMC4wMDAwICAgIDAuNzA1MyAgICAwLjAwMDAgQyAgIDAgIDAgIDAgIDAgIDAgIDAgICAgICAgIDAgIDAgIDBcXG4nICtcclxuXHRcdFx0JyAgICAwLjAwMDAgICAgMS43MDc4ICAgIDAuMDAwMCBDICAgMCAgMCAgMCAgMCAgMCAgMCAgICAgICAgMCAgMCAgMFxcbicgK1xyXG5cdFx0XHQnICAgIDAuNzA1MyAgICAyLjQxMzEgICAgMC4wMDAwIEMgICAwICAwICAwICAwICAwICAwICAgICAgICAwICAwICAwXFxuJyArXHJcblx0XHRcdCcgICAgMC43MDU2ICAgIDAuMDAwMCAgICAwLjAwMDAgQyAgIDAgIDAgIDAgIDAgIDAgIDAgICAgICAgIDAgIDAgIDBcXG4nICtcclxuXHRcdFx0JyAgICAxLjcwNzkgICAgMC4wMDAwICAgIDAuMDAwMCBDICAgMCAgMCAgMCAgMCAgMCAgMCAgICAgICAgMCAgMCAgMFxcbicgK1xyXG5cdFx0XHQnICAgIDIuNDEzMyAgICAwLjcwNTMgICAgMC4wMDAwIEMgICAwICAwICAwICAwICAwICAwICAgICAgICAwICAwICAwXFxuJyArXHJcblx0XHRcdCcgICAgMi40MTMzICAgIDEuNzA3OCAgICAwLjAwMDAgQyAgIDAgIDAgIDAgIDAgIDAgIDAgICAgICAgIDAgIDAgIDBcXG4nICtcclxuXHRcdFx0JyAgICAxLjcwNzkgICAgMi40MTMxICAgIDAuMDAwMCBDICAgMCAgMCAgMCAgMCAgMCAgMCAgICAgICAgMCAgMCAgMFxcbicgK1xyXG5cdFx0XHQnICA4ICAzICAxICAwICAgICAwICAwXFxuJyArXHJcblx0XHRcdCcgIDcgIDggIDEgIDAgICAgIDAgIDBcXG4nICtcclxuXHRcdFx0JyAgNiAgNyAgMSAgMCAgICAgMCAgMFxcbicgK1xyXG5cdFx0XHQnICA1ICA2ICAxICAwICAgICAwICAwXFxuJyArXHJcblx0XHRcdCcgIDQgIDUgIDEgIDAgICAgIDAgIDBcXG4nICtcclxuXHRcdFx0JyAgMSAgNCAgMSAgMCAgICAgMCAgMFxcbicgK1xyXG5cdFx0XHQnICAyICAzICAxICAwICAgICAwICAwXFxuJyArXHJcblx0XHRcdCcgIDEgIDIgIDEgIDAgICAgIDAgIDBcXG4nICtcclxuXHRcdFx0J00gIEVORFxcbicsXHJcblx0XHRiaWQ6IDAsXHJcblx0XHRhaWQ6IDBcclxuXHR9XHJcbl07XHJcbiIsInZhciBnZXRYSFIgPSByZXF1aXJlKCd4aHJwb2x5ZmlsbCcpO1xyXG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJ3Byb21pc2UtcG9seWZpbGwnKTtcclxudmFyIHV0aWwgPSByZXF1aXJlKCcuL2luZGV4LmpzJyk7XHJcblxyXG5mdW5jdGlvbiBhamF4KG9wdGlvbnMsIGNhbGxiYWNrKSB7XHJcblx0dmFyIHhociA9IGdldFhIUigpO1xyXG5cdHZhciBoZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9O1xyXG5cclxuXHR4aHIub3BlbihvcHRpb25zLm1ldGhvZCwgb3B0aW9ucy51cmwsICEhY2FsbGJhY2ssIG9wdGlvbnMudXNlciwgb3B0aW9ucy5wYXNzd29yZCk7XHJcblxyXG5cdGZvciAodmFyIGsgaW4gaGVhZGVycykge1xyXG5cdFx0aWYgKGhlYWRlcnMuaGFzT3duUHJvcGVydHkoaykpIHtcclxuXHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoaywgaGVhZGVyc1trXSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5jb25maWcgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdHZhciBtYXliZVhociA9IG9wdGlvbnMuY29uZmlnKHhociwgb3B0aW9ucyk7XHJcblx0XHRpZiAobWF5YmVYaHIgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR4aHIgPSBtYXliZVhocjtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKG9wdGlvbnMudGltZW91dCA+IDApIHtcclxuXHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR4aHIuc3RhdHVzID0gLTE7XHJcblx0XHRcdHhoci5hYm9ydCgpO1xyXG5cdFx0fSwgb3B0aW9ucy50aW1lb3V0KTtcclxuXHR9XHJcblx0aWYgKGNhbGxiYWNrKSB7XHJcblx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcclxuXHRcdFx0XHRjYWxsYmFjayh4aHIpO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cdH1cclxuXHR4aHIuc2VuZChvcHRpb25zLmRhdGEpO1xyXG5cdHJldHVybiB4aHI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN1Y2Nlc3NmdWwoeGhyKSB7XHJcblx0cmV0dXJuIHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHF1ZXJ5U3RyaW5nKG9iaikge1xyXG5cdHZhciBzdHIgPSBbXTtcclxuXHRmb3IgKHZhciBwcm9wIGluIG9iaikge1xyXG5cdFx0aWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgeyAvLyBkb24ndCBoYW5kbGUgbmVzdGVkIG9iamVjdHNcclxuXHRcdFx0c3RyLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KHByb3ApICsgJz0nICtcclxuXHRcdFx0ZW5jb2RlVVJJQ29tcG9uZW50KG9ialtwcm9wXSkpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gc3RyLmpvaW4oJyYnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVxdWVzdChvcHRzKSB7XHJcblx0dmFyIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XHJcblx0XHRtZXRob2Q6ICdHRVQnLFxyXG5cdFx0aGVhZGVyczoge30sXHJcblx0XHR0aW1lb3V0OiA2MDAwXHJcblx0fSwgdXRpbC5pc09iamVjdChvcHRzKSA/IG9wdHMgOiB7IHVybDogb3B0cyB9KTtcclxuXHRpZiAodXRpbC5pc09iamVjdChvcHRpb25zLmRhdGEpKSB7XHJcblx0XHRvcHRpb25zLmRhdGEgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLmRhdGEpO1xyXG5cdFx0b3B0aW9ucy5oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04JztcclxuXHR9XHJcblx0aWYgKG9wdGlvbnMucGFyYW1zKSB7XHJcblx0XHRvcHRpb25zLnVybCA9IG9wdGlvbnMudXJsICsgKG9wdGlvbnMudXJsLmluZGV4T2YoJz8nKSA8IDAgPyAnPycgOiAnJicpICsgcXVlcnlTdHJpbmcob3B0aW9ucy5wYXJhbXMpO1xyXG5cdH1cclxuXHJcblx0aWYgKCFvcHRpb25zLnN5bmMpIHtcclxuXHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcblx0XHRcdGFqYXgob3B0aW9ucywgZnVuY3Rpb24gKHhocikge1xyXG5cdFx0XHRcdHZhciBjb21wbGV0ZSA9IHN1Y2Nlc3NmdWwoeGhyKSA/IHJlc29sdmUgOiByZWplY3Q7XHJcblx0XHRcdFx0Y29tcGxldGUoeGhyKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdHZhciB4aHIgPSBhamF4KG9wdGlvbnMpO1xyXG5cdGlmICghc3VjY2Vzc2Z1bCh4aHIpKSB7XHJcblx0XHR0aHJvdyB4aHI7XHJcblx0fVxyXG5cdHJldHVybiB4aHI7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWVzdDtcclxuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL2luZGV4Jyk7XHJcbnZhciBWZWMyID0gcmVxdWlyZSgnLi92ZWMyJyk7XHJcblxyXG52YXIgQm94MkFicyA9IGZ1bmN0aW9uICgpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxICYmICdtaW4nIGluIGFyZ3VtZW50c1swXSAmJiAnbWF4JyBpbiBhcmd1bWVudHNbMF0pIHtcclxuXHRcdHRoaXMucDAgPSBhcmd1bWVudHNbMF0ubWluO1xyXG5cdFx0dGhpcy5wMSA9IGFyZ3VtZW50c1swXS5tYXg7XHJcblx0fVxyXG5cclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyICYmIGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIFZlYzIgJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgVmVjMikge1xyXG5cdFx0dGhpcy5wMCA9IGFyZ3VtZW50c1swXTtcclxuXHRcdHRoaXMucDEgPSBhcmd1bWVudHNbMV07XHJcblx0fSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDQpIHtcclxuXHRcdHRoaXMucDAgPSBuZXcgVmVjMihhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSk7XHJcblx0XHR0aGlzLnAxID0gbmV3IFZlYzIoYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10pO1xyXG5cdH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAwKSB7XHJcblx0XHR0aGlzLnAwID0gbmV3IFZlYzIoKTtcclxuXHRcdHRoaXMucDEgPSBuZXcgVmVjMigpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRuZXcgRXJyb3IoJ0JveDJBYnMgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIDQgbnVtYmVycyBvciAyIHZlY3RvcnMgb3Igbm8gYXJndW1lbnRzIScpO1xyXG5cdH1cclxufTtcclxuXHJcbkJveDJBYnMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG5cdHJldHVybiB0aGlzLnAwLnRvU3RyaW5nKCkgKyAnICcgKyB0aGlzLnAxLnRvU3RyaW5nKCk7XHJcblxyXG59O1xyXG5cclxuQm94MkFicy5mcm9tUmVsQm94ID0gZnVuY3Rpb24gKHJlbEJveCkge1xyXG5cdHV0aWwuYXNzZXJ0RGVmaW5lZChyZWxCb3gpO1xyXG5cdHJldHVybiBuZXcgQm94MkFicyhyZWxCb3gueCwgcmVsQm94LnksIHJlbEJveC54ICsgcmVsQm94LndpZHRoLCByZWxCb3gueSArIHJlbEJveC5oZWlnaHQpO1xyXG59O1xyXG5cclxuQm94MkFicy5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblx0cmV0dXJuIG5ldyBCb3gyQWJzKHRoaXMucDAsIHRoaXMucDEpO1xyXG59O1xyXG5cclxuQm94MkFicy51bmlvbiA9IGZ1bmN0aW9uICgvKkJveDJBYnMqL2IxLCAvKkJveDJBYnMqL2IyKSB7XHJcblx0dXRpbC5hc3NlcnREZWZpbmVkKGIxKTtcclxuXHR1dGlsLmFzc2VydERlZmluZWQoYjIpO1xyXG5cdHJldHVybiBuZXcgQm94MkFicyhWZWMyLm1pbihiMS5wMCwgYjIucDApLCBWZWMyLm1heChiMS5wMSwgYjIucDEpKTtcclxufTtcclxuXHJcbkJveDJBYnMucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uICgvKlZlYzIqL2xwLCAvKlZlYzIqL3JiKSB7XHJcblx0dXRpbC5hc3NlcnREZWZpbmVkKGxwKTtcclxuXHRyYiA9IHJiIHx8IGxwO1xyXG5cdHJldHVybiBuZXcgQm94MkFicyh0aGlzLnAwLnN1YihscCksIHRoaXMucDEuYWRkKHJiKSk7XHJcbn07XHJcblxyXG5Cb3gyQWJzLnByb3RvdHlwZS5pbmNsdWRlID0gZnVuY3Rpb24gKC8qVmVjMiovcCkge1xyXG5cdHV0aWwuYXNzZXJ0RGVmaW5lZChwKTtcclxuXHRyZXR1cm4gbmV3IEJveDJBYnModGhpcy5wMC5taW4ocCksIHRoaXMucDEubWF4KHApKTtcclxufTtcclxuXHJcbkJveDJBYnMucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKC8qVmVjMiovcCwgLypmbG9hdCovZXh0KSB7XHJcblx0ZXh0ID0gKGV4dCB8fCAwKSAtIDA7XHJcblx0dXRpbC5hc3NlcnREZWZpbmVkKHApO1xyXG5cdHJldHVybiBwLnggPj0gdGhpcy5wMC54IC0gZXh0ICYmIHAueCA8PSB0aGlzLnAxLnggKyBleHQgJiYgcC55ID49IHRoaXMucDAueSAtIGV4dCAmJiBwLnkgPD0gdGhpcy5wMS55ICsgZXh0O1xyXG59O1xyXG5cclxuQm94MkFicy5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24gKC8qVmVjMiovZCkge1xyXG5cdHV0aWwuYXNzZXJ0RGVmaW5lZChkKTtcclxuXHRyZXR1cm4gbmV3IEJveDJBYnModGhpcy5wMC5hZGQoZCksIHRoaXMucDEuYWRkKGQpKTtcclxufTtcclxuXHJcbkJveDJBYnMucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICgvKmZ1bmN0aW9uKFZlYzIpOlZlYzIqL2YsIGNvbnRleHQpIHtcclxuXHR1dGlsLmFzc2VydCghdXRpbC5pc051bGxPclVuZGVmaW5lZChmKSk7XHJcblx0cmV0dXJuIG5ldyBCb3gyQWJzKGYuY2FsbChjb250ZXh0LCB0aGlzLnAwKSwgZi5jYWxsKGNvbnRleHQsIHRoaXMucDEpKTtcclxufTtcclxuXHJcbkJveDJBYnMucHJvdG90eXBlLnN6ID0gZnVuY3Rpb24gKCkge1xyXG5cdHJldHVybiB0aGlzLnAxLnN1Yih0aGlzLnAwKTtcclxufTtcclxuXHJcbkJveDJBYnMucHJvdG90eXBlLmNlbnRyZSA9IGZ1bmN0aW9uICgpIHtcclxuXHRyZXR1cm4gVmVjMi5jZW50cmUodGhpcy5wMCwgdGhpcy5wMSk7XHJcbn07XHJcblxyXG5Cb3gyQWJzLnByb3RvdHlwZS5wb3MgPSBmdW5jdGlvbiAoKSB7XHJcblx0cmV0dXJuIHRoaXMucDA7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJveDJBYnM7XHJcbiIsIkFycmF5LnByb3RvdHlwZS5zd2FwID0gZnVuY3Rpb24gKGkxLCBpMikgeyAvL2VzbGludC1kaXNhYmxlLWxpbmVcclxuXHR2YXIgdG1wID0gdGhpc1tpMV07XHJcblx0dGhpc1tpMV0gPSB0aGlzW2kyXTtcclxuXHR0aGlzW2kyXSA9IHRtcDtcclxufTtcclxuXHJcbnZhciB0ZnggPSBmdW5jdGlvbiAodikge1xyXG5cdHJldHVybiAodiAtIDApLnRvRml4ZWQoOCk7XHJcbn07XHJcblxyXG4vLyBcImVhY2hcIiBmdW5jdGlvbiBmb3IgYW4gYXJyYXlcclxudmFyIGVhY2ggPSBmdW5jdGlvbiAoYXJyYXksIGZ1bmMsIGNvbnRleHQpIHtcclxuXHRhc3NlcnQoIWlzTnVsbE9yVW5kZWZpbmVkKGFycmF5KSwgJ2FycmF5IG11c3QgYmUgZGVmaW5lZCcpO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcclxuXHRcdGZ1bmMuY2FsbChjb250ZXh0LCBhcnJheVtpXSwgaSk7XHJcblx0fVxyXG59O1xyXG5cclxudmFyIG1hcF9lYWNoID0gZnVuY3Rpb24gKG1hcCwgZnVuYywgY29udGV4dCkge1xyXG5cdGFzc2VydCghaXNOdWxsT3JVbmRlZmluZWQobWFwKSwgJ21hcCBtdXN0IGJlIGRlZmluZWQnKTtcclxuXHRmb3IgKHZhciBrZXkgaW4gbWFwKSB7XHJcblx0XHRpZiAobWFwLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuXHRcdFx0ZnVuYy5jYWxsKGNvbnRleHQsIGtleSwgbWFwW2tleV0pO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIGZpbmQoYXJyYXksIHByZWQpIHtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZiAocHJlZChhcnJheVtpXSwgaSwgYXJyYXkpKVxyXG5cdFx0XHRyZXR1cm4gYXJyYXlbaV07XHJcblx0fVxyXG5cdHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgZnVuYywgY29udGV4dCkge1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcclxuXHRcdGlmIChmdW5jLmNhbGwoY29udGV4dCwgYXJyYXlbaV0sIGkpKSB7XHJcblx0XHRcdHJldHVybiBpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gLTE7XHJcbn07XHJcblxyXG52YXIgZmluZEFsbCA9IGZ1bmN0aW9uIChhcnJheSwgZnVuYywgY29udGV4dCkge1xyXG5cdHZhciBpO1xyXG5cdHZhciByZXQgPSBbXTtcclxuXHRmb3IgKGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcclxuXHRcdGlmIChmdW5jLmNhbGwoY29udGV4dCwgYXJyYXlbaV0sIGkpKSB7XHJcblx0XHRcdHJldC5wdXNoKGFycmF5W2ldKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufTtcclxuXHJcbnZhciBhcnJheSA9IGZ1bmN0aW9uIChhcnJheUxpa2UpIHtcclxuXHR2YXIgYSA9IFtdO1xyXG5cdHZhciBpID0gYXJyYXlMaWtlLmxlbmd0aDtcclxuXHR3aGlsZSAoLS1pID49IDApIHtcclxuXHRcdGFbaV0gPSBhcnJheUxpa2VbaV07XHJcblx0fVxyXG5cdHJldHVybiBhO1xyXG59O1xyXG5cclxudmFyIGlzRW1wdHkgPSBmdW5jdGlvbiAob2JqKSB7XHJcblx0Zm9yICh2YXIgdiBpbiBvYmopIHtcclxuXHRcdGlmIChvYmouaGFzT3duUHJvcGVydHkodikpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbnZhciBzdG9wRXZlbnRQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uIChldmVudCkge1xyXG5cdGlmICgnc3RvcFByb3BhZ2F0aW9uJyBpbiBldmVudCkgey8vIE1vemlsbGEsIE9wZXJhLCBTYWZhcmlcclxuXHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cdH0gZWxzZSBpZiAoJ2NhbmNlbEJ1YmJsZScgaW4gZXZlbnQpIHsvLyBJRVxyXG5cdFx0ZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhyb3cgRXJyb3IoJ0Jyb3dzZXIgdW5yZWNvZ25pemVkJyk7XHJcblx0fVxyXG59O1xyXG5cclxudmFyIHByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0aWYgKCdwcmV2ZW50RGVmYXVsdCcgaW4gZXZlbnQpIHtcclxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblx0fVxyXG5cdGlmIChQcm90b3R5cGUuQnJvd3Nlci5JRSkge1xyXG5cdFx0ZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcclxuXHRcdGV2ZW50LmtleUNvZGUgPSAwO1xyXG5cdH1cclxuXHRyZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG52YXIgc2V0RWxlbWVudFRleHRDb250ZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIHRleHQpIHtcclxuXHRpZiAoJ3RleHRDb250ZW50JyBpbiBlbGVtZW50KSB7Ly8gTW96aWxsYSwgT3BlcmEsIFNhZmFyaVxyXG5cdFx0ZWxlbWVudC50ZXh0Q29udGVudCA9IHRleHQ7XHJcblx0fSBlbHNlIGlmICgnaW5uZXJUZXh0JyBpbiBlbGVtZW50KSB7Ly8gSUUgYW5kIG90aGVycyAoZXhjZXB0IE1vemlsbGEpXHJcblx0XHRlbGVtZW50LmlubmVyVGV4dCA9IHRleHQ7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRocm93IEVycm9yKCdCcm93c2VyIHVucmVjb2duaXplZCcpO1xyXG5cdH1cclxufTtcclxuXHJcbnZhciBnZXRFbGVtZW50VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG5cdGlmICgndGV4dENvbnRlbnQnIGluIGVsZW1lbnQpIHsvLyBNb3ppbGxhLCBPcGVyYSwgU2FmYXJpXHJcblx0XHRyZXR1cm4gZWxlbWVudC50ZXh0Q29udGVudDtcclxuXHR9IGVsc2UgaWYgKCdpbm5lclRleHQnIGluIGVsZW1lbnQpIHsvLyBJRSBhbmQgb3RoZXJzIChleGNlcHQgTW96aWxsYSlcclxuXHRcdHJldHVybiBlbGVtZW50LmlubmVyVGV4dDtcclxuXHR9XHJcblxyXG5cdHRocm93IEVycm9yKCdCcm93c2VyIHVucmVjb2duaXplZCcpO1xyXG59O1xyXG5cclxudmFyIHN0cmluZ1BhZGRlZCA9IGZ1bmN0aW9uIChzdHJpbmcsIHdpZHRoLCBsZWZ0QWxpZ25lZCkge1xyXG5cdHZhciBzdHIgPSBzdHJpbmcgKyAnJztcclxuXHR2YXIgc3BhY2UgPSAnJztcclxuXHR3aGlsZSAoc3RyLmxlbmd0aCArIHNwYWNlLmxlbmd0aCA8IHdpZHRoKSB7XHJcblx0XHRzcGFjZSArPSAnICc7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gKGxlZnRBbGlnbmVkKSA/IHN0cmluZyArIHNwYWNlIDogc3BhY2UgKyBzdHJpbmc7XHJcbn07XHJcblxyXG5cclxuLy8gQWNjb3JkaW5nIFVuaWNvZGUgQ29uc29ydGl1bSBzb3VsZCBiZVxyXG4vLyBubFJlID0gL1xcclxcbnxbXFxuXFx2XFxmXFxyXFx4ODVcXHUyMDI4XFx1MjAyOV0vZztcclxuLy8gaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMTgvI0xpbmVfQm91bmRhcmllc1xyXG52YXIgbmxSZSA9IC9cXHJcXG58W1xcblxccl0vZztcclxuXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZU5ld2xpbmVzKHN0cikge1xyXG5cdHJldHVybiBzdHIucmVwbGFjZShubFJlLCAnXFxuJyk7XHJcbn07XHJcbmZ1bmN0aW9uIHNwbGl0TmV3bGluZXMoc3RyKSB7XHJcblx0cmV0dXJuIHN0ci5zcGxpdChubFJlKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIHVuaWNvZGVMaXRlcmFsKHN0cil7XHJcblx0ZnVuY3Rpb24gZml4ZWRIZXgobnVtYmVyLCBsZW5ndGgpe1xyXG5cdFx0dmFyIHN0ciA9IG51bWJlci50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcclxuXHRcdHdoaWxlKHN0ci5sZW5ndGggPCBsZW5ndGgpXHJcblx0XHRcdHN0ciA9IFwiMFwiICsgc3RyO1xyXG5cdFx0cmV0dXJuIHN0cjtcclxuXHR9XHJcblx0dmFyIGk7XHJcblx0dmFyIHJlc3VsdCA9IFwiXCI7XHJcblx0Zm9yKCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSl7XHJcblx0XHRpZihzdHIuY2hhckNvZGVBdChpKSA+IDEyNiB8fCBzdHIuY2hhckNvZGVBdChpKSA8IDMyKVxyXG5cdFx0XHRyZXN1bHQgKz0gXCJcXFxcdVwiICsgZml4ZWRIZXgoc3RyLmNoYXJDb2RlQXQoaSksNCk7XHJcblx0XHRlbHNlXHJcblx0XHRcdHJlc3VsdCArPSBzdHJbaV07XHJcblx0fVxyXG5cdHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcblxyXG52YXIgaWRMaXN0ID0gZnVuY3Rpb24gKG9iamVjdCkge1xyXG5cdHZhciBsaXN0ID0gW107XHJcblx0Zm9yICh2YXIgYWlkIGluIG9iamVjdCkge1xyXG5cdFx0aWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShhaWQpKSB7XHJcblx0XHRcdGxpc3QucHVzaChhaWQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gbGlzdDtcclxufTtcclxuXHJcbnZhciBtYXBBcnJheSA9IGZ1bmN0aW9uIChzcmMsIG1hcCkge1xyXG5cdHZhciBkc3QgPSBbXTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHNyYy5sZW5ndGg7ICsraSkge1xyXG5cdFx0ZHN0LnB1c2gobWFwW3NyY1tpXV0pO1xyXG5cdH1cclxuXHRyZXR1cm4gZHN0O1xyXG59O1xyXG5cclxudmFyIGFycmF5TWF4ID0gZnVuY3Rpb24gKGFycmF5KSB7XHJcblx0cmV0dXJuIE1hdGgubWF4LmFwcGx5KE1hdGgsIGFycmF5KTtcclxufTtcclxuXHJcbnZhciBhcnJheU1pbiA9IGZ1bmN0aW9uIChhcnJheSkge1xyXG5cdHJldHVybiBNYXRoLm1pbi5hcHBseShNYXRoLCBhcnJheSk7XHJcbn07XHJcblxyXG52YXIgbWFwID0gZnVuY3Rpb24gKHNyYywgZnVuYywgY29udGV4dCkge1xyXG5cdHZhciBkc3QgPSBbXTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHNyYy5sZW5ndGg7ICsraSkge1xyXG5cdFx0ZHN0LnB1c2goZnVuYy5jYWxsKGNvbnRleHQsIHNyY1tpXSkpO1xyXG5cdH1cclxuXHRyZXR1cm4gZHN0O1xyXG59O1xyXG5cclxudmFyIGFwcGx5ID0gZnVuY3Rpb24gKGFycmF5LCBmdW5jKSB7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSkge1xyXG5cdFx0YXJyYXlbaV0gPSBmdW5jKGFycmF5W2ldKTtcclxuXHR9XHJcbn07XHJcblxyXG52YXIgaWZEZWYgPSBmdW5jdGlvbiAoZHN0LCBzcmMsIHByb3AsIGRlZikge1xyXG5cdGRzdFtwcm9wXSA9ICFPYmplY3QuaXNVbmRlZmluZWQoc3JjW3Byb3BdKSA/IHNyY1twcm9wXSA6IGRlZjtcclxufTtcclxuXHJcbnZhciBpZkRlZkxpc3QgPSBmdW5jdGlvbiAoZHN0LCBzcmMsIHByb3AsIGRlZikge1xyXG5cdGRzdFtwcm9wXSA9ICFPYmplY3QuaXNVbmRlZmluZWQoc3JjW3Byb3BdKSAmJiBzcmNbcHJvcF0gIT09IG51bGwgPyBhcnJheShzcmNbcHJvcF0pIDogZGVmO1xyXG59O1xyXG5cclxudmFyIGlkZW50aXR5TWFwID0gZnVuY3Rpb24gKGFycmF5KSB7XHJcblx0dmFyIG1hcCA9IHt9O1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcclxuXHRcdG1hcFthcnJheVtpXV0gPSBhcnJheVtpXTtcclxuXHR9XHJcblx0cmV0dXJuIG1hcDtcclxufTtcclxuXHJcbnZhciBzdHJpcCA9IGZ1bmN0aW9uIChzcmMpIHtcclxuXHRyZXR1cm4gc3JjLnJlcGxhY2UoL1xccyokLywgJycpLnJlcGxhY2UoL15cXHMqLywgJycpO1xyXG59O1xyXG5cclxudmFyIHN0cmlwUmlnaHQgPSBmdW5jdGlvbiAoc3JjKSB7XHJcblx0cmV0dXJuIHNyYy5yZXBsYWNlKC9cXHMqJC8sICcnKTtcclxufTtcclxuXHJcbnZhciBzdHJpcFF1b3RlcyA9IGZ1bmN0aW9uIChzdHIpIHtcclxuXHRpZiAoc3RyWzBdID09PSAnXCInICYmIHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICdcIicpIHtcclxuXHRcdHJldHVybiBzdHIuc3Vic3RyKDEsIHN0ci5sZW5ndGggLSAyKTtcclxuXHR9XHJcblx0cmV0dXJuIHN0cjtcclxufTtcclxuXHJcbnZhciBwYWRkZWRGbG9hdCA9IGZ1bmN0aW9uIChudW1iZXIsIHdpZHRoLCBwcmVjaXNpb24pIHtcclxuXHR2YXIgbnVtU3RyID0gbnVtYmVyLnRvRml4ZWQocHJlY2lzaW9uKS5yZXBsYWNlKCcsJywgJy4nKTtcclxuXHRpZiAobnVtU3RyLmxlbmd0aCA+IHdpZHRoKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ251bWJlciBkb2VzIG5vdCBmaXQnKTtcclxuXHR9XHJcblx0cmV0dXJuIHN0cmluZ1BhZGRlZChudW1TdHIsIHdpZHRoKTtcclxufTtcclxuXHJcbnZhciBwYWRkZWRJbnQgPSBmdW5jdGlvbiAobnVtYmVyLCB3aWR0aCkge1xyXG5cdHZhciBudW1TdHIgPSBudW1iZXIudG9GaXhlZCgwKTtcclxuXHRpZiAobnVtU3RyLmxlbmd0aCA+IHdpZHRoKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ251bWJlciBkb2VzIG5vdCBmaXQnKTtcclxuXHR9XHJcblx0cmV0dXJuIHN0cmluZ1BhZGRlZChudW1TdHIsIHdpZHRoKTtcclxufTtcclxuXHJcbnZhciBhcnJheUFkZElmTWlzc2luZyA9IGZ1bmN0aW9uIChhcnJheSwgaXRlbSkge1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcclxuXHRcdGlmIChhcnJheVtpXSA9PT0gaXRlbSkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0fVxyXG5cdGFycmF5LnB1c2goaXRlbSk7XHJcblx0cmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG52YXIgYXNzZXJ0ID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgY29tbWVudCkge1xyXG5cdGlmICghY29uZGl0aW9uKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoY29tbWVudCA/ICgnQXNzZXJ0aW9uIGZhaWxlZDogJyArIGNvbW1lbnQpIDogJ0Fzc2VydGlvbiBmYWlsZWQnKTtcclxuXHR9XHJcbn07XHJcblxyXG52YXIgYXNzZXJ0RGVmaW5lZCA9IGZ1bmN0aW9uKHYpIHtcclxuXHRhc3NlcnQoIWlzTnVsbE9yVW5kZWZpbmVkKHYpKTtcclxufTtcclxuXHJcbnZhciBpc1VuZGVmaW5lZCA9IGZ1bmN0aW9uICh2YXJpYWJsZSkge1xyXG5cdHJldHVybiBPYmplY3QuaXNVbmRlZmluZWQodmFyaWFibGUpOyAvLyB1c2UgcHJvdG90eXBlLmpzIG1ldGhvZCBmb3Igbm93XHJcbn07XHJcblxyXG52YXIgaXNOdWxsID0gZnVuY3Rpb24gKHZhcmlhYmxlKSB7XHJcblx0cmV0dXJuIHZhcmlhYmxlID09PSBudWxsO1xyXG59O1xyXG5cclxudmFyIGlzTnVsbE9yVW5kZWZpbmVkID0gZnVuY3Rpb24gKHYpIHtcclxuXHRyZXR1cm4gaXNVbmRlZmluZWQodikgfHwgaXNOdWxsKHYpO1xyXG59O1xyXG5cclxudmFyIGFycmF5UmVtb3ZlQnlWYWx1ZSA9IGZ1bmN0aW9uIChhcnJheSwgaXRlbSkge1xyXG5cdGFzc2VydCghaXNVbmRlZmluZWQoYXJyYXkpICYmICFpc051bGwoYXJyYXkpLCAnYXJyYXkgbXVzdCBiZSBkZWZpbmVkJyk7XHJcblx0dmFyIGlkeCA9IGFycmF5LmluZGV4T2YoaXRlbSk7XHJcblx0dmFyIGNudCA9IDA7XHJcblx0d2hpbGUgKGlkeCA+PSAwKSB7XHJcblx0XHRhcnJheS5zcGxpY2UoaWR4LCAxKTtcclxuXHRcdGNudCArPSAxO1xyXG5cdFx0aWR4ID0gYXJyYXkuaW5kZXhPZihpdGVtKTtcclxuXHR9XHJcblx0cmV0dXJuIGNudDtcclxufTtcclxuXHJcbnZhciBsaXN0TmV4dFJvdGF0ZSA9IGZ1bmN0aW9uIChsaXN0LCB2YWx1ZSkge1xyXG5cdHJldHVybiBsaXN0WyhsaXN0LmluZGV4T2YodmFsdWUpICsgMSkgJSBsaXN0Lmxlbmd0aF07XHJcbn07XHJcblxyXG4vLyBzaW1pbGFyIHRvIE9iamVjdC5hc3NpZ25cclxuLy8gaHR0cDovL3d3dy4yYWxpdHkuY29tLzIwMTQvMDEvb2JqZWN0LWFzc2lnbi5odG1sXHJcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoZGVzdCwgc3JjKSB7XHJcblx0Zm9yICh2YXIgcHJvcCBpbiBzcmMpIHtcclxuXHRcdGlmIChzcmMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcclxuXHRcdFx0ZGVzdFtwcm9wXSA9IHNyY1twcm9wXTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGRlc3Q7XHJcbn07XHJcblxyXG52YXIgaXNPYmplY3QgPSBmdW5jdGlvbiAob2JqKSB7XHJcblx0cmV0dXJuIG9iaiA9PT0gT2JqZWN0KG9iaik7XHJcbn07XHJcblxyXG52YXIgcmVsQm94ID0gZnVuY3Rpb24gKGJveCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB4OiBib3gueCxcclxuICAgICAgICB5OiBib3gueSxcclxuICAgICAgICB3aWR0aDogYm94LndpZHRoLFxyXG4gICAgICAgIGhlaWdodDogYm94LmhlaWdodFxyXG4gICAgfTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cdHRmeDogdGZ4LFxyXG5cdGVhY2g6IGVhY2gsXHJcblx0ZmluZDogZmluZCxcclxuXHRmaW5kSW5kZXg6IGZpbmRJbmRleCxcclxuXHRmaW5kQWxsOiBmaW5kQWxsLFxyXG5cdGFycmF5OiBhcnJheSxcclxuXHRpc0VtcHR5OiBpc0VtcHR5LFxyXG5cdHN0b3BFdmVudFByb3BhZ2F0aW9uOiBzdG9wRXZlbnRQcm9wYWdhdGlvbixcclxuXHRwcmV2ZW50RGVmYXVsdDogcHJldmVudERlZmF1bHQsXHJcblx0c2V0RWxlbWVudFRleHRDb250ZW50OiBzZXRFbGVtZW50VGV4dENvbnRlbnQsXHJcblx0Z2V0RWxlbWVudFRleHRDb250ZW50OiBnZXRFbGVtZW50VGV4dENvbnRlbnQsXHJcblx0c3RyaW5nUGFkZGVkOiBzdHJpbmdQYWRkZWQsXHJcblx0bm9ybWFsaXplTmV3bGluZXM6IG5vcm1hbGl6ZU5ld2xpbmVzLFxyXG5cdHNwbGl0TmV3bGluZXM6IHNwbGl0TmV3bGluZXMsXHJcblx0dW5pY29kZUxpdGVyYWw6IHVuaWNvZGVMaXRlcmFsLFxyXG5cdGlkTGlzdDogaWRMaXN0LFxyXG5cdG1hcEFycmF5OiBtYXBBcnJheSxcclxuXHRhcnJheU1heDogYXJyYXlNYXgsXHJcblx0YXJyYXlNaW46IGFycmF5TWluLFxyXG5cdG1hcDogbWFwLFxyXG5cdGFwcGx5OiBhcHBseSxcclxuXHRpZkRlZjogaWZEZWYsXHJcblx0aWZEZWZMaXN0OiBpZkRlZkxpc3QsXHJcblx0aWRlbnRpdHlNYXA6IGlkZW50aXR5TWFwLFxyXG5cdHN0cmlwOiBzdHJpcCxcclxuXHRzdHJpcFJpZ2h0OiBzdHJpcFJpZ2h0LFxyXG5cdHN0cmlwUXVvdGVzOiBzdHJpcFF1b3RlcyxcclxuXHRwYWRkZWRGbG9hdDogcGFkZGVkRmxvYXQsXHJcblx0cGFkZGVkSW50OiBwYWRkZWRJbnQsXHJcblx0YXJyYXlBZGRJZk1pc3Npbmc6IGFycmF5QWRkSWZNaXNzaW5nLFxyXG5cdGFzc2VydDogYXNzZXJ0LFxyXG5cdGFzc2VydERlZmluZWQ6IGFzc2VydERlZmluZWQsXHJcblx0aXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxyXG5cdGlzTnVsbDogaXNOdWxsLFxyXG5cdGlzTnVsbE9yVW5kZWZpbmVkOiBpc051bGxPclVuZGVmaW5lZCxcclxuXHRhcnJheVJlbW92ZUJ5VmFsdWU6IGFycmF5UmVtb3ZlQnlWYWx1ZSxcclxuXHRsaXN0TmV4dFJvdGF0ZTogbGlzdE5leHRSb3RhdGUsXHJcblx0ZXh0ZW5kOiBleHRlbmQsXHJcbiAgICBpc09iamVjdDogaXNPYmplY3QsXHJcbiAgICByZWxCb3g6IHJlbEJveFxyXG59O1xyXG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vaW5kZXgnKTtcclxuXHJcbnZhciBNYXAgPSBmdW5jdGlvbiAob2JqKSB7XHJcblx0aWYgKHR5cGVvZiAob2JqKSAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHtcclxuXHRcdHRocm93IEVycm9yKCdQYXNzZWQgb2JqZWN0IGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBcIk9iamVjdFwiIScpO1xyXG5cdH1cclxuXHR0aGlzLl9vYmogPSBvYmogfHwge307XHJcblx0dGhpcy5fY291bnQgPSAwO1xyXG59O1xyXG5cclxuTWFwLnByb3RvdHlwZS5lYWNoID0gZnVuY3Rpb24gKGZ1bmMsIGNvbnRleHQpIHtcclxuXHR2YXIgdjtcclxuXHR2YXIgdmFsdWU7XHJcblx0dmFyIHZJbnQ7XHJcblxyXG5cdGZvciAodiBpbiB0aGlzLl9vYmopIHtcclxuXHRcdHZJbnQgPSBwYXJzZUludCh2LCAxMCk7XHJcblx0XHR2YWx1ZSA9IHRoaXMuX29ialt2XTtcclxuXHJcblx0XHRpZiAoIWlzTmFOKHZJbnQpKSB7XHJcblx0XHRcdHYgPSB2SW50O1xyXG5cdFx0fVxyXG5cdFx0ZnVuYy5jYWxsKGNvbnRleHQsIHYsIHZhbHVlKTtcclxuXHR9XHJcbn07XHJcblxyXG5NYXAucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmdW5jLCBjb250ZXh0KSB7XHJcblx0dmFyIHJldCA9IG5ldyBNYXAoKTtcclxuXHR0aGlzLmVhY2goZnVuY3Rpb24gKHYsIHZhbHVlKSB7XHJcblx0XHRyZXQuc2V0KHYsIGZ1bmMuY2FsbChjb250ZXh0LCB2LCB2YWx1ZSkpO1xyXG5cdH0sIHRoaXMpO1xyXG5cdHJldHVybiByZXQ7XHJcbn07XHJcblxyXG5NYXAucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoZnVuYywgY29udGV4dCkge1xyXG5cdHZhciB2O1xyXG5cdHZhciB2SW50O1xyXG5cdHZhciB2YWx1ZTtcclxuXHJcblx0Zm9yICh2IGluIHRoaXMuX29iaikge1xyXG5cdFx0dkludCA9IHBhcnNlSW50KHYsIDEwKTtcclxuXHRcdHZhbHVlID0gdGhpcy5fb2JqW3ZdO1xyXG5cclxuXHRcdGlmICghaXNOYU4odkludCkpIHtcclxuXHRcdFx0diA9IHZJbnQ7XHJcblx0XHR9XHJcblx0XHRpZiAoZnVuYy5jYWxsKGNvbnRleHQsIHYsIHZhbHVlKSkge1xyXG5cdFx0XHRyZXR1cm4gdjtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxyXG5NYXAucHJvdG90eXBlLmZpbmRBbGwgPSBmdW5jdGlvbiAoZnVuYywgY29udGV4dCkge1xyXG5cdHZhciB2O1xyXG5cdHZhciB2SW50O1xyXG5cdHZhciB2YWx1ZTtcclxuXHR2YXIgdnYgPSBbXTtcclxuXHJcblx0Zm9yICh2IGluIHRoaXMuX29iaikge1xyXG5cdFx0dkludCA9IHBhcnNlSW50KHYsIDEwKTtcclxuXHRcdHZhbHVlID0gdGhpcy5fb2JqW3ZdO1xyXG5cdFx0aWYgKCFpc05hTih2SW50KSkge1xyXG5cdFx0XHR2ID0gdkludDtcclxuXHRcdH1cclxuXHRcdGlmIChmdW5jLmNhbGwoY29udGV4dCwgdiwgdmFsdWUpKSB7XHJcblx0XHRcdHZ2LnB1c2godik7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiB2djtcclxufTtcclxuXHJcbk1hcC5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHtcclxuXHR2YXIga2V5cyA9IFtdO1xyXG5cdHZhciB2O1xyXG5cdGZvciAodiBpbiB0aGlzLl9vYmopIHtcclxuXHRcdGtleXMucHVzaCh2KTtcclxuXHR9XHJcblx0cmV0dXJuIGtleXM7XHJcbn07XHJcblxyXG5NYXAucHJvdG90eXBlLmlrZXlzID0gZnVuY3Rpb24gKCkge1xyXG5cdHZhciBrZXlzID0gW107XHJcblx0Zm9yICh2YXIgdiBpbiB0aGlzLl9vYmopIHtcclxuXHRcdGtleXMucHVzaCh2IC0gMCk7XHJcblx0fVxyXG5cdHJldHVybiBrZXlzO1xyXG59O1xyXG5cclxuTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG5cdHZhciB2YWw7XHJcblx0dGhpcy5fY291bnQgKz0gKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgPyAxIDogMCkgLSAodHlwZW9mIHRoaXMuX29ialtrZXldICE9PSAndW5kZWZpbmVkJyA/IDEgOiAwKTtcclxuXHJcblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdHZhbCA9IHRoaXMuX29ialtrZXldO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX29ialtrZXldO1xyXG5cdFx0cmV0dXJuIHZhbDtcclxuXHR9XHJcblxyXG5cdHRoaXMuX29ialtrZXldID0gdmFsdWU7XHJcblx0cmV0dXJuIHZhbHVlO1xyXG59O1xyXG5cclxuTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XHJcblx0aWYgKHRoaXMuX29ialtrZXldICE9PSBPYmplY3QucHJvdG90eXBlW2tleV0pIHtcclxuXHRcdHJldHVybiB0aGlzLl9vYmpba2V5XTtcclxuXHR9XHJcblx0cmV0dXJuIHVuZGVmaW5lZDtcclxufTtcclxuXHJcbk1hcC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xyXG5cdHJldHVybiAodGhpcy5fb2JqW2tleV0gIT09IE9iamVjdC5wcm90b3R5cGVba2V5XSk7XHJcbn07XHJcblxyXG5NYXAucHJvdG90eXBlLnVuc2V0ID0gZnVuY3Rpb24gKGtleSkge1xyXG5cdHJldHVybiB0aGlzLnNldChrZXksIHVuZGVmaW5lZCk7XHJcbn07XHJcblxyXG5NYXAucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcclxuXHRmb3IgKHZhciB2IGluIG9iamVjdCkge1xyXG5cdFx0dGhpcy5zZXQodiwgb2JqZWN0W3ZdKTtcclxuXHR9XHJcbn07XHJcblxyXG5NYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG5cdHRoaXMuX29iaiA9IHt9O1xyXG5cdHRoaXMuX2NvdW50ID0gMDtcclxufTtcclxuXHJcbk1hcC5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0cmV0dXJuIHRoaXMuX2NvdW50O1xyXG59O1xyXG5cclxuTWFwLnByb3RvdHlwZS5pZExpc3QgPSBmdW5jdGlvbiAoKSB7XHJcblx0cmV0dXJuIHV0aWwuaWRMaXN0KHRoaXMuX29iaik7XHJcbn07XHJcblxyXG5NYXAucHJvdG90eXBlLmtleU9mID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcblx0Zm9yICh2YXIga2V5IGluIHRoaXMuX29iaikge1xyXG5cdFx0aWYgKHRoaXMuX29ialtrZXldID09PSB2YWx1ZSkge1xyXG5cdFx0XHRyZXR1cm4ga2V5O1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTWFwO1xyXG4iLCJ2YXIgTWFwID0gcmVxdWlyZSgnLi9tYXAuanMnKTtcclxuXHJcbnZhciBQb29sID0gZnVuY3Rpb24gKCkge1xyXG5cdHRoaXMuX21hcCA9IG5ldyBNYXAoKTtcclxuXHR0aGlzLl9uZXh0SWQgPSAwO1xyXG59O1xyXG5cclxuUG9vbC5wcm90b3R5cGUubmV3SWQgPSBmdW5jdGlvbiAoKSB7XHJcblx0cmV0dXJuIHRoaXMuX25leHRJZCsrO1xyXG59O1xyXG5cclxuUG9vbC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG9iaikge1xyXG5cdHZhciBpZCA9IHRoaXMuX25leHRJZCsrO1xyXG5cdHRoaXMuX21hcC5zZXQoaWQsIG9iaik7XHJcblx0cmV0dXJuIGlkO1xyXG59O1xyXG5cclxuUG9vbC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGlkLCBvYmopIHtcclxuXHR0aGlzLl9tYXAuc2V0KGlkLCBvYmopO1xyXG59O1xyXG5cclxuUG9vbC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGlkKSB7XHJcblx0cmV0dXJuIHRoaXMuX21hcC5nZXQoaWQpO1xyXG59O1xyXG5cclxuUG9vbC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGlkKSB7XHJcblx0cmV0dXJuIHRoaXMuX21hcC5oYXMoaWQpO1xyXG59O1xyXG5cclxuUG9vbC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGlkKSB7XHJcblx0cmV0dXJuIHRoaXMuX21hcC51bnNldChpZCk7XHJcbn07XHJcblxyXG5Qb29sLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuXHR0aGlzLl9tYXAuY2xlYXIoKTtcclxufTtcclxuXHJcblBvb2wucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7XHJcblx0cmV0dXJuIHRoaXMuX21hcC5rZXlzKCk7XHJcbn07XHJcblxyXG5Qb29sLnByb3RvdHlwZS5pa2V5cyA9IGZ1bmN0aW9uICgpIHtcclxuXHRyZXR1cm4gdGhpcy5fbWFwLmlrZXlzKCk7XHJcbn07XHJcblxyXG5Qb29sLnByb3RvdHlwZS5lYWNoID0gZnVuY3Rpb24gKGZ1bmMsIGNvbnRleHQpIHtcclxuXHR0aGlzLl9tYXAuZWFjaChmdW5jLCBjb250ZXh0KTtcclxufTtcclxuXHJcblBvb2wucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmdW5jLCBjb250ZXh0KSB7XHJcblx0cmV0dXJuIHRoaXMuX21hcC5tYXAoZnVuYywgY29udGV4dCk7XHJcbn07XHJcblxyXG5Qb29sLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKGZ1bmMsIGNvbnRleHQpIHtcclxuXHRyZXR1cm4gdGhpcy5fbWFwLmZpbmQoZnVuYywgY29udGV4dCk7XHJcbn07XHJcblxyXG5Qb29sLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuXHRyZXR1cm4gdGhpcy5fbWFwLmNvdW50KCk7XHJcbn07XHJcblxyXG5Qb29sLnByb3RvdHlwZS5rZXlPZiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cdHJldHVybiB0aGlzLl9tYXAua2V5T2YodmFsdWUpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQb29sO1xyXG4iLCJ2YXIgU2V0ID0ge1xyXG5cdGVtcHR5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4ge307XHJcblx0fSxcclxuXHJcblx0c2luZ2xlOiBmdW5jdGlvbiAoaXRlbSkge1xyXG5cdFx0dmFyIHNldCA9IHt9O1xyXG5cdFx0U2V0LmFkZChzZXQsIGl0ZW0pO1xyXG5cdFx0cmV0dXJuIHNldDtcclxuXHR9LFxyXG5cclxuXHRzaXplOiBmdW5jdGlvbiAoc2V0KSB7XHJcblx0XHR2YXIgY250ID0gMDtcclxuXHRcdGZvciAodmFyIGlkIGluIHNldCkge1xyXG5cdFx0XHRpZiAoc2V0W2lkXSAhPT0gT2JqZWN0LnByb3RvdHlwZVtpZF0pIHtcclxuXHRcdFx0XHRjbnQrKztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGNudDtcclxuXHR9LFxyXG5cclxuXHRjb250YWluczogZnVuY3Rpb24gKHNldCwgdikge1xyXG5cdFx0cmV0dXJuIHR5cGVvZiAoc2V0W3ZdKSAhPT0gJ3VuZGVmaW5lZCcgJiYgc2V0W3ZdICE9PSBPYmplY3QucHJvdG90eXBlW3ZdO1xyXG5cdH0sXHJcblxyXG5cdHN1YnNldDogZnVuY3Rpb24gKHN1YnNldCwgc3VwZXJzZXQpIHtcclxuXHRcdGZvciAodmFyIGlkIGluIHN1YnNldCkge1xyXG5cdFx0XHRpZiAoc3Vic2V0W2lkXSAhPT0gT2JqZWN0LnByb3RvdHlwZVtpZF0pIHtcclxuXHRcdFx0XHRpZiAoc3VwZXJzZXRbaWRdICE9PSBzdWJzZXRbaWRdKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHRpbnRlcnNlY3Rpb246IGZ1bmN0aW9uIChzZXQxLCBzZXQyKSB7XHJcblx0XHR2YXIgc2V0ID0ge307XHJcblx0XHRmb3IgKHZhciBpZCBpbiBzZXQxKSB7XHJcblx0XHRcdGlmIChzZXQxW2lkXSAhPT0gT2JqZWN0LnByb3RvdHlwZVtpZF0pIHtcclxuXHRcdFx0XHRpZiAoc2V0MltpZF0gPT09IHNldDFbaWRdKSB7XHJcblx0XHRcdFx0XHRTZXQuYWRkKHNldCwgaWQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHNldDtcclxuXHR9LFxyXG5cclxuXHRkaXNqb2ludDogZnVuY3Rpb24gKHNldDEsIHNldDIpIHtcclxuXHRcdGZvciAodmFyIGlkIGluIHNldDEpIHtcclxuXHRcdFx0aWYgKHNldDFbaWRdICE9PSBPYmplY3QucHJvdG90eXBlW2lkXSkge1xyXG5cdFx0XHRcdGlmIChzZXQyW2lkXSA9PT0gc2V0MVtpZF0pIHtcclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdGVxOiBmdW5jdGlvbiAoc2V0MSwgc2V0Mikge1xyXG5cdFx0cmV0dXJuIFNldC5zdWJzZXQoc2V0MSwgc2V0MikgJiYgU2V0LnN1YnNldChzZXQyLCBzZXQxKTtcclxuXHR9LFxyXG5cclxuXHRlYWNoOiBmdW5jdGlvbiAoc2V0LCBmdW5jLCBjb250ZXh0KSB7XHJcblx0XHRmb3IgKHZhciB2IGluIHNldCkge1xyXG5cdFx0XHRpZiAoc2V0W3ZdICE9PSBPYmplY3QucHJvdG90eXBlW3ZdKSB7XHJcblx0XHRcdFx0ZnVuYy5jYWxsKGNvbnRleHQsIHNldFt2XSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRmaWx0ZXI6IGZ1bmN0aW9uIChzZXQsIGZ1bmMsIGNvbnRleHQpIHtcclxuXHRcdHZhciBzdWJzZXQgPSB7fTtcclxuXHRcdGZvciAodmFyIHYgaW4gc2V0KSB7XHJcblx0XHRcdGlmIChzZXRbdl0gIT09IE9iamVjdC5wcm90b3R5cGVbdl0pIHtcclxuXHRcdFx0XHRpZiAoZnVuYy5jYWxsKGNvbnRleHQsIHNldFt2XSkpIHtcclxuXHRcdFx0XHRcdHN1YnNldFtzZXRbdl1dID0gc2V0W3ZdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHN1YnNldDtcclxuXHR9LFxyXG5cclxuXHRwaWNrOiBmdW5jdGlvbiAoc2V0KSB7XHJcblx0XHRmb3IgKHZhciB2IGluIHNldCkge1xyXG5cdFx0XHRpZiAoc2V0W3ZdICE9PSBPYmplY3QucHJvdG90eXBlW3ZdKSB7XHJcblx0XHRcdFx0cmV0dXJuIHNldFt2XTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fSxcclxuXHJcblx0bGlzdDogZnVuY3Rpb24gKHNldCkge1xyXG5cdFx0dmFyIGxpc3QgPSBbXTtcclxuXHRcdGZvciAodmFyIHYgaW4gc2V0KSB7XHJcblx0XHRcdGlmIChzZXRbdl0gIT09IE9iamVjdC5wcm90b3R5cGVbdl0pIHtcclxuXHRcdFx0XHRsaXN0LnB1c2goc2V0W3ZdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGxpc3Q7XHJcblx0fSxcclxuXHJcblx0YWRkOiBmdW5jdGlvbiAoc2V0LCBpdGVtKSB7XHJcblx0XHRzZXRbaXRlbV0gPSBpdGVtO1xyXG5cdH0sXHJcblxyXG5cdG1lcmdlSW46IGZ1bmN0aW9uIChzZXQsIG90aGVyKSB7XHJcblx0XHRTZXQuZWFjaChvdGhlciwgZnVuY3Rpb24gKGl0ZW0pIHtcclxuXHRcdFx0U2V0LmFkZChzZXQsIGl0ZW0pO1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlOiBmdW5jdGlvbiAoc2V0LCBpdGVtKSB7XHJcblx0XHR2YXIgdiA9IHNldFtpdGVtXTtcclxuXHRcdGRlbGV0ZSBzZXRbaXRlbV07XHJcblx0XHRyZXR1cm4gdjtcclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKG90aGVyKSB7XHJcblx0XHR2YXIgc2V0ID0ge307XHJcblx0XHRTZXQubWVyZ2VJbihzZXQsIG90aGVyKTtcclxuXHRcdHJldHVybiBzZXQ7XHJcblx0fSxcclxuXHJcblx0ZnJvbUxpc3Q6IGZ1bmN0aW9uIChsaXN0KSB7XHJcblx0XHR2YXIgc2V0ID0ge307XHJcblx0XHRpZiAobGlzdCkge1xyXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcclxuXHRcdFx0XHRzZXRbbGlzdFtpXSAtIDBdID0gbGlzdFtpXSAtIDA7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBzZXQ7XHJcblx0fSxcclxuXHJcblx0a2V5U2V0SW50OiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR2YXIgc2V0ID0ge307XHJcblx0XHRtYXAuZWFjaChmdW5jdGlvbiAoaWQpIHtcclxuXHRcdFx0c2V0W2lkIC0gMF0gPSBpZCAtIDA7XHJcblx0XHR9KTtcclxuXHRcdHJldHVybiBzZXQ7XHJcblx0fSxcclxuXHJcblx0ZmluZDogZnVuY3Rpb24gKHNldCwgZnVuYywgY29udGV4dCkge1xyXG5cdFx0Zm9yICh2YXIgdiBpbiBzZXQpIHtcclxuXHRcdFx0aWYgKHNldFt2XSAhPT0gT2JqZWN0LnByb3RvdHlwZVt2XSkge1xyXG5cdFx0XHRcdGlmIChmdW5jLmNhbGwoY29udGV4dCwgc2V0W3ZdKSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHY7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldDtcclxuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL2luZGV4Jyk7XHJcblxyXG52YXIgVmVjMiA9IGZ1bmN0aW9uICh4LCB5KVxyXG57XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMCkge1xyXG5cdFx0dGhpcy54ID0gMDtcclxuXHRcdHRoaXMueSA9IDA7XHJcblx0fSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcclxuXHRcdHRoaXMueCA9IHBhcnNlRmxvYXQoeC54KTtcclxuXHRcdHRoaXMueSA9IHBhcnNlRmxvYXQoeC55KTtcclxuXHR9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xyXG5cdFx0dGhpcy54ID0gcGFyc2VGbG9hdCh4KTtcclxuXHRcdHRoaXMueSA9IHBhcnNlRmxvYXQoeSk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcignVmVjMigpOiBpbnZhbGlkIGFyZ3VtZW50cycpO1xyXG5cdH1cclxufTtcclxuXHJcblZlYzIuWkVSTyA9IG5ldyBWZWMyKDAsIDApO1xyXG5WZWMyLlVOSVQgPSBuZXcgVmVjMigxLCAxKTtcclxuXHJcblZlYzIuc2VnbWVudEludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XHJcblx0dmFyIGRjID0gKGEueCAtIGMueCkgKiAoYi55IC0gYy55KSAtIChhLnkgLSBjLnkpICogKGIueCAtIGMueCk7XHJcblx0dmFyIGRkID0gKGEueCAtIGQueCkgKiAoYi55IC0gZC55KSAtIChhLnkgLSBkLnkpICogKGIueCAtIGQueCk7XHJcblx0dmFyIGRhID0gKGMueCAtIGEueCkgKiAoZC55IC0gYS55KSAtIChjLnkgLSBhLnkpICogKGQueCAtIGEueCk7XHJcblx0dmFyIGRiID0gKGMueCAtIGIueCkgKiAoZC55IC0gYi55KSAtIChjLnkgLSBiLnkpICogKGQueCAtIGIueCk7XHJcblx0cmV0dXJuIGRjICogZGQgPD0gMCAmJiBkYSAqIGRiIDw9IDA7XHJcbn07XHJcblxyXG5WZWMyLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XHJcblx0cmV0dXJuIE1hdGguc3FydCh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkpO1xyXG59O1xyXG5cclxuVmVjMi5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKHYpIHtcclxuXHR1dGlsLmFzc2VydERlZmluZWQodik7XHJcblx0cmV0dXJuIHRoaXMueCA9PSB2LnggJiYgdGhpcy55ID09IHYueTtcclxufTtcclxuXHJcblZlYzIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2KSB7XHJcblx0dXRpbC5hc3NlcnREZWZpbmVkKHYpO1xyXG5cdHJldHVybiBuZXcgVmVjMih0aGlzLnggKyB2LngsIHRoaXMueSArIHYueSk7XHJcbn07XHJcblxyXG5WZWMyLnByb3RvdHlwZS5hZGRfID0gZnVuY3Rpb24gKHYpIHtcclxuXHR1dGlsLmFzc2VydERlZmluZWQodik7XHJcblx0dGhpcy54ICs9IHYueDtcclxuXHR0aGlzLnkgKz0gdi55O1xyXG59O1xyXG5cclxuVmVjMi5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gKHYpIHtcclxuXHR1dGlsLmFzc2VydERlZmluZWQodik7XHJcblx0cmV0dXJuIG5ldyBWZWMyKHRoaXMueCAtIHYueCwgdGhpcy55IC0gdi55KTtcclxufTtcclxuXHJcblZlYzIucHJvdG90eXBlLnNjYWxlZCA9IGZ1bmN0aW9uIChzKSB7XHJcblx0dXRpbC5hc3NlcnREZWZpbmVkKHMpO1xyXG5cdHJldHVybiBuZXcgVmVjMih0aGlzLnggKiBzLCB0aGlzLnkgKiBzKTtcclxufTtcclxuXHJcblZlYzIucHJvdG90eXBlLm5lZ2F0ZWQgPSBmdW5jdGlvbiAoKSB7XHJcblx0cmV0dXJuIG5ldyBWZWMyKC10aGlzLngsIC10aGlzLnkpO1xyXG59O1xyXG5cclxuVmVjMi5wcm90b3R5cGUueUNvbXBsZW1lbnQgPSBmdW5jdGlvbiAoeTEpIHtcclxuXHR5MSA9IHkxIHx8IDA7XHJcblx0cmV0dXJuIG5ldyBWZWMyKHRoaXMueCwgeTEgLSB0aGlzLnkpO1xyXG59O1xyXG5cclxuVmVjMi5wcm90b3R5cGUuYWRkU2NhbGVkID0gZnVuY3Rpb24gKHYsIGYpIHtcclxuXHR1dGlsLmFzc2VydERlZmluZWQodik7XHJcblx0dXRpbC5hc3NlcnREZWZpbmVkKGYpO1xyXG5cdHJldHVybiBuZXcgVmVjMih0aGlzLnggKyB2LnggKiBmLCB0aGlzLnkgKyB2LnkgKiBmKTtcclxufTtcclxuXHJcblZlYzIucHJvdG90eXBlLm5vcm1hbGl6ZWQgPSBmdW5jdGlvbiAoKSB7XHJcblx0cmV0dXJuIHRoaXMuc2NhbGVkKDEgLyB0aGlzLmxlbmd0aCgpKTtcclxufTtcclxuXHJcblZlYzIucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgbCA9IHRoaXMubGVuZ3RoKCk7XHJcblxyXG5cdGlmIChsIDwgMC4wMDAwMDEpXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdHRoaXMueCAvPSBsO1xyXG5cdHRoaXMueSAvPSBsO1xyXG5cclxuXHRyZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcblZlYzIucHJvdG90eXBlLnR1cm5MZWZ0ID0gZnVuY3Rpb24gKCkge1xyXG5cdHJldHVybiBuZXcgVmVjMigtdGhpcy55LCB0aGlzLngpO1xyXG59O1xyXG5cclxuVmVjMi5wcm90b3R5cGUuY29vcmRTdHIgPSBmdW5jdGlvbiAoKSB7XHJcblx0cmV0dXJuIHRoaXMueC50b1N0cmluZygpICsgJyAsICcgKyB0aGlzLnkudG9TdHJpbmcoKTtcclxufTtcclxuXHJcblZlYzIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG5cdHJldHVybiAnKCcgKyB0aGlzLngudG9GaXhlZCgyKSArICcsJyArIHRoaXMueS50b0ZpeGVkKDIpICsgJyknO1xyXG59O1xyXG5cclxuVmVjMi5kaXN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuXHR1dGlsLmFzc2VydERlZmluZWQoYSk7XHJcblx0dXRpbC5hc3NlcnREZWZpbmVkKGIpO1xyXG5cdHJldHVybiBWZWMyLmRpZmYoYSwgYikubGVuZ3RoKCk7XHJcbn07XHJcblxyXG5WZWMyLm1heCA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcclxuXHR1dGlsLmFzc2VydERlZmluZWQodjEpO1xyXG5cdHV0aWwuYXNzZXJ0RGVmaW5lZCh2Mik7XHJcblx0cmV0dXJuIG5ldyBWZWMyKE1hdGgubWF4KHYxLngsIHYyLngpLCBNYXRoLm1heCh2MS55LCB2Mi55KSk7XHJcbn07XHJcblxyXG5WZWMyLm1pbiA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcclxuXHR1dGlsLmFzc2VydERlZmluZWQodjEpO1xyXG5cdHV0aWwuYXNzZXJ0RGVmaW5lZCh2Mik7XHJcblx0cmV0dXJuIG5ldyBWZWMyKE1hdGgubWluKHYxLngsIHYyLngpLCBNYXRoLm1pbih2MS55LCB2Mi55KSk7XHJcbn07XHJcblxyXG5WZWMyLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAodikge1xyXG5cdHV0aWwuYXNzZXJ0RGVmaW5lZCh2KTtcclxuXHRyZXR1cm4gbmV3IFZlYzIubWF4KHRoaXMsIHYpO1xyXG59O1xyXG5cclxuVmVjMi5wcm90b3R5cGUubWluID0gZnVuY3Rpb24gKHYpIHtcclxuXHR1dGlsLmFzc2VydERlZmluZWQodik7XHJcblx0cmV0dXJuIG5ldyBWZWMyLm1pbih0aGlzLCB2KTtcclxufTtcclxuXHJcblZlYzIucHJvdG90eXBlLmNlaWwgPSBmdW5jdGlvbiAoKSB7XHJcblx0cmV0dXJuIG5ldyBWZWMyKE1hdGguY2VpbCh0aGlzLngpLCBNYXRoLmNlaWwodGhpcy55KSk7XHJcbn07XHJcblxyXG5WZWMyLnByb3RvdHlwZS5mbG9vciA9IGZ1bmN0aW9uICgpIHtcclxuXHRyZXR1cm4gbmV3IFZlYzIoTWF0aC5mbG9vcih0aGlzLngpLCBNYXRoLmZsb29yKHRoaXMueSkpO1xyXG59O1xyXG5cclxuVmVjMi5zdW0gPSBmdW5jdGlvbiAodjEsIHYyKSB7XHJcblx0dXRpbC5hc3NlcnREZWZpbmVkKHYxKTtcclxuXHR1dGlsLmFzc2VydERlZmluZWQodjIpO1xyXG5cdHJldHVybiBuZXcgVmVjMih2MS54ICsgdjIueCwgdjEueSArIHYyLnkpO1xyXG59O1xyXG5cclxuVmVjMi5kb3QgPSBmdW5jdGlvbiAodjEsIHYyKSB7XHJcblx0dXRpbC5hc3NlcnREZWZpbmVkKHYxKTtcclxuXHR1dGlsLmFzc2VydERlZmluZWQodjIpO1xyXG5cdHJldHVybiB2MS54ICogdjIueCArIHYxLnkgKiB2Mi55O1xyXG59O1xyXG5cclxuVmVjMi5jcm9zcyA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcclxuXHR1dGlsLmFzc2VydERlZmluZWQodjEpO1xyXG5cdHV0aWwuYXNzZXJ0RGVmaW5lZCh2Mik7XHJcblx0cmV0dXJuIHYxLnggKiB2Mi55IC0gdjEueSAqIHYyLng7XHJcbn07XHJcblxyXG5WZWMyLnByb3RvdHlwZS5yb3RhdGUgPSBmdW5jdGlvbiAoYW5nbGUpIHtcclxuXHR1dGlsLmFzc2VydERlZmluZWQoYW5nbGUpO1xyXG5cdHZhciBzaSA9IE1hdGguc2luKGFuZ2xlKTtcclxuXHR2YXIgY28gPSBNYXRoLmNvcyhhbmdsZSk7XHJcblxyXG5cdHJldHVybiB0aGlzLnJvdGF0ZVNDKHNpLCBjbyk7XHJcbn07XHJcblxyXG5WZWMyLnByb3RvdHlwZS5yb3RhdGVTQyA9IGZ1bmN0aW9uIChzaSwgY28pIHtcclxuXHR1dGlsLmFzc2VydERlZmluZWQoc2kpO1xyXG5cdHV0aWwuYXNzZXJ0RGVmaW5lZChjbyk7XHJcblx0cmV0dXJuIG5ldyBWZWMyKHRoaXMueCAqIGNvIC0gdGhpcy55ICogc2ksIHRoaXMueCAqIHNpICsgdGhpcy55ICogY28pO1xyXG59O1xyXG5cclxuVmVjMi5hbmdsZSA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcclxuXHR1dGlsLmFzc2VydERlZmluZWQodjEpO1xyXG5cdHV0aWwuYXNzZXJ0RGVmaW5lZCh2Mik7XHJcblx0cmV0dXJuIE1hdGguYXRhbjIoVmVjMi5jcm9zcyh2MSwgdjIpLCBWZWMyLmRvdCh2MSwgdjIpKTtcclxufTtcclxuXHJcblZlYzIucHJvdG90eXBlLm94QW5nbGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0cmV0dXJuIE1hdGguYXRhbjIodGhpcy55LCB0aGlzLngpO1xyXG59O1xyXG5cclxuVmVjMi5kaWZmID0gZnVuY3Rpb24gKHYxLCB2Mikge1xyXG5cdHV0aWwuYXNzZXJ0RGVmaW5lZCh2MSk7XHJcblx0dXRpbC5hc3NlcnREZWZpbmVkKHYyKTtcclxuXHRyZXR1cm4gbmV3IFZlYzIodjEueCAtIHYyLngsIHYxLnkgLSB2Mi55KTtcclxufTtcclxuXHJcbi8vIGFzc3VtZSBhcmd1bWVudHMgdjEsIGYxLCB2MiwgZjIsIHYzLCBmMywgZXRjLlxyXG4vLyB3aGVyZSB2W2ldIGFyZSB2ZWN0b3JzIGFuZCBmW2ldIGFyZSBjb3JyZXNwb25kaW5nIGNvZWZmaWNpZW50c1xyXG5WZWMyLmxjID0gZnVuY3Rpb24gKCkge1xyXG5cdHZhciB2ID0gbmV3IFZlYzIoKTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLyAyOyArK2kpXHJcblx0XHR2ID0gdi5hZGRTY2FsZWQoYXJndW1lbnRzWzIgKiBpXSwgYXJndW1lbnRzWzIgKiBpICsgMV0pO1xyXG5cdHJldHVybiB2O1xyXG59O1xyXG5cclxuVmVjMi5sYzIgPSBmdW5jdGlvbiAodjEsIGYxLCB2MiwgZjIpIHtcclxuXHR1dGlsLmFzc2VydERlZmluZWQodjEpO1xyXG5cdHV0aWwuYXNzZXJ0RGVmaW5lZCh2Mik7XHJcblx0dXRpbC5hc3NlcnREZWZpbmVkKGYxKTtcclxuXHR1dGlsLmFzc2VydERlZmluZWQoZjIpO1xyXG5cdHJldHVybiBuZXcgVmVjMih2MS54ICogZjEgKyB2Mi54ICogZjIsIHYxLnkgKiBmMSArIHYyLnkgKiBmMik7XHJcbn07XHJcblxyXG5WZWMyLmNlbnRyZSA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcclxuXHRyZXR1cm4gbmV3IFZlYzIubGMyKHYxLCAwLjUsIHYyLCAwLjUpO1xyXG59O1xyXG5cclxuLy8gZmluZCBpbnRlcnNlY3Rpb24gb2YgYSByYXkgYW5kIGEgYm94IGFuZFxyXG4vLyAgcmV0dXJuIHRoZSBzaGlmdCBtYWduaXR1ZGUgdG8gYXZvaWQgaXRcclxuVmVjMi5zaGlmdFJheUJveCA9IGZ1bmN0aW9uICgvKlZlYzIqL3AsIC8qVmVjMiovZCwgLypCb3gyQWJzKi9iYikge1xyXG5cdHV0aWwuYXNzZXJ0RGVmaW5lZChwKTtcclxuXHR1dGlsLmFzc2VydERlZmluZWQoZCk7XHJcblx0dXRpbC5hc3NlcnREZWZpbmVkKGJiKTtcclxuXHQvLyBmb3VyIGNvcm5lciBwb2ludHMgb2YgdGhlIGJveFxyXG5cdHZhciBiID0gW2JiLnAwLCBuZXcgVmVjMihiYi5wMS54LCBiYi5wMC55KSxcclxuXHRcdFx0YmIucDEsIG5ldyBWZWMyKGJiLnAwLngsIGJiLnAxLnkpXTtcclxuXHR2YXIgciA9IGIubWFwKGZ1bmN0aW9uICh2KXtyZXR1cm4gdi5zdWIocCl9KTsgLy8gYiByZWxhdGl2ZSB0byBwXHJcblx0ZCA9IGQubm9ybWFsaXplZCgpO1xyXG5cdHZhciByYyA9IHIubWFwKGZ1bmN0aW9uICh2KXtyZXR1cm4gVmVjMi5jcm9zcyh2LCBkKX0pOyAvLyBjcm9zcyBwcm9kc1xyXG5cdHZhciByZCA9IHIubWFwKGZ1bmN0aW9uICh2KXtyZXR1cm4gVmVjMi5kb3QodiwgZCl9KTsgLy8gZG90IHByb2RzXHJcblxyXG5cdC8vIGZpbmQgZm9yZW1vc3QgcG9pbnRzIG9uIHRoZSByaWdodCBhbmQgb24gdGhlIGxlZnQgb2YgdGhlIHJheVxyXG5cdHZhciBwaWQgPSAtMSwgbmlkID0gLTE7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCA0OyArK2kpXHJcblx0XHRpZiAocmNbaV0gPiAwKSAge2lmIChwaWQgPCAwIHx8IHJkW3BpZF0gPCByZFtpXSkgcGlkID0gaTt9XHJcblx0XHRlbHNlICAgICAgICAgICAge2lmIChuaWQgPCAwIHx8IHJkW25pZF0gPCByZFtpXSkgbmlkID0gaTt9XHJcblxyXG5cdGlmIChuaWQgPCAwIHx8IHBpZCA8IDApIC8vIG5vIGludGVyc2VjdGlvbiwgbm8gc2hpZnRcclxuXHRcdHJldHVybiAwO1xyXG5cclxuXHQvLyBjaGVjayB0aGUgb3JkZXJcclxuXHR2YXIgaWQwLCBpZDE7XHJcblx0aWYgKHJkW3BpZF0gPiByZFtuaWRdKVxyXG5cdFx0aWQwID0gbmlkLCBpZDEgPSBwaWQ7XHJcblx0ZWxzZVxyXG5cdFx0aWQwID0gcGlkLCBpZDEgPSBuaWQ7XHJcblxyXG5cdC8vIHNpbXBsZSBwcm9wb3J0aW9uIHRvIGNhbGN1bGF0ZSB0aGUgc2hpZnRcclxuXHRyZXR1cm4gcmRbaWQwXSArIE1hdGguYWJzKHJjW2lkMF0pICogKHJkW2lkMV0gLSByZFtpZDBdKVxyXG5cdFx0IC8gKE1hdGguYWJzKHJjW2lkMF0pICsgTWF0aC5hYnMocmNbaWQxXSkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBWZWMyO1xyXG4iXX0=
